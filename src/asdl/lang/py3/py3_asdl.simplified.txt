## ASDL's 5 builtin types are:
identifier, int, string, object, constant

mod = Module(stmt* body, type_ignore *type_ignores)
    | Interactive(stmt* body)
    | Expression(expr body)
    | FunctionType(expr* argtypes, expr returns)
    -- not really an actual node but useful in Jython's typesystem.
    | Suite(stmt* body)

stmt = FunctionDef(identifier name, arguments args, stmt* body, expr* decorator_list, expr? returns, string? type_comment)

    | AsyncFunctionDef(identifier name, arguments args, stmt* body, expr* decorator_list, expr? returns, string? type_comment)
    | ClassDef(identifier name, expr* bases, keyword* keywords, stmt* body, expr* decorator_list)
    | Return(expr? value)

    | Delete(expr* targets)
    | Assign(expr* targets, expr value, string? type_comment)
    | AugAssign(expr target, operator op, expr value)
    | AnnAssign(expr target, expr annotation, expr? value, int simple)

    | For(expr target, expr iter, stmt* body, stmt* orelse, string? type_comment)
    | AsyncFor(expr target, expr iter, stmt* body, stmt* orelse, string? type_comment)
    | While(expr test, stmt* body, stmt* orelse)
    | If(expr test, stmt* body, stmt* orelse)
    | With(withitem* items, stmt* body, string? type_comment)
    | AsyncWith(withitem* items, stmt* body, string? type_comment)

    | Raise(expr? exc, expr? cause)
    | Try(stmt* body, excepthandler* handlers, stmt* orelse, stmt* finalbody)
    | Assert(expr test, expr? msg)

    | Import(alias* names)
    | ImportFrom(identifier? module, alias* names, int? level)

    | Global(identifier* names)
    | Nonlocal(identifier* names)
    | Expr(expr value)
    | Pass | Break | Continue

expr = BoolOp(boolop op, expr* values)
    | NamedExpr(expr target, expr value)
    | BinOp(expr left, operator op, expr right)
    | UnaryOp(unaryop op, expr operand)
    | Lambda(arguments args, expr body)
    | IfExp(expr test, expr body, expr orelse)
    | Dict(expr* keys, expr* values)
    | Set(expr* elts)
    | ListComp(expr elt, comprehension* generators)
    | SetComp(expr elt, comprehension* generators)
    | DictComp(expr key, expr value, comprehension* generators)
    | GeneratorExp(expr elt, comprehension* generators)
    | Await(expr value)
    | Yield(expr? value)
    | YieldFrom(expr value)
    | Compare(expr left, cmpop* ops, expr* comparators)
    | Call(expr func, expr* args, keyword* keywords)
    | FormattedValue(expr value, int? conversion, expr? format_spec)
    | JoinedStr(expr* values)
    | Constant(constant value, string? kind)
    | Attribute(expr value, identifier attr, expr_context ctx)
    | Subscript(expr value, slice slice, expr_context ctx)
    | Starred(expr value, expr_context ctx)
    | Name(identifier id, expr_context ctx)
    | List(expr* elts, expr_context ctx)
    | Tuple(expr* elts, expr_context ctx)

expr_context = Load | Store | Del | AugLoad | AugStore | Param

slice = Slice(expr? lower, expr? upper, expr? step)
    | ExtSlice(slice* dims)
    | Index(expr value)

boolop = And | Or

operator = Add | Sub | Mult | MatMult | Div | Mod | Pow | LShift
             | RShift | BitOr | BitXor | BitAnd | FloorDiv

unaryop = Invert | Not | UAdd | USub

cmpop = Eq | NotEq | Lt | LtE | Gt | GtE | Is | IsNot | In | NotIn

comprehension = comprehension(expr target, expr iter, expr* ifs, int is_async)

excepthandler = ExceptHandler(expr? type, identifier? name, stmt* body)

arguments = arguments(arg* posonlyargs, arg* args, arg? vararg, arg* kwonlyargs, expr* kw_defaults, arg? kwarg, expr* defaults)

arg = arg(identifier arg, expr? annotation, string? type_comment)

keyword = keyword(identifier? arg, expr value)

alias = alias(identifier name, identifier? asname)

withitem = withitem(expr context_expr, expr? optional_vars)

type_ignore = TypeIgnore(int lineno, string tag)
