{
 "15080500.0": {
  "intent": "send a signal `signal.sigusr1` to the current process",
  "body": "I have this code which listens to USR1 signals\nimport signal\nimport os\nimport time\n\ndef receive_signal(signum, stack):\n    print 'Received:', signum\n\nsignal.signal(signal.SIGUSR1, receive_signal)\nsignal.signal(signal.SIGUSR2, receive_signal)\n\nprint 'My PID is:', os.getpid()\n\nwhile True:\n    print 'Waiting...'\n    time.sleep(3)\n\nThis works when I send signals with kill -USR1 pid\nBut how can I send the same signal from within the above python script so that after 10 seconds it automatically sends USR1  and also receives it , without me having to open two terminals to check it?\n",
  "preds": {
   "base:Baseline": "sys.communicate('signal.sigusr1')",
   "body:Baseline": "print('USR1 is:', sigusr1)",
   "body:-Blocks": "process.call(USR1, 'signal.sigusr1')",
   "body:-Code": "sys.system('signal.sigusr1')",
   "body:-Inline": "signal.SIGUSR1, receive_signal)",
   "body:-NL": "print(signal.SIGUSR1, receive_signal)",
   "base:+Mined": "sys.stdout.write('signal.sigusr1')",
   "body+mined:Baseline": "signal.SIGUSR1.communicate()[0]",
   "body+mined:-Code": "signal.SIGUSR1(0, 1)",
   "body+mined:-NL": "signal.SIGUSR1.communicate()",
   "body+mined:-Blocks": "signal.sigusr1.communicate()[0]",
   "body+mined:-Inline": "signal.SIGUSR1.communicate()"
  },
  "snippet": "os.kill(os.getpid(), signal.SIGUSR1)"
 },
 "3283984.1": {
  "intent": "decode a hex string '4a4b4c' to utf-8.",
  "body": "In Python 2, converting the hexadecimal form of a string into the corresponding unicode was straightforward:\ncomments.decode(\"hex\")\n\nwhere the variable 'comments' is a part of a line in a file (the rest of the line does not  need to be converted, as it is represented only in ASCII.\nNow in Python 3, however, this doesn't work (I assume because of the bytes/string vs. string/unicode switch. I feel like there should be a one-liner in Python 3 to do the same thing, rather than reading the entire line as a series of bytes (which I don't want to do) and then converting each part of the line separately. If it's possible, I'd like to read the entire line as a unicode string (because the rest of the line is in unicode) and only convert this one part from a hexadecimal representation.\n",
  "preds": {
   "base:Baseline": "print('4a4b4c'.decode('hex')",
   "body:Baseline": "struct.unpack('4a4b4c').decode('hex')",
   "body:-Blocks": "urllib.parse.unquote('4a4b4c')",
   "body:-Code": "urllib.parse.unquote('4a4b4c')",
   "body:-Inline": "comments.decode('hex').encode('4a4b4c')",
   "body:-NL": "comments.decode('4a4b4c').encode('hex')",
   "base:+Mined": "decoded('4a4b4c', 16)",
   "body+mined:Baseline": "int('4a4b4c', 16)",
   "body+mined:-Code": "\"\"\"4a4b4c\"\"\".decode('hex')",
   "body+mined:-NL": "comment.decode('4a4b4c')",
   "body+mined:-Blocks": "\"\"\"4a4b4c\"\"\".decode('hex')",
   "body+mined:-Inline": "int('4a4b4c', 16)"
  },
  "snippet": "bytes.fromhex('4a4b4c').decode('utf-8')"
 },
 "3844801.2": {
  "intent": "check if all elements in list `mylist` are identical",
  "body": "I need a function which takes in a list  and outputs True  if all elements in the input list evaluate as equal to each other using the standard equality operator and False  otherwise.\nI feel it would be best to iterate through the list comparing adjacent elements and then AND  all the resulting Boolean values. But I'm not sure what's the most Pythonic way to do that.\n",
  "preds": {
   "base:Baseline": "all(i == j for i in mylist)",
   "body:Baseline": "all(i == j for i, j in mylist)",
   "body:-Blocks": "all(x == y for x in mylist)",
   "body:-Code": "all(iter(mylist) == 0)",
   "body:-Inline": "all(i == j for i, j in mylist)",
   "body:-NL": "all(x in mylist for x in x)",
   "base:+Mined": "len(set(myList)) == 1",
   "body+mined:Baseline": "all(isinstance(x, y) for x, y in mylist)",
   "body+mined:-Code": "all(i == j for i, j in enumerate(myList) if j == j)",
   "body+mined:-NL": "all(x == mylist for x in mylist)",
   "body+mined:-Blocks": "all(i == j for i, j in zip(myList, myList))",
   "body+mined:-Inline": "all(i == j for i, j in enumerate(mylist))"
  },
  "snippet": "all(x == myList[0] for x in myList)"
 },
 "4302166.3": {
  "intent": "format number of spaces between strings `python`, `:` and `very good` to be `20`",
  "body": "If I want to make my formatted string dynamically adjustable, I can change the following code from\nprint '%20s : %20s' % (\"Python\", \"Very Good\")\n\nto\nwidth = 20\nprint ('%' + str(width) + 's : %' + str(width) + 's') % (\"Python\", \"Very Good\")\n\nHowever, it seems that string concatenation is cumbersome here. Any other way to simplify things?\n",
  "preds": {
   "base:Baseline": "\"\"\"{0:.2f}\"\"\".format(python, `:','very good')",
   "body:Baseline": "print('%20s : %s' % ('Python', ':') + 'very good')",
   "body:-Blocks": "\"\"\"{0:.2f}\"\"\".format(python, ':', 'very good')",
   "body:-Code": "\"\"\"{0:}\"\"\".format(python, `:','very good'))",
   "body:-Inline": "print('%20s : %20s') % ('Python', 'Very Good')",
   "body:-NL": "print('%20s : %20s' % ('Python', 'Very Good')",
   "base:+Mined": "\"\"\"{0:.2f}\"\"\".format(python, ':', 'very good')",
   "body+mined:Baseline": "print('%20s : %20s' % ('Python', 'Very Good')",
   "body+mined:-Code": "\"\"\"{:.2f}\"\"\".format(my_string)",
   "body+mined:-NL": "print('%20s : %20s' % ('Python', 'Very Good')",
   "body+mined:-Blocks": "\"\"\"python, :, very good\"\"\".format(('python', ':','very good')",
   "body+mined:-Inline": "print('%20s : %20s' % ('Python', 'Very Good')"
  },
  "snippet": "print('%*s : %*s' % (20, 'Python', 20, 'Very Good'))"
 },
 "7555335.4": {
  "intent": "how to convert a string from cp-1251 to utf-8?",
  "body": "I'm using mutagen to convert ID3 tags data from CP-1251 / CP-1252  to UTF-8. In Linux there is no problem. But on Windows, calling SetValue()  on a wx.TextCtrl produces the error:\n\nUnicodeDecodeError: 'ascii' codec can't decode byte 0xc3 in position\n  0: ordinal not in range(128)\n\nThe original string (assumed to be CP-1251 encoded) that I'm pulling from mutagen  is:\nu'\\xc1\\xe5\\xeb\\xe0\\xff \\xff\\xe1\\xeb\\xfb\\xed\\xff \\xe3\\xf0\\xee\\xec\\xf3'\n\nI've tried converting this to UTF-8:\ndd = d.decode('utf-8')\n\n<console_out>and even changing the default encoding from ASCII to UTF-8:\nsys.setdefaultencoding('utf-8')\n\n<console_out>But I get the same error.\n",
  "preds": {
   "base:Baseline": "\"\"\"cp-1251\"\"\".encode('utf8')",
   "body:Baseline": "struct.setdefaultencoding('cp-1251', 'utf8')",
   "body:-Blocks": "urllib.parse.unquote('cp-1251', 'utf-8')",
   "body:-Code": "urllib.parse.unquote('cp-1251', 'utf-8')",
   "body:-Inline": "sys.setdefaultencoding('cp-1251', UTF - 8)",
   "body:-NL": "sys.setdefaultencoding('cp-1251')",
   "base:+Mined": "s.decode('cp1251').encode('utf8')",
   "body+mined:Baseline": "sys.setdefaultencoding('utf-8')",
   "body+mined:-Code": "s.decode('cp-1252').encode('utf-8')",
   "body+mined:-NL": "sys.setdefaultencoding('cp-1251', 'ignore')",
   "body+mined:-Blocks": "s.decode('utf-8').encode('ascii', 'ignore')",
   "body+mined:-Inline": "sys.setdefaultencoding('cp-1251').encode('utf8')"
  },
  "snippet": "d.decode('cp1251').encode('utf8')"
 },
 "2544710.5": {
  "intent": "get rid of none values in dictionary `kwargs`",
  "body": "Something like:\nfor (a,b) in kwargs.iteritems():\n    if not b : del kwargs[a]\n\nThis code raise exception because changing of dictionary when iterating.\nI discover only non pretty solution with another dictionary:\nres ={}\nres.update((a,b) for a,b in kwargs.iteritems() if b is not None)\n\nThanks\n",
  "preds": {
   "base:Baseline": "dict((k, v) for k, v in list(kwargs.items()))",
   "body:Baseline": "res.update((a, b) for a, b in kwargs.iteritems())",
   "body:-Blocks": "dict((k, v) for k, v in list(kwargs.items())",
   "body:-Code": "dict((k, v) for k, v in kargs.items())",
   "body:-Inline": "res.update((a, b) for a, b in kwargs.iteritems(): if b not None)",
   "body:-NL": "res.update((a, b) if b is not None)",
   "base:+Mined": "{k: v for k, v in list(kwargs.items()) if v is not None}",
   "body+mined:Baseline": "res = {k: v for k, v in list(kwargs.items()) if v is not None}",
   "body+mined:-Code": "{k: v for k, v in list(kwargs.items()) if v is not None}",
   "body+mined:-NL": "res.update((a, b) for a, b in kwargs.items() if b is not None)",
   "body+mined:-Blocks": "{k: v for k, v in list(kwargs.items()) if v is not None}",
   "body+mined:-Inline": "res = {k: v for k, v in list(kwargs.items()) if v is not None}"
  },
  "snippet": "res = {k: v for k, v in list(kwargs.items()) if v is not None}"
 },
 "2544710.6": {
  "intent": "get rid of none values in dictionary `kwargs`",
  "body": "Something like:\nfor (a,b) in kwargs.iteritems():\n    if not b : del kwargs[a]\n\nThis code raise exception because changing of dictionary when iterating.\nI discover only non pretty solution with another dictionary:\nres ={}\nres.update((a,b) for a,b in kwargs.iteritems() if b is not None)\n\nThanks\n",
  "preds": {
   "base:Baseline": "dict((k, v) for k, v in list(kwargs.items()))",
   "body:Baseline": "res.update((a, b) for a, b in kwargs.iteritems())",
   "body:-Blocks": "dict((k, v) for k, v in list(kwargs.items())",
   "body:-Code": "dict((k, v) for k, v in kargs.items())",
   "body:-Inline": "res.update((a, b) for a, b in kwargs.iteritems(): if b not None)",
   "body:-NL": "res.update((a, b) if b is not None)",
   "base:+Mined": "{k: v for k, v in list(kwargs.items()) if v is not None}",
   "body+mined:Baseline": "res = {k: v for k, v in list(kwargs.items()) if v is not None}",
   "body+mined:-Code": "{k: v for k, v in list(kwargs.items()) if v is not None}",
   "body+mined:-NL": "res.update((a, b) for a, b in kwargs.items() if b is not None)",
   "body+mined:-Blocks": "{k: v for k, v in list(kwargs.items()) if v is not None}",
   "body+mined:-Inline": "res = {k: v for k, v in list(kwargs.items()) if v is not None}"
  },
  "snippet": "res = dict((k, v) for k, v in kwargs.items() if v is not None)"
 },
 "14971373.7": {
  "intent": "capture final output of a chain of system commands `ps -ef | grep something | wc -l`",
  "body": "There are many posts here on SO, like this one: Store output of subprocess.Popen call in a string\nThere is problem with complicated commands. For example, if I need to get output from this\n\nps -ef|grep something|wc -l\n\nSubprocess won't do the job, because argument for subprocess is [name of program, arguments], so it is not possible to use more sophisicated commands (more programs, pipes, etc.). \nIs there way to capture the output of a chain of multiple commands?\n",
  "preds": {
   "base:Baseline": "sys.system('ps -ef | grep something | wc -l')",
   "body:Baseline": "ps -ef | grep something | wc -l[::-1]",
   "body:-Blocks": "subprocess.Popen('ps -ef | grep something | wc -l')",
   "body:-Code": "subprocess.call('ps -ef | grep something | wc -l')",
   "body:-Inline": "subprocess.communicate(ps -ef | grep something | wc -l)",
   "body:-NL": "sys.communicate('ps -ef | grep something | wc -l')",
   "base:+Mined": "p.communicate()[0]",
   "body+mined:Baseline": "output = subprocess.Popen(['ps -ef', 'grep something | wc -l'])",
   "body+mined:-Code": "process.check_output(ps -ef | grep something | wc -l)",
   "body+mined:-NL": "ps.communicate()[0]",
   "body+mined:-Blocks": "output = subprocess.Popen('ps -ef | grep something | wc -l')",
   "body+mined:-Inline": "output = subprocess.Popen(['ps -ef', 'grep something | wc -l'])"
  },
  "snippet": "subprocess.check_output('ps -ef | grep something | wc -l', shell=True)"
 },
 "6726636.8": {
  "intent": "concatenate a list of strings `['a', 'b', 'c']`",
  "body": "I was wondering if python had a built in function similar to \nstring->list\n\nand list->string  in scheme.\nSo for example I would like to turn 'abc' into ['a','b','c']  and vice versa using a built in function.\n",
  "preds": {
   "base:Baseline": "list(['a', 'b', 'c']))",
   "body:Baseline": "['a', 'b', 'c']",
   "body:-Blocks": "['abc'] = ['a', 'b', 'c']",
   "body:-Code": "list(['a', 'b', 'c']))",
   "body:-Inline": "list(['a', 'b', 'c']))",
   "body:-NL": "list(['a', 'b', 'c']))",
   "base:+Mined": "['a', 'b', 'c']",
   "body+mined:Baseline": "['a', 'b', 'c']",
   "body+mined:-Code": "['abc', 'b', 'c']",
   "body+mined:-NL": "['a', 'b', 'c']",
   "body+mined:-Blocks": "['a', 'b', 'c']",
   "body+mined:-Inline": "['a', 'b', 'c']"
  },
  "snippet": "\"\"\"\"\"\".join(['a', 'b', 'c'])"
 },
 "18079563.9": {
  "intent": "find intersection data between series `s1` and series `s2`",
  "body": "I have two series s1  and s2  in pandas and want to compute the intersection i.e. where all of the values of the series are common.\nHow would I use the concat  function to do this? I have been trying to work it out but have been unable to (I don't want to compute the intersection on the indices of s1  and s2 , but on the values).\n",
  "preds": {
   "base:Baseline": "print(s1.intersection(s2.index(1))",
   "body:Baseline": "np.arange(s1, s2)",
   "body:-Blocks": "pd.concat([i for i, j in s1, s2])",
   "body:-Code": "np.arange(s1, s2)",
   "body:-Inline": "df.intersection(s1, s2)",
   "body:-NL": "s1.intersection(s2.split())",
   "base:+Mined": "s1.intersection(s2.cross(s1))",
   "body+mined:Baseline": "pd.concat([s1, s2], axis=1)",
   "body+mined:-Code": "pd.concat([s1, s2], axis=1)",
   "body+mined:-NL": "s1.find_intersection(s2)",
   "body+mined:-Blocks": "pd.concat([s1, s2], axis=1)",
   "body+mined:-Inline": "pd.concat([s1, s2], axis=1)"
  },
  "snippet": "pd.Series(list(set(s1).intersection(set(s2))))"
 },
 "8315209.10": {
  "intent": "sending http headers to `client`",
  "body": "I've set up a little script that should feed a client with html.\nimport socket\n\nsock = socket.socket()\nsock.bind(('', 8080))\nsock.listen(5)\nclient, adress = sock.accept()\n\n\nprint \"Incoming:\", adress\nprint client.recv(1024)\nprint\n\nclient.send(\"Content-Type: text/html\\n\\n\")\nclient.send(' </body> </html>')\n\nprint \"Answering <console_out>\"\nprint \"Finished.\"\n\nimport os\nos.system(\"pause\")\n\nBut it is shown as plain text in the browser. Can you please tell what I need to do ? I just can't find something in google that helps me..\nThanks.\n",
  "preds": {
   "base:Baseline": "client.send(' headers', headers=False)",
   "body:Baseline": "client.send('Content-Type: text/html\\n\\n')",
   "body:-Blocks": "client.send('http://www.headers.com')",
   "body:-Code": "request.headers.get('utf-8')",
   "body:-Inline": "client.send('Content-Type: text/html\\n\\n')",
   "body:-NL": "client.send('Content-Type: text/html\\n')",
   "base:+Mined": "client.send('HTTP/1.0 200 OK')",
   "body+mined:Baseline": "client.send('Content-Type: text/html\\n')",
   "body+mined:-Code": "client.sendheaders('http://www.gmail.com')",
   "body+mined:-NL": "client.send('Content-Type: text/html\\\\n\\\\n')",
   "body+mined:-Blocks": "client.serve_forever()",
   "body+mined:-Inline": "client.send('Content-Type: text/html\\n\\n')"
  },
  "snippet": "client.send('HTTP/1.0 200 OK\\r\\n')"
 },
 "26153795.11": {
  "intent": "format a datetime string `when` to extract date only",
  "body": "I have a date string and want to convert it to the date type:\nI have tried to use datetime.datetime.strptime with the format that I want but it is returning the time with the conversion.\n    when = alldates[int(daypos[0])]\n    print when, type(when)\n\n    then = datetime.datetime.strptime(when, '%Y-%m-%d')\n    print then, type(then)\n\nThis is what the output returns:\n   2013-05-07 <type 'str'>\n   2013-05-07 00:00:00 <type 'datetime.datetime'>\n\nI need to remove the the time: 00:00:00.\n",
  "preds": {
   "base:Baseline": "datetime.strptime('today', '%Y-%m-%d %H:%M')",
   "body:Baseline": "time.datetime.strptime(when, '%Y-%m-%d')",
   "body:-Blocks": "datetime.strptime(when, '%Y:%M:%S')",
   "body:-Code": "datetime.strptime(when)",
   "body:-Inline": "when = datetime.datetime.strptime(when, '%Y-%m-%d')",
   "body:-NL": "time.strptime(when, '%Y-%m-%d')",
   "base:+Mined": "datetime.strptime('2012-03-01T19:00:00Z', '%Y-%m-%dT%H:%M:%SZ')",
   "body+mined:Baseline": "date = datetime.datetime.strptime(2013-05-07, '%Y-%m-%d')",
   "body+mined:-Code": "datetime.strptime('2012-05-29T19:00:00', '%Y-%m-%dT%H:%M:%SZ')",
   "body+mined:-NL": "dt = datetime.datetime.now().strftime('%Y-%m-%d')",
   "body+mined:-Blocks": "datetime.strptime('2012-05-01T19:00:00', '%Y-%m-%dT%H:%M:%SZ')",
   "body+mined:-Inline": "date.strptime(when, '%Y-%m-%d').date()"
  },
  "snippet": "then = datetime.datetime.strptime(when, '%Y-%m-%d').date()"
 },
 "172439.12": {
  "intent": "split a multi-line string `inputstring` into separate strings",
  "body": "I have a multi-line string literal that I want to do an operation on each line, like so:\ninputString = \"\"\"Line 1\nLine 2\nLine 3\"\"\"\n\nI want to do something like the following:\nfor line in inputString:\n    doStuff()\n\n",
  "preds": {
   "base:Baseline": "\"\"\"{0:.2f}\"\"\".format(inputstring)",
   "body:Baseline": "inputString.split(',', 1)[::-1]",
   "body:-Blocks": "inputString = re.sub('[^a-z]', '', inputstring)",
   "body:-Code": "inputString.split(',', 1)[0]",
   "body:-Inline": "\"\"\"Line 1\"\"\"\".join(chr(inputString))",
   "body:-NL": "re.split('', inputString)",
   "base:+Mined": "\"\"\" \"\"\".join(map(str, inputstring))",
   "body+mined:Baseline": "\"\"\"\"\"\".join(map(str, inputString))",
   "body+mined:-Code": "\"\"\" \"\"\".join(map(lambda x: x.split('\\n'))",
   "body+mined:-NL": "\"\"\"\"\"\".join(map(str, inputString))",
   "body+mined:-Blocks": "\"\"\"\"\"\".join(map(inputstring, inputstring.split())",
   "body+mined:-Inline": "\"\"\"\"\"\".join(map(str, inputString.split(',')))"
  },
  "snippet": "inputString.split('\\n')"
 },
 "172439.13": {
  "intent": "split a multi-line string ` a \\n b \\r\\n c ` by new line character `\\n`",
  "body": "I have a multi-line string literal that I want to do an operation on each line, like so:\ninputString = \"\"\"Line 1\nLine 2\nLine 3\"\"\"\n\nI want to do something like the following:\nfor line in inputString:\n    doStuff()\n\n",
  "preds": {
   "base:Baseline": "re.split('\\n', 'a \\n b \\r\\n c')",
   "body:Baseline": "a \\n b \\r\\n c = re.findall('\\n')",
   "body:-Blocks": "'A \\n b \\r\\n c'.split('\\n')",
   "body:-Code": "re.split('\\n', 'A \\n b \\r\\n c')",
   "body:-Inline": "'A \\n b \\r\\n c'.split('\\n')",
   "body:-NL": "re.split('\\n', '\\n')",
   "base:+Mined": "re.split('\\n', a \\n b \\r\\n c)",
   "body+mined:Baseline": "'A \\n b \\r\\n c'.split()",
   "body+mined:-Code": "'A \\n b \\r\\n c'.split(',')",
   "body+mined:-NL": "'a \\n b \\r\\n c'.split()",
   "body+mined:-Blocks": "'a \\n b \\r\\n c'.split()",
   "body+mined:-Inline": "'A \\n b \\r\\n c'.split()"
  },
  "snippet": "' a \\n b \\r\\n c '.split('\\n')"
 },
 "13954222.14": {
  "intent": "concatenate elements of list `b` by a colon \":\"",
  "body": "I have a list (array) with mixed \na = [\"x\", \"2\", \"y\"]\nb = [\"x\", 2, \"y\"]\nprint \":\".join(a)\nprint \":\".join(b)\n\nThe first join works, but the second one throws a TypeError exception \nI came up with this, but is this the Python solution?\nprint \":\".join(map(str, b))\n\nBTW in the end I just would like to write this string to a file, so if there is a specific solution for that, I'd appreciate that too.\n",
  "preds": {
   "base:Baseline": "[(x + y) for x, y in zip(b, b)]",
   "body:Baseline": "b = map(str, b))",
   "body:-Blocks": "b = [i.split(':\"] for i in range(0, len(b))]",
   "body:-Code": "b = [(':\") for i in range(0, len(b), ':\"))",
   "body:-Inline": "print(':'.join(a, b))",
   "body:-NL": "b = [(x + b) for x, b in zip(a, b)]",
   "base:+Mined": "b = [int(i) for i in b]",
   "body+mined:Baseline": "print(':'.join(map(str, b))",
   "body+mined:-Code": "\"\"\"\"\"\".join(str(i) for i in b)",
   "body+mined:-NL": "print(':'.join(map(str, b))",
   "body+mined:-Blocks": "\"\"\"\"\"\".join(b[:, (None)])",
   "body+mined:-Inline": "print(':'.join(map(str, b))"
  },
  "snippet": "\"\"\":\"\"\".join(str(x) for x in b)"
 },
 "5123839.15": {
  "intent": "get the first object from a queryset in django model `entry`",
  "body": "Often I find myself wanting to get the first object from a queryset in Django, or return None  if there aren't any.  There are lots of ways to do this which all work.  But I'm wondering which is the most performant.\nqs = MyModel.objects.filter(blah = blah)\nif qs.count() > 0:\n    return qs[0]\nelse:\n    return None\n\nDoes this result in two database calls?  That seems wasteful.  Is this any faster? \nqs = MyModel.objects.filter(blah = blah)\nif len(qs) > 0:\n    return qs[0]\nelse:\n    return None\n\nAnother option would be:\nqs = MyModel.objects.filter(blah = blah)\ntry:\n    return qs[0]\nexcept IndexError:\n    return None\n\nThis generates a single database call, which is good.  But requires creating an exception object a lot of the time, which is a very memory-intensive thing to do when all you really need is a trivial if-test.\nHow can I do this with just a single database call and without churning memory with exception objects?\n",
  "preds": {
   "base:Baseline": "Entry.objects.get_first()",
   "body:Baseline": "MyModel.objects.filter(blah=blah)",
   "body:-Blocks": "Entry.objects[0] = None",
   "body:-Code": "entry.objects()[0].first()",
   "body:-Inline": "entry.objects.first(0)",
   "body:-NL": "entry.objects.filter(blah=blah)",
   "base:+Mined": "Entry.objects.all().order_by('?')[0]",
   "body+mined:Baseline": "MyModel.objects.filter(Q(blah=blah))",
   "body+mined:-Code": "Entry.objects.get(0)",
   "body+mined:-NL": "Entry.objects.filter(blah='blah')",
   "body+mined:-Blocks": "Entry.objects.order_by('-id')[0]",
   "body+mined:-Inline": "MyModel.objects.filter(Q(blah=blah))"
  },
  "snippet": "Entry.objects.filter()[:1].get()"
 },
 "13567345.16": {
  "intent": "calculate sum over all rows of 2d numpy array",
  "body": "Let's say I have the following 2D numpy array consisting of four rows and three columns:\na = numpy.arange(12).reshape(4,3)\nprint(a)\n[[ 0  1  2]\n [ 3  4  5]\n [ 6  7  8]\n [ 9 10 11]]\n\nWhat would be an efficient way to generate a 1D array that contains the sum of all columns (like [18, 22, 26] )? Can this be done without having the need to loop through all columns?\n",
  "preds": {
   "base:Baseline": "sum(np.sum(2, 3))",
   "body:Baseline": "sum(np.arange(12), axis=1)",
   "body:-Blocks": "sum(np.sum(axis=1))",
   "body:-Code": "np.sum(np.arange(1, 2), axis=1)",
   "body:-Inline": "np.sum(np.arange(4, 3))",
   "body:-NL": "sum(np.arange(12), axis=1)",
   "base:+Mined": "np.sum(axis=1)",
   "body+mined:Baseline": "a.sum(axis=1)",
   "body+mined:-Code": "np.sum(axis=1)",
   "body+mined:-NL": "a.sum(axis=1)",
   "body+mined:-Blocks": "np.sum(sum(axis=1))",
   "body+mined:-Inline": "a.sum(axis=1)"
  },
  "snippet": "a.sum(axis=1)"
 },
 "29784889.17": {
  "intent": "enable warnings using action 'always'",
  "body": "I was setting up a ImportWarning as seemed appropriate but noticed this warning is not reported by default;\nHow can I set python to report ImportWarning or all warnings?\nHere is the import warning i wrote:\ntry:\n    from markdown import markdown\n\nexcept ImportError, err:\n    warnings.warn(\n        'Unable to load Pypi package `markdown`, HTML output will be unavailable. {}'.format(err),\n        ImportWarning\n    )\n\n",
  "preds": {
   "base:Baseline": "if not always:\n    pass",
   "body:Baseline": "re.findall('Markdown', 'always')",
   "body:-Blocks": "importWarning.set_exists('always')",
   "body:-Code": "importWarning.set_option('always')",
   "body:-Inline": "app.set_exists('always')",
   "body:-NL": "warn(('always', 'ignore')",
   "base:+Mined": "warnings.setLevel(0)",
   "body+mined:Baseline": "warnings.warn(('always')",
   "body+mined:-Code": "warnings.extra(('always')",
   "body+mined:-NL": "warn('always', action='always')",
   "body+mined:-Blocks": "warnings = warnings.get('always')",
   "body+mined:-Inline": "warn('always', action='always')"
  },
  "snippet": "warnings.simplefilter('always')"
 },
 "13550423.18": {
  "intent": "concatenate items of list `l` with a space ' '",
  "body": "How can I print lists without brackets and commas?\nI have a list of permutations like this:\n   [1, 2, 3]\n   [1, 3, 2] etc.. \n\nI want to print them like this: 1 2 3\n",
  "preds": {
   "base:Baseline": "[x for x in L if x.strip()]",
   "body:Baseline": "print(' '.join(str(x) for x in l))",
   "body:-Blocks": "print(' '.join(str(x) for x in L))",
   "body:-Code": "print(' '.join(str(x) for x in L))",
   "body:-Inline": "print(' '.join(str(x) for x in L))",
   "body:-NL": "[x for x in L if x.strip()]",
   "base:+Mined": "[item for item in L if '' in item]",
   "body+mined:Baseline": "print(' '.join(str(x) for x in L))",
   "body+mined:-Code": "print(' '.join(str(x) for x in L))",
   "body+mined:-NL": "[item for item in L if '  ' in item]",
   "body+mined:-Blocks": "print(' '.join(str(x) for x in L))",
   "body+mined:-Inline": "print(' '.join(str(x) for x in L))"
  },
  "snippet": "print(' '.join(map(str, l)))"
 },
 "25651990.19": {
  "intent": "run script 'hello.py' with argument 'htmlfilename.htm' on terminal using python executable",
  "body": "I am trying to call a python file \"hello.py\" from within the python interpreter with subprocess. But I am unable to resolve this error. [Python 3.4.1]. \nimport subprocess    \nsubprocess.call(['hello.py', 'htmlfilename.htm'])\nTraceback (most recent call last):\n  File \" <pyshell#42>\", line 1, in <module>\n    subprocess.call(['hello.py', 'htmlfilename.htm'])\n  File \"C:\\Python34\\lib\\subprocess.py\", line 537, in call\n    with Popen(*popenargs, **kwargs) as p:\n  File \"C:\\Python34\\lib\\subprocess.py\", line 858, in __init__\n    restore_signals, start_new_session)\n  File \"C:\\Python34\\lib\\subprocess.py\", line 1111, in _execute_child\n    startupinfo)\nOSError: [WinError 193] %1 is not a valid Win32 application\n\nAlso is there any alternate way to \"call a python script with arguments\" other than using subprocess?\nThanks in advance.\n",
  "preds": {
   "base:Baseline": "os.system('hello.py', 'htmlfilename.htm')",
   "body:Baseline": "subprocess.call(['hello.py', 'htmlfilename.htm'])",
   "body:-Blocks": "subprocess.call('hello.py', 'htmlfilename.htm')",
   "body:-Code": "subprocess.call('hello.py', 'htmlfilename.htm', shell=True)",
   "body:-Inline": "subprocess.call('hello.py', 'htmlfilename.htm')",
   "body:-NL": "subprocess.call(['hello.py', 'htmlfilename.htm'])",
   "base:+Mined": "subprocess.call('hello.py', shell=True)",
   "body+mined:Baseline": "subprocess.call(['hello.py', 'htmlfilename.htm'])",
   "body+mined:-Code": "subprocess.call('hello.py', shell=True)",
   "body+mined:-NL": "subprocess.call(['hello.py', 'htmlfilename.htm'])",
   "body+mined:-Blocks": "subprocess.call('hello.py', shell=True)",
   "body+mined:-Inline": "subprocess.call(['hello.py', 'htmlfilename.htm'])"
  },
  "snippet": "subprocess.call(['python.exe', 'hello.py', 'htmlfilename.htm'])"
 },
 "698223.20": {
  "intent": "how can i parse a time string containing milliseconds in it with python?",
  "body": "I am able to parse strings containing date/time with time.strptime\nimport time\ntime.strptime('30/03/09 16:31:32', '%d/%m/%y %H:%M:%S')\n(2009, 3, 30, 16, 31, 32, 0, 89, -1)\n\nHow can I parse a time string that contains milliseconds?\ntime.strptime('30/03/09 16:31:32.123', '%d/%m/%y %H:%M:%S')\nTraceback (most recent call last):\n  File \" <stdin>\", line 1, in <module>\n  File \"/usr/lib/python2.5/_strptime.py\", line 333, in strptime\n    data_string[found.end():])\nValueError: unconverted data remains: .123\n\n",
  "preds": {
   "base:Baseline": "time.strftime('%s' % milliseconds)",
   "body:Baseline": "time.strptime('30/03/09 16:31:32.123', '%d/%m/%y %H:%M:%S')",
   "body:-Blocks": "time.strptime('%Y-%m-%d %H:%M')",
   "body:-Code": "time.strptime('%s/%s' % milliseconds)",
   "body:-Inline": "time.strptime('%d/%m/%y %H:%M:%S')",
   "body:-NL": "time.strptime('30/03/09 16:31:32.123', '%d/%m/%y %H:%M:%S')",
   "base:+Mined": "time.strftime('%Y-%m-%d %H:%M:%S')",
   "body+mined:Baseline": "time.strptime('30/03/09 16:31:32.123', '%d/%m/%y %H:%M:%S')",
   "body+mined:-Code": "print(map(int, '%Y-%m-%d').strptime('%H:%M:%S'))",
   "body+mined:-NL": "time.strptime('30/03/09 16:31:32', '%d/%m/%y %H:%M:%S')",
   "body+mined:-Blocks": "print(datetime.strptime('12/01/2014', '%Y-%m-%dT%H:%M:%SZ')",
   "body+mined:-Inline": "time.strptime('30/03/09 16:31:32.123', '%d/%m/%y %H:%M:%S')"
  },
  "snippet": "time.strptime('30/03/09 16:31:32.123', '%d/%m/%y %H:%M:%S.%f')"
 },
 "6633523.21": {
  "intent": "convert a string `my_string` with dot and comma into a float number `my_float`",
  "body": "How can I convert a string like 123,456.908  to float 123456.908  in Python?\n",
  "preds": {
   "base:Baseline": "my_string = float(my_float)",
   "body:Baseline": "float(my_string.split())",
   "body:-Blocks": "my_string.float('my_float')",
   "body:-Code": "my_string.float('my_float')",
   "body:-Inline": "my_string.float('my_float')",
   "body:-NL": "my_string.split(',')",
   "base:+Mined": "my_string.split(',')",
   "body+mined:Baseline": "my_string.float('123456.908')",
   "body+mined:-Code": "my_string.float('my_float')",
   "body+mined:-NL": "my_string.split(',')",
   "body+mined:-Blocks": "my_string.split('.')[0]",
   "body+mined:-Inline": "my_string.float('my_float')"
  },
  "snippet": "my_float = float(my_string.replace(',', ''))"
 },
 "6633523.22": {
  "intent": "convert a string `123,456.908` with dot and comma into a floating number",
  "body": "How can I convert a string like 123,456.908  to float 123456.908  in Python?\n",
  "preds": {
   "base:Baseline": "\"\"\"123,456.908\"\"\".split()",
   "body:Baseline": "float('123,456.908', '')",
   "body:-Blocks": "float('123,456.908')",
   "body:-Code": "float('123,456.908')",
   "body:-Inline": "float('123,456.908')",
   "body:-NL": "\"\"\"\"\"\".join(str(123, 456.908))",
   "base:+Mined": "\"\"\"123,456.908\"\"\".replace(',', '')",
   "body+mined:Baseline": "float('123,456.908')",
   "body+mined:-Code": "float('123,456.908')",
   "body+mined:-NL": "\"\"\"123,456.908\"\"\".replace(', ', '')",
   "body+mined:-Blocks": "float('123,456.908').replace(',', '.')",
   "body+mined:-Inline": "float('123,456.908')"
  },
  "snippet": "float('123,456.908'.replace(',', ''))"
 },
 "3108285.23": {
  "intent": "set pythonpath in python script.",
  "body": "I know how to set it in my /etc/profile and in my environment variables.\nBut what if I want to set it during a script?\nIs it import os, sys? How do I do it?\n",
  "preds": {
   "base:Baseline": "os.path.realpath(__file__)",
   "body:Baseline": "os.path.setdefault(path)",
   "body:-Blocks": "os.path.set_path('/etc/profile')",
   "body:-Code": "os.path.set_path('/etc/profile')",
   "body:-Inline": "os.path.set_path('/etc/profile')",
   "body:-NL": "sys.path.realpath(__file__)",
   "base:+Mined": "sys.path.append('/path/to/my/path')",
   "body+mined:Baseline": "os.path.setp(path)",
   "body+mined:-Code": "os.path.set_dirname('/etc/profile')",
   "body+mined:-NL": "os.path.dirname(__file__)",
   "body+mined:-Blocks": "os.system('/etc/profile')",
   "body+mined:-Inline": "sys.path.append('/etc/profile')"
  },
  "snippet": "sys.path.append('/path/to/whatever')"
 },
 "2195340.24": {
  "intent": "split string 'words, words, words.' using a regex '(\\\\w+)'",
  "body": "Suppose I have a string \"a foobar\" and I use \"^a\\s*\" to match \"a \".\nIs there a way to easily get \"foobar\" returned? (What was NOT matched)\nI want to use a regex to look for a command word  and also use the regex to remove the command word from the string.\nI know how to do this using something like: \nmystring[:regexobj.start()] + email[regexobj.end():]\n\nBut this falls apart if I have multiple matches.\nThanks!\n",
  "preds": {
   "base:Baseline": "re.split('Words, words, words.')",
   "body:Baseline": "re.sub('\\\\w+)', 'Words, words, words.')",
   "body:-Blocks": "re.split('(\\\\w+)', '', 'words, words, words.')",
   "body:-Code": "re.split('\\\\w+)', 'Words, words, words.')",
   "body:-Inline": "re.split('Words, words, words.')",
   "body:-NL": "re.split('Words, words, words.')",
   "base:+Mined": "re.split('\\\\w+)', 'Words, words, words.')",
   "body+mined:Baseline": "re.split('(\\\\w+)', '', mystring)",
   "body+mined:-Code": "re.split('\\\\w+)', 'Words, words, words.')",
   "body+mined:-NL": "re.split('\\\\w+)', 'Words, words, words.')",
   "body+mined:-Blocks": "re.split('\\\\w+', 'Words, words, words.')",
   "body+mined:-Inline": "re.split('\\\\w+)', 'a foobar')"
  },
  "snippet": "re.split('(\\\\W+)', 'Words, words, words.')"
 },
 "17977584.25": {
  "intent": "open a file `output.txt` in append mode",
  "body": "I want to write code to get data from Excel and write it to a text file. Here is the code I have:\nimport xlrd\nimport os.path\nwb = xlrd.open_workbook(os.path.join('D:\\TRB 2014 Data','SPS1 demo data.xlsx'))\nwb.sheet_names()\nsh = wb.sheet_by_index(0)\ni = 1\n\nwhile sh.cell(i,11).value != 0:\n\n   Load = sh.cell(i,11).value\n   D1 = sh.cell(i,13).value\n   D2 = sh.cell(i,14).value\n   D3 = sh.cell(i,15).value\n   D4 = sh.cell(i,16).value\n   D5 = sh.cell(i,17).value\n   D6 = sh.cell(i,18).value\n   D7 = sh.cell(i,19).value\n   DB1 = str(Load) + \"  \" + str(D1) + \"  \" + str(D2) + \"  \" + str(D3)+ \"  \" + str(D4)+ \"  \" + str(D5)+ \"  \" + str(D6)+ \"  \" + str(D7)\n\n   file = open(\"Output.txt\", \"w\")\n   file.write(DB1 + '\\n')\n   file.close\n   i = i + 1\n\nThe problem with this code is the data written to the text file is always displayed at the first row. Therefore, although I have 20 rows of data in excel, the text file only shows the last data in the excel file at the very first row in the text file. I have '\\n'  in file.write  but, it doesn't seem to work.\n",
  "preds": {
   "base:Baseline": "open('output.txt', shell=True)",
   "body:Baseline": "wb = xlrd.open('Output.txt', 'w')",
   "body:-Blocks": "open('output.txt', append=True)",
   "body:-Code": "open('output.txt', append=True)",
   "body:-Inline": "wb.open('Output.txt', 'w')",
   "body:-NL": "wb.open('Output.txt', append=True)",
   "base:+Mined": "f = open('output.txt', 'r')",
   "body+mined:Baseline": "file = open('Output.txt', 'wb')",
   "body+mined:-Code": "open('output.txt', 'r', append=True)",
   "body+mined:-NL": "file.write(DB1 + '\\n')",
   "body+mined:-Blocks": "f.write('output.txt', append=True)",
   "body+mined:-Inline": "file = open('Output.txt', 'wb')"
  },
  "snippet": "file = open('Output.txt', 'a')"
 },
 "22676.26": {
  "intent": "download a file \"http://www.example.com/songs/mp3.mp3\" over http and save to \"mp3.mp3\"",
  "body": "I have a small utility that I use to download an MP3 file from a website on a schedule and then builds/updates a podcast XML file which I've added to iTunes.\nThe text processing that creates/updates the XML file is written in Python. However, I use wget inside a Windows .bat  file to download the actual MP3 file. I would prefer to have the entire utility written in Python.\nI struggled to find a way to actually download the file in Python, thus why I resorted to using wget .\nSo, how do I download the file using Python?\n",
  "preds": {
   "base:Baseline": "urllib.request.urlretrieve('http://www.example.com/songs/mp3.mp3')",
   "body:Baseline": "wget.download('http://www.example.com/songs/mp3.mp3', shell=True)",
   "body:-Blocks": "wget.download('http://www.example.com/songs/mp3.mp3')",
   "body:-Code": "urllib.request.urlretrieve('http://www.example.com/songs/mp3.mp3')",
   "body:-Inline": "wget.download('http://www.example.com/songs/mp3.mp3')",
   "body:-NL": "download('http://www.example.com/songs/mp3.mp3', shell=True)",
   "base:+Mined": "file = open('http://www.example.com/songs/mp3.mp3', 'wb')",
   "body+mined:Baseline": "urllib.request.urlretrieve('http://www.example.com/songs/mp3.mp3', files)",
   "body+mined:-Code": "urllib.request.urlretrieve('http://www.example.com/songs/mp3.mp3', 'wb')",
   "body+mined:-NL": "urllib.request.urlretrieve('http://www.example.com/songs/mp3.mp3', filename)",
   "body+mined:-Blocks": "wget('http://www.example.com/songs/mp3.mp3')",
   "body+mined:-Inline": "urllib.request.urlretrieve('http://www.example.com/songs/mp3.mp3', 'rb')"
  },
  "snippet": "urllib.request.urlretrieve('http://www.example.com/songs/mp3.mp3', 'mp3.mp3')"
 },
 "22676.28": {
  "intent": "download a file 'http://www.example.com/' over http",
  "body": "I have a small utility that I use to download an MP3 file from a website on a schedule and then builds/updates a podcast XML file which I've added to iTunes.\nThe text processing that creates/updates the XML file is written in Python. However, I use wget inside a Windows .bat  file to download the actual MP3 file. I would prefer to have the entire utility written in Python.\nI struggled to find a way to actually download the file in Python, thus why I resorted to using wget .\nSo, how do I download the file using Python?\n",
  "preds": {
   "base:Baseline": "download('http://www.example.com/', shell=True)",
   "body:Baseline": "wget.download('http://www.example.com/', shell=True)",
   "body:-Blocks": "wget.download('http://www.example.com/')",
   "body:-Code": "urllib.request.urlopen('http://www.example.com/')",
   "body:-Inline": "download('http://www.example.com/', shell=True)",
   "body:-NL": "download('http://www.example.com/', shell=True)",
   "base:+Mined": "urllib.request.urlretrieve('http://www.example.com/', filename)",
   "body+mined:Baseline": "urllib.request.urlretrieve('http://www.example.com/', file)",
   "body+mined:-Code": "webbrowser.download('http://www.example.com/')",
   "body+mined:-NL": "print(open('http://www.example.com/').read())",
   "body+mined:-Blocks": "webbrowser.open('http://www.example.com/')",
   "body+mined:-Inline": "urllib.request.urlretrieve('http://www.example.com/', files)"
  },
  "snippet": "response = urllib.request.urlopen('http://www.example.com/')\nhtml = response.read()"
 },
 "22676.29": {
  "intent": "download a file `url` over http",
  "body": "I have a small utility that I use to download an MP3 file from a website on a schedule and then builds/updates a podcast XML file which I've added to iTunes.\nThe text processing that creates/updates the XML file is written in Python. However, I use wget inside a Windows .bat  file to download the actual MP3 file. I would prefer to have the entire utility written in Python.\nI struggled to find a way to actually download the file in Python, thus why I resorted to using wget .\nSo, how do I download the file using Python?\n",
  "preds": {
   "base:Baseline": "urllib.request.urlretrieve(url)",
   "body:Baseline": "wget.read_open('url', shell=True)",
   "body:-Blocks": "wget.download('url', shell=True)",
   "body:-Code": "urllib.request.urlopen(url)",
   "body:-Inline": "print(open('download', 'url').read())",
   "body:-NL": "print(url.read(), 1)",
   "base:+Mined": "urllib.request.urlopen(url)",
   "body+mined:Baseline": "urllib.request.urlretrieve('http://www.google.com', url)",
   "body+mined:-Code": "webbrowser.download(url)",
   "body+mined:-NL": "urllib.request.urlretrieve('http://stackoverflow.com', 'url', filename)",
   "body+mined:-Blocks": "webbrowser.open(url)",
   "body+mined:-Inline": "urllib.request.urlretrieve('http://httpbin.org/download', files)"
  },
  "snippet": "r = requests.get(url)"
 },
 "15405636.31": {
  "intent": "argparse add argument with flag '--version' and version action of '%(prog)s 2.0' to parser `parser`",
  "body": "What's the preferred way of specifying program name and version info within argparse?\n\n__version_info__ = ('2013','03','14')\n__version__ = '-'.join(__version_info__)\n<console_out>\nparser.add_argument('-V', '--version', action='version', version=\"%(prog)s (\"+__version__+\")\")\n\n\nhttp://argparse.googlecode.com/svn/trunk/doc/ArgumentParser.html#prog\nhttp://pymotw.com/2/argparse/\nhttp://www.python.org/dev/peps/pep-0386/\nhttp://www.python.org/dev/peps/pep-0396/\nhttp://www.python.org/dev/peps/pep-3001/\n\n",
  "preds": {
   "base:Baseline": "parser.add_argument('--version', '%(prog)s 2.0')",
   "body:Baseline": "parser.add_argument('-V', '--version', action='version', '%(prog)s 2.0')",
   "body:-Blocks": "parser.add_argument('--version', '%(prog)s 2.0')",
   "body:-Code": "parser.add_argument('--version', '%(prog)s 2.0')",
   "body:-Inline": "parser.add_argument('-V', '--version', version='%(prog)s 2.0')",
   "body:-NL": "parser.add_argument('-V', '--version', action='version', version=\"%(prog)s 2.0')",
   "base:+Mined": "parser.add_argument('--version', nargs='%(prog)s 2.0')",
   "body+mined:Baseline": "parser.add_argument('-V', '--version', action='version', version=\n    '%(prog)s (\"+__version__+')",
   "body+mined:-Code": "parser.add_argument('--version', action='%(prog)s 2.0')",
   "body+mined:-NL": "parser.add_argument('-V', '--version', action='version', version='%(prog)s ('+__version__+')",
   "body+mined:-Blocks": "parser.add_argument('--version', help='%(prog)s 2.0')",
   "body+mined:-Inline": "parser.add_argument('-V', '--version', version='%(prog)s (\"+__version__+\")')"
  },
  "snippet": "parser.add_argument('--version', action='version', version='%(prog)s 2.0')"
 },
 "17665809.32": {
  "intent": "remove key 'c' from dictionary `d`",
  "body": "I have a dictionary\nd = {'a':1, 'b':2, 'c':3}\n\nI need to remove a key, say c  and return the dictionary without that key in one function call\n{'a':1, 'b':2}\n\nd.pop('c') will return the key value - 3 - instead of the dictionary.\nI am going to need one function solution if it exists, as this will go into comprehensions\n",
  "preds": {
   "base:Baseline": "d = d.remove('c')",
   "body:Baseline": "d = {'a': 1, 'b': 2, 'c': 3}",
   "body:-Blocks": "d = d.pop('c')",
   "body:-Code": "dict((k, c) for k, c in d.items())",
   "body:-Inline": "dict((k, v) for k, v in list(d.items()))",
   "body:-NL": "d = {'a': 1, 'b': 2, 'c': 3}",
   "base:+Mined": "d = {k: v for k, v in d.items()}",
   "body+mined:Baseline": "d = {k: v for k, v in list(d.items())}",
   "body+mined:-Code": "d['c'] = dict((k, v) for k, v in d.items())",
   "body+mined:-NL": "d = {k: v for k, v in list(d.items()) if v}",
   "body+mined:-Blocks": "dict((k, v) for k, v in d.items() if v != 'c')",
   "body+mined:-Inline": "d = {k: v for k, v in list(d.items()) if 'c' in k}"
  },
  "snippet": "{i: d[i] for i in d if i != 'c'}"
 },
 "41861705.33": {
  "intent": "create new dataframe object by merging columns \"key\" of  dataframes `split_df` and `csv_df` and rename the columns from dataframes `split_df` and `csv_df` with suffix `_left` and `_right` respectively",
  "body": "I've seen this question a few times, but the answers are not working for me.  I have two dataframes, split_df  and csv_df  that I;m trying to merge on a column that is called key  in each of them.  \nHere's the top 5 items from split_df\n        key        tags\n2785  30000        ipv6\n2785  30000  networking\n2785  30000    wireless\n2785  30000   standards\n2785  30000      satcom\n\nHere's the top 5 items from the csv_df\n     key\n0  30000\n1  30002\n2  31288\n3  33630\n4  31663\n\nWhen I run this merge statement:\ncommon_df = pd.merge(split_df,csv_df, on=['key'], suffixes=('_left', '_right'))\n\nI get:\nEmpty DataFrame\nColumns: [key, tags]\nIndex: []\n\nProcess finished with exit code 0\nI can't figure out why the merge isn't working for me.  Any suggestions?\nI have indexes on both (and have run the merge with them out as well)\ncsv_df.set_index('key')\nsplit_df.set_index('key')\n\nI am very new to Pyton and Pandas\nThanks!\n",
  "preds": {
   "base:Baseline": "pd.merge(split_df, csv_df)",
   "body:Baseline": "pd.merge(set_index('key', on=['key'], sep='_left', '_right'))",
   "body:-Blocks": "dataframe.merge(['key'], 'csv_df'], inplace=True)",
   "body:-Code": "df.merge(['key'], 'csv_df', 'key'])",
   "body:-Inline": "common_df.set_index('key')",
   "body:-NL": "pd.merge(split_df,csv_df), on=['key'], suffixes=['_left', '_right'])",
   "base:+Mined": "pd.concat([split_df, csv_df], axis=1)",
   "body+mined:Baseline": "df.set_index('key')",
   "body+mined:-Code": "pd.merge(df1, df2, on=['key', '_right'])",
   "body+mined:-NL": "df.set_index('key')",
   "body+mined:-Blocks": "merged = pd.merge(df1, df2, on='key', on='value')",
   "body+mined:-Inline": "df.set_index('key')"
  },
  "snippet": "pd.merge(split_df, csv_df, on=['key'], suffixes=('_left', '_right'))"
 },
 "10697757.34": {
  "intent": "split a string `s` by space with `4` splits",
  "body": "I'm quite new to regular expression in python. I have the following string and want to split them into five categories. I just use the split() but it will just split according to white spaces.\ns = \"1 0 A10B 1/00 Description: This is description with spaces\"\nsp = s.split()\nsp\n[\"1\", \"0\", \"A10B\", \"1/00\", \"Description:\", \"This\", \"is\", \"description\", \"with\", \"spaces\"]\n\nHow can I write a regular expression to make it split like this:\n [\"1\", \"0\", \"A10B\", \"1/00\", \"Description: This is description with spaces\"]\n\nCan somebody help please? Thanks!\n",
  "preds": {
   "base:Baseline": "s = s.split(4)",
   "body:Baseline": "s = s.split(4)",
   "body:-Blocks": "re.split('\\\\4', s)",
   "body:-Code": "s.split(4, 4)",
   "body:-Inline": "sp = s.split(4)",
   "body:-NL": "sp = s.split(4)",
   "base:+Mined": "re.split('\\\\s+', s)",
   "body+mined:Baseline": "re.split('\\\\s+', s)",
   "body+mined:-Code": "re.findall('\\\\s+', s)",
   "body+mined:-NL": "re.split('\\\\s+', s)",
   "body+mined:-Blocks": "s.split(',')[4]",
   "body+mined:-Inline": "re.findall('\\\\[^\\\\]]*', s)"
  },
  "snippet": "s.split(' ', 4)"
 },
 "5404068.35": {
  "intent": "read keyboard-input",
  "body": "I would like to read data from the keyboard in python\nI try this:\nnb = input('Choose a number')\nprint ('Number%s \\n' % (nb))\n\nBut it doesn't work, neither with eclipse nor in the terminal, it's always stop of the question. I can type a number but after nothing happen.\nDo you know why?\n",
  "preds": {
   "base:Baseline": "input = input.read_key('input')",
   "body:Baseline": "print('Number%s \\n' % nb)",
   "body:-Blocks": "sys.stdout.read().read()",
   "body:-Code": "input = pd.read().input()",
   "body:-Inline": "nb = input('Number%s \\n' % nb)",
   "body:-NL": "nb = input('Choose a number')",
   "base:+Mined": "input('Press Enter to continue;')",
   "body+mined:Baseline": "nb = input('Choose a number')",
   "body+mined:-Code": "input('Enter a number: ')",
   "body+mined:-NL": "nb = input('Choose a number')",
   "body+mined:-Blocks": "input('Press Enter to continue;')",
   "body+mined:-Inline": "nb = input('Choose a number')"
  },
  "snippet": "input('Enter your input:')"
 },
 "16344756.36": {
  "intent": "enable debug mode on flask application `app`",
  "body": "I'm investigating how to develop a decent web app with Python. Since I don't want some high-order structures to get in my way, my choice fell on the lightweight Flask framework . Time will tell if this was the right choice.\nSo, now I've set up an Apache server with mod_wsgi, and my test site is running fine. However, I'd like to speed up the development routine by making the site automatically reload upon any changes in py or template files I make. I see that any changes in site's .wsgi file causes reloading (even without WSGIScriptReloading On in the apache config file), but I still have to prod it manually (ie, insert extra linebreak, save). Is there some way how to cause reload when I edit some of the app's py files? Or, I am expected to use IDE that refreshes the .wsgi file for me?\n",
  "preds": {
   "base:Baseline": "app.debug().disable_mode()",
   "body:Baseline": "app.config(debug=True)",
   "body:-Blocks": "app.set_debug_mode(app)",
   "body:-Code": "app.set_debug_mode(app.WRITE_SYSTEM)",
   "body:-Inline": "app.disableDebug()[::-1]",
   "body:-NL": "app.configure_mode(debug=False)",
   "base:+Mined": "app.run(debug=True)",
   "body+mined:Baseline": "app.run(debug=True)",
   "body+mined:-Code": "app.run(debug=True)",
   "body+mined:-NL": "app.run(debug=True)",
   "body+mined:-Blocks": "app.run(debug=True)",
   "body+mined:-Inline": "app.run(debug=True)"
  },
  "snippet": "app.run(debug=True)"
 },
 "40133826.37": {
  "intent": "python save list `mylist` to file object 'save.txt'",
  "body": "Basically I would like to save a list to python and then when the program starts I would like to retrieve the data from the file and put it back into the list.\n \nSo far this is the code I am using\nmylist = pickle.load(\"save.txt\")\n<console_out>\nsaveToList = (name, data)\nmylist.append(saveList)\nimport pickle\npickle.dump(mylist, \"save.txt\")\n\nBut it just returns the following error: TypeError: file must have 'read' and 'readline' attributes\n",
  "preds": {
   "base:Baseline": "mylist.save('save.txt')",
   "body:Baseline": "pickle.dump(mylist, 'save.txt')",
   "body:-Blocks": "mylist.save(filename='save.txt')",
   "body:-Code": "mylist = os.save('save.txt')",
   "body:-Inline": "pickle.load('save.txt')",
   "body:-NL": "pickle.dump(mylist, 'save.txt')",
   "base:+Mined": "mylist.write('save.txt')",
   "body+mined:Baseline": "pickle.dump(mylist, 'save.txt')",
   "body+mined:-Code": "mylist = open('save.txt', 'r')",
   "body+mined:-NL": "pickle.dump(mylist, 'save.txt')",
   "body+mined:-Blocks": "mylist.write('save.txt')",
   "body+mined:-Inline": "pickle.dump(mylist, 'save.txt')"
  },
  "snippet": "pickle.dump(mylist, open('save.txt', 'wb'))"
 },
 "4490961.38": {
  "intent": "multiply a matrix `p` with a 3d tensor `t` in scipy",
  "body": "I have a matrix P  with shape MxN  and a 3d tensor T  with shape KxNxR . I want to multiply P  with every NxR  matrix in T , resulting in a KxMxR  3d tensor.\nP.dot(T).transpose(1,0,2)  gives the desired result. Is there a nicer  solution (i.e. getting rid of transpose ) to this problem? This must be quite a common operation, so I assume, others have found different approaches, e.g. using tensordot  (which I tried but failed to get the desired result). Opinions/Views would be highly appreciated!\n",
  "preds": {
   "base:Baseline": "p = p.multiply(t)",
   "body:Baseline": "P.dot(T).transpose(1, 0, 2)",
   "body:-Blocks": "P.dot(T).transpose(1, 0, 2)",
   "body:-Code": "p = scipy.multiply(p, t)",
   "body:-Inline": "p = scipy.multiply(p, t)",
   "body:-NL": "p.dot(T).transpose(1, 0, 2)",
   "base:+Mined": "np.einsum('ij->ij->ik->j->ik', p)",
   "body+mined:Baseline": "P.dot(T).transpose(1, 0, 2)",
   "body+mined:-Code": "np.einsum('ijk,ikl->ikl', p)",
   "body+mined:-NL": "T.transpose(1, 0, 2)",
   "body+mined:-Blocks": "P.dot(T).transpose(1, 0, 2).tolist()",
   "body+mined:-Inline": "scipy.T.ravel()"
  },
  "snippet": "scipy.tensordot(P, T, axes=[1, 1]).swapaxes(0, 1)"
 },
 "2173087.39": {
  "intent": "create 3d array of zeroes of size `(3,3,3)`",
  "body": "I know you can create easily nested lists in python like this:\n[[1,2],[3,4]]\n\nBut how to create a 3x3x3 matrix of zeroes?\n[[[0] * 3 for i in range(0, 3)] for j in range (0,3)]\n\nor \n[[[0]*3]*3]*3\n\nDoesn't seem right. There is no way to create it just passing a list of dimensions to a method? Ex:\nCreateArray([3,3,3])\n\n",
  "preds": {
   "base:Baseline": "np.zeros((3, 3, 3))",
   "body:Baseline": "[[(3, 3, 3)], [1, 2], [3, 4]]",
   "body:-Blocks": "zip(*(3, 3, 3))",
   "body:-Code": "np.array([3, 3, 3])",
   "body:-Inline": "[(3, 3, 3)]",
   "body:-NL": "np.array([3, 3, 3])",
   "base:+Mined": "np.zeroes(3, 3, 3)",
   "body+mined:Baseline": "[[[0] * 3 for i in range(0, 3)] for j in range (3, 3)]]",
   "body+mined:-Code": "np.zeros((3, 3, 3))",
   "body+mined:-NL": "np.array([[0] * 3) for j in range(0, 3)]",
   "body+mined:-Blocks": "np.zeros((3, 3, 3))",
   "body+mined:-Inline": "[[[0] * 3] for j in range(0, 3)] for i in range (0, 4)]"
  },
  "snippet": "numpy.zeros((3, 3, 3))"
 },
 "6266727.40": {
  "intent": "cut off the last word of a sentence `content`",
  "body": "What's the best way to slice the last word from a block of text? \nI can think of \n\nSplit it to a list (by spaces) and removing the last item, then reconcatenating the list.\nUse a regular expression to replace the last word.\n\nI'm currently taking approach #1, but I don't know how to concatenate the list...\ncontent = content[position-1:position+249] # Content\nwords = string.split(content, ' ')\nwords = words[len[words] -1] # Cut of the last word\n\nAny code examples are much appreciated.\n",
  "preds": {
   "base:Baseline": "content = re.sub('[-1]', '', content)",
   "body:Baseline": "content = re.sub('\\\\w+', '', content)",
   "body:-Blocks": "re.sub('[^a-zA-Z]', content)",
   "body:-Code": "[x for x in content if x.rstrip()]",
   "body:-Inline": "content.split(content, '')",
   "body:-NL": "content = content[position - 1:position + 249]",
   "base:+Mined": "content.rstrip().split()[-1]",
   "body+mined:Baseline": "content = content[position - 1:position + 249]",
   "body+mined:-Code": "re.sub('\\\\s+', '', content)",
   "body+mined:-NL": "content = content[position - 1:position + 249]",
   "body+mined:-Blocks": "re.sub('[^\\\\w]', '', content)",
   "body+mined:-Inline": "content.split(',')[-1]"
  },
  "snippet": "\"\"\" \"\"\".join(content.split(' ')[:-1])"
 },
 "30385151.41": {
  "intent": "convert scalar `x` to array",
  "body": "I am evaluating arbitrary expressions in terms of an x array, such as 3*x**2 + 4. This normally results in an array with x's shape. However if the expression is just a constant, it returns a scalar. What is the best way to ensure it has x's shape without explicitly checking the shape? Multiplying by numpy.ones(x.shape) works, but I think that uses unnecessary computations. \nEdit:\nTo be clear, I don't just want it to be an array with size one, I want it to be the same shape and size as X. \nI'm evaluating a string using NumExpr which can contain an arbitrary function of x:\nx = numpy.linspace(min, max, num)\ny = numexpr.evaluate(expr, {'x': x}, {})\n\nI want to get an array of y-values that could be plotted against x through matplotlib. Currently I am doing this, which works fine:\ny = numpy.ones(x.size) * y\n\nBut I'm worried that this is wasteful for large sizes. Is there a better way?\n",
  "preds": {
   "base:Baseline": "np.arange(x, 2)",
   "body:Baseline": "np.linspace(min, max, num) * np.ones(x.shape)",
   "body:-Blocks": "np.array(x.shape)",
   "body:-Code": "np.array([x.shape]))",
   "body:-Inline": "np.linspace(x.shape)",
   "body:-NL": "np.linspace(min, max, num)",
   "base:+Mined": "np.array(x).reshape(-1, 1)",
   "body+mined:Baseline": "numpy.linspace(min, max, num) * np.ones(x.shape)",
   "body+mined:-Code": "x = np.zeros((3, **2))",
   "body+mined:-NL": "numpy.linspace(min, max, num)",
   "body+mined:-Blocks": "x = np.zeros((3, 2))",
   "body+mined:-Inline": "numpy.linspace(min, max, num)"
  },
  "snippet": "x = np.asarray(x).reshape(1, -1)[(0), :]"
 },
 "15856127.42": {
  "intent": "sum all elements of nested list `l`",
  "body": "import math\nlists =  [1,[2,3],4]\ntotal = 0\nfor i in range(len(lists)):\n    total += sum(i)\nprint(total)\n\nI want it to print,\n<console_in>10\n\nBut throws a error.\nI would like it to get it to add all numbers, including the ones within the nested if.\n",
  "preds": {
   "base:Baseline": "sum(l) for l in l)",
   "body:Baseline": "sum(i) for i, j in zip(L, L)]",
   "body:-Blocks": "print([x for x in L if x not in x]",
   "body:-Code": "print([sum(x) for x in L)]",
   "body:-Inline": "total = sum(len(list))",
   "body:-NL": "sum(itertools.chain(*l))",
   "base:+Mined": "sum(l[0] for l in L)",
   "body+mined:Baseline": "total = sum(list(range(len(lists)))",
   "body+mined:-Code": "print(sum(l) for l in L)",
   "body+mined:-NL": "sum(list(itertools.chain.from_iterable(l)))",
   "body+mined:-Blocks": "[(x, y) for x, y in zip(*l)]",
   "body+mined:-Inline": "total = sum(map(lambda x: x + list(len(x)))"
  },
  "snippet": "sum(sum(i) if isinstance(i, list) else i for i in L)"
 },
 "1592158.43": {
  "intent": "convert hex string '470fc614' to a float number",
  "body": "How to convert the following hex string to float (single precision 32-bit) in Python?\n\"41973333\" -> 1.88999996185302734375E1\n\n\"41995C29\" -> 1.91700000762939453125E1\n\n\"470FC614\" -> 3.6806078125E4\n\n",
  "preds": {
   "base:Baseline": "float('470fc614', 16)",
   "body:Baseline": "float('470FC614', 16)",
   "body:-Blocks": "float('470fc614', 16)",
   "body:-Code": "float('470fc614', 16)",
   "body:-Inline": "float('470FC614', 16)",
   "body:-NL": "\"\"\"470FC614\"\"\".decode('hex')",
   "base:+Mined": "int('470fc614', 16)",
   "body+mined:Baseline": "int('470FC614', 16)",
   "body+mined:-Code": "int('470fc614', 16)",
   "body+mined:-NL": "int('470FC614', 16)",
   "body+mined:-Blocks": "struct.unpack('470fc614', 16)",
   "body+mined:-Inline": "int('470FC614', 16)"
  },
  "snippet": "struct.unpack('!f', '470FC614'.decode('hex'))[0]"
 },
 "5010536.44": {
  "intent": "multiple each value by `2` for all keys in a dictionary `my_dict`",
  "body": "In python 2.6 I want to perform an operation on each dictionary value, for example, I want to multiply by 2 for each of them. How to code less for this task? \n",
  "preds": {
   "base:Baseline": "[k for k, v in list(my_dict.items() if v > 2]",
   "body:Baseline": "max(k, v) for k, v in my_dict.items())",
   "body:-Blocks": "dict((k, v) for k, v in my_dict.items())",
   "body:-Code": "max(k, v) for k, v in my_dict.items()",
   "body:-Inline": "max(my_dict.keys())",
   "body:-NL": "max(my_dict.values())",
   "base:+Mined": "dict((k, v) for k, v in my_dict.items())",
   "body+mined:Baseline": "my_dict.values.multiply(2, 2)",
   "body+mined:-Code": "[(k, v) for k, v in my_dict.items()]",
   "body+mined:-NL": "list(my_dict.values())",
   "body+mined:-Blocks": "[(v * 2) for k, v in my_dict.items()]",
   "body+mined:-Inline": "my_dict.values.multiply(2)"
  },
  "snippet": "my_dict.update((x, y * 2) for x, y in list(my_dict.items()))"
 },
 "13745648.45": {
  "intent": "running bash script 'sleep.sh'",
  "body": "I have a problem with the following code:\ncallBash.py:\nimport subprocess\nprint \"start\"\nsubprocess.call(\"sleep.sh\")\nprint \"end\"\n\nsleep.sh:\nsleep 10\n\nI want the \"end\" to be printed after 10s. (I know that this is a dumb example, I could simply sleep within python, but this simple sleep.sh file was just as a test)\n",
  "preds": {
   "base:Baseline": "os.system('sleep.sh')",
   "body:Baseline": "subprocess.call('sleep.sh')",
   "body:-Blocks": "sys.system('sleep.sh')",
   "body:-Code": "os.system('sleep.sh')",
   "body:-Inline": "subprocess.call('sleep.sh')",
   "body:-NL": "subprocess.call('sleep.sh')",
   "base:+Mined": "subprocess.call('sleep.sh', shell=True)",
   "body+mined:Baseline": "subprocess.call('sleep.sh', shell=True)",
   "body+mined:-Code": "os.system('sleep.sh')",
   "body+mined:-NL": "subprocess.call('sleep.sh', shell=True)",
   "body+mined:-Blocks": "os.system('sleep.sh')",
   "body+mined:-Inline": "subprocess.call('sleep.sh', shell=True)"
  },
  "snippet": "subprocess.call('sleep.sh', shell=True)"
 },
 "44778.46": {
  "intent": "join elements of list `l` with a comma `,`",
  "body": "What would be your preferred way to concatenate strings from a sequence such that between every two consecutive pairs a comma is added. That is, how do you map, for instance, ['a', 'b', 'c']  to 'a,b,c' ? (The cases ['s']  and []  should be mapped to 's'  and '' , respectively.)\nI usually end up using something like ''.join(map(lambda x: x+',',l))[:-1] , but also feeling somewhat unsatisfied.\n",
  "preds": {
   "base:Baseline": "[x for x in L if x.split(',')]",
   "body:Baseline": "'.join(map(lambda x: x +',', l))[:-1]",
   "body:-Blocks": "l = map(lambda x: x+',',l))",
   "body:-Code": "[(x + y) for x, y in L.split(',')]",
   "body:-Inline": "[(a, b) for a, b in L]",
   "body:-NL": "'.join(map(lambda x: x +',',l))[:-1]",
   "base:+Mined": "l = [item for item in l if item.isdigit()]",
   "body+mined:Baseline": "\"\"\", \"\"\".join(map(lambda x: x + ',', L))[:-1]",
   "body+mined:-Code": "\"\"\"\"\"\".join(str(x) for x in L)",
   "body+mined:-NL": "\"\"\"\"\"\".join(map(lambda x: x + ',', l))[:-1]",
   "body+mined:-Blocks": "map(lambda x: x + 'a', l))",
   "body+mined:-Inline": "[(x + y) for x, y in L.split(',')]"
  },
  "snippet": "\"\"\",\"\"\".join(l)"
 },
 "44778.47": {
  "intent": "make a comma-separated string from a list `mylist`",
  "body": "What would be your preferred way to concatenate strings from a sequence such that between every two consecutive pairs a comma is added. That is, how do you map, for instance, ['a', 'b', 'c']  to 'a,b,c' ? (The cases ['s']  and []  should be mapped to 's'  and '' , respectively.)\nI usually end up using something like ''.join(map(lambda x: x+',',l))[:-1] , but also feeling somewhat unsatisfied.\n",
  "preds": {
   "base:Baseline": "re.sub('[^a-zA-Z]', mylist)",
   "body:Baseline": "\"\"\"\"\"\".join(map(lambda x: x + ',', l))[:-1]",
   "body:-Blocks": "\"\"\"\"\"\".join(map(lambda x: x + ',', l))[:-1]",
   "body:-Code": "\"\"\"\"\"\".join(mylist.split())",
   "body:-Inline": "\"\"\"\"\"\".join(c for c in mylist if c.split())",
   "body:-NL": "'.join(map(lambda x: x +',', l))[:-1]",
   "base:+Mined": "myList = [item.split() for item in myList]",
   "body+mined:Baseline": "\"\"\"\"\"\".join(map(lambda x: x + ',', L))[:-1]",
   "body+mined:-Code": "\"\"\"\"\"\".join(myList[:2])",
   "body+mined:-NL": "\"\"\"\"\"\".join(map(lambda x: x + ',', l))[:-1]",
   "body+mined:-Blocks": "mylist.split(',')[:-1]",
   "body+mined:-Inline": "\"\"\"\"\"\".join(mylist[::2] + mylist[1::2])"
  },
  "snippet": "myList = ','.join(map(str, myList))"
 },
 "7286365.48": {
  "intent": "reverse the list that contains 1 to 10",
  "body": "How can you produce the following list with range()  in Python?\n[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]\n\n",
  "preds": {
   "base:Baseline": "[x for x in range(10)]",
   "body:Baseline": "[i for i, j in range(10)]",
   "body:-Blocks": "[x for x in range(10)]",
   "body:-Code": "[i for i in range(10)]",
   "body:-Inline": "[list(range(10)) for _ in range(10)]",
   "body:-NL": "[x for x in range(10)]",
   "base:+Mined": "[x[0] for x in range(10)]",
   "body+mined:Baseline": "[x for x in range(10)]",
   "body+mined:-Code": "[reverse([1, 10]) for _ in range(10)]",
   "body+mined:-NL": "[x for x in range(10)]",
   "body+mined:-Blocks": "[l[::-1] for l in range(10)]",
   "body+mined:-Inline": "[x[1] for x in range(10)]"
  },
  "snippet": "list(reversed(list(range(10))))"
 },
 "18454570.49": {
  "intent": "remove substring 'bag,' from a string 'lamp, bag, mirror'",
  "body": "I have a long string, which is basically a list like str=\"lamp, bag, mirror,\"  (and other items)\nI was wondering if I can add or subtract some items, in other programming languages I can easily do: str=str-\"bag,\"  and get str=\"lamp, mirror,\"  this doesnt work in python (I'm using 2.7 on a W8 pc)\nIs there a way to split the string across say \"bag,\" and somehow use that as a subtraction? Then I still need to figure out how to add.\n",
  "preds": {
   "base:Baseline": "\"\"\"\"\"\".join('lamp, bag, mirror')",
   "body:Baseline": "\"\"\"lamp, bag, mirror\"\"\"[::-1]",
   "body:-Blocks": "\"\"\"lamp, bag, mirror\"\"\".replace('bag', 'bag')",
   "body:-Code": "\"\"\"Lamp, bag, mirror\"\"\".replace('bag', '')",
   "body:-Inline": "re.sub('lamp, bag, mirror', 'bag', 1)",
   "body:-NL": "\"\"\"lamp, bag, mirror\"\"\".replace('bag', '')",
   "base:+Mined": "\"\"\"lamp, bag, mirror\"\"\".replace('bag', '')",
   "body+mined:Baseline": "re.sub('\\\\bbag\\\\b', '', 'lamp, bag, mirror', s)",
   "body+mined:-Code": "\"\"\"Lamp, bag, mirror\"\"\".replace('bag', '')",
   "body+mined:-NL": "\"\"\"lamp, bag, mirror.\"\"\".replace('bag', '')",
   "body+mined:-Blocks": "re.sub('\\\\bbag', '', str)",
   "body+mined:-Inline": "\"\"\"Lamp, bag, mirror\"\"\".translate(None, 'bag')"
  },
  "snippet": "print('lamp, bag, mirror'.replace('bag,', ''))"
 },
 "4357787.50": {
  "intent": "reverse the order of words, delimited by `.`, in string `s`",
  "body": "I have the following string:\napple.orange.red.green.yellow\n\nHow can i reverse it to get the following:\nyellow.green.red.orange.apple\n\n",
  "preds": {
   "base:Baseline": "re.sub('(.)', s)",
   "body:Baseline": "re.findall('\\\\b\\\\d+', s)",
   "body:-Blocks": "re.findall('\\\\d+', s)",
   "body:-Code": "re.sub('\\\\.\\\\.', s)",
   "body:-Inline": "re.findall('\\\\.', s)",
   "body:-NL": "s.split('.', 1)[::-1]",
   "base:+Mined": "reversed(s, delimiter='.', reverse=True)",
   "body+mined:Baseline": "s = s.split(',')",
   "body+mined:-Code": "re.sub('(.+)\\\\.\\\\.', '', s)",
   "body+mined:-NL": "re.split('\\\\.', s)",
   "body+mined:-Blocks": "re.sub('(.+)', '\\\\1', s)",
   "body+mined:-Inline": "re.findall('\\\\.\\\\s+', s)"
  },
  "snippet": "\"\"\".\"\"\".join(s.split('.')[::-1])"
 },
 "21787496.51": {
  "intent": "convert epoch time represented as milliseconds `s` to string using format '%y-%m-%d %h:%m:%s.%f'",
  "body": "I have used a ruby script to convert iso time stamp to epoch, the files that I am parsing has following time stamp structure: \n2009-03-08T00:27:31.807\n\nSince I want to keep milliseconds I used following ruby code to convert it to epoch time: \nirb(main):010:0> DateTime.parse('2009-03-08T00:27:31.807').strftime(\"%Q\")\n=> \"1236472051807\"\n\nBut In python I tried following: \nimport time \ntime.strftime('%Y-%m-%d %H:%M:%S', time.gmtime(1236472051807))\n\nBut I don't get the original time date time back, \ntime.strftime('%Y-%m-%d %H:%M:%S', time.gmtime(1236472051807))\n'41152-03-29 02:50:07'\n\n\nI wonder is it related to how I am formatting? \n",
  "preds": {
   "base:Baseline": "time.strftime('%Y-%m-%d %H:%M:%S.%f')",
   "body:Baseline": "time.strftime('%Y-%m-%d %H:%M:%S.%f')",
   "body:-Blocks": "time.strftime('%Y-%m-%d %H:%M:%S.%f')",
   "body:-Code": "time.strftime('%Y-%m-%d %H:%M:%S.%f')",
   "body:-Inline": "time.strftime('%Y-%m-%d %H:%M:%S.%f')",
   "body:-NL": "time.strftime('%Y-%m-%d %H:%M:%S.%f')",
   "base:+Mined": "time.mktime(s, '%Y-%m-%d %H:%M:%S.%f')",
   "body+mined:Baseline": "time.strftime('%Y-%m-%d %H:%M:%S.%f')",
   "body+mined:-Code": "time.strftime('%Y-%m-%d %H:%M:%S.%f')",
   "body+mined:-NL": "time.strftime('%Y-%m-%d %H:%M:%S', time.gmtime(1236472051807))",
   "body+mined:-Blocks": "time.strptime('%Y-%m-%d %H:%M:%S.%f')",
   "body+mined:-Inline": "time.strftime('%Y-%m-%d %H:%M:%S.%f')"
  },
  "snippet": "datetime.datetime.fromtimestamp(s).strftime('%Y-%m-%d %H:%M:%S.%f')"
 },
 "21787496.52": {
  "intent": "parse milliseconds epoch time '1236472051807' to format '%y-%m-%d %h:%m:%s'",
  "body": "I have used a ruby script to convert iso time stamp to epoch, the files that I am parsing has following time stamp structure: \n2009-03-08T00:27:31.807\n\nSince I want to keep milliseconds I used following ruby code to convert it to epoch time: \nirb(main):010:0> DateTime.parse('2009-03-08T00:27:31.807').strftime(\"%Q\")\n=> \"1236472051807\"\n\nBut In python I tried following: \nimport time \ntime.strftime('%Y-%m-%d %H:%M:%S', time.gmtime(1236472051807))\n\nBut I don't get the original time date time back, \ntime.strftime('%Y-%m-%d %H:%M:%S', time.gmtime(1236472051807))\n'41152-03-29 02:50:07'\n\n\nI wonder is it related to how I am formatting? \n",
  "preds": {
   "base:Baseline": "time.strptime('1236472051807', '%Y-%m-%d %H:%M:%S')",
   "body:Baseline": "time.strftime('%Y-%m-%d %H:%M:%S', time.gmtime(1236472051807))",
   "body:-Blocks": "time.strftime('1236472051807', '%Y-%m-%d %H:%M:%S')",
   "body:-Code": "time.mktime('1236472051807', '%Y-%m-%d %H:%M:%S')",
   "body:-Inline": "time.strftime('%Y-%m-%d %H:%M:%S')",
   "body:-NL": "DateTime.parse('2009-03-08T00:27:31.807').strftime('%Y-%m-%d %H:%M:%S')",
   "base:+Mined": "time.strptime('1236472051807', '%Y-%m-%d %H:%M:%S')",
   "body+mined:Baseline": "time.strftime('%Y-%m-%d %H:%M:%S')",
   "body+mined:-Code": "time.mktime(1236472051807, '%Y-%m-%d %H:%M:%S')",
   "body+mined:-NL": "time.strftime('%Y-%m-%d %H:%M:%S')",
   "body+mined:-Blocks": "time.strptime('1236472051807', '%Y-%m-%d %H:%M:%S')",
   "body+mined:-Inline": "time.strftime('%Y-%m-%d %H:%M:%S')"
  },
  "snippet": "time.strftime('%Y-%m-%d %H:%M:%S', time.gmtime(1236472051807 / 1000.0))"
 },
 "20573459.53": {
  "intent": "get the date 7 days before the current date",
  "body": "I'm trying to get the date that was 7 days ago starting from current date in python. Can anyone help me?\n",
  "preds": {
   "base:Baseline": "today = datetime.datetime.now().date()",
   "body:Baseline": "calendar.datetime.now().date()",
   "body:-Blocks": "calendar.datetime.now().date()",
   "body:-Code": "today = datetime.datetime.now().date()",
   "body:-Inline": "calendar.datetime.now().date()",
   "body:-NL": "calendar.datetime.now().date()",
   "base:+Mined": "datetime.datetime(7, 7, 7)",
   "body+mined:Baseline": "datetime.now() - datetime.timedelta(days=7, weeks=1)",
   "body+mined:-Code": "today = datetime.datetime.now().date()",
   "body+mined:-NL": "datetime.now() - datetime.timedelta(days=7, hours=7)",
   "body+mined:-Blocks": "datetime.now() - datetime.timedelta(days=1)",
   "body+mined:-Inline": "date(today - datetime.timedelta(days=7, weeks=1))"
  },
  "snippet": "(datetime.datetime.now() - datetime.timedelta(days=7)).date()"
 },
 "15352457.54": {
  "intent": "sum elements at index `column` of each list in list `data`",
  "body": "I have a Python array, like so:\n[[1,2,3],\n [1,2,3]]\n\nI can add the row by doing sum(array[i]) , how can I sum a column, using a double for loop?\nI.E. for the first column, I could get 2, then 4, then 6.\n",
  "preds": {
   "base:Baseline": "data[x[0] for x in data]",
   "body:Baseline": "sum(np.sum(column))",
   "body:-Blocks": "np.sum(iter(data), axis=1)",
   "body:-Code": "sum(iter(data), axis=1)",
   "body:-Inline": "[np.sum(column) for column in data]",
   "body:-NL": "sum(iter(x) for x in data)",
   "base:+Mined": "data = [sum(x) for x in data]",
   "body+mined:Baseline": "sum(item[0] for item in data)",
   "body+mined:-Code": "sum(data[0] for i in range(0, len(data), 3))",
   "body+mined:-NL": "sum(item[0] for item in data)",
   "body+mined:-Blocks": "sum(item[0] for item in data)",
   "body+mined:-Inline": "sum([1, 2, 3])"
  },
  "snippet": "print(sum(row[column] for row in data))"
 },
 "15352457.55": {
  "intent": "sum columns of a list `array`",
  "body": "I have a Python array, like so:\n[[1,2,3],\n [1,2,3]]\n\nI can add the row by doing sum(array[i]) , how can I sum a column, using a double for loop?\nI.E. for the first column, I could get 2, then 4, then 6.\n",
  "preds": {
   "base:Baseline": "sum([x[0] for x in array]",
   "body:Baseline": "sum(np.sum(axis=1, 2, 3), axis=1)",
   "body:-Blocks": "np.sum(array[i])",
   "body:-Code": "np.sum(np.arange(array))",
   "body:-Inline": "sum(list(array.values())",
   "body:-NL": "sum(array[i] for i in range(1, 2, 3)]",
   "base:+Mined": "sum(x[0] for x in array)",
   "body+mined:Baseline": "sum([1, 2, 3])",
   "body+mined:-Code": "sum(map(sum, my_list))",
   "body+mined:-NL": "sum(x[1] for x in array)",
   "body+mined:-Blocks": "sum(map(sum, my_array))",
   "body+mined:-Inline": "sum([1, 2, 3])"
  },
  "snippet": "[sum(row[i] for row in array) for i in range(len(array[0]))]"
 },
 "23164058.56": {
  "intent": "encode binary string 'your string' to base64 code",
  "body": "I am trying to encode a text string to base64.\ni tried doing this :\nname = \"your name\"\nprint('encoding %s in base64 yields = %s\\n'%(name,name.encode('base64','strict')))\n\nBut this gives me the following error:\nLookupError: 'base64' is not a text encoding; use codecs.encode() to handle arbitrary codecs\n\nHow do I go about doing this ? ( using Python 3.4)\n",
  "preds": {
   "base:Baseline": "struct.encode('your string', 16)",
   "body:Baseline": "codecs.encode('base64','strict'))",
   "body:-Blocks": "codecs.encode('your string')",
   "body:-Code": "struct.encode('your string', 16)",
   "body:-Inline": "codecs.encode('your string')",
   "body:-NL": "codecs.encode('your string', 'strict')",
   "base:+Mined": "binascii.encode('base64')",
   "body+mined:Baseline": "print('encoding %s in base64 yields = %s\\n' % (name, name.encode('base64',\n    'strict')))",
   "body+mined:-Code": "base64.b64encode('your string')",
   "body+mined:-NL": "print('encoding %s in base64 yields = %s\\n'.encode('base64', 'strict'))",
   "body+mined:-Blocks": "base64.b64encode('your string')",
   "body+mined:-Inline": "print('encoding %s in base64 yields = %s\\n'.encode('base64', 'strict'))"
  },
  "snippet": "base64.b64encode(bytes('your string', 'utf-8'))"
 },
 "11533274.57": {
  "intent": "combine list of dictionaries `dicts` with the same keys in each list to a single dictionary",
  "body": "I have a list of dictionaries like so:\ndicts = [\n    {'key_a': valuex1,\n     'key_b': valuex2,\n     'key_c': valuex3},\n\n    {'key_a': valuey1,\n     'key_b': valuey2,\n     'key_c': valuey3},\n\n    {'key_a': valuez1,\n     'key_b': valuez2,\n     'key_c': valuez3}\n]\n\nI would like to take these and construct a big dictionary like so:\nbig_dict = {\n    'key_a': [valuex1, valuey1, valuez1],\n    'key_b': [valuex2, valuey2, valuez2],\n    'key_c': [valuex3, valuey3, valuez3]\n}\n\nIs there any elegant \" zip \"-like way for me to do this? \nAll the keys are always going to be identical.\n",
  "preds": {
   "base:Baseline": "dict((k, v) for k, v in dicts.items() if v)",
   "body:Baseline": "dict((k, v) for k, v in dicts.items()))",
   "body:-Blocks": "dict((k, v) for k, v in list(dicts.items()))",
   "body:-Code": "dict((k, v) for k, v in list(dicts.items()))",
   "body:-Inline": "dict((k, v) for k, v in dicts.items()))",
   "body:-NL": "dict((k, v) for k, v in big_dict.items())",
   "base:+Mined": "dict((k, v) for k, v in dicts)",
   "body+mined:Baseline": "dict((k, v) for k, v in dicts.items() if v}",
   "body+mined:-Code": "{k: bigdict(v) for k, v in list(dicts.items())}",
   "body+mined:-NL": "{k: v for d in dicts for k, v in list(d.items())}",
   "body+mined:-Blocks": "{k: bigdict(v) for k, v in list(dicts.items())}",
   "body+mined:-Inline": "{k: v for d in dicts for k, v in list(d.items())}"
  },
  "snippet": "dict((k, [d[k] for d in dicts]) for k in dicts[0])"
 },
 "11533274.58": {
  "intent": "merge a nested dictionary `dicts` into a flat dictionary by concatenating nested values with the same key `k`",
  "body": "I have a list of dictionaries like so:\ndicts = [\n    {'key_a': valuex1,\n     'key_b': valuex2,\n     'key_c': valuex3},\n\n    {'key_a': valuey1,\n     'key_b': valuey2,\n     'key_c': valuey3},\n\n    {'key_a': valuez1,\n     'key_b': valuez2,\n     'key_c': valuez3}\n]\n\nI would like to take these and construct a big dictionary like so:\nbig_dict = {\n    'key_a': [valuex1, valuey1, valuez1],\n    'key_b': [valuex2, valuey2, valuez2],\n    'key_c': [valuex3, valuey3, valuez3]\n}\n\nIs there any elegant \" zip \"-like way for me to do this? \nAll the keys are always going to be identical.\n",
  "preds": {
   "base:Baseline": "dict((k, v) for k, v in dicts.items() if v != k)",
   "body:Baseline": "dict((k, v) for k, v in dicts.items()))",
   "body:-Blocks": "dict((k, v) for k, v in dicts.items() if v.split(k))",
   "body:-Code": "dict((k, v) for k, v in list(dicts.items()))",
   "body:-Inline": "{k: v for k, v in dicts.items()}",
   "body:-NL": "{k: big_dict[k] for k in list(dicts.items())}",
   "base:+Mined": "dict((k, v) for k, v in list(dicts.items()))",
   "body+mined:Baseline": "dict((k, v) for k, v in list(dicts.items()))",
   "body+mined:-Code": "{k: bigdict(v) for k, v in list(dicts.items())}",
   "body+mined:-NL": "{k: v for k, v in list(big_dict.items()) if v}",
   "body+mined:-Blocks": "{k: bigdict(v) for k, v in dicts.items()}",
   "body+mined:-Inline": "{k: big_dict[k] for k in dicts}"
  },
  "snippet": "{k: [d[k] for d in dicts] for k in dicts[0]}"
 },
 "14026704.59": {
  "intent": "how do i get the url parameter in a flask view",
  "body": "I am trying to get the url parameters from a flask view:\nwww.domain.com/?f=x**2\n\nHow do I get x**2  from the url  in a Flask view?\n",
  "preds": {
   "base:Baseline": "self.url.get('r', 1)[0]",
   "body:Baseline": "url = Flask.get(url)",
   "body:-Blocks": "url = Flask.View(url)",
   "body:-Code": "url = Flask.get('r', 1)",
   "body:-Inline": "url = flask.get('url')",
   "body:-NL": "urllib.request.urlretrieve(url)",
   "base:+Mined": "app.run(debug=True)",
   "body+mined:Baseline": "app.run(debug=True)",
   "body+mined:-Code": "app.run(debug=True)",
   "body+mined:-NL": "app.run(debug=True)",
   "body+mined:-Blocks": "app.run(debug=True)",
   "body+mined:-Inline": "app.run(debug=True)"
  },
  "snippet": "request.args['myParam']"
 },
 "11236006.60": {
  "intent": "identify duplicate values in list `mylist`",
  "body": "Is it possible to get which values are duplicates in a list using python?\nI have a list of items:\n    mylist = [20, 30, 25, 20]\n\nI know the best way of removing the duplicates is set(mylist) , but is it possible to know what values are being duplicated? As you can see, in this list the duplicates are the first and last values. [0, 3] .\nIs it possible to get this result or something similar in python? I'm trying to avoid making a ridiculously big if elif  conditional statement.\n",
  "preds": {
   "base:Baseline": "for (key, value) in mylist):\n    pass",
   "body:Baseline": "set(set(mylist)))",
   "body:-Blocks": "[x for x in set(mylist)]",
   "body:-Code": "[x for x in mylist]",
   "body:-Inline": "[x for x in mylist if x is duplicated]",
   "body:-NL": "set(mylist, key=lambda x: x[1])",
   "base:+Mined": "mylist = set(set(mylist))",
   "body+mined:Baseline": "print(list(set(mylist))",
   "body+mined:-Code": "myList = list(set(myList))",
   "body+mined:-NL": "set([x for x in mylist if x == 3])",
   "body+mined:-Blocks": "print(list(set(mylist))",
   "body+mined:-Inline": "print(list(set(mylist))"
  },
  "snippet": "[k for k, v in list(Counter(mylist).items()) if v > 1]"
 },
 "2354166.61": {
  "intent": "insert directory 'apps' into directory `__file__`",
  "body": "I've tried adding the following line to my handler script (main.py), but it doesn't seem to work:\n\nsys.path.append('subdir')\n\nsubdir  lives in the my root directory (i.e. the one containing app.yaml ).\nThis doesn't seem to work, because when I try to import modules that live in subdir , my app explodes.\n",
  "preds": {
   "base:Baseline": "os.path.insert(__file__)",
   "body:Baseline": "sys.path.append('__file__')",
   "body:-Blocks": "os.path.insert(__file__)",
   "body:-Code": "__file__ = os.path.append('apps')",
   "body:-Inline": "sys.path.append('__file__')",
   "body:-NL": "os.path.insert(__file__)",
   "base:+Mined": "__file__.append('apps')",
   "body+mined:Baseline": "sys.path.insert(0, 'apps')",
   "body+mined:-Code": "__file__.append('apps')",
   "body+mined:-NL": "os.chdir(os.path.dirname(__file__))",
   "body+mined:-Blocks": "sys.path.insert(__file__)",
   "body+mined:-Inline": "sys.path.append('__file__')"
  },
  "snippet": "sys.path.insert(1, os.path.join(os.path.dirname(__file__), 'apps'))"
 },
 "2354166.62": {
  "intent": "modify sys.path for python module `subdir`",
  "body": "I've tried adding the following line to my handler script (main.py), but it doesn't seem to work:\n\nsys.path.append('subdir')\n\nsubdir  lives in the my root directory (i.e. the one containing app.yaml ).\nThis doesn't seem to work, because when I try to import modules that live in subdir , my app explodes.\n",
  "preds": {
   "base:Baseline": "subdir = os.path.modify_path(subdir)",
   "body:Baseline": "sys.path.append('subdir')",
   "body:-Blocks": "sys.path.append('subdir')",
   "body:-Code": "sys.path.append('subdir')",
   "body:-Inline": "sys.path.append('subdir')",
   "body:-NL": "subdir = sys.path.dirname(subdir)",
   "base:+Mined": "sys.path.append(subdir)",
   "body+mined:Baseline": "sys.path.append('subdir')",
   "body+mined:-Code": "sys.path.append('subdir')",
   "body+mined:-NL": "sys.path.append(subdir)",
   "body+mined:-Blocks": "sys.path.append('subdir')",
   "body+mined:-Inline": "sys.path.append('subdir')"
  },
  "snippet": "sys.path.append(os.path.join(os.path.dirname(__file__), 'subdir'))"
 },
 "20211942.63": {
  "intent": "insert a 'none' value into a sqlite3 table.",
  "body": "I am trying to insert a None  value into a row entry of my db. The table present  exists\ndb.execute(\"INSERT INTO present VALUES('test', ?, 9)\", \"This is a test!\")\ndb.execute(\"INSERT INTO present VALUES('test2', ?, 10)\", None)\n\nbut I get an error:\nValueError: parameters are of unsupported type\n\nhow do I insert a blank value for the second field in the row?\n",
  "preds": {
   "base:Baseline": "cursor.execute('INSERT INTO table VALUES (%s)', None)",
   "body:Baseline": "db.execute('INSERT INTO present VALUES('test2',?, 10', None)",
   "body:-Blocks": "cursor.execute('INSERT INTO table VALUES (%s, None))",
   "body:-Code": "cursor.execute('INSERT INTO table VALUES (%s)', None)",
   "body:-Inline": "db.execute('INSERT INTO present VALUES('test',?, 10)\", None)",
   "body:-NL": "db.execute('INSERT INTO present VALUES('test',?, 9)\", None)",
   "base:+Mined": "cursor.execute('INSERT INTO table VALUES (%s)', None)",
   "body+mined:Baseline": "db.execute('INSERT INTO present VALUES('test2',?, 10', None)",
   "body+mined:-Code": "cursor.execute('INSERT INTO table VALUES (%s, %s)', (None,))",
   "body+mined:-NL": "db.execute('INSERT INTO present VALUES('test2',?, 9', None)",
   "body+mined:-Blocks": "cursor.execute('INSERT INTO table VALUES (%s)', (None, None))",
   "body+mined:-Inline": "db.execute('INSERT INTO table VALUES ('test',?, 9)')"
  },
  "snippet": "db.execute(\"INSERT INTO present VALUES('test2',?, 10)\", (None,))"
 },
 "406121.64": {
  "intent": "flatten list `list_of_menuitems`",
  "body": "Is there a simple way to flatten a list of iterables with a list comprehension, or failing that, what would you all consider to be the best way to flatten a shallow list like this, balancing performance and readability?\nI tried to flatten such a list with a nested list comprehension, like this:\n[image for image in menuitem for menuitem in list_of_menuitems]\n\nBut I get in trouble of the NameError  variety there, because the name 'menuitem' is not defined .  After googling and looking around on Stack Overflow, I got the desired results with a reduce  statement:\nreduce(list.__add__, map(lambda x: list(x), list_of_menuitems))\n\nBut this method is fairly unreadable because I need that list(x)  call there because x is a Django QuerySet  object.\nConclusion : \nThanks to everyone who contributed to this question.  Here is a summary of what I learned.  I'm also making this a community wiki in case others want to add to or correct these observations.\nMy original reduce statement is redundant and is better written this way:\nreduce(list.__add__, (list(mi) for mi in list_of_menuitems))\n\nThis is the correct syntax for a nested list comprehension (Brilliant summary dF !):\n[image for mi in list_of_menuitems for image in mi]\n\nBut neither of these methods are as efficient as using itertools.chain :\nfrom itertools import chain\nlist(chain(*list_of_menuitems))\n\nAnd as @cdleary notes, it's probably better style to avoid * operator magic by using chain.from_iterable  like so:\nchain = itertools.chain.from_iterable([[1,2],[3],[5,89],[],[6]])\nprint(list(chain))\n[1, 2, 3, 5, 89, 6]\n\n",
  "preds": {
   "base:Baseline": "list_of_menuitems = []",
   "body:Baseline": "flatten(list_of_menuitems)",
   "body:-Blocks": "list_of_menuitems.flatten()",
   "body:-Code": "list_of_menuitems[::-1]",
   "body:-Inline": "flatten(list_of_menuitems)",
   "body:-NL": "[image for image in list_of_menuitems]",
   "base:+Mined": "list_of_menuitems = []",
   "body+mined:Baseline": "from_iterable([[1, 2], [3, 89], [6]])",
   "body+mined:-Code": "[list_of_menuitems for _ in range(length)]",
   "body+mined:-NL": "from itertools import list(chain(*list_of_menuitems))",
   "body+mined:-Blocks": "[list_of_menuitems[0] for _ in range(menuitem)]",
   "body+mined:-Inline": "from itertools.chain.from_iterable([[1, 2], [3, 89], [6]])"
  },
  "snippet": "[image for menuitem in list_of_menuitems for image in menuitem]"
 },
 "4741537.65": {
  "intent": "append elements of a set `b` to a list `a`",
  "body": "How do you append the elements of a set to a list in Python in the most succinct way?\na = [1,2]\nb = set([3,4])\na.append(list(b))\na\n[1, 2, [3, 4]]\n\nBut what I want is:\n[1, 2, 3, 4]\n\n",
  "preds": {
   "base:Baseline": "a = [b[i] for i in a]",
   "body:Baseline": "a.append(list(b))",
   "body:-Blocks": "a = a[(b) for b in a]",
   "body:-Code": "a.append(b, a)",
   "body:-Inline": "a.append(list(b))",
   "body:-NL": "a.append(list(b))",
   "base:+Mined": "a = a[:] + b + a[:-1]",
   "body+mined:Baseline": "a = [1, 2, 3, 4]",
   "body+mined:-Code": "a = [i for i, j in zip(b, a)]",
   "body+mined:-NL": "a = [list(b) for b in a]",
   "body+mined:-Blocks": "a.append(b, a)",
   "body+mined:-Inline": "a = [1, 2, 3, 4]"
  },
  "snippet": "a.extend(b)"
 },
 "4741537.66": {
  "intent": "append elements of a set to a list in python",
  "body": "How do you append the elements of a set to a list in Python in the most succinct way?\na = [1,2]\nb = set([3,4])\na.append(list(b))\na\n[1, 2, [3, 4]]\n\nBut what I want is:\n[1, 2, 3, 4]\n\n",
  "preds": {
   "base:Baseline": "list(itertools.product([i for i in range(0, len(a)))",
   "body:Baseline": "[x[0] for x in zip(a, b)]",
   "body:-Blocks": "[x for x in set.items()]",
   "body:-Code": "[set(x) for x in set(x))",
   "body:-Inline": "[x[0] for x in a]",
   "body:-NL": "[x[0] for x in a]",
   "base:+Mined": "[1, 2, 3, 4, 5, 6]",
   "body+mined:Baseline": "[1, 2, 3, 4]",
   "body+mined:-Code": "[1, 2, 3, 4, 5, 6]",
   "body+mined:-NL": "[1, 2, 3, 4]",
   "body+mined:-Blocks": "['a', 'b', 'c', 'd', 'e']",
   "body+mined:-Inline": "[1, 2, 3, 4]"
  },
  "snippet": "a.extend(list(b))"
 },
 "31247198.67": {
  "intent": "write the data of dataframe `df` into text file `np.txt`",
  "body": "I have pandas DataFrame like this\n        X    Y  Z    Value \n0      18   55  1      70   \n1      18   55  2      67 \n2      18   57  2      75     \n3      18   58  1      35  \n4      19   54  2      70   \n\nI want to write this data to a text file that looks like this:\n18 55 1 70   \n18 55 2 67 \n18 57 2 75     \n18 58 1 35  \n19 54 2 70 \n\nI have tried something like \nf = open(writePath, 'a')\nf.writelines(['\\n', str(data['X']), ' ', str(data['Y']), ' ', str(data['Z']), ' ', str(data['Value'])])\nf.close()\n\nbut it's not working. How to do this?      \n",
  "preds": {
   "base:Baseline": "df.write('np.txt', header=False)",
   "body:Baseline": "df = open(writePath, 'a')",
   "body:-Blocks": "df.to_open('np.txt')",
   "body:-Code": "df.to_csv('np.txt')",
   "body:-Inline": "df.write(np.txt)",
   "body:-NL": "df.write(np.txt, '\\n')",
   "base:+Mined": "df.write(np.txt)",
   "body+mined:Baseline": "np.txt.write(df)",
   "body+mined:-Code": "df.to_csv('np.txt', sep='\\t')",
   "body+mined:-NL": "np.write(df, delimiter=',')",
   "body+mined:-Blocks": "df.to_text('np.txt')",
   "body+mined:-Inline": "df.write(np.txt)"
  },
  "snippet": "np.savetxt('c:\\\\data\\\\np.txt', df.values, fmt='%d')"
 },
 "31247198.68": {
  "intent": "write content of dataframe `df` into text file 'c:\\\\data\\\\pandas.txt'",
  "body": "I have pandas DataFrame like this\n        X    Y  Z    Value \n0      18   55  1      70   \n1      18   55  2      67 \n2      18   57  2      75     \n3      18   58  1      35  \n4      19   54  2      70   \n\nI want to write this data to a text file that looks like this:\n18 55 1 70   \n18 55 2 67 \n18 57 2 75     \n18 58 1 35  \n19 54 2 70 \n\nI have tried something like \nf = open(writePath, 'a')\nf.writelines(['\\n', str(data['X']), ' ', str(data['Y']), ' ', str(data['Z']), ' ', str(data['Value'])])\nf.close()\n\nbut it's not working. How to do this?      \n",
  "preds": {
   "base:Baseline": "df.write('C:\\\\data\\\\pandas.txt')",
   "body:Baseline": "df = open(writePath, 'C:\\\\data\\\\pandas.txt')",
   "body:-Blocks": "df.write('C:\\\\data\\\\pandas.txt')",
   "body:-Code": "df.write('C:\\\\data\\\\pandas.txt')",
   "body:-Inline": "df.write('C:\\\\data\\\\pandas.txt')",
   "body:-NL": "df.write('C:\\\\data\\\\pandas.txt')",
   "base:+Mined": "df.write('C:\\\\data\\\\pandas.txt')",
   "body+mined:Baseline": "f.write('C:\\\\data\\\\pandas.txt')",
   "body+mined:-Code": "df.to_csv('c:\\\\data\\\\pandas.txt')",
   "body+mined:-NL": "f.write('C:\\\\data\\\\pandas.txt')",
   "body+mined:-Blocks": "df.write('C:\\\\data\\\\pandas.txt')",
   "body+mined:-Inline": "f.write('c:\\\\data\\\\pandas.txt')"
  },
  "snippet": "df.to_csv('c:\\\\data\\\\pandas.txt', header=None, index=None, sep=' ', mode='a')"
 },
 "15851568.69": {
  "intent": "split a string `x` by last occurrence of character `-`",
  "body": "I am trying to print the last part of a string before a certain character.  \nI'm not quite sure whether to use the string .split() method or string slicing or maybe something else.    \nHere is some code that doesn't work but I think shows the logic:  \nx = 'http://test.com/lalala-134'\nprint x['-':0] # beginning at the end of the string, return everything before '-'\n\nNote that the number at the end will vary in size so I can't set an exact count from the end of the string.  \n",
  "preds": {
   "base:Baseline": "x = re.split('-')",
   "body:Baseline": "print(x['-'] + '-'))",
   "body:-Blocks": "x.split(-1)[::-1]",
   "body:-Code": "x.split(',', '-')",
   "body:-Inline": "print(x['-'] + x['-'])",
   "body:-NL": "x = 'http://test.com/lalala-134'",
   "base:+Mined": "x.split(':')[-1]",
   "body+mined:Baseline": "x.split('-')[-]",
   "body+mined:-Code": "x.split('-')[-1]",
   "body+mined:-NL": "x.split(':')[-1]",
   "body+mined:-Blocks": "x.split('-')[-]",
   "body+mined:-Inline": "print(x['-'] + x['-'])"
  },
  "snippet": "print(x.rpartition('-')[0])"
 },
 "15851568.70": {
  "intent": "get the last part of a string before the character '-'",
  "body": "I am trying to print the last part of a string before a certain character.  \nI'm not quite sure whether to use the string .split() method or string slicing or maybe something else.    \nHere is some code that doesn't work but I think shows the logic:  \nx = 'http://test.com/lalala-134'\nprint x['-':0] # beginning at the end of the string, return everything before '-'\n\nNote that the number at the end will vary in size so I can't set an exact count from the end of the string.  \n",
  "preds": {
   "base:Baseline": "\"\"\"\"\"\".join(re.sub('-'))",
   "body:Baseline": "\"\"\"http://test.com/lalala-134\"\"\".replace('-'', '')",
   "body:-Blocks": "print('-' + str(last.split('-'))",
   "body:-Code": "\"\"\"\"\"\".join(str('.-', '-'))",
   "body:-Inline": "print(x['-': 0))",
   "body:-NL": "\"\"\"\"\"\".join(x['-'] for x in '-')",
   "base:+Mined": "re.findall('-', '-', s)",
   "body+mined:Baseline": "\"\"\"-\"\"\".join(x[-:] for x in s.split())",
   "body+mined:-Code": "last_part.split('-')",
   "body+mined:-NL": "print(x['-'] + '-')",
   "body+mined:-Blocks": "print('-'.rstrip('-')",
   "body+mined:-Inline": "print(x['-'] + '-' + str(x))"
  },
  "snippet": "print(x.rsplit('-', 1)[0])"
 },
 "17438096.71": {
  "intent": "upload file using ftp",
  "body": "I am trying to upload file from windows server to a unix server (basically trying to do FTP). I have used the code below \n#!/usr/bin/python\nimport ftplib\nimport os\nfilename = \"MyFile.py\"\nftp = ftplib.FTP(\"xx.xx.xx.xx\")\nftp.login(\"UID\", \"PSW\")\nftp.cwd(\"/Unix/Folder/where/I/want/to/put/file\")\nos.chdir(r\"\\\\windows\\folder\\which\\has\\file\")\nftp.storbinary('RETR %s' % filename, open(filename, 'w').write)\n\nI am getting the following error: \nTraceback (most recent call last):\n  File \"Windows\\folder\\which\\has\\file\\MyFile.py\", line 11, in <module>\n    ftp.storbinary('RETR %s' % filename, open(filename, 'w').write)\n  File \"windows\\folder\\Python\\lib\\ftplib.py\", line 466, in storbinary\n    buf = fp.read(blocksize)\nAttributeError: 'builtin_function_or_method' object has no attribute 'read'\n\nAlso all contents of MyFile.py  got deleted .\nCan anyone advise what is going wrong.I have read that ftp.storbinary is used for uploading files using FTP. \n",
  "preds": {
   "base:Baseline": "ftp.uploadFile(filename)",
   "body:Baseline": "ftp = ftplib.FTP('/Unix/Folder/where/I/want/to/put/file')",
   "body:-Blocks": "ftp.storbinary('file://myFile.py')",
   "body:-Code": "ftp.uploadFile(filename)",
   "body:-Inline": "ftp.storbinary('RETR %s', open(filename, 'w').write)",
   "body:-NL": "ftp.cwd('/Unix/Folder/where/I/want/to/put/file')",
   "base:+Mined": "ftp.retrbinary('upload_file.txt', filename)",
   "body+mined:Baseline": "ftp.storbinary('RETR %s' % filename, open(filename, 'w').write)",
   "body+mined:-Code": "ftp.storbinary('RETR %s', filename)",
   "body+mined:-NL": "ftp.cwd('/Unix/Folder/where/I/want/to/put/file')",
   "body+mined:-Blocks": "ftp.storbinary('MyFile.py')",
   "body+mined:-Inline": "ftp.storbinary('RETR %s % filename, open(filename, 'w').write)"
  },
  "snippet": "ftp.storlines('STOR' + filename, open(filename, 'r'))"
 },
 "15049182.72": {
  "intent": "add one to the hidden web element with id 'xyz' with selenium python script",
  "body": "I'm trying to write to a text box with my python selenium code but get an error since a parent tag of the text box is hidden.\ndriver.find_element_by_xpath(\"//input[@itemcode='XYZ']\").send_keys(1)\n\nI see a Javascript executor workaround with java but need help with something similar for python script.\nThanks in advance!!\n",
  "preds": {
   "base:Baseline": "driver.find_element_by_id('xyz')",
   "body:Baseline": "driver.find_element_by_xpath(\"//input[@itemcode='XYZ']\").send_keys(1)",
   "body:-Blocks": "driver.find_element_by_id('xyz')",
   "body:-Code": "driver.find_element_by_id('xyz')",
   "body:-Inline": "driver.find_element_by_xpath(\"//input[@itemcode='XYZ']\").send_keys(1)",
   "body:-NL": "driver.find_element_by_xpath(\"//input[@itemcode='XYZ']\").send_keys(1)",
   "base:+Mined": "driver.find_element_by_id('xyz').click()",
   "body+mined:Baseline": "driver.find_element_by_xpath(\"//input[@itemcode='XYZ']\").send_keys(1)",
   "body+mined:-Code": "driver.find_element_by_id('xyz')",
   "body+mined:-NL": "driver.find_element_by_xpath(\"//input[@itemcode='XYZ']\").send_keys(1)",
   "body+mined:-Blocks": "driver.find_element_by_id('xyz')",
   "body+mined:-Inline": "driver.find_element_by_xpath(\"//input[@itemcode='XYZ']\").send_keys(1)"
  },
  "snippet": "browser.execute_script(\"document.getElementById('XYZ').value+='1'\")"
 },
 "28742436.73": {
  "intent": "create array containing the maximum value of respective elements of array `[2, 3, 4]` and array `[1, 5, 2]`",
  "body": "I want to combine two numpy arrays to produce an array with the largest values from each array.\nimport numpy as np\n\na  = np.array([[ 0.,  0.,  0.5],\n               [ 0.1,  0.5,  0.5],\n               [ 0.1,  0.,  0.]])\n\nb  = np.array([[ 0.,  0.,  0.0],\n               [ 0.5,  0.1,  0.5],\n               [ 0.5,  0.1,  0.]])\n\nI would like to produce\narray([[ 0.,  0.,  0.5],\n       [ 0.5,  0.5,  0.5],\n       [ 0.5,  0.1,  0.]])\n\nI know you can do\na += b\n\nwhich results in\narray([[ 0. ,  0. ,  0.5],\n       [ 0.6,  0.6,  1. ],\n       [ 0.6,  0.1,  0. ]])\n\nThis is clearly not what I'm after. It seems like such an easy problem and I assume it most probably is.\n",
  "preds": {
   "base:Baseline": "np.array([2, 3, 4], [2, 5, 2])",
   "body:Baseline": "np.array([2, 3, 4], [1, 5, 2]])",
   "body:-Blocks": "np.array([2, 3, 4], np.max([1, 5, 2])",
   "body:-Code": "np.array([2, 3, 4], [2, 5, 2])",
   "body:-Inline": "np.array([2, 3, 4], [1, 5, 2])",
   "body:-NL": "np.max(np.array([2, 3, 4], [1, 5, 2])",
   "base:+Mined": "np.argmax(a, [2, 3, 4], [1, 5, 2])",
   "body+mined:Baseline": "np.maximum(a, b)",
   "body+mined:-Code": "np.argmax(x, y)",
   "body+mined:-NL": "np.argmax(a, np.maximum(b, [2, 3, 4]))",
   "body+mined:-Blocks": "np.maximum_array([2, 3, 4], [1, 5, 2])",
   "body+mined:-Inline": "np.argmax(a, b)"
  },
  "snippet": "np.maximum([2, 3, 4], [1, 5, 2])"
 },
 "34280147.74": {
  "intent": "print a list `l` and move first 3 elements to the end of the list",
  "body": "I'm trying to figure out how to print the following list while not starting by the first item. To be clear: If the list is [0,1,2,3,4,5,6,7,8] , I want to print something like 4,5,6,7,8,0,1,2,3\nHere's the code:\nyou_can_move_on = False\n\nList = [0,1,2,3,4,5,6,7,8]\n\nnext_player = 3\n\nwhile not you_can_move_on:\n    next_player = self.get_next_player_index(next_player)\n    you_can_move_on = self.check_if_I_can_move_on\n    print(next_player)\n\n\ndef get_next_player_index(self, i):\n    if i == len(self.players):\n        return 0\n    else:\n        return i+1\n\ndef check_if_I_can_move_on(self):\n    return False\n\n",
  "preds": {
   "base:Baseline": "print(l[0] + 3)",
   "body:Baseline": "print([0, 1, 2, 3, 4, 5, 6, 7, 8])",
   "body:-Blocks": "print('[0,1,2,3,4, 5, 6, 7, 8])",
   "body:-Code": "print(l, key=lambda x: x[3])",
   "body:-Inline": "print(l[0] + 3]",
   "body:-NL": "print(l[0:3] + L[0, 1, 2, 3, 4, 5, 6, 7, 8])",
   "base:+Mined": "print(l[i:i + 3] for i in range(3))",
   "body+mined:Baseline": "print(''.join(l[i:i + 3])",
   "body+mined:-Code": "print(' '.join(str(i) for i in L))",
   "body+mined:-NL": "print([0, 1, 2, 3, 4, 5, 6, 7, 8])",
   "body+mined:-Blocks": "print('[0,1,2,3,4,5,6,7,8]'.join(l))",
   "body+mined:-Inline": "print(' '.join(L[i:i + 3])"
  },
  "snippet": "print(l[3:] + l[:3])"
 },
 "11801309.75": {
  "intent": "loop over files in directory '.'",
  "body": "I have a folder with ten files in it which I want to loop through. When I print out the name of the file my code works fine:\nimport os\nindir = '/home/des/test'\nfor root, dirs, filenames in os.walk(indir):\n    for f in filenames:\n        print(f)\n\nWhich prints:\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\nBut if I try to open the file in the loop I get an IO error:\nimport os\nindir = '/home/des/test'\nfor root, dirs, filenames in os.walk(indir):\n    for f in filenames:\n        log = open(f, 'r')\n\nTraceback (most recent call last):\nFile \"/home/des/my_python_progs/loop_over_dir.py\", line 6, in <module>\nlog = open(f, 'r')\nIOError: [Errno 2] No such file or directory: '1'\n\n\nDo I need to pass the full path of the file even inside the loop to open()  them?\n",
  "preds": {
   "base:Baseline": "os.path.join(open('.'))",
   "body:Baseline": "os.walk(indir, '.')",
   "body:-Blocks": "os.path.open('.')",
   "body:-Code": "os.path.join(open('.'))",
   "body:-Inline": "log = open(f, '.')",
   "body:-NL": "log = open(f, '.')",
   "base:+Mined": "print(os.listdir('.'))",
   "body+mined:Baseline": "os.walk(os.path.join(path, '.'))",
   "body+mined:-Code": "for line in open('.'):\n    pass",
   "body+mined:-NL": "f = open(f, 'r')",
   "body+mined:-Blocks": "open('.').seek(0)",
   "body+mined:-Inline": "f = os.path.join(['.'], '.')"
  },
  "snippet": "for fn in os.listdir('.'):\n    if os.path.isfile(fn):\n        pass"
 },
 "11801309.76": {
  "intent": "loop over files in directory `source`",
  "body": "I have a folder with ten files in it which I want to loop through. When I print out the name of the file my code works fine:\nimport os\nindir = '/home/des/test'\nfor root, dirs, filenames in os.walk(indir):\n    for f in filenames:\n        print(f)\n\nWhich prints:\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\nBut if I try to open the file in the loop I get an IO error:\nimport os\nindir = '/home/des/test'\nfor root, dirs, filenames in os.walk(indir):\n    for f in filenames:\n        log = open(f, 'r')\n\nTraceback (most recent call last):\nFile \"/home/des/my_python_progs/loop_over_dir.py\", line 6, in <module>\nlog = open(f, 'r')\nIOError: [Errno 2] No such file or directory: '1'\n\n\nDo I need to pass the full path of the file even inside the loop to open()  them?\n",
  "preds": {
   "base:Baseline": "print(os.path.join(source))",
   "body:Baseline": "os.walk(open(source, 'r')",
   "body:-Blocks": "os.path.open(source)",
   "body:-Code": "print(os.path.join(source))",
   "body:-Inline": "log = open(f, 'r')",
   "body:-NL": "log = open(f, 'r')",
   "base:+Mined": "print(os.path.join(source))",
   "body+mined:Baseline": "os.walk(os.path.abspath(source))",
   "body+mined:-Code": "for line in os.listdir(source):\n    pass",
   "body+mined:-NL": "f = open(f, 'r')",
   "body+mined:-Blocks": "os.system('open(source)')",
   "body+mined:-Inline": "f = os.path.join(source, 'rb')"
  },
  "snippet": "for root, dirs, filenames in os.walk(source):\n    for f in filenames:\n        pass"
 },
 "4172131.77": {
  "intent": "create a random list of integers",
  "body": "I'd like to create a random list of integers for testing purposes. The distribution of the numbers is not important. The only thing that is counting is time . I know generating random numbers is a time-consuming task, but there must be a better way.\nHere's my current solution:\nimport random\nimport timeit\n\n# Random lists from [0-999] interval\nprint [random.randint(0, 1000) for r in xrange(10)] # v1\nprint [random.choice([i for i in xrange(1000)]) for r in xrange(10)] # v2\n\n# Measurement:\nt1 = timeit.Timer('[random.randint(0, 1000) for r in xrange(10000)]', 'import random') # v1\nt2 = timeit.Timer('random.sample(range(1000), 10000)', 'import random') # v2\n\nprint t1.timeit(1000)/1000\nprint t2.timeit(1000)/1000\n\nv2 is faster than v1, but it is not working on such a large scale. It gives the following error:\n\nValueError: sample larger than population\n\nIs there a fast, efficient solution that works at that scale?\nSome results from the answer\nAndrew's: 0.000290962934494\ngnibbler's: 0.0058455221653\nKennyTM's: 0.00219276118279\nNumPy came, saw, and conquered.\n",
  "preds": {
   "base:Baseline": "random.sample(list(range(10)), 16)",
   "body:Baseline": "random.sample(range(1000), 10000)",
   "body:-Blocks": "random.sample(list(range(10)), 1)",
   "body:-Code": "random.sample(range(0, len(random.values())))",
   "body:-Inline": "timeit.random.sample(range(1000), 10000)",
   "body:-NL": "timeit.Timer('random.sample(range(1000), 10000)', 'import random')",
   "base:+Mined": "random.sample(list(range(10)), 10)",
   "body+mined:Baseline": "random.sample(range(1000), 10000)",
   "body+mined:-Code": "random.sample(list(range(0, 10)), 10)",
   "body+mined:-NL": "random.sample(range(1000), 10000)",
   "body+mined:-Blocks": "random.sample(range(0, 10))",
   "body+mined:-Inline": "print(random.randint(0, 1000) for r in range(1000))"
  },
  "snippet": "[int(1000 * random.random()) for i in range(10000)]"
 },
 "6677332.78": {
  "intent": "using %f with strftime() in python to get microseconds",
  "body": "I'm trying to use strftime() to microsecond precision, which seems possible using %f (as stated here ). However when I try the following code:\nimport time\nimport strftime from time\n\nprint strftime(\"%H:%M:%S.%f\")\n\n<console_out>I get the hour, the minutes and the seconds, but %f prints as %f, with no sign of the microseconds. I'm running Python 2.6.5 on Ubuntu, so it should be fine and %f should be supported (it's supported for 2.6 and above, as far as I know.)\n",
  "preds": {
   "base:Baseline": "min(os.getmtime(0, %f))",
   "body:Baseline": "time.mktime(hours=1, minutes=10)",
   "body:-Blocks": "microseconds = microsecond( %f, strftime()",
   "body:-Code": "print(strftime('%f' % s))",
   "body:-Inline": "print(strftime('%H:%M:%S.%f')",
   "body:-NL": "print(strftime('%H:%M:%S.%f')",
   "base:+Mined": "time.mktime(microseconds)",
   "body+mined:Baseline": "print(strftime('%H:%M:%S.%f'))",
   "body+mined:-Code": "print(struct.unpack('%f'))",
   "body+mined:-NL": "print(strftime('%H:%M:%S.%f'))",
   "body+mined:-Blocks": "time.strftime('%f %d %H:%M:%S')",
   "body+mined:-Inline": "print(strftime('%H:%M:%S.%f'))"
  },
  "snippet": "datetime.datetime.now().strftime('%H:%M:%S.%f')"
 },
 "852055.79": {
  "intent": "google app engine execute gql query 'select * from schedule where station = $1' with parameter `foo.key()`",
  "body": "Say I have the following model:\nclass Schedule(db.Model):\n    tripCode = db.StringProperty(required=True)\n    station = db.ReferenceProperty(Station, required=True)    \n    arrivalTime = db.TimeProperty(required=True)\n    departureTime = db.TimeProperty(required=True)\n\nAnd let's say I have a Station object stored in the var foo .\nHow do I assemble a GQL query that returns all Schedule objects with a reference to the Station object referenced by foo ?\nThis is my best (albeit incorrect ) attempt to form such a query:\nmyQuery = \"SELECT * FROM Schedule where station = \" + str(foo.key())\n\nOnce again foo  is a Station  object\n",
  "preds": {
   "base:Baseline": "google.engine.execute('SELECT * FROM schedule WHERE station = $1', 'foo.key()')",
   "body:Baseline": "GQL.query('SELECT * FROM Schedule WHERE station =' + str(foo.key()))",
   "body:-Blocks": "GQL.execute('SELECT * FROM schedule WHERE station = $1', 'foo.key()')",
   "body:-Code": "GQL.execute('SELECT * FROM schedule WHERE station = $1', 'foo.key()')",
   "body:-Inline": "google.engine.query('SELECT * FROM Schedule WHERE station = $1', str(foo.key())\n    )",
   "body:-NL": "google.query('SELECT * FROM Schedule WHERE station = $1')",
   "base:+Mined": "urllib.request.urlretrieve('select * from schedule WHERE station = $1',\n    'foo.key()')",
   "body+mined:Baseline": "myQuery = 'SELECT * FROM Schedule where station =' + str(foo.key())",
   "body+mined:-Code": "GQL.GQL('SELECT * FROM schedule WHERE station = $1')",
   "body+mined:-NL": "myQuery = 'SELECT * FROM Schedule where station =' + str(foo.key())",
   "body+mined:-Blocks": "GQL.GQL('select * from schedule where station = $1')",
   "body+mined:-Inline": "GQL.query('SELECT * FROM Schedule where station ='+ str(foo.key())"
  },
  "snippet": "db.GqlQuery('SELECT * FROM Schedule WHERE station = $1', foo.key())"
 },
 "15325182.80": {
  "intent": "filter rows in pandas starting with alphabet 'f' using regular expression.",
  "body": "I would like to cleanly filter a dataframe using regex on one of the columns.\nFor a contrived example:\nfoo = pd.DataFrame({'a' : [1,2,3,4], 'b' : ['hi', 'foo', 'fat', 'cat']})\nfoo\n\n   a    b\n0  1   hi\n1  2  foo\n2  3  fat\n3  4  cat\n\nI want to filter the rows to those that start with f  using a regex. First go:\nfoo.b.str.match('f.*')\n\n0    []\n1    ()\n2    ()\n3    []\n\nThat's not too terribly useful. However this will get me my boolean index:\nfoo.b.str.match('(f.*)').str.len() > 0\n\n0    False\n1     True\n2     True\n3    False\nName: b\n\nSo I could then do my restriction by:\nfoo[foo.b.str.match('(f.*)').str.len() > 0]\n\n   a    b\n1  2  foo\n2  3  fat\n\nThat makes me artificially put a group into the regex though, and seems like maybe not the clean way to go. Is there a better way to do this?\n",
  "preds": {
   "base:Baseline": "df = pandas.filter(re.search('f')",
   "body:Baseline": "pd.DataFrame({'a': 'f.*', 'b': 'a'})",
   "body:-Blocks": "df.groupby('f').filter(df.index('f')",
   "body:-Code": "df.groupby('f').filter(lambda x: x.startswith('f')",
   "body:-Inline": "pd.concat([df.startswith('f.*')])",
   "body:-NL": "df.filter(lambda x: x.startswith('f.*'))",
   "base:+Mined": "df.groupby(['f'])['A'].apply(lambda x: x.startswith('F'))",
   "body+mined:Baseline": "df[df.str.startswith('f')]",
   "body+mined:-Code": "df[df.columns.str.startswith('f')]",
   "body+mined:-NL": "df[df.groupby('f').apply(lambda x: x.startswith('f'))]",
   "body+mined:-Blocks": "df[df.index.str.startswith('f')]",
   "body+mined:-Inline": "df[df.str.startswith('f')]"
  },
  "snippet": "df.b.str.contains('^f')"
 },
 "583557.81": {
  "intent": "print a 2 dimensional list `tab` as a table with delimiters",
  "body": "I want to print a table mixed with string and float values, as tab delimited output printout. Sure I can get the job done:\ntab = [['a', 1], ['b', 2]]\nfor row in tab:\n    out = \"\"\n    for col in row:\n            out = out + str(col) + \"\\t\"\n    print out.rstrip()\n\na   1\nb   2\n\nBut I have a feeling there is a better way to do it in Python, at least to print each row with specified delimiter, if not the whole table. Little googling (from here ) and it is already shorter:\nfor row in tab:\n    print \"\\t\".join([str(col) for col in row])\n\na   1\nb   2\n\nIs there still a better, or more Python-ish, way to do it?\n",
  "preds": {
   "base:Baseline": "print(' '.join(item[0] for item in tab))",
   "body:Baseline": "[['a', 1], ['b', 2]]] for 'a', 'b' in tab]",
   "body:-Blocks": "print(' '.join(table.split()) for row in tab)",
   "body:-Code": "print(' '.join(table) for table in tab)",
   "body:-Inline": "print('\\t'.join([str(col) for col in row])",
   "body:-NL": "print('\\t'.join([str(col) for col in tab])",
   "base:+Mined": "print('\\n'.join(map(str, t))",
   "body+mined:Baseline": "print('\\t'.join([str(col) for col in row])",
   "body+mined:-Code": "print('\\n'.join(map(str, row)))",
   "body+mined:-NL": "print('\\t'.join([str(col) for col in row])",
   "body+mined:-Blocks": "print('\\n'.join(map(str, row)) for row in tab])",
   "body+mined:-Inline": "print('\\t'.join([str(col) for col in row])"
  },
  "snippet": "print('\\n'.join('\\t'.join(str(col) for col in row) for row in tab))"
 },
 "38535931.82": {
  "intent": "pandas: delete rows in dataframe `df` based on multiple columns values",
  "body": "I have a dataframe with columns A,B,C . I have a list of tuples like [(x1,y1), (x2,y2), <console_out>] . I would like to delete all rows that meet the following condition:\n(B=x1 && C=y1) | (B=x2 && C=y2) |  How can I do that in pandas? I wanted to use the isin  function, but not sure if it is possible since my list has tuples. I could do something like this:\nfor x,y in tuples:   \n    df = df.drop(df[df.B==x && df.C==y].index)\n\nMaybe there is an easier way.\n",
  "preds": {
   "base:Baseline": "df.apply(lambda x: x[1], axis=1)",
   "body:Baseline": "df = df.drop(['A', 'B', 'C'], axis=1)",
   "body:-Blocks": "pd.merge(df, columns=['A,B,C'], axis=1)",
   "body:-Code": "df.apply(lambda x: x.columns, axis=1)",
   "body:-Inline": "df = df.drop(df.columns, axis=1)",
   "body:-NL": "df = df.drop(df.B==x && df.C==y)",
   "base:+Mined": "df.drop(df.columns, axis=1)",
   "body+mined:Baseline": "df.drop(df[df.B==x && df.C==y].index)",
   "body+mined:-Code": "df.drop(df.index, axis=1, inplace=True)",
   "body+mined:-NL": "df = df.drop(df.B==x && df.C==y).index",
   "body+mined:-Blocks": "pd.merge(df, on='A', on='B', how='inner')",
   "body+mined:-Inline": "df = df.drop(df[df.B==x && df.C==y].index)"
  },
  "snippet": "df.set_index(list('BC')).drop(tuples, errors='ignore').reset_index()"
 },
 "13945749.83": {
  "intent": "format the variables `self.goals` and `self.penalties` using string formatting",
  "body": "I do this in Python 2:\n\"(%d goals, $%d)\" % (self.goals, self.penalties)\n\nWhat is the Python 3 version of this?\nI tried searching for examples online but I kept getting Python 2 versions.\n",
  "preds": {
   "base:Baseline": "\"\"\"{}\"\"\".format(self.goals, self.penalties)",
   "body:Baseline": "\"\"\"%d goals, $%d)\" % (self.goals, self.penalties)",
   "body:-Blocks": "\"\"\"self.goals\"\"\".format(self.penalties))",
   "body:-Code": "\"\"\"self.goals\"\"\".format(self.penalties))",
   "body:-Inline": "\"\"\"%d goals, $%d)\" % (self.goals, self.penalties)",
   "body:-NL": "\"\"\"%d goals, $%d)\" % (self.goals, self.penalties)",
   "base:+Mined": "\"\"\"{} {}\"\"\".format(self.goals, self.penalties)",
   "body+mined:Baseline": "\"\"\"{} goals, {} {}\"\"\".format(self.goals, self.penalties)",
   "body+mined:-Code": "\"\"\"{} {}\"\"\".format(self.goals, self.penalties)",
   "body+mined:-NL": "\"\"\"{}_{}\"\"\".format(self.goals, self.penalties)",
   "body+mined:-Blocks": "\"\"\"{} {}\"\"\".format(self.goals, self.penalties)",
   "body+mined:-Inline": "\"\"\"{} goals {}\"\"\".format(self.goals, self.penalties)"
  },
  "snippet": "\"\"\"({:d} goals, ${:d})\"\"\".format(self.goals, self.penalties)"
 },
 "13945749.84": {
  "intent": "format string \"({} goals, ${})\" with variables `goals` and `penalties`",
  "body": "I do this in Python 2:\n\"(%d goals, $%d)\" % (self.goals, self.penalties)\n\nWhat is the Python 3 version of this?\nI tried searching for examples online but I kept getting Python 2 versions.\n",
  "preds": {
   "base:Baseline": "print('({} goals, ${})\"",
   "body:Baseline": "\"\"{} goals, ${}\"\"\".format(goals, penalties)",
   "body:-Blocks": "\"\"\"({} goals, ${})\"",
   "body:-Code": "\"\"\"({} goals, ${})\"",
   "body:-Inline": "print('({} goals, ${})\" % (self.goals, self.penalties))",
   "body:-NL": "\"\"\"({} goals, ${})\" % (goals, penalties)",
   "base:+Mined": "\"\"\"({} goals, ${})\"\"\".format('goals', 'penalties')",
   "body+mined:Baseline": "\"\"\"{} goals, ${}\"\"\".format(goals, flags)",
   "body+mined:-Code": "format(({} goals, ${})",
   "body+mined:-NL": "\"\"\"({} goals, ${})\" % (goals, flags)",
   "body+mined:-Blocks": "format('({} goals, ${})')",
   "body+mined:-Inline": "\"\"\"({} goals, ${})\"\"\".format(goals, flags)"
  },
  "snippet": "\"\"\"({} goals, ${})\"\"\".format(self.goals, self.penalties)"
 },
 "13945749.85": {
  "intent": "format string \"({0.goals} goals, ${0.penalties})\"",
  "body": "I do this in Python 2:\n\"(%d goals, $%d)\" % (self.goals, self.penalties)\n\nWhat is the Python 3 version of this?\nI tried searching for examples online but I kept getting Python 2 versions.\n",
  "preds": {
   "base:Baseline": "print('({0.goals} goals, ${0.penalties})\"",
   "body:Baseline": "\"\"\"({0.goals} goals, ${0.penalties})\"",
   "body:-Blocks": "\"\"\"({0.goals} goals, ${0.penalties})\"",
   "body:-Code": "\"\"\"({0.goals} goals, ${0.penalties})\"",
   "body:-Inline": "print('({0.goals} goals, ${0.penalties}')",
   "body:-NL": "\"\"\"({0.goals} goals, ${0.penalties}\"\"\".format('%d goals, $%d'))",
   "base:+Mined": "\"\"\"({0.goals} goals, ${0.penalties})\"",
   "body+mined:Baseline": "print('({0.goals} goals, ${0.penalties})'.format(self))",
   "body+mined:-Code": "format('({0.goals} goals, ${0.penalties})')",
   "body+mined:-NL": "\"\"\"({0.goals} goals, ${0.penalties}\"\"\".format('%d goals, %d penalties'))",
   "body+mined:-Blocks": "format('({0.goals} goals, ${0.penalties}')",
   "body+mined:-Inline": "\"\"\"({0.goals} goals, ${0.penalties}\"\"\".format(self, goal)"
  },
  "snippet": "\"\"\"({0.goals} goals, ${0.penalties})\"\"\".format(self)"
 },
 "18524642.86": {
  "intent": "convert list of lists `l` to list of integers",
  "body": "I need to convert a list of lists to a list of integers.\nfrom: \nL1 = [[1, 2, 3, 4], [3, 7, 1, 7], [0, 5, 6, 7], [9, 4, 5, 6]]\n\nto:  \nL2 = [1234, 3717, 0567, 9456]\n\nHow can I make python recognize an integer starting with 0? Like the case L2[2]\nThe other question is, how can I check if items in a list are ordered?\nA = [1, 2, 6, 9] ---->True\n\nOther than this:  \nA == sorted(A)\n\nYou guys are FAST. Thanks!\n",
  "preds": {
   "base:Baseline": "[int(x) for x in l]",
   "body:Baseline": "[i for i, j in zip(L1, L2)]",
   "body:-Blocks": "[int(x) for x in L]",
   "body:-Code": "[int(x) for x in l]",
   "body:-Inline": "[int(x) for x in L]",
   "body:-NL": "[i for i, j in zip(L1, L2)]",
   "base:+Mined": "[int(x) for x in L]",
   "body+mined:Baseline": "[int(x) for x in L1]",
   "body+mined:-Code": "l = [int(x) for x in l]",
   "body+mined:-NL": "[int(x) for x in L2]",
   "body+mined:-Blocks": "[int(x) for x in L]",
   "body+mined:-Inline": "[int(x) for x in L]"
  },
  "snippet": "[int(''.join(str(d) for d in x)) for x in L]"
 },
 "18524642.87": {
  "intent": "combine elements of each list in list `l` into digits of a single integer",
  "body": "I need to convert a list of lists to a list of integers.\nfrom: \nL1 = [[1, 2, 3, 4], [3, 7, 1, 7], [0, 5, 6, 7], [9, 4, 5, 6]]\n\nto:  \nL2 = [1234, 3717, 0567, 9456]\n\nHow can I make python recognize an integer starting with 0? Like the case L2[2]\nThe other question is, how can I check if items in a list are ordered?\nA = [1, 2, 6, 9] ---->True\n\nOther than this:  \nA == sorted(A)\n\nYou guys are FAST. Thanks!\n",
  "preds": {
   "base:Baseline": "[int(x) for x in L]",
   "body:Baseline": "[i for i, j in zip(L1, L2)]",
   "body:-Blocks": "[int(x) for x in L]",
   "body:-Code": "[int(x) for x in L]",
   "body:-Inline": "[int(x) for x in L]",
   "body:-NL": "[int(x) for x in L]",
   "base:+Mined": "[int(x) for x in L]",
   "body+mined:Baseline": "[int(x) for x in L1]",
   "body+mined:-Code": "[int(x) for x in L]",
   "body+mined:-NL": "[int(x) for x in L1 if x.isdigit()]",
   "body+mined:-Blocks": "[int(x) for x in L]",
   "body+mined:-Inline": "[int(x) for x in L1]"
  },
  "snippet": "[''.join(str(d) for d in x) for x in L]"
 },
 "18524642.88": {
  "intent": "convert a list of lists `l` to list of integers",
  "body": "I need to convert a list of lists to a list of integers.\nfrom: \nL1 = [[1, 2, 3, 4], [3, 7, 1, 7], [0, 5, 6, 7], [9, 4, 5, 6]]\n\nto:  \nL2 = [1234, 3717, 0567, 9456]\n\nHow can I make python recognize an integer starting with 0? Like the case L2[2]\nThe other question is, how can I check if items in a list are ordered?\nA = [1, 2, 6, 9] ---->True\n\nOther than this:  \nA == sorted(A)\n\nYou guys are FAST. Thanks!\n",
  "preds": {
   "base:Baseline": "[int(x) for x in L]",
   "body:Baseline": "[i for i, j in zip(L1, L2)]",
   "body:-Blocks": "[int(x) for x in L]",
   "body:-Code": "[int(x) for x in l]",
   "body:-Inline": "[int(x) for x in L]",
   "body:-NL": "[int(x) for x in zip(L1, L2)]",
   "base:+Mined": "[int(x) for x in L]",
   "body+mined:Baseline": "[int(x) for x in L1]",
   "body+mined:-Code": "l = [int(x) for x in l]",
   "body+mined:-NL": "[int(x) for x in L2]",
   "body+mined:-Blocks": "[int(x) for x in L]",
   "body+mined:-Inline": "[int(x) for x in L]"
  },
  "snippet": "L = [int(''.join([str(y) for y in x])) for x in L]"
 },
 "7138686.89": {
  "intent": "write the elements of list `lines` concatenated by special character '\\n' to file `myfile`",
  "body": "I'm trying to write an array (list?) to a text file using Python 3. Currently I have:\ndef save_to_file(*text):\n\n    with open('/path/to/filename.txt', mode='wt', encoding='utf-8') as myfile:\n        for lines in text:\n            print(lines, file = myfile)\n    myfile.close\n\nThis writes what looks like the array straight to the text file, i.e.,\n['element1', 'element2', 'element3']\nusername@machine:/path$\n\nWhat I'm looking to do is create the file with\nelement1\nelement2\nelement3\nusername@machine:/path$\n\nI've tried different ways to loop through and append a \"\\n\" but it seems that the write is dumping the array in one operation. The question is similar to How to write list of strings to file, adding newlines?  but the syntax looked like it was for Python 2? When I tried a modified version of it:\ndef save_to_file(*text):\n\n    myfile = open('/path/to/filename.txt', mode='wt', encoding='utf-8')\n    for lines in text:\n        myfile.write(lines)\n    myfile.close\n\n<console_out>the Python shell gives \"TypeError: must be str, not list\" which I think is because of changes between Python2 and Python 3. What am I missing to get each element on a newline?\nEDIT: Thank you to @agf and @arafangion; combining what both of you wrote, I came up with:\ndef save_to_file(text):\n\n    with open('/path/to/filename.txt', mode='wt', encoding='utf-8') as myfile:\n        myfile.write('\\n'.join(text))\n        myfile.write('\\n')\n\nIt looks like I had part of the issue with \"*text\" (I had read that expands arguments but it didn't click until you wrote that [element] was becoming [[element]] that I was getting a str-not-list type error; I kept thinking I needed to tell the definition that it was getting a list/array passed to it and that just stating \"test\" would be a string.) It worked once I changed it to just text and used myfile.write with join, and the additional \\n puts in the final newline at the end of the file.\n",
  "preds": {
   "base:Baseline": "myfile.write('\\n')",
   "body:Baseline": "myfile.write('\\n'.join(text))",
   "body:-Blocks": "myfile.write('\\n')",
   "body:-Code": "myfile.write('\\n')",
   "body:-Inline": "myfile.write('\\n'.join(lines))",
   "body:-NL": "myfile.write('\\n'.join(text))",
   "base:+Mined": "myfile.write('\\n'.join(lines))",
   "body+mined:Baseline": "myfile.write('\\n')",
   "body+mined:-Code": "f.write('\\n'.join(myfile))",
   "body+mined:-NL": "myfile.write('\\n'.join(lines))",
   "body+mined:-Blocks": "myfile.write('\\n'.join(lines))",
   "body+mined:-Inline": "myfile.write('\\n'.join(lines))"
  },
  "snippet": "myfile.write('\\n'.join(lines))"
 },
 "1866343.90": {
  "intent": "removing an element from a list based on a predicate 'x' or 'n'",
  "body": "I want to remove an element from list, such that the element contains 'X'  or 'N' . I have to apply for a large genome. Here is an example:\ninput:\ncodon=['AAT','XAC','ANT','TTA']\n\nexpected output:  \ncodon=['AAT','TTA']  \n\n",
  "preds": {
   "base:Baseline": "[x[0] for x in n]",
   "body:Baseline": "[i for i, j in enumerate(x, n)]",
   "body:-Blocks": "[x for x in enumerate(x, n)]",
   "body:-Code": "[x[i] for i in range(10)]",
   "body:-Inline": "[x[0] for x in 'n']",
   "body:-NL": "[x[i] for i in range(n)]",
   "base:+Mined": "[x for x in a if x != 'n']",
   "body+mined:Baseline": "[x for x in lst if x['X'] == 'N']",
   "body+mined:-Code": "[x for x in l if 'x' in x]",
   "body+mined:-NL": "[x for x in lst if 'X' in x]",
   "body+mined:-Blocks": "[x for x in DNA if 'x' in x]",
   "body+mined:-Inline": "[x for x in ['AAT', 'XAC', 'ANT', 'TTA'] if x != 'N']"
  },
  "snippet": "[x for x in ['AAT', 'XAC', 'ANT', 'TTA'] if 'X' not in x and 'N' not in x]"
 },
 "17238587.91": {
  "intent": "remove duplicate words from a string `text` using regex",
  "body": "I am very new a Python\nI want to change sentence if there are repeated words.\nCorrect\n\n\nEx. \"this just so so so nice\" --> \"this is just so nice\"\nEx. \"this is just is is\" --> \"this is just is\"\n\nRight now am I using this reg. but it do all so change on letters.\nEx. \"My friend and i is happy\" --> \"My friend and is happy\" (it remove the \"i\" and space) ERROR\ntext = re.sub(r'(\\w+)\\1', r'\\1', text) #remove duplicated words in row\n\nHow can I do the same change but instead of letters it have to check on words?\n",
  "preds": {
   "base:Baseline": "re.sub('\\\\w+', text)",
   "body:Baseline": "re.sub('\\\\w+\\\\1', text)",
   "body:-Blocks": "re.sub('[^a-zA-Z]', text)",
   "body:-Code": "re.sub('\\\\[\\\\]', text)",
   "body:-Inline": "re.sub('\\\\w+\\\\1', text)",
   "body:-NL": "re.sub('\\\\w+\\\\1', text)",
   "base:+Mined": "re.sub('(\\\\w+)', '\\\\1', text)",
   "body+mined:Baseline": "re.sub('(\\\\w+)', '\\\\1', text)",
   "body+mined:-Code": "re.sub('[^a-zA-Z]', '', text)",
   "body+mined:-NL": "re.sub('\\\\w+', '\\\\1', text)",
   "body+mined:-Blocks": "re.sub('[^a-zA-Z]', '', text)",
   "body+mined:-Inline": "re.sub('(\\\\w+)', '\\\\1', text)"
  },
  "snippet": "text = re.sub('\\\\b(\\\\w+)( \\\\1\\\\b)+', '\\\\1', text)"
 },
 "26053849.92": {
  "intent": "count non zero values in each column in pandas data frame",
  "body": "I have a python-pandas-dataframe in which first column is user_id and rest of the columns are tags(tag_0 to tag_122). \nI have the data in the following format:\nUserId  Tag_0   Tag_1\n7867688 0   5\n7867688 0   3\n7867688 3   0\n7867688 3.5 3.5\n7867688 4   4\n7867688 3.5 0\n\nMy aim is to achieve Sum(Tag)/Count(NonZero(Tags))  for each user_id\ndf.groupby('user_id').sum() , gives me sum(tag) , however I am clueless about counting non zero values\nIs it possible to achieve Sum(Tag)/Count(NonZero(Tags))  in one command?\nIn MySQL I could achieve this as follows:-\nselect user_id, sum(tag)/count(nullif(tag,0)) from table group by 1\n\nAny help shall be appreciated.\n",
  "preds": {
   "base:Baseline": "df['nonzero'] = df['zero'].sum()",
   "body:Baseline": "df.groupby('user_id').sum()",
   "body:-Blocks": "df.groupby('user_id').sum()",
   "body:-Code": "df['User_ID'] = df['Tag_0']",
   "body:-Inline": "df.groupby('UserId').apply(lambda x: x.count(tag, 0))",
   "body:-NL": "df.groupby('user_id').sum()",
   "base:+Mined": "df.count_nonzero(axis=1)",
   "body+mined:Baseline": "df.groupby('user_id').sum()",
   "body+mined:-Code": "df.groupby('user_id').agg(lambda x: x.tag_0).count()",
   "body+mined:-NL": "df.groupby('user_id').sum()",
   "body+mined:-Blocks": "df.groupby('user_id').sum()",
   "body+mined:-Inline": "df.groupby('UserId').sum()"
  },
  "snippet": "df.astype(bool).sum(axis=1)"
 },
 "15534223.93": {
  "intent": "search for string that matches regular expression pattern '(?<!distillr)\\\\\\\\acrotray\\\\.exe' in string 'c:\\\\somedir\\\\acrotray.exe'",
  "body": "I want to search for a file called \"AcroTray.exe\" on my disk. The program should print a warning if the file is located in a directory other than \"Distillr\" .\nI used the following Syntax to perform the negative match\n(?!Distillr)\n\nThe problem is that although I use the \"!\" it always produces a MATCH. I tried to figure out the problem using IPython but failed. \nThis is what I tried: \nimport re\n\nfilePath = \"C:\\Distillr\\AcroTray.exe\"\n\nif re.search(r'(?!Distillr)\\\\AcroTray\\.exe', filePath):\n    print \"MATCH\"\n\nIt prints a MATCH.\nWhat is wrong with my regex?\nI would like to get a match on:\nC:\\SomeDir\\AcroTray.exe\n\nBut not on:\nC:\\Distillr\\AcroTray.exe\n\n",
  "preds": {
   "base:Baseline": "re.findall('(?<!distillr)\\\\\\\\acrotray\\\\.exe', 'C:\\\\Somedir\\\\acroTRAY.exe')",
   "body:Baseline": "re.search('(?<!distillr)\\\\\\\\acrotray\\\\.exe', 'C:\\\\Somedir\\\\AcroTray.exe')",
   "body:-Blocks": "re.findall('(?<!distillr)\\\\\\\\acrotray\\\\.exe', 'C:\\\\Somedir\\\\acroTray.exe')",
   "body:-Code": "re.findall('(?<!distillr)\\\\\\\\acrotray\\\\.exe', 'C:\\\\somedir\\\\acroTray.exe')",
   "body:-Inline": "re.search('(?<!distillr)\\\\\\\\acrotray\\\\.exe', 'C:\\\\Somedir\\\\acroTray.exe')",
   "body:-NL": "re.search('(?<!distillr)\\\\AcroTray\\\\.exe', 'C:\\\\somedir\\\\acrotray.exe')",
   "base:+Mined": "re.findall('(?<!distillr)\\\\\\\\acrotray\\\\.exe', 'c:\\\\somedir\\\\acroTRAY.exe')",
   "body+mined:Baseline": "re.search('(?<!distillr)\\\\\\\\acrotray\\\\.exe', c)",
   "body+mined:-Code": "match = re.compile('(?<!distillr)\\\\\\\\acrotray\\\\.exe')",
   "body+mined:-NL": "re.search('(?<!distillr)\\\\\\\\acrotray\\\\.exe', s)",
   "body+mined:-Blocks": "match = re.compile('(?<!distillr)\\\\\\\\acrotray\\\\.exe')",
   "body+mined:-Inline": "re.search('(?<!distillr)\\\\\\\\acrotray\\\\.exe', 'c:\\\\Somedir\\\\AcroTray.exe')"
  },
  "snippet": "re.search('(?<!Distillr)\\\\\\\\AcroTray\\\\.exe', 'C:\\\\SomeDir\\\\AcroTray.exe')"
 },
 "5453026.94": {
  "intent": "split string 'qh qd jc kd js' into a list on white spaces",
  "body": "I'm trying to split a string:\n'QH QD JC KD JS'\n\ninto a list like:\n['QH', 'QD', 'JC', 'KD', 'JS']\n\nHow would I go about doing this? \n",
  "preds": {
   "base:Baseline": "list('qh qd jc kd js')",
   "body:Baseline": "list('QH QD JC KD JS')",
   "body:-Blocks": "list('qh qd jc kd js')",
   "body:-Code": "list('qh qd jc kd js')",
   "body:-Inline": "['QH QD JC kd js'].split()",
   "body:-NL": "list('QH QD JC KD JS')",
   "base:+Mined": "\"\"\"QH QD JC kD js\"\"\".replace(' ', '')",
   "body+mined:Baseline": "['QH', 'Qd', 'JC', 'KD', 'JS']",
   "body+mined:-Code": "['qh qd jc kd js', 'QH QD jC kD js']",
   "body+mined:-NL": "['QH', 'Qd', 'JC', 'KD', 'JS']",
   "body+mined:-Blocks": "['qh qd jc kd js'.split()]",
   "body+mined:-Inline": "['QH', 'Qd', 'JC', 'KD', 'JS']"
  },
  "snippet": "\"\"\"QH QD JC KD JS\"\"\".split()"
 },
 "18168684.95": {
  "intent": "search for occurrences of regex pattern '>.*<' in xml string `line`",
  "body": "I'm trying to use regex to parse an XML  file (in my case this seems the simplest way).\nFor example a line might be:\nline=' <City_State>PLAINSBORO, NJ 08536-1906 </City_State>'\n\nTo access the text for the tag City_State, I'm using:\nattr = re.match('>.* <', line)\n\nbut nothing is being returned.\nCan someone point out what I'm doing wrong?\n",
  "preds": {
   "base:Baseline": "print(re.search('>.*<', line))",
   "body:Baseline": "re.match('>.*<', line)",
   "body:-Blocks": "print(re.search('>.*<')",
   "body:-Code": "re.search('>.*<', line)",
   "body:-Inline": "re.search('>.*<', line)",
   "body:-NL": "re.match('>.*<', line)",
   "base:+Mined": "print(re.findall('>.*<', line))",
   "body+mined:Baseline": "re.findall('>.*<', line)",
   "body+mined:-Code": "print(re.search('>.*<', line))",
   "body+mined:-NL": "re.findall('>.*<', line)",
   "body+mined:-Blocks": "print(re.search('>.*<', line))",
   "body+mined:-Inline": "re.search('>.*<', line)"
  },
  "snippet": "print(re.search('>.*<', line).group(0))"
 },
 "4914277.96": {
  "intent": "erase all the contents of a file `filename`",
  "body": "In the Unix shell I can do this to empty a file:\ncd /the/file/directory/\n:> thefile.ext\n\nHow would I go about doing this in Python?\nIs os.system  the way here, I wouldn't know how since I would have to send 2 actions after each other i.e. the cd  and then the :> . \n",
  "preds": {
   "base:Baseline": "open('filename', 'rb', filename)",
   "body:Baseline": "os.system.exit(filename)",
   "body:-Blocks": "os.system.exit(filename)",
   "body:-Code": "os.system('\\n'.join(open(filename))",
   "body:-Inline": "os.system('/the/file/directory/', filename)",
   "body:-NL": "os.system.from_file('filename')",
   "base:+Mined": "os.chdir('filename')[0]",
   "body+mined:Baseline": "os.system('/the/file/directory/')",
   "body+mined:-Code": "f = open('filename', 'r')",
   "body+mined:-NL": "os.environ['filename'].close()",
   "body+mined:-Blocks": "os.system('open(filename)')",
   "body+mined:-Inline": "os.system('thefile.ext')"
  },
  "snippet": "open(filename, 'w').close()"
 },
 "19068269.97": {
  "intent": "convert a string into datetime using the format '%y-%m-%d %h:%m:%s.%f'",
  "body": "How do I convert a a string of datetime into datetime format in python so that it can be compared with another date?\nstring_date = \"2013-09-28 20:30:55.78200\"\nabc = datetime.datetime.now()\n\nif abc  > string_date :\n    print True\n\n",
  "preds": {
   "base:Baseline": "datetime.strptime('%Y-%m-%d %H:%M:%S.%f')",
   "body:Baseline": "date = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.%f')",
   "body:-Blocks": "datetime.strptime('%Y-%m-%d %H:%M:%S.%f')",
   "body:-Code": "datetime.strptime('%Y-%m-%d %H:%M:%S.%f')",
   "body:-Inline": "datetime.strptime('2013-09-28 20:30:55.78200', '%Y-%m-%d %H:%M:%S.%f')",
   "body:-NL": "abc.datetime.now().strftime('%Y-%m-%d %H:%M:%S.%f')",
   "base:+Mined": "datetime.strptime('%Y-%m-%d %H:%M:%S.%f')",
   "body+mined:Baseline": "dt = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.%f')",
   "body+mined:-Code": "date.strftime('%Y-%m-%d %H:%M:%S.%f')",
   "body+mined:-NL": "date = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.%f')",
   "body+mined:-Blocks": "d.strftime('%Y-%m-%d %H:%M:%S.%f')",
   "body+mined:-Inline": "date = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.%f')"
  },
  "snippet": "datetime.datetime.strptime(string_date, '%Y-%m-%d %H:%M:%S.%f')"
 },
 "20683167.98": {
  "intent": "find the index of a list with the first element equal to '332' within the list of lists `thelist`",
  "body": "The list is similar to this: \n[[\"12\", \"stuA\", \"stuB\"], [\"51\", \"stuC\", \"stuD\"], <console_out>, [\"3234\", \"moreStuff\", \"andMore\"]]\n\nNow I need to locate an item (get index) only by its first value (e.g. \"332\" ). Is there any better way to do this, apart from iterating from the first one to compare with each value?\nCode:\nindex = 0\nfor item in thelist:\n    if item[0] == \"332\":\n         print index\n\n    index = index + 1\n\n",
  "preds": {
   "base:Baseline": "[x[0] for x in thelist if x[1] == 332]",
   "body:Baseline": "[i for i, j in thelist if j == '332']",
   "body:-Blocks": "[x[0] for x in thelist if x[1] == '332']",
   "body:-Code": "[i[0] for i in thelist if i == '332']",
   "body:-Inline": "[x for x in thelist if x == '332']",
   "body:-NL": "[x for x in thelist if x[0] == '332']",
   "base:+Mined": "[i for i, j in enumerate(thelist) if j == '332']",
   "body+mined:Baseline": "[x for x in thelist if x[0] == '332']",
   "body+mined:-Code": "[i for i, v in enumerate(thelist) if v[0] == 332]",
   "body+mined:-NL": "[x for x in thelist if x[0] == '332']",
   "body+mined:-Blocks": "[x for x in thelist if x[0] == '332']",
   "body+mined:-Inline": "[x for x in thelist if x[0] == '332']"
  },
  "snippet": "[index for index, item in enumerate(thelist) if item[0] == '332']"
 },
 "30693804.99": {
  "intent": "lower a string `text` and remove non-alphanumeric characters aside from space",
  "body": "I'm trying to remove all non-alphanumeric characters except the space from a string, but can't seem to figure out how I exclude space. I'm currently doing it this way:\nre.sub('[\\W_]+', '', text).lower().strip()\n\nBut running my function yields the following results:\nprint removePunctuation('Hi, you!')\nprint removePunctuation(' No under_score!')\nhiyou\nnounderscore\n\nWhere I want it to be:\nhi you\nno underscore\n\nSo how do I exclude space from being replaced?\nMy current optimum is this:\nre.sub('[^\\s\\w]+', '', text).lower().strip().replace('_','')\n\n",
  "preds": {
   "base:Baseline": "re.sub('[^a-zA-Z]', '', text)",
   "body:Baseline": "re.sub('[^\\\\s\\\\w]+', '', text).lower().replace('_', '')",
   "body:-Blocks": "re.sub('[^a-zA-Z]', text)",
   "body:-Code": "re.sub('\\\\d+', text)",
   "body:-Inline": "re.sub('[^\\\\s\\\\w]+', '', text).lower().strip().replace('_', '')",
   "body:-NL": "re.sub('[^\\\\s\\\\w]+', '', text).lower().strip().replace('_', '')",
   "base:+Mined": "re.sub('[^a-zA-Z]', '', text)",
   "body+mined:Baseline": "re.sub('[^\\\\s\\\\w]+', '', text).lower().strip().replace('_', '')",
   "body+mined:-Code": "re.sub('[^a-zA-Z0-9-]+', '', text)",
   "body+mined:-NL": "re.sub('[^\\\\s\\\\w]+', '', text).lower().strip().replace('_', '')",
   "body+mined:-Blocks": "re.sub('\\\\w', '', text)",
   "body+mined:-Inline": "re.sub('[^\\\\s\\\\w]+', '', text).lower().strip().replace('_', '')"
  },
  "snippet": "re.sub('[^\\\\sa-zA-Z0-9]', '', text).lower().strip()"
 },
 "30693804.100": {
  "intent": "remove all non-alphanumeric characters except space from a string `text` and lower it",
  "body": "I'm trying to remove all non-alphanumeric characters except the space from a string, but can't seem to figure out how I exclude space. I'm currently doing it this way:\nre.sub('[\\W_]+', '', text).lower().strip()\n\nBut running my function yields the following results:\nprint removePunctuation('Hi, you!')\nprint removePunctuation(' No under_score!')\nhiyou\nnounderscore\n\nWhere I want it to be:\nhi you\nno underscore\n\nSo how do I exclude space from being replaced?\nMy current optimum is this:\nre.sub('[^\\s\\w]+', '', text).lower().strip().replace('_','')\n\n",
  "preds": {
   "base:Baseline": "re.sub('[^a-zA-Z]', '', text)",
   "body:Baseline": "re.sub('[^\\\\w_]+', '', text).lower().strip()",
   "body:-Blocks": "re.sub('[^a-zA-Z]', '', text)",
   "body:-Code": "re.sub('\\\\s+', text)",
   "body:-Inline": "re.sub('[^\\\\s\\\\w]+', '', text).lower().strip().replace('_', '')",
   "body:-NL": "re.sub('[^\\\\s\\\\w]+', '', text).lower().strip().replace('_', '')",
   "base:+Mined": "re.sub('[^a-zA-Z]', '', text)",
   "body+mined:Baseline": "re.sub('[^\\\\s\\\\w]+', '', text).lower().replace('_', '')",
   "body+mined:-Code": "re.sub('[^a-zA-Z0-9-]+', '', text)",
   "body+mined:-NL": "re.sub('[^\\\\s\\\\w]+', '', text).lower().strip().replace('_', '')",
   "body+mined:-Blocks": "re.sub('[^a-zA-Z]', '', text)",
   "body+mined:-Inline": "re.sub('[^\\\\s\\\\w]+', '', text).lower().strip().replace('_', '')"
  },
  "snippet": "re.sub('(?!\\\\s)[\\\\W_]', '', text).lower().strip()"
 },
 "17138464.101": {
  "intent": "subscript text 'h20' with '2' as subscripted in matplotlib labels for arrays 'x' and 'y'.",
  "body": "this is my first question and I am a noob at python. So probably more to follow...\nI would like to create a figure with matplotlib. In the labels, I would like to include a chemical formula, which involves subscripts (I think the same would work for superscripts...).\nAnyway, I have no idea, how the label would have to look like.\nimport numpy as nu\nimport pylab as plt\n\nx = nu.array([1,2,3,4])\ny = nu.array([1,2,3,4])\n\nplt.plot(x,y, label='H2O')\nplt.legend(loc=1)\nplt.show()\n\nOk, this gives me a plot with the label \"H2O\". How can I subscript the \"2\" in the label, as is common for chemical formulae?\nI searched the web, but I didn't find anything useful yet.\nI figured that I could use \nfrom matplotlib import rc\nrc['text', usetex=True]\n\nbut I don't want to use it (I know how to use LaTeX, but I don't want here). \nAnother option is:\nlabel='H$_2$O'\n\nbut this changes the font (math).\nThere MUST be a way, how does subscripting in matplotlib-legends work?\nThanks a lot!\n",
  "preds": {
   "base:Baseline": "plt.subscript('h20', '2')",
   "body:Baseline": "plt.legend(loc=1, font='H$_2$O')",
   "body:-Blocks": "legend.legend('H2O', 'X', 'Y')",
   "body:-Code": "legend.legend('H20', '2')",
   "body:-Inline": "plt.subscript('H$_2$O')",
   "body:-NL": "plt.subscript('H20', '2')",
   "base:+Mined": "plt.subplots_adjust(label='H20', label='Y')",
   "body+mined:Baseline": "plt.plot(x, y, label='H2O')",
   "body+mined:-Code": "ax.set_title('H20')",
   "body+mined:-NL": "rc['text', usetex=True, label='H$_2$O')",
   "body+mined:-Blocks": "ax.set_xticklabels(['x', 'y'])",
   "body+mined:-Inline": "rc['text', usetex=True)"
  },
  "snippet": "plt.plot(x, y, label='H\u2082O')"
 },
 "17138464.102": {
  "intent": "subscript text 'h20' with '2' as subscripted in matplotlib labels for arrays 'x' and 'y'.",
  "body": "this is my first question and I am a noob at python. So probably more to follow...\nI would like to create a figure with matplotlib. In the labels, I would like to include a chemical formula, which involves subscripts (I think the same would work for superscripts...).\nAnyway, I have no idea, how the label would have to look like.\nimport numpy as nu\nimport pylab as plt\n\nx = nu.array([1,2,3,4])\ny = nu.array([1,2,3,4])\n\nplt.plot(x,y, label='H2O')\nplt.legend(loc=1)\nplt.show()\n\nOk, this gives me a plot with the label \"H2O\". How can I subscript the \"2\" in the label, as is common for chemical formulae?\nI searched the web, but I didn't find anything useful yet.\nI figured that I could use \nfrom matplotlib import rc\nrc['text', usetex=True]\n\nbut I don't want to use it (I know how to use LaTeX, but I don't want here). \nAnother option is:\nlabel='H$_2$O'\n\nbut this changes the font (math).\nThere MUST be a way, how does subscripting in matplotlib-legends work?\nThanks a lot!\n",
  "preds": {
   "base:Baseline": "plt.subscript('h20', '2')",
   "body:Baseline": "plt.legend(loc=1, font='H$_2$O')",
   "body:-Blocks": "legend.legend('H2O', 'X', 'Y')",
   "body:-Code": "legend.legend('H20', '2')",
   "body:-Inline": "plt.subscript('H$_2$O')",
   "body:-NL": "plt.subscript('H20', '2')",
   "base:+Mined": "plt.subplots_adjust(label='H20', label='Y')",
   "body+mined:Baseline": "plt.plot(x, y, label='H2O')",
   "body+mined:-Code": "ax.set_title('H20')",
   "body+mined:-NL": "rc['text', usetex=True, label='H$_2$O')",
   "body+mined:-Blocks": "ax.set_xticklabels(['x', 'y'])",
   "body+mined:-Inline": "rc['text', usetex=True)"
  },
  "snippet": "plt.plot(x, y, label='$H_2O$')"
 },
 "9138112.103": {
  "intent": "loop over a list `mylist` if sublists length equals 3",
  "body": "I have a list with sublists in it. I want to print all the sublists with length equal to 3.\nI am doing the following in python:\nfor x in values[:]:\n    if len(x) == 3:\n        print(x)\n\nvalues  is the original list. Does the above code print every sublist with length equal to 3 for each value of x ? I want to display the sublists where length == 3  only once.\nThe problem is solved. The problem is with the Eclipse editor. I don't understand the reason, but it is displaying only half of my list when I run my loop.\nAre there any settings I have to change in Eclipse?\n",
  "preds": {
   "base:Baseline": "myList.loop(lambda x: len(x[1]))",
   "body:Baseline": "print(len(x) == 3)",
   "body:-Blocks": "print(set(mylist, sublist) if sublist length == 3)",
   "body:-Code": "print(list(mylist.items() == 3))",
   "body:-Inline": "print(list(mylist.items() if len(x) == 3))",
   "body:-NL": "for i in mylist:\n    pass",
   "base:+Mined": "myList[len(myList)) == 3",
   "body+mined:Baseline": "[sublist for sublist in mylist if len(x) == 3]",
   "body+mined:-Code": "print(list(range(len(mylist), 3))",
   "body+mined:-NL": "[len(x) for x in mylist if len(y) == 3]",
   "body+mined:-Blocks": "[list(x) for x in mylist if len(x))]",
   "body+mined:-Inline": "print(list(itertools.chain.from_iterable(mylist)))"
  },
  "snippet": "[x for x in mylist if len(x) == 3]"
 },
 "1807026.104": {
  "intent": "initialize a list `lst` of 100 objects object()",
  "body": "I'm a  looking to initialize an array/list of objects that are not empty -- the class constructor generates data. In C++ and Java I would do something like this:\nObject lst = new Object[100];\n\nI've dug around, but is there a Pythonic way to get this done?\nThis doesn't work like I thought it would (I get 100 references to the same object):\nlst = [Object()]*100\n\nBut this seems to work in the way I want:\nlst = [Object() for i in range(100)]\n\nList comprehension seems (intellectually) like \"a lot\" of work for something that's so simple in Java.\n",
  "preds": {
   "base:Baseline": "lst = [i for i in range(100)]",
   "body:Baseline": "lst = [Object() for i in range(100)]",
   "body:-Blocks": "lst = [i for i in range(100)]",
   "body:-Code": "lst = [i for i in range(100)]",
   "body:-Inline": "lst = [Object() for i in range(100)]",
   "body:-NL": "lst = [Object() for i in range(100)]",
   "base:+Mined": "lst = [x for x in lst]",
   "body+mined:Baseline": "lst = [Object() for i in range(100)]",
   "body+mined:-Code": "lst = [i for i in range(100)]",
   "body+mined:-NL": "lst = [Object() for i in range(100)]",
   "body+mined:-Blocks": "lst = [i for i in range(100)]",
   "body+mined:-Inline": "lst = [Object() for i in range(100)]"
  },
  "snippet": "lst = [Object() for _ in range(100)]"
 },
 "1807026.105": {
  "intent": "create list `lst` containing 100 instances of object `object`",
  "body": "I'm a  looking to initialize an array/list of objects that are not empty -- the class constructor generates data. In C++ and Java I would do something like this:\nObject lst = new Object[100];\n\nI've dug around, but is there a Pythonic way to get this done?\nThis doesn't work like I thought it would (I get 100 references to the same object):\nlst = [Object()]*100\n\nBut this seems to work in the way I want:\nlst = [Object() for i in range(100)]\n\nList comprehension seems (intellectually) like \"a lot\" of work for something that's so simple in Java.\n",
  "preds": {
   "base:Baseline": "lst = [x for x in object]",
   "body:Baseline": "lst = [Object() for i in range(100)]",
   "body:-Blocks": "lst = [i for i in range(100)]",
   "body:-Code": "lst = [i for i in range(100)]",
   "body:-Inline": "lst = [Object() for i in range(100)]",
   "body:-NL": "lst = [x for x in range(100)]",
   "base:+Mined": "lst = [x for x in object]",
   "body+mined:Baseline": "lst = [Object() for i in range(100)]",
   "body+mined:-Code": "lst = [i for i in range(100)]",
   "body+mined:-NL": "lst = [x for x in range(100)]",
   "body+mined:-Blocks": "lst = [i for i in range(100)]",
   "body+mined:-Inline": "lst = [Object() for i in range(100)]"
  },
  "snippet": "lst = [Object() for i in range(100)]"
 },
 "19664253.106": {
  "intent": "get the content of child tag with`href` attribute whose parent has css `someclass`",
  "body": "I am trying to retrieve the data from the webpage has the html in below\n       <div class=\"someclass\">\n       <p class=\"name\"> <a href=\"#/word/1/\">helloworld </a> </p>\n       </div>\n\nMy goal is to parse \"#/word/1/\"\nWhat I did is \n        target = self.driver.find_element_by_class_name('someclass')\n        print target\n        print target.text\n        print target.get_attribute(\"css=a@href\")\n        print target.tag_name\n\nbut the output are \n <selenium.webdriver.remote.webelement.WebElement object at 0x10bf16210>\n helloworld\n None\n div \n\nI tried so many ways , it seems there is no way i can get the content of 'a href' within the targeted class.\nI really dont want to do is get the source code of the page, and then do a string searching, that seems dumb....\nanyway to get that?\n",
  "preds": {
   "base:Baseline": "Child.find_element_by_css_name('someclass')",
   "body:Baseline": "self.driver.find_element_by_class_name('someclass')",
   "body:-Blocks": "Child.find_element_by_id('someClass')",
   "body:-Code": "Child.find_element_by_css_selector('someclass')",
   "body:-Inline": "self.driver.find_element_by_class_name('someclass')",
   "body:-NL": "self.driver.find_element_by_class_name('someclass')",
   "base:+Mined": "soup.find_element_by_css_selector('someclass')",
   "body+mined:Baseline": "print(target.get_attribute('css=a@href')",
   "body+mined:-Code": "print(element['a href']).get('a href'))",
   "body+mined:-NL": "target.get_attribute('css=a@href')",
   "body+mined:-Blocks": "child.tag.get_href()",
   "body+mined:-Inline": "get_attribute('css=a@href')"
  },
  "snippet": "self.driver.find_element_by_css_selector('.someclass a').get_attribute('href')"
 },
 "13793321.107": {
  "intent": "joining data from dataframe `df1` with data from dataframe `df2` based on matching values of column 'date_time' in both dataframes",
  "body": "I have two DataFrames:\ndf1 = ['Date_Time',\n    'Temp_1',\n    'Latitude',\n    'N_S',\n    'Longitude',\n    'E_W']\n\ndf2 = ['Date_Time',\n    'Year',\n    'Month',\n    'Day',\n    'Hour',\n    'Minute',\n    'Seconds']\n\nAs You can see both DataFrames have Date_Time  as a common column. I want to Join these two DataFrames by matching Date_Time .\nMy current code is: df.join(df2, on='Date_Time') , but this is giving an error.\n",
  "preds": {
   "base:Baseline": "pd.merge(df1, df2, inplace=True)",
   "body:Baseline": "df1.join(df2, on='Date_Time')",
   "body:-Blocks": "df1.join(df2, on='Date_Time')",
   "body:-Code": "df1.merge(df2.values())",
   "body:-Inline": "df1.merge(df2.values())",
   "body:-NL": "df1.join(df2, on='Date_Time')",
   "base:+Mined": "df1.merge(df2, on='Date_Time')",
   "body+mined:Baseline": "pd.merge(df1, df2, on='Date_Time')",
   "body+mined:-Code": "df1.merge(df2, how='left', on='date_time')",
   "body+mined:-NL": "pd.concat([df1, df2], axis=1)",
   "body+mined:-Blocks": "df1.merge(df2, on='Date_Time')",
   "body+mined:-Inline": "pd.concat([df1, df2], axis=1)"
  },
  "snippet": "df1.merge(df2, on='Date_Time')"
 },
 "3367288.108": {
  "intent": "use `%s` operator to print variable values `str1` inside a string",
  "body": "I want to introduce a variable [i]  into a string in Python.\nFor example look at the following script. I just want to be able to give a name to the image, for example geo[0].tif  to geo[i].tif , or if you use an accountant as I can replace a portion of the value chain to generate a counter.\ndata = self.cmd(\"r.out.gdal in=rdata out=geo.tif\")\nself.dataOutTIF.setValue(\"geo.tif\")\n\n",
  "preds": {
   "base:Baseline": "str1 = str1.split('%s')",
   "body:Baseline": "self.dataOutTIF.setValue(str1))",
   "body:-Blocks": "str1 = str1.split('%s')",
   "body:-Code": "print('%s', str1)",
   "body:-Inline": "print('%s'.join(str1))",
   "body:-NL": "self.dataOutTIF.setValue('str1')",
   "base:+Mined": "print(''.join(str1))",
   "body+mined:Baseline": "\"\"\"\"\"\".join(str1)",
   "body+mined:-Code": "\"\"\"\"\"\".join(str1)",
   "body+mined:-NL": "print('\\n'.join(str1))",
   "body+mined:-Blocks": "str1 = str1.split('.')[0]",
   "body+mined:-Inline": "\"\"\"\"\"\".join(str1)"
  },
  "snippet": "'first string is: %s, second one is: %s' % (str1, 'geo.tif')"
 },
 "3475251.109": {
  "intent": "split a string by a delimiter in python",
  "body": "How to split this string where __  is the delimiter\nMATCHES__STRING\n\nTo get an output of ['MATCHES', 'STRING'] ?\n",
  "preds": {
   "base:Baseline": "\"\"\"{0:.2f}\"\"\".format(',', '')",
   "body:Baseline": "'MATCHES', 'STRING']",
   "body:-Blocks": "\"\"\"MATCHES', 'STRING'\".split('__')",
   "body:-Code": "re.split('\\n', '', str)",
   "body:-Inline": "\"\"\"\"\"\".join(str(s) for s in MATCHES__STRING()))",
   "body:-NL": "\"\"\"MATCHES__STRING\"\"\".split()",
   "base:+Mined": "re.split('\\\\s+', s)",
   "body+mined:Baseline": "\"\"\"MATCHES__STRING\"\"\".split(',')",
   "body+mined:-Code": "mystring.split('\\n')",
   "body+mined:-NL": "\"\"\"MATCHES__STRING\"\"\".split()",
   "body+mined:-Blocks": "re.split('(?<=__)', 'MATCHES', 'STRING')",
   "body+mined:-Inline": "mATCHES__STRING.split(',')"
  },
  "snippet": "[x.strip() for x in '2.MATCHES $$TEXT$$ STRING'.split('$$TEXT$$')]"
 },
 "273192.110": {
  "intent": "check if directory `directory ` exists and create it if necessary",
  "body": "What is the most elegant way to check if the directory a file is going to be written to exists, and if not, create the directory using Python? Here is what I tried:\nimport os\n\nfile_path = \"/my/directory/filename.txt\"\ndirectory = os.path.dirname(file_path)\n\ntry:\n    os.stat(directory)\nexcept:\n    os.mkdir(directory)       \n\nf = file(filename)\n\nSomehow, I missed os.path.exists  (thanks kanja, Blair, and Douglas). This is what I have now:\ndef ensure_dir(file_path):\n    directory = os.path.dirname(file_path)\n    if not os.path.exists(directory):\n        os.makedirs(directory)\n\nIs there a flag for \"open\", that makes this happen automatically?\n",
  "preds": {
   "base:Baseline": "os.path.isfile(directory)",
   "body:Baseline": "os.path.exists(directory)",
   "body:-Blocks": "os.path.exists(directory)",
   "body:-Code": "os.path.exists(directory)",
   "body:-Inline": "os.path.exists(directory)",
   "body:-NL": "os.path.exists(directory)",
   "base:+Mined": "os.path.exists(directory)",
   "body+mined:Baseline": "os.path.exists(directory)",
   "body+mined:-Code": "os.path.exists(directory)",
   "body+mined:-NL": "os.path.exists(directory)",
   "body+mined:-Blocks": "print(os.path.exists(directory))",
   "body+mined:-Inline": "os.path.exists(directory)"
  },
  "snippet": "if not os.path.exists(directory):\n    os.makedirs(directory)"
 },
 "273192.111": {
  "intent": "check if a directory `path` exists and create it if necessary",
  "body": "What is the most elegant way to check if the directory a file is going to be written to exists, and if not, create the directory using Python? Here is what I tried:\nimport os\n\nfile_path = \"/my/directory/filename.txt\"\ndirectory = os.path.dirname(file_path)\n\ntry:\n    os.stat(directory)\nexcept:\n    os.mkdir(directory)       \n\nf = file(filename)\n\nSomehow, I missed os.path.exists  (thanks kanja, Blair, and Douglas). This is what I have now:\ndef ensure_dir(file_path):\n    directory = os.path.dirname(file_path)\n    if not os.path.exists(directory):\n        os.makedirs(directory)\n\nIs there a flag for \"open\", that makes this happen automatically?\n",
  "preds": {
   "base:Baseline": "os.path.exists(path)",
   "body:Baseline": "os.path.exists(path)",
   "body:-Blocks": "os.path.exists(path)",
   "body:-Code": "print(os.path.exists())",
   "body:-Inline": "os.path.exists(directory)",
   "body:-NL": "os.path.exists(path)",
   "base:+Mined": "os.path.exists(path)",
   "body+mined:Baseline": "os.path.exists(path)",
   "body+mined:-Code": "os.path.exists(path)",
   "body+mined:-NL": "os.path.exists(path)",
   "body+mined:-Blocks": "print(os.path.exists(path))",
   "body+mined:-Inline": "os.path.exists(path)"
  },
  "snippet": "try:\n    os.makedirs(path)\nexcept OSError:\n    if not os.path.isdir(path):\n        raise"
 },
 "273192.112": {
  "intent": "check if a directory `path` exists and create it if necessary",
  "body": "What is the most elegant way to check if the directory a file is going to be written to exists, and if not, create the directory using Python? Here is what I tried:\nimport os\n\nfile_path = \"/my/directory/filename.txt\"\ndirectory = os.path.dirname(file_path)\n\ntry:\n    os.stat(directory)\nexcept:\n    os.mkdir(directory)       \n\nf = file(filename)\n\nSomehow, I missed os.path.exists  (thanks kanja, Blair, and Douglas). This is what I have now:\ndef ensure_dir(file_path):\n    directory = os.path.dirname(file_path)\n    if not os.path.exists(directory):\n        os.makedirs(directory)\n\nIs there a flag for \"open\", that makes this happen automatically?\n",
  "preds": {
   "base:Baseline": "os.path.exists(path)",
   "body:Baseline": "os.path.exists(path)",
   "body:-Blocks": "os.path.exists(path)",
   "body:-Code": "print(os.path.exists())",
   "body:-Inline": "os.path.exists(directory)",
   "body:-NL": "os.path.exists(path)",
   "base:+Mined": "os.path.exists(path)",
   "body+mined:Baseline": "os.path.exists(path)",
   "body+mined:-Code": "os.path.exists(path)",
   "body+mined:-NL": "os.path.exists(path)",
   "body+mined:-Blocks": "print(os.path.exists(path))",
   "body+mined:-Inline": "os.path.exists(path)"
  },
  "snippet": "distutils.dir_util.mkpath(path)"
 },
 "273192.113": {
  "intent": "check if a directory `path` exists and create it if necessary",
  "body": "What is the most elegant way to check if the directory a file is going to be written to exists, and if not, create the directory using Python? Here is what I tried:\nimport os\n\nfile_path = \"/my/directory/filename.txt\"\ndirectory = os.path.dirname(file_path)\n\ntry:\n    os.stat(directory)\nexcept:\n    os.mkdir(directory)       \n\nf = file(filename)\n\nSomehow, I missed os.path.exists  (thanks kanja, Blair, and Douglas). This is what I have now:\ndef ensure_dir(file_path):\n    directory = os.path.dirname(file_path)\n    if not os.path.exists(directory):\n        os.makedirs(directory)\n\nIs there a flag for \"open\", that makes this happen automatically?\n",
  "preds": {
   "base:Baseline": "os.path.exists(path)",
   "body:Baseline": "os.path.exists(path)",
   "body:-Blocks": "os.path.exists(path)",
   "body:-Code": "print(os.path.exists())",
   "body:-Inline": "os.path.exists(directory)",
   "body:-NL": "os.path.exists(path)",
   "base:+Mined": "os.path.exists(path)",
   "body+mined:Baseline": "os.path.exists(path)",
   "body+mined:-Code": "os.path.exists(path)",
   "body+mined:-NL": "os.path.exists(path)",
   "body+mined:-Blocks": "print(os.path.exists(path))",
   "body+mined:-Inline": "os.path.exists(path)"
  },
  "snippet": "try:\n    os.makedirs(path)\nexcept OSError as exception:\n    if exception.errno != errno.EEXIST:\n        raise"
 },
 "18785032.114": {
  "intent": "replace a separate word 'h3' by 'h1' in a string 'text'",
  "body": "I am trying to replace a string i.e. \"H3\" in a file with \"H1\" but I want only \"H3\" to get replaced and not \"mmmoleculeH3\" to become \"mmmoleculeH1\". I tried re but my limited knowledge in python didn't get me anywhere. If there is any other method than that would be great.script that i am using now is:\n#!/usr/bin/python\n\nimport fileinput\nimport sys\ndef replaceAll(file,searchExp,replaceExp):\n    for line in fileinput.input(file, inplace=1):\n        if searchExp in line:\n            line = line.replace(searchExp,replaceExp)\n        sys.stdout.write(line)\n\nreplaceAll(\"boxFile.cof\",\"H3\",\"H1\")\n\nIf there is any way i can do it with this itself without using re then that would be great.Thanks in advance.\n",
  "preds": {
   "base:Baseline": "re.sub('\\\\d+', 'h3', text)",
   "body:Baseline": "re.sub('(?=?=)', 'H3', text)",
   "body:-Blocks": "re.sub('(?)', 'H3', text)",
   "body:-Code": "re.sub('(?)', 'H3', text)",
   "body:-Inline": "re.sub('(?=H3)', 'H1')",
   "body:-NL": "re.sub('[h3]', 'H1', text)",
   "base:+Mined": "text = re.sub('(\\\\w+)', '\\\\1', 'h3', text)",
   "body+mined:Baseline": "re.sub('((\\\\w+)', '\\\\1', text)",
   "body+mined:-Code": "text.replace('h3', 'h1')",
   "body+mined:-NL": "line = line.replace('h3', '')",
   "body+mined:-Blocks": "text.replace('h3', 'h1')",
   "body+mined:-Inline": "text.replace('H3', 'H1')"
  },
  "snippet": "re.sub('\\\\bH3\\\\b', 'H1', text)"
 },
 "1450897.115": {
  "intent": "substitute ascii letters in string 'aas30dsa20' with empty string ''",
  "body": "How can I remove all characters except numbers from string?\n",
  "preds": {
   "base:Baseline": "\"\"\"aas30dsA20\"\"\".replace('', '')",
   "body:Baseline": "\"\"\"\"\"\".join(re.sub('Aas30dsA20', ''))",
   "body:-Blocks": "\"\"\"aas30dsa20\"\"\".replace('', '')",
   "body:-Code": "\"\"\"Aas30dsA20\"\"\".replace('', '')",
   "body:-Inline": "\"\"\"aas30dsa20\"\"\".replace('', '')",
   "body:-NL": "\"\"\"Aas30dsA20\"\"\".replace('', '')",
   "base:+Mined": "\"\"\"aas30dsA20\"\"\".replace(' ', '')",
   "body+mined:Baseline": "\"\"\"aas30dsa20\"\"\".replace(' ', '')",
   "body+mined:-Code": "\"\"\"aas30dsa20\"\"\".replace(',', '')",
   "body+mined:-NL": "\"\"\"aas30dsa20\"\"\".encode('ascii')",
   "body+mined:-Blocks": "re.sub('(\\\\d+)', '\\\\1', 'Aas30DA20')",
   "body+mined:-Inline": "\"\"\"aas30dsa20\"\"\".replace('', '')"
  },
  "snippet": "re.sub('\\\\D', '', 'aas30dsa20')"
 },
 "1450897.116": {
  "intent": "get digits only from a string `aas30dsa20` using lambda function",
  "body": "How can I remove all characters except numbers from string?\n",
  "preds": {
   "base:Baseline": "\"\"\"{0:.2f}\"\"\".format(aas30dsa20)",
   "body:Baseline": "re.sub('(aas30dsa20))', '', aas30DFa20)",
   "body:-Blocks": "re.sub('\\\\d+', 'aas30dsa20')",
   "body:-Code": "re.sub('\\\\d+', 'aas30dsa20')",
   "body:-Inline": "\"\"\"\"\"\".join(str(aas30dsa20))",
   "body:-NL": "\"\"\"\"\"\".join(str(aas30dsa20))",
   "base:+Mined": "\"\"\"\"\"\".join(str(aas30dsA20))",
   "body+mined:Baseline": "\"\"\"\"\"\".join(str(aas30dsa20))",
   "body+mined:-Code": "\"\"\"aas30dsa20\"\"\".isdigit()",
   "body+mined:-NL": "\"\"\"\"\"\".join(str(aas30dsa20))",
   "body+mined:-Blocks": "\"\"\"aas30dsa20\"\"\".replace(',', '')",
   "body+mined:-Inline": "\"\"\"aas30dsa20\"\"\".replace(',', '')"
  },
  "snippet": "\"\"\"\"\"\".join([x for x in 'aas30dsa20' if x.isdigit()])"
 },
 "14435268.117": {
  "intent": "access a tag called \"name\" in beautifulsoup `soup`",
  "body": "I want to access a tag called as \"name\"  such as:\n<name>Yesugey </name> <lastName>Yesil </lastName> <phone>+90 333 9695395 </phone> </contact>\n\nSince \"name\"  is a property of a BeautifulSoup tag object, I cannot access the child tag name :\nc1\n<name>Yesugey </name> <lastname>Yesil </lastname> <phone>+90 333 9695395 </p\nhone> </contact>\nc1.name\n'contact'\nc1.lastname\n<lastname>Yesil </lastname>\n\n",
  "preds": {
   "base:Baseline": "soup.find_elements_by_xpath(\"name')",
   "body:Baseline": "soup.findall('name')",
   "body:-Blocks": "soup.findChild('name')",
   "body:-Code": "soup.findChild('name')",
   "body:-Inline": "soup.find_element_by_name('name')",
   "body:-NL": "soup.find_tag('name')",
   "base:+Mined": "soup.findAll(text=True)",
   "body+mined:Baseline": "soup.findAll('name')",
   "body+mined:-Code": "soup.findAll('name')",
   "body+mined:-NL": "soup.find_all('contact', {'lastname': 'Yesil'})",
   "body+mined:-Blocks": "soup.findAll('name')",
   "body+mined:-Inline": "soup.find('contact', {'lastname': 'Yesil'})"
  },
  "snippet": "print(soup.find('name').string)"
 },
 "4928274.118": {
  "intent": "get a dictionary `records` of key-value pairs in pymongo cursor `cursor`",
  "body": "Is it possible to iterate over a pymongo Cursor  as a key-value pair like a dict ? I'm using python 2.6 and pymongo 1.9.\nI've tried this:\nimport pymongo\nmongo = pymongo.Connection('localhost')\nmongo_db = mongo['my_database']\nmongo_coll = mongo_db['my_collection']\ncursor = mongo_coll.find()\nrecords = dict([(record_id, record) for record_id, record in mongo_cursor])\n\nBut I get the error:\nValueError: too many values to unpack\n\n",
  "preds": {
   "base:Baseline": "cursor.dict((k, v) for k, v in list(records.items()))",
   "body:Baseline": "dict((k, v) for k, v in cursor.items()))",
   "body:-Blocks": "records = pymongo.dict((k, v) for k, v in cursor.items())",
   "body:-Code": "{k: v for k, v in list(cursor.keys())}",
   "body:-Inline": "records = pymongo.keys()",
   "body:-NL": "records = dict((k, v) for k, v in cursor.items()))",
   "base:+Mined": "cursor.dict((k, v) for k, v in cursor.items())",
   "body+mined:Baseline": "records = dict([(record_id, record) for record_id in mongo_cursor])",
   "body+mined:-Code": "records = {k: v for k, v in list(cursor.items())}",
   "body+mined:-NL": "cursor = mongo_coll.find_all(list(d.keys()))",
   "body+mined:-Blocks": "dict((k, v) for k, v in list(Cursor.items()))",
   "body+mined:-Inline": "{k: v for k, v in list(mongo_coll.items())}"
  },
  "snippet": "records = dict((record['_id'], record) for record in cursor)"
 },
 "20180210.119": {
  "intent": "create new matrix object  by concatenating data from matrix a and matrix b",
  "body": "new to Python, struggling in numpy, hope someone can help me, thank you!\nfrom numpy  import *   \nA = matrix('1.0 2.0; 3.0 4.0')    \nB = matrix('5.0 6.0')\nC = matrix('1.0 2.0; 3.0 4.0; 5.0 6.0')\nprint \"A=\",A\nprint \"B=\",B\nprint \"C=\",C\n\nresults:\nA= [[ 1.  2.]\n   [ 3.  4.]]\nB= [[ 5.  6.]]\nC= [[ 1.  2.]\n   [ 3.  4.]\n   [ 5.  6.]]\n\nQuestion: how to use A and B to generate C, like in matlab C=[A;B] ?\n",
  "preds": {
   "base:Baseline": "np.matrix(a, b)",
   "body:Baseline": "np.matlab(A, B, C)",
   "body:-Blocks": "np.concat([A; B], axis=0)",
   "body:-Code": "np.concat([A, B], axis=1)",
   "body:-Inline": "np.concat([A, B], axis=1)",
   "body:-NL": "np.concat([A, B], axis=1)",
   "base:+Mined": "numpy.concatenate((a, b))",
   "body+mined:Baseline": "C = np.concatenate(A, B)",
   "body+mined:-Code": "C = np.concatenate((A, B))",
   "body+mined:-NL": "np.concatenate((A, B))",
   "body+mined:-Blocks": "C = np.concatenate((A, B))",
   "body+mined:-Inline": "np.concatenate((A, B), axis=1)"
  },
  "snippet": "np.concatenate((A, B))"
 },
 "20180210.120": {
  "intent": "concat two matrices `a` and `b` in numpy",
  "body": "new to Python, struggling in numpy, hope someone can help me, thank you!\nfrom numpy  import *   \nA = matrix('1.0 2.0; 3.0 4.0')    \nB = matrix('5.0 6.0')\nC = matrix('1.0 2.0; 3.0 4.0; 5.0 6.0')\nprint \"A=\",A\nprint \"B=\",B\nprint \"C=\",C\n\nresults:\nA= [[ 1.  2.]\n   [ 3.  4.]]\nB= [[ 5.  6.]]\nC= [[ 1.  2.]\n   [ 3.  4.]\n   [ 5.  6.]]\n\nQuestion: how to use A and B to generate C, like in matlab C=[A;B] ?\n",
  "preds": {
   "base:Baseline": "numpy.concat([a, b])",
   "body:Baseline": "np.concat([A, B], axis=1)",
   "body:-Blocks": "numpy.concat([A; B])",
   "body:-Code": "np.concat([a, b])",
   "body:-Inline": "numpy.concat([A, B])",
   "body:-NL": "numpy.concat([A, B])",
   "base:+Mined": "np.concatenate((a, b), axis=1)",
   "body+mined:Baseline": "np.concatenate(A, B)",
   "body+mined:-Code": "np.concatenate((A, B), axis=1)",
   "body+mined:-NL": "np.concatenate((A, B), axis=1)",
   "body+mined:-Blocks": "np.concatenate(a, b)",
   "body+mined:-Inline": "np.concatenate((A, B), axis=1)"
  },
  "snippet": "np.vstack((A, B))"
 },
 "2011048.121": {
  "intent": "get the characters count in a file `filepath`",
  "body": "I have a python code which reads many files.\nbut some files are extremely large due to which i have errors coming in other codes.\ni want a way in which i can check for the character count of the files so that i avoid reading those extremely large files.\nThanks.\n",
  "preds": {
   "base:Baseline": "print(os.path.getcount(filepath))",
   "body:Baseline": "print(os.path.count(len(filepath))))",
   "body:-Blocks": "print(os.path.count(filepath))",
   "body:-Code": "print(os.path.count(filepath))",
   "body:-Inline": "print(os.path.getccount(filepath))",
   "body:-NL": "print(os.path.realpath(filepath))",
   "base:+Mined": "len(filePath) - len(filepath)",
   "body+mined:Baseline": "len(open('filepath').read())",
   "body+mined:-Code": "print(re.findall('(?<=\\\\w+)\\\\s+', filePath))",
   "body+mined:-NL": "print(len(os.path.join(filepath, filepath)))",
   "body+mined:-Blocks": "len(open('filepath').read())",
   "body+mined:-Inline": "print(len(open('filepath').read())"
  },
  "snippet": "os.stat(filepath).st_size"
 },
 "2600191.122": {
  "intent": "count the occurrences of item \"a\" in list `l`",
  "body": "Given an item, how can I count its occurrences in a list in Python?\n",
  "preds": {
   "base:Baseline": "sum(len(x) for x in L)",
   "body:Baseline": "sum(x for x in l if x not in x)",
   "body:-Blocks": "len(x) for x in L)",
   "body:-Code": "sum(x for x in l if x.isdigit() == 'a')",
   "body:-Inline": "count(x for x in L)",
   "body:-NL": "[x for x in L if x == a]",
   "base:+Mined": "sum(len(s) for s in L)",
   "body+mined:Baseline": "Counter({'a': a, 'b': a})",
   "body+mined:-Code": "Counter({'a': 1, 'b': 1})",
   "body+mined:-NL": "len(L) - len(L))",
   "body+mined:-Blocks": "sum(1 for item in L if item == 'a')",
   "body+mined:-Inline": "Counter({'a': 1, 'b': 1})"
  },
  "snippet": "l.count('a')"
 },
 "2600191.123": {
  "intent": "count the occurrences of items in list `l`",
  "body": "Given an item, how can I count its occurrences in a list in Python?\n",
  "preds": {
   "base:Baseline": "sum(len(x) for x in L)",
   "body:Baseline": "sum(x) for x in L)",
   "body:-Blocks": "len(x) for x in L)",
   "body:-Code": "sum(x for x in l)",
   "body:-Inline": "count(x for x in L)",
   "body:-NL": "count(x for x in L)",
   "base:+Mined": "sum(len(x) for x in L)",
   "body+mined:Baseline": "Counter({x for x in l if x % 2 == 0}",
   "body+mined:-Code": "Counter({'c': 1, 'd': 2, 'e': 1})",
   "body+mined:-NL": "Counter(L, key=lambda x: x[1])",
   "body+mined:-Blocks": "sum(1 for i in L if i % 2 == 0)",
   "body+mined:-Inline": "sum(1 for i in L if i == 0)"
  },
  "snippet": "Counter(l)"
 },
 "2600191.124": {
  "intent": "count the occurrences of items in list `l`",
  "body": "Given an item, how can I count its occurrences in a list in Python?\n",
  "preds": {
   "base:Baseline": "sum(len(x) for x in L)",
   "body:Baseline": "sum(x) for x in L)",
   "body:-Blocks": "len(x) for x in L)",
   "body:-Code": "sum(x for x in l)",
   "body:-Inline": "count(x for x in L)",
   "body:-NL": "count(x for x in L)",
   "base:+Mined": "sum(len(x) for x in L)",
   "body+mined:Baseline": "Counter({x for x in l if x % 2 == 0}",
   "body+mined:-Code": "Counter({'c': 1, 'd': 2, 'e': 1})",
   "body+mined:-NL": "Counter(L, key=lambda x: x[1])",
   "body+mined:-Blocks": "sum(1 for i in L if i % 2 == 0)",
   "body+mined:-Inline": "sum(1 for i in L if i == 0)"
  },
  "snippet": "[[x, l.count(x)] for x in set(l)]"
 },
 "2600191.125": {
  "intent": "count the occurrences of items in list `l`",
  "body": "Given an item, how can I count its occurrences in a list in Python?\n",
  "preds": {
   "base:Baseline": "sum(len(x) for x in L)",
   "body:Baseline": "sum(x) for x in L)",
   "body:-Blocks": "len(x) for x in L)",
   "body:-Code": "sum(x for x in l)",
   "body:-Inline": "count(x for x in L)",
   "body:-NL": "count(x for x in L)",
   "base:+Mined": "sum(len(x) for x in L)",
   "body+mined:Baseline": "Counter({x for x in l if x % 2 == 0}",
   "body+mined:-Code": "Counter({'c': 1, 'd': 2, 'e': 1})",
   "body+mined:-NL": "Counter(L, key=lambda x: x[1])",
   "body+mined:-Blocks": "sum(1 for i in L if i % 2 == 0)",
   "body+mined:-Inline": "sum(1 for i in L if i == 0)"
  },
  "snippet": "dict((x, l.count(x)) for x in set(l))"
 },
 "2600191.126": {
  "intent": "count the occurrences of item \"b\" in list `l`",
  "body": "Given an item, how can I count its occurrences in a list in Python?\n",
  "preds": {
   "base:Baseline": "[x for x in L if 'b' in x]",
   "body:Baseline": "sum(item for item in L if item == 'b' in item)",
   "body:-Blocks": "len(l) == 'b')",
   "body:-Code": "sum(len(b)) for b in L)",
   "body:-Inline": "count(x for x in L)",
   "body:-NL": "[x for x in L if x == 'b']",
   "base:+Mined": "sum(len(s) for s in L)",
   "body+mined:Baseline": "sum(1 for item in L if item == 'b')",
   "body+mined:-Code": "Counter({'b': 1, 'c': 2, 'd': 3})",
   "body+mined:-NL": "len(L) - len(L))",
   "body+mined:-Blocks": "sum(1 for item in L if item == 'b')",
   "body+mined:-Inline": "sum(1 for item in L if 'b' in item)"
  },
  "snippet": "l.count('b')"
 },
 "12842997.127": {
  "intent": "copy file `srcfile` to directory `dstdir`",
  "body": "First thing I have to mention here, I'm new to python.\nNow I have a file located in:\na/long/long/path/to/file.py\n\nI want to copy to my home directory with a new folder created:\n/home/myhome/new_folder\n\nMy expected result is:\n/home/myhome/new_folder/a/long/long/path/to/file.py\n\nIs there any existing library to do that? If no, how can I achieve that?\n",
  "preds": {
   "base:Baseline": "os.copydir(srcfile, dstdir)",
   "body:Baseline": "os.path.dirname(srcfile, dstdir)",
   "body:-Blocks": "os.copydir(srcfile, dstdir)",
   "body:-Code": "os.copy(srcfile, dstdir)",
   "body:-Inline": "os.path.copydir(srcfile, dstdir)",
   "body:-NL": "os.copydir(srcfile, dstdir)",
   "base:+Mined": "os.chdir(srcfile, dstdir)",
   "body+mined:Baseline": "os.path.dirname(srcfile)",
   "body+mined:-Code": "os.path.join(srcfile, dstdir)",
   "body+mined:-NL": "os.path.dirname(srcfile)",
   "body+mined:-Blocks": "dstdir = os.path.join(srcfile, dstdir)",
   "body+mined:-Inline": "os.chdir(srcfile)"
  },
  "snippet": "shutil.copy(srcfile, dstdir)"
 },
 "1555968.128": {
  "intent": "find the key associated with the largest value in dictionary `x` whilst key is non-zero value",
  "body": "I'm new Python and trying to implement code in a more Pythonic and efficient fashion.\nGiven a dictionary with numeric keys and values, what is the best way to find the largest key with a non-zero value?\nThanks\n",
  "preds": {
   "base:Baseline": "max(x, key=lambda x: x[0])",
   "body:Baseline": "max(key, value) == 0",
   "body:-Blocks": "max(x, key=lambda x: x[0])",
   "body:-Code": "max(x, key=operator.itemgetter(x))",
   "body:-Inline": "max(x, key=lambda x: x.isnull()",
   "body:-NL": "[k for k, v in x.items() if v is nonzero]",
   "base:+Mined": "max(x, key=lambda x: x[1])",
   "body+mined:Baseline": "max(x, key=lambda x: x[1])",
   "body+mined:-Code": "max(x, key=lambda x: x[1])",
   "body+mined:-NL": "max(x, key=lambda x: x[1])",
   "body+mined:-Blocks": "max(x, key=lambda x: x.isnull(x))",
   "body+mined:-Inline": "max(x, key=lambda x: x[1])"
  },
  "snippet": "max(k for k, v in x.items() if v != 0)"
 },
 "1555968.129": {
  "intent": "get the largest key whose not associated with value of 0 in dictionary `x`",
  "body": "I'm new Python and trying to implement code in a more Pythonic and efficient fashion.\nGiven a dictionary with numeric keys and values, what is the best way to find the largest key with a non-zero value?\nThanks\n",
  "preds": {
   "base:Baseline": "max(x, key=lambda x: x[0])",
   "body:Baseline": "max(k, v) for k, v in x.items()",
   "body:-Blocks": "max(x, key=lambda x: x[0])",
   "body:-Code": "max(x, key=lambda x: x[0])",
   "body:-Inline": "max(x, key=lambda x: x[0])",
   "body:-NL": "max(x, key=lambda x: x[0])",
   "base:+Mined": "max(x, key=lambda x: x[0])",
   "body+mined:Baseline": "max(x, key=lambda x: x[0])",
   "body+mined:-Code": "max(x, key=lambda x: x[0])",
   "body+mined:-NL": "max(x, key=lambda x: x[0])",
   "body+mined:-Blocks": "max(x, key=lambda x: x[0])",
   "body+mined:-Inline": "max(x, key=lambda x: x != 0)"
  },
  "snippet": "(k for k, v in x.items() if v != 0)"
 },
 "1555968.130": {
  "intent": "get the largest key in a dictionary `x` with non-zero value",
  "body": "I'm new Python and trying to implement code in a more Pythonic and efficient fashion.\nGiven a dictionary with numeric keys and values, what is the best way to find the largest key with a non-zero value?\nThanks\n",
  "preds": {
   "base:Baseline": "max(x, key=lambda x: nonzero)",
   "body:Baseline": "max(x, key=operator.itemgetter(0)))",
   "body:-Blocks": "max(x, key=lambda x: x[0])",
   "body:-Code": "max(x, key=operator.itemgetter(0))",
   "body:-Inline": "max(x, key=lambda x: nonzero)",
   "body:-NL": "max(x, key=lambda x: nonzero)",
   "base:+Mined": "max(x, key=lambda x: x[1])",
   "body+mined:Baseline": "max(x, key=lambda x: x[1])",
   "body+mined:-Code": "max(x, key=lambda x: x[1])",
   "body+mined:-NL": "max(x, key=lambda x: x[0])",
   "body+mined:-Blocks": "max(x, key=operator.itemgetter(0))",
   "body+mined:-Inline": "max(x, key=lambda x: x != 0)"
  },
  "snippet": "max(k for k, v in x.items() if v != 0)"
 },
 "17021863.131": {
  "intent": "put the curser at beginning of the file",
  "body": "I have a script that reads a file and then completes tests based on that file however I am running into a problem because the file reloads after one hour and I cannot get the script to re-read the file after or at that point in time.\nSo:\n\nGETS NEW FILE TO READ\nReads file\nperforms tests on file\nGET NEW FILE TO READ (with same name - but that can change if it is part of a solution)\nReads new file\nperform same tests on new file\n\nCan anyone suggest a way to get Python to re-read the file?\n",
  "preds": {
   "base:Baseline": "curser.start_new_file()",
   "body:Baseline": "print(os.path.getmtime(0, 1))",
   "body:-Blocks": "curser.read().reset_file()",
   "body:-Code": "os.chmod(curser)",
   "body:-Inline": "curser.read().reset_file()",
   "body:-NL": "print(os.path.realpath(__file__))",
   "base:+Mined": "curser.add_argument('foo', 'bar')",
   "body+mined:Baseline": "print(os.path.join(dirname, file))",
   "body+mined:-Code": "print(os.path.join(file, curser))",
   "body+mined:-NL": "os.startswith(file_name)",
   "body+mined:-Blocks": "curser.seek(open('myfile.txt').read())",
   "body+mined:-Inline": "return os.path.join(file, curser)"
  },
  "snippet": "file.seek(0)"
 },
 "38152389.132": {
  "intent": "combine values from column 'b' and column 'a' of dataframe `df`  into column 'c' of datafram `df`",
  "body": "I'm looking for a method that behaves similarly to coalesce in T-SQL. I have 2 columns (column A and B) that are sparsely populated in a pandas dataframe. I'd like to create a new column using the following rules:\n\nIf the value in column A is not null , use that value for the new column C\nIf the value in column A is null , use the value in column B for the new column C\n\nLike I mentioned, this can be accomplished in MS SQL Server via the coalesce function. I haven't found a good pythonic method for this; does one exist?\n",
  "preds": {
   "base:Baseline": "df['b'] = df['A'] + df['C']",
   "body:Baseline": "df['B', 'A'] = df['C']",
   "body:-Blocks": "df['C'] = df['A'].merge(['B', 'A'], axis=1)",
   "body:-Code": "df['C'] = df['A'].concat([df['B'], df['C'], axis=1)",
   "body:-Inline": "df['A'] = df['C']",
   "body:-NL": "df['b', 'a'] = df['c']",
   "base:+Mined": "df['b'].combine(df['a'], df['c'])",
   "body+mined:Baseline": "df['C'] = df['A'].combine(df['B'], df['C'])",
   "body+mined:-Code": "df['c'] = df['b'].coalesce(df['A'], df['B'])",
   "body+mined:-NL": "df['c'] = df['b'].combine(df['a'], df['c'])",
   "body+mined:-Blocks": "df.concat([df.B], axis=1)",
   "body+mined:-Inline": "df.concat([df['b'], df['a'], axis=1)"
  },
  "snippet": "df['c'] = np.where(df['a'].isnull, df['b'], df['a'])"
 },
 "4175686.133": {
  "intent": "remove key 'ele' from dictionary `d`",
  "body": "I use this way to remove an emelment from a dict:\n    d[\"ele\"] = data\n<console_out>\n    d[\"ele\"] = None\n\nI think by this I can remove the reference on the original element so that the removed data can be freed, no memory leak.\nIs it the right way to do this?\n",
  "preds": {
   "base:Baseline": "d = {'ele': 'ele'}",
   "body:Baseline": "d = dict((k, v) for k, v in d.items()) if v in k]",
   "body:-Blocks": "d = dict((k, v) for k, v in d.items() if 'ele' in k)",
   "body:-Code": "d = dict.remove('ele')",
   "body:-Inline": "dict((k, 'ele') for k, v in list(d.items()))",
   "body:-NL": "d = list(d.items()))",
   "base:+Mined": "d = {k: v for k, v in list(d.items())}",
   "body+mined:Baseline": "d = dict((k, e) for k, e in d.items())",
   "body+mined:-Code": "d = dict((i for i, e in list(d.items()) if e!= 'ele')",
   "body+mined:-NL": "d['ele'] = 'None'",
   "body+mined:-Blocks": "d.update({'ele': 1, 'x': 2, 'y': 1})",
   "body+mined:-Inline": "d = dict(data['ele'] for data in data)"
  },
  "snippet": "del d['ele']"
 },
 "5871168.134": {
  "intent": "update datetime field in `mymodel` to be the existing `timestamp` plus 100 years",
  "body": "How can I subtract or add 100 years to a datetime  field in the database in Django?\nThe date is in database, I just want to directly update the field without retrieving it out to calculate and then insert.\n",
  "preds": {
   "base:Baseline": "myModel.update(timestamp=100, datetime=100)",
   "body:Baseline": "timestamp = datetime.datetime.now().date()",
   "body:-Blocks": "myModel.update(timestamp, 100)",
   "body:-Code": "myModel.update({'timestamp': 100, 'year': 100})",
   "body:-Inline": "myModel.update(timestamp, 100 years)",
   "body:-NL": "myModel.update({timestamp: 100, datetime: 100})",
   "base:+Mined": "myModel.update({'date': datetime.datetime.combine(date.today, date.today))})",
   "body+mined:Baseline": "myModel.update(date=today + datetime.timedelta(100) + 100)",
   "body+mined:-Code": "MyModel.set_index(['timestamp', '100Y'])",
   "body+mined:-NL": "myModel.dt.to_timestamp()",
   "body+mined:-Blocks": "MyModel.date.set_index(['timestamp', '100Y'])",
   "body+mined:-Inline": "myModel.update({'date': datetime.timestamp + 100 years})"
  },
  "snippet": "MyModel.objects.update(timestamp=F('timestamp') + timedelta(days=36524.25))"
 },
 "11574195.135": {
  "intent": "merge list `['it']` and list `['was']` and list `['annoying']` into one list",
  "body": "\nPossible Duplicate:\nMaking a flat list out of list of lists in Python\nJoin a list of lists together into one list in Python\n\n\nI have many lists which looks like \n['it']\n['was']\n['annoying']\n\nI want the above to look like \n['it', 'was', 'annoying']\n\nHow do I achieve that?\n",
  "preds": {
   "base:Baseline": "[list(['it', 'was'], ['annoying'] for _ in range(1)]",
   "body:Baseline": "list(['it']', 'was', 'annoying']))",
   "body:-Blocks": "[(x, y) for x, y in zip(['it', 'was']], 'annoying']]",
   "body:-Code": "[(x, y) for x, y in zip(['it', 'was']], 'annoying']]",
   "body:-Inline": "[list(['it'] and list(['was']], ['annoying']]]",
   "body:-NL": "[list(['it'] and list(['was']], ['annoying']]",
   "base:+Mined": "['it', 'annoying']",
   "body+mined:Baseline": "[['it', 'was', 'annoying'] for _ in range(10)]",
   "body+mined:-Code": "[['it', 'was', 'annoying']]",
   "body+mined:-NL": "[['it', 'was', 'annoying'] for _ in range(0, len(s)], s)]",
   "body+mined:-Blocks": "[['it', 'was'], ['annoying']]",
   "body+mined:-Inline": "['it', 'was', 'annoying']"
  },
  "snippet": "['it'] + ['was'] + ['annoying']"
 },
 "587647.136": {
  "intent": "increment a value with leading zeroes in a number `x`",
  "body": "What would be the best way to increment a value that contains leading zeroes?  For example, I'd like to increment \"00000001\".  However, it should be noted that the number of leading zeroes will not exceed 30.  So there may be cases like \"0000012\", \"00000000000000099\", or \"000000000000045\".\nI can think of a couple ways, but I want to see if someone comes up with something slick.\n",
  "preds": {
   "base:Baseline": "max(x, zeroes=0)",
   "body:Baseline": "len(x, key=lambda x: x[0]))",
   "body:-Blocks": "x[0] = x[1]",
   "body:-Code": "x[0].strftime('0')",
   "body:-Inline": "x['0'] = ''.join(x)",
   "body:-NL": "x = zeroes.randint(x)",
   "base:+Mined": "[(1, 2), (2, 3), (3, 4), (5, 6)]",
   "body+mined:Baseline": " increment((x[1:]) for x in range(30))",
   "body+mined:-Code": "x = increment(0, 1)",
   "body+mined:-NL": "x = zeroes.multivariate_normal(x, axis=1)",
   "body+mined:-Blocks": "x.groupby(1).agg(1)",
   "body+mined:-Inline": "x.loc[:, (0)]"
  },
  "snippet": "str(int(x) + 1).zfill(len(x))"
 },
 "17315881.137": {
  "intent": "check if a pandas dataframe `df`'s index is sorted",
  "body": "I have a vanilla pandas dataframe with an index. I need to check if the index is sorted. Preferably without sorting it again.\ne.g. I can test an index to see if it is unique by index.is_unique() is there a similar way for testing sorted?\n",
  "preds": {
   "base:Baseline": "df.index.sort(key=lambda x: x[1])",
   "body:Baseline": "df.index.is_unique()",
   "body:-Blocks": "df.index.sort(key=lambda x: x.is_unique()",
   "body:-Code": "if df.is_unique():\n    pass",
   "body:-Inline": "df.index.is_unique()",
   "body:-NL": "df.index.sort(key=lambda x: x[1])",
   "base:+Mined": "df.sort(index=False, inplace=True)",
   "body+mined:Baseline": "df.index.sort(key=lambda x: x.is_unique())",
   "body+mined:-Code": "df.index.is_unique()",
   "body+mined:-NL": "df.index.sort(key=lambda x: x[1])",
   "body+mined:-Blocks": "df.index.sort(key=lambda index: index.is_unique(index))",
   "body+mined:-Inline": "df.index.isin(['unique', 'unique'])"
  },
  "snippet": "all(df.index[:-1] <= df.index[1:])"
 },
 "16296643.138": {
  "intent": "convert tuple `t` to list",
  "body": "I'm currently working on a map editor for a game in pygame, using tile maps.\nThe level is built up out of blocks in the following structure (though much larger):\nlevel1 = (\n         (1,1,1,1,1,1)\n         (1,0,0,0,0,1)\n         (1,0,0,0,0,1)\n         (1,0,0,0,0,1)\n         (1,0,0,0,0,1)\n         (1,1,1,1,1,1))\n\nwhere \"1\" is a block that's a wall and \"0\" is a block that's empty air.\nThe following code is basically the one handling the change of block type:\nclicked = pygame.mouse.get_pressed()\nif clicked[0] == 1:\n    currLevel[((mousey+cameraY)/60)][((mousex+cameraX)/60)] = 1\n\nBut since the level is stored in a tuple, I'm unable to change the values of the different blocks. How do I go about changing the different values in the level in an easy manner?\n",
  "preds": {
   "base:Baseline": "t = t[::-1]",
   "body:Baseline": "t = pygame.tile_map(map(t, map(t)), reverse=True)",
   "body:-Blocks": "t = map.setLevel(t)",
   "body:-Code": "t = map(t.split())",
   "body:-Inline": "t = map(list(t.items()))",
   "body:-NL": "currLevel[(t) for t in zip(*t)]",
   "base:+Mined": "t = [t[i] for i in t]",
   "body+mined:Baseline": "t = map(t, level1)",
   "body+mined:-Code": "list(level(t) for t in tuple(t.items())",
   "body+mined:-NL": "currLevel[(x + y) for x in t]",
   "body+mined:-Blocks": "t = map(t, t)",
   "body+mined:-Inline": "t = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]"
  },
  "snippet": "list(t)"
 },
 "16296643.139": {
  "intent": "convert list `t` to tuple",
  "body": "I'm currently working on a map editor for a game in pygame, using tile maps.\nThe level is built up out of blocks in the following structure (though much larger):\nlevel1 = (\n         (1,1,1,1,1,1)\n         (1,0,0,0,0,1)\n         (1,0,0,0,0,1)\n         (1,0,0,0,0,1)\n         (1,0,0,0,0,1)\n         (1,1,1,1,1,1))\n\nwhere \"1\" is a block that's a wall and \"0\" is a block that's empty air.\nThe following code is basically the one handling the change of block type:\nclicked = pygame.mouse.get_pressed()\nif clicked[0] == 1:\n    currLevel[((mousey+cameraY)/60)][((mousex+cameraX)/60)] = 1\n\nBut since the level is stored in a tuple, I'm unable to change the values of the different blocks. How do I go about changing the different values in the level in an easy manner?\n",
  "preds": {
   "base:Baseline": "t = tuple([i for i in t])",
   "body:Baseline": "t = pygame.tile_map(t, t))",
   "body:-Blocks": "t = map.setLevel(t)",
   "body:-Code": "t = map(list(t.items())",
   "body:-Inline": "t = tuple(map(list(t.items()), key=lambda t: t[0])",
   "body:-NL": "tuple(t, key=lambda t: t[0])",
   "base:+Mined": "tuple(map(t, l))",
   "body+mined:Baseline": "tuple(map(tuple, level1))",
   "body+mined:-Code": "tuple(map(tuple, iter(t))",
   "body+mined:-NL": "tuple(x[0] for x in t)",
   "body+mined:-Blocks": "tuple(map(t, t))",
   "body+mined:-Inline": "tuple(map(tuple, level1))"
  },
  "snippet": "tuple(l)"
 },
 "16296643.140": {
  "intent": "convert tuple `level1` to list",
  "body": "I'm currently working on a map editor for a game in pygame, using tile maps.\nThe level is built up out of blocks in the following structure (though much larger):\nlevel1 = (\n         (1,1,1,1,1,1)\n         (1,0,0,0,0,1)\n         (1,0,0,0,0,1)\n         (1,0,0,0,0,1)\n         (1,0,0,0,0,1)\n         (1,1,1,1,1,1))\n\nwhere \"1\" is a block that's a wall and \"0\" is a block that's empty air.\nThe following code is basically the one handling the change of block type:\nclicked = pygame.mouse.get_pressed()\nif clicked[0] == 1:\n    currLevel[((mousey+cameraY)/60)][((mousex+cameraX)/60)] = 1\n\nBut since the level is stored in a tuple, I'm unable to change the values of the different blocks. How do I go about changing the different values in the level in an easy manner?\n",
  "preds": {
   "base:Baseline": "list(level1, key=lambda tup: tup[1])",
   "body:Baseline": "pygame.tile_map(level1, key=lambda t: t[0], reverse=True)",
   "body:-Blocks": "level1 = map(level1, level2)",
   "body:-Code": "list(level1, key=lambda tup: tup[0])",
   "body:-Inline": "list(level1, key=lambda t: t[0])",
   "body:-NL": "[(level1, key=lambda t: t[0]) for t in level1]",
   "base:+Mined": "map(lambda x: x[1])",
   "body+mined:Baseline": "pygame.tile(level1, 0)",
   "body+mined:-Code": "list(level1.flatten())",
   "body+mined:-NL": "currLevel[(x + y) for x, y in zip(level1, levelX)]",
   "body+mined:-Blocks": "Level1 = [tuple(level1) for tuple in tuple]",
   "body+mined:-Inline": "currLevel[(1, 0), (1, 1), (0, 0)]"
  },
  "snippet": "level1 = map(list, level1)"
 },
 "3880399.141": {
  "intent": "send the output of pprint object `dataobject` to file `logfile`",
  "body": "I have the following code:\nlogFile=open('c:\\\\temp\\\\mylogfile'+'.txt', 'w')\npprint.pprint(dataobject)\n\nhow can i send the contents of dataobject to the log file on the pretty print format ?\n",
  "preds": {
   "base:Baseline": "logfile.send('//logfile')",
   "body:Baseline": "pprint.pprint(dataobject, logFile)",
   "body:-Blocks": "logfile = pd.open('dataobject', 'logfile')",
   "body:-Code": "logfile = pd.open('dataobject', 'logfile')",
   "body:-Inline": "pprint.pprint(dataobject)",
   "body:-NL": "pprint.pprint(dataobject)",
   "base:+Mined": "dataobject.send('logfile')",
   "body+mined:Baseline": "pprint.pprint(dataobject)",
   "body+mined:-Code": "logfile.write(dataobject)",
   "body+mined:-NL": "pprint.pprint(dataobject)",
   "body+mined:-Blocks": "logfile.write('\\n'.join(dataobject))",
   "body+mined:-Inline": "pprint.pprint(dataobject, pretty_print=True)"
  },
  "snippet": "pprint.pprint(dataobject, logFile)"
 },
 "21800169.142": {
  "intent": "get index of rows in column 'boolcol'",
  "body": "Given a DataFrame with a column \"BoolCol\", we want to find the indexes of the DataFrame in which the values for \"BoolCol\" == True\nI currently have the iterating way to do it, which works perfectly:\nfor i in range(100,3000):\n    if df.iloc[i]['BoolCol']== True:\n         print i,df.iloc[i]['BoolCol']\n\nBut this is not the correct panda's way to do it.\nAfter some research, I am currently using this code:\ndf[df['BoolCol'] == True].index.tolist()\n\nThis one gives me a list of indexes, but they dont match, when I check them by doing:\ndf.iloc[i]['BoolCol']\n\nThe result is actually False!!\nWhich would be the correct Pandas way to do this?\n",
  "preds": {
   "base:Baseline": "df['boolcol'].index('index')",
   "body:Baseline": "df[df['BoolCol'] == True].index.tolist()",
   "body:-Blocks": "df['boolCol'] = df['BoolCol']",
   "body:-Code": "df['boolCol'] = df['BoolCol']",
   "body:-Inline": "df.iloc[i]['BoolCol'] == True",
   "body:-NL": "df['boolCol'] == True].index.tolist()",
   "base:+Mined": "df.index.get_level_values('boolcol')",
   "body+mined:Baseline": "df[df['BoolCol'] == True]",
   "body+mined:-Code": "df.index.get_level_values('BoolCol') == True",
   "body+mined:-NL": "df[df['BoolCol'] == True].index.tolist()",
   "body+mined:-Blocks": "df.index.get_level_values('BoolCol')",
   "body+mined:-Inline": "df[df['BoolCol'] == True].index.tolist()"
  },
  "snippet": "df.loc[df['BoolCol']]"
 },
 "21800169.143": {
  "intent": "create a list containing the indexes of rows where the value of column 'boolcol' in dataframe `df` are equal to true",
  "body": "Given a DataFrame with a column \"BoolCol\", we want to find the indexes of the DataFrame in which the values for \"BoolCol\" == True\nI currently have the iterating way to do it, which works perfectly:\nfor i in range(100,3000):\n    if df.iloc[i]['BoolCol']== True:\n         print i,df.iloc[i]['BoolCol']\n\nBut this is not the correct panda's way to do it.\nAfter some research, I am currently using this code:\ndf[df['BoolCol'] == True].index.tolist()\n\nThis one gives me a list of indexes, but they dont match, when I check them by doing:\ndf.iloc[i]['BoolCol']\n\nThe result is actually False!!\nWhich would be the correct Pandas way to do this?\n",
  "preds": {
   "base:Baseline": "df[index(df['boolcol'] == True]",
   "body:Baseline": "df[i]['BoolCol'] == True].index.tolist()",
   "body:-Blocks": "[i for i, j in df.values() if j == True]",
   "body:-Code": "[i for i, j in df if j == 'boolCol']",
   "body:-Inline": "[df[i]['BoolCol'] == True]",
   "body:-NL": "df[df['BoolCol'] == True].index.tolist()",
   "base:+Mined": "df[df['boolCol'] == True]",
   "body+mined:Baseline": "df[df['BoolCol'] == True].index.tolist()",
   "body+mined:-Code": "[i for i, v in df.index.get('BoolCol') if v == True]",
   "body+mined:-NL": "df[df['BoolCol'] == True].index.tolist()",
   "body+mined:-Blocks": "[(df == 'BoolCol').any(axis=1)]",
   "body+mined:-Inline": "df[df['BoolCol'] == True].index.tolist()"
  },
  "snippet": "df.iloc[np.flatnonzero(df['BoolCol'])]"
 },
 "21800169.144": {
  "intent": "get list of indexes of rows where column 'boolcol' values match true",
  "body": "Given a DataFrame with a column \"BoolCol\", we want to find the indexes of the DataFrame in which the values for \"BoolCol\" == True\nI currently have the iterating way to do it, which works perfectly:\nfor i in range(100,3000):\n    if df.iloc[i]['BoolCol']== True:\n         print i,df.iloc[i]['BoolCol']\n\nBut this is not the correct panda's way to do it.\nAfter some research, I am currently using this code:\ndf[df['BoolCol'] == True].index.tolist()\n\nThis one gives me a list of indexes, but they dont match, when I check them by doing:\ndf.iloc[i]['BoolCol']\n\nThe result is actually False!!\nWhich would be the correct Pandas way to do this?\n",
  "preds": {
   "base:Baseline": "[i for i, v in enumerate(boolcol.values()) if v == True]",
   "body:Baseline": "df[df['BoolCol'] == True].index.tolist()",
   "body:-Blocks": "[i for i, j in enumerate(df['boolCol'] if j == True]",
   "body:-Code": "[x['boolCol'] == True]",
   "body:-Inline": "df[df['BoolCol'] == True].index.tolist()",
   "body:-NL": "df[df['boolCol'] == True].index.tolist()",
   "base:+Mined": "[index for index, row in enumerate(boolcol) if row == True]",
   "body+mined:Baseline": "df[df['BoolCol'] == True]",
   "body+mined:-Code": "[i for i, v in enumerate(df.BoolCol) if v == True]",
   "body+mined:-NL": "df[df['BoolCol'] == True].index.tolist()",
   "body+mined:-Blocks": "[index for index, row in df.index if row['BoolCol'] == True]",
   "body+mined:-Inline": "df[df['BoolCol'] == True].index.tolist()"
  },
  "snippet": "df[df['BoolCol'] == True].index.tolist()"
 },
 "21800169.145": {
  "intent": "get index of rows in dataframe `df` which column 'boolcol' matches value true",
  "body": "Given a DataFrame with a column \"BoolCol\", we want to find the indexes of the DataFrame in which the values for \"BoolCol\" == True\nI currently have the iterating way to do it, which works perfectly:\nfor i in range(100,3000):\n    if df.iloc[i]['BoolCol']== True:\n         print i,df.iloc[i]['BoolCol']\n\nBut this is not the correct panda's way to do it.\nAfter some research, I am currently using this code:\ndf[df['BoolCol'] == True].index.tolist()\n\nThis one gives me a list of indexes, but they dont match, when I check them by doing:\ndf.iloc[i]['BoolCol']\n\nThe result is actually False!!\nWhich would be the correct Pandas way to do this?\n",
  "preds": {
   "base:Baseline": "df.loc[df['boolcol'] == True]",
   "body:Baseline": "df[df['BoolCol'] == True].index.tolist()",
   "body:-Blocks": "df.index(['boolCol'] == True)",
   "body:-Code": "df.index['boolCol'] == True",
   "body:-Inline": "df[df['BoolCol'] == True]",
   "body:-NL": "df[df['boolCol'] == True].index.tolist()",
   "base:+Mined": "df[df['boolCol'] == True]",
   "body+mined:Baseline": "df[df['BoolCol'] == True].index.tolist()",
   "body+mined:-Code": "df[df['BoolCol'] == True]",
   "body+mined:-NL": "df[df['BoolCol'] == True].index.tolist()",
   "body+mined:-Blocks": "df[df['BoolCol'] == True]",
   "body+mined:-Inline": "df[df['BoolCol'] == True].index.tolist()"
  },
  "snippet": "df[df['BoolCol']].index.tolist()"
 },
 "299446.146": {
  "intent": "change working directory to the directory `owd`",
  "body": "I have a function that resembles the one below. I'm not sure how to use the os module to get back to my original working directory at the conclusion of the jar's execution. \ndef run(): \n    owd = os.getcwd()\n    #first change dir to build_dir path\n    os.chdir(testDir)\n    #run jar from test directory\n    os.system(cmd)\n    #change dir back to original working directory (owd)\n\nnote: I think my code formatting is off - not sure why. My apologies in advance\n",
  "preds": {
   "base:Baseline": "os.chdir('owd')",
   "body:Baseline": "os.chdir(testDir)",
   "body:-Blocks": "os.chdir(owd)",
   "body:-Code": "os.chdir('owd')",
   "body:-Inline": "os.chdir(owd)",
   "body:-NL": "os.chdir(owd)",
   "base:+Mined": "os.chdir('owd')",
   "body+mined:Baseline": "os.chdir(testDir)",
   "body+mined:-Code": "os.chdir('/tmp/owd')",
   "body+mined:-NL": "os.chdir(os.path.dirname(__file__))",
   "body+mined:-Blocks": "os.chdir(os.path.dirname(owd))",
   "body+mined:-Inline": "os.chdir(__file__)"
  },
  "snippet": "os.chdir(owd)"
 },
 "14695134.147": {
  "intent": "insert data from a string `testfield` to sqlite db `c`",
  "body": "I'm trying to insert strings read from a file into an sqlite  database in Python. The strings have whitespace (newline, tab characters, and spaces) and also have appearances of single or double quotes.  Here's how I try to do it:\nimport sqlite3\nconn = sqlite3.connect('example.db')\nc = conn.cursor()\n\n# Create table\nc.execute('''CREATE TABLE test\n             (a text, b text)''')\n\nf = open(\"foo\", \"w\")\nf.write(\"hello\\n\\'world\\'\\n\")\nf.close()\n\ntestfield = open(\"foo\").read()\n\n# Insert a row of data\nc.execute(\"INSERT INTO test VALUES ('%s', 'bar')\" %(testfield))\n\n# Save (commit) the changes\nconn.commit()\n\nI find that this fails with the error: \n    c.execute(\"INSERT INTO test VALUES ('%s', 'bar')\" %(testfield))\nsqlite3.OperationalError: near \"world\": syntax error\n\nHow can I achieve this? Do the strings need to be escaped before insertion in the db, and if so how? thanks.\n",
  "preds": {
   "base:Baseline": "c.execute('INSERT INTO testfield')",
   "body:Baseline": "c = sqlite3.connect('example.db')",
   "body:-Blocks": "c = db.read_csv('testfield')",
   "body:-Code": "c = db.insert(testfield)",
   "body:-Inline": "c.execute('INSERT INTO test VALUES ('%s', 'bar') % (testfield))",
   "body:-NL": "c.execute('INSERT INTO test VALUES ('%s', 'bar') % (testfield))",
   "base:+Mined": "cursor.execute('INSERT INTO testfield VALUES (%s, %s)', (testfield,))",
   "body+mined:Baseline": "c.execute('INSERT INTO test VALUES ('%s', 'bar')' % (testfield))",
   "body+mined:-Code": "cursor.execute('INSERT INTO testfield (text) VALUES (%s)', (testfield,))",
   "body+mined:-NL": "c.execute('INSERT INTO test VALUES ('%s', 'bar')' % (testfield))",
   "body+mined:-Blocks": "cursor.execute('INSERT INTO testfield data (newline) VALUES (%s)', testfield)",
   "body+mined:-Inline": "c.execute('SELECT * FROM testfield WHERE bar = {}')"
  },
  "snippet": "c.execute(\"INSERT INTO test VALUES (?, 'bar')\", (testfield,))"
 },
 "24242433.148": {
  "intent": "decode string \"\\\\x89\\\\n\" into a normal string",
  "body": "In Python, I have a string like this:\n'\\\\x89\\\\n'\n\nHow can I decode it into a normal string like:\n'\\x89\\n'\n\n",
  "preds": {
   "base:Baseline": "\"\"\"\\\\x89\\\\n\"\"\".decode('normal')",
   "body:Baseline": "\"\"\"\\\\x89\\\\n\"\"\".decode('normal')",
   "body:-Blocks": "\"\"\"\\\\x89\\\\n\"\"\".decode('normal')",
   "body:-Code": "\"\"\"\\\\x89\\\\n\"\"\".decode('normal')",
   "body:-Inline": "\"\"\"\\\\x89\\\\n\"\"\".decode('normal')",
   "body:-NL": "\"\"\"\\\\x89\\\\n\"\"\".decode('normal')",
   "base:+Mined": "\"\"\"\\\\x89\\\\n\"\"\".decode('normal')",
   "body+mined:Baseline": "\"\"\"\"\"\".decode('\\\\x89\\\\n')",
   "body+mined:-Code": "\"\"\"\\\\x89\\\\n\"\"\".decode('normal')",
   "body+mined:-NL": "\"\"\"\\\\x89\\\\n\"\"\".decode('unicode-escape')",
   "body+mined:-Blocks": "\"\"\\\\x89\\\\n\"\"\".decode('utf-8')",
   "body+mined:-Inline": "normalize('NFKD', 'x89\\\\n')"
  },
  "snippet": "\"\"\"\\\\x89\\\\n\"\"\".decode('string_escape')"
 },
 "24242433.149": {
  "intent": "convert a raw string `raw_string` into a normal string",
  "body": "In Python, I have a string like this:\n'\\\\x89\\\\n'\n\nHow can I decode it into a normal string like:\n'\\x89\\n'\n\n",
  "preds": {
   "base:Baseline": "\"\"\"\"\"\".join(raw_string.split())",
   "body:Baseline": "raw_string.decode('normal')",
   "body:-Blocks": "raw_string.decode('normal')",
   "body:-Code": "raw_string.decode('normal')",
   "body:-Inline": "raw_string.decode('normal')",
   "body:-NL": "raw_string.split('\\x89\\\\n')",
   "base:+Mined": "\"\"\"\"\"\".join(raw_string)",
   "body+mined:Baseline": "\"\"\"\"\"\".join(raw_string)",
   "body+mined:-Code": "raw_string.decode('normal')",
   "body+mined:-NL": "raw_string.split('\\x89\\\\n')",
   "body+mined:-Blocks": "raw_string.decode('utf-8')",
   "body+mined:-Inline": "\"\"\"\"\"\".join(raw_string)"
  },
  "snippet": "raw_string.decode('string_escape')"
 },
 "24242433.150": {
  "intent": "convert a raw string `raw_byte_string` into a normal string",
  "body": "In Python, I have a string like this:\n'\\\\x89\\\\n'\n\nHow can I decode it into a normal string like:\n'\\x89\\n'\n\n",
  "preds": {
   "base:Baseline": "\"\"\"raw_byte_string\"\"\".split()",
   "body:Baseline": "raw_byte_string.decode('normal')",
   "body:-Blocks": "raw_byte_string.decode('normal')",
   "body:-Code": "raw_byte_string.decode('normal')",
   "body:-Inline": "raw_byte_string.decode('normal')",
   "body:-NL": "raw_byte_string.split('\\x89\\\\n')",
   "base:+Mined": "\"\"\"\"\"\".join(raw_byte_string)",
   "body+mined:Baseline": "\"\"\"\"\"\".join(raw_byte_string)",
   "body+mined:-Code": "raw_byte_string.decode('unicode_escape')",
   "body+mined:-NL": "\"\"\"\"\"\".join(raw_byte_string.split(','))",
   "body+mined:-Blocks": "\"\"\"\"\"\".join(chr(raw_byte_string))",
   "body+mined:-Inline": "\"\"\"\"\"\".join(raw_byte_string)"
  },
  "snippet": "raw_byte_string.decode('unicode_escape')"
 },
 "22882922.151": {
  "intent": "split a string `s` with into all strings of repeated characters",
  "body": "I am not well experienced with Regex but I have been reading a lot about it. Assume there's a string s = '111234'  I want a list with the string split into L = ['111', '2', '3', '4'] . My approach was to make a group checking if it's a digit or not and then check for a repetition of the group. Something like this \nL = re.findall('\\d[\\1+]', s)\n\nI think that \\d[\\1+]  will basically check for either \"digit\" or \"digit +\" the same repetitions. I think this might do what I want. \n",
  "preds": {
   "base:Baseline": "re.split('\\\\d+', s)",
   "body:Baseline": "re.findall('\\\\d[\\\\1+]', s)",
   "body:-Blocks": "re.split('\\\\d+', s)",
   "body:-Code": "re.findall('\\\\d+', s)",
   "body:-Inline": "re.findall('\\\\d[\\\\1+]', s)",
   "body:-NL": "re.findall('\\\\d[\\\\1+]', s)",
   "base:+Mined": "re.findall('\\\\s+', s)",
   "body+mined:Baseline": "L = re.findall('\\\\d[\\\\1+]', s)",
   "body+mined:-Code": "re.findall('\\\\d+', s)",
   "body+mined:-NL": "re.findall('\\\\d[\\\\1+]', s)",
   "body+mined:-Blocks": "re.findall('\\\\d+(?<=\\\\d+)', s)",
   "body+mined:-Inline": "re.findall('\\\\d[\\\\1+]', s)"
  },
  "snippet": "[m.group(0) for m in re.finditer('(\\\\d)\\\\1*', s)]"
 },
 "4143502.152": {
  "intent": "scatter a plot with x, y position of `np.random.randn(100)` and face color equal to none",
  "body": "In Python, with Matplotlib, how can a scatter plot with empty  circles be plotted?  The goal is to draw empty circles around some  of the colored disks already plotted by scatter() , so as to highlight them, ideally without having to redraw the colored circles.\nI tried facecolors=None , to no avail.\n",
  "preds": {
   "base:Baseline": "np.random.randn(100)",
   "body:Baseline": "np.random.randn(100)",
   "body:-Blocks": "plt.scatter(np.random.randn(100))",
   "body:-Code": "plt.scatter(np.random.randn(100))",
   "body:-Inline": "np.random.randn(100)",
   "body:-NL": "np.random.randn(100)",
   "base:+Mined": "plt.savefig('np.random.randn(100)')",
   "body+mined:Baseline": "plt.plot(x, y, na.random.randn(100))",
   "body+mined:-Code": "plt.scatter(x, y, marker=np.random.randn(100))",
   "body+mined:-NL": "plt.plot(x, y, np.random.randn(100))",
   "body+mined:-Blocks": "plt.scatter(x, y, z, marker=np.random.randn(100))",
   "body+mined:-Inline": "plt.plot(x, y, 'np.random.randn(100))"
  },
  "snippet": "plt.scatter(np.random.randn(100), np.random.randn(100), facecolors='none')"
 },
 "4143502.153": {
  "intent": "do a scatter plot with empty circles",
  "body": "In Python, with Matplotlib, how can a scatter plot with empty  circles be plotted?  The goal is to draw empty circles around some  of the colored disks already plotted by scatter() , so as to highlight them, ideally without having to redraw the colored circles.\nI tried facecolors=None , to no avail.\n",
  "preds": {
   "base:Baseline": "plt.scatter(background=False)",
   "body:Baseline": "re.findall('\\n')[::-1]",
   "body:-Blocks": "plt.scatter(inner=None)",
   "body:-Code": "plt.scatter('\\n')",
   "body:-Inline": "plt. scatterplot(empty circles)",
   "body:-NL": "sorted(list(range(10)), key=lambda x: x[1])",
   "base:+Mined": "plt.plot(x, y)",
   "body+mined:Baseline": "ax.spines['left'].set_visible(False)",
   "body+mined:-Code": "plt.scatter(ax.get_yticklabels(), marker='r')",
   "body+mined:-NL": "plt.plot(x, y, 'bo')",
   "body+mined:-Blocks": "ax.scatter(x, y, color='r', label='black')",
   "body+mined:-Inline": "plt.plot(x, y, 'r')"
  },
  "snippet": "plt.plot(np.random.randn(100), np.random.randn(100), 'o', mfc='none')"
 },
 "32063985.154": {
  "intent": "remove a div with a id `main-content` using beautifulsoup",
  "body": "I want to delete the specific div  from soup  object. \nI am using python 2.7  and bs4 . \nAccording to documentation we can use div.decompose() . \nBut that would delete all the div . How can I delete a div  with specific class?\n",
  "preds": {
   "base:Baseline": "soup.findAll(id=main - content)",
   "body:Baseline": "soup.delete(div, id=main - content)",
   "body:-Blocks": "soup.remove(id=main - content)",
   "body:-Code": "beautifulsoup.remove(id=main - content)",
   "body:-Inline": "soup.delete(div, id=main - content)",
   "body:-NL": "soup.remove(div, id=main - content)",
   "base:+Mined": "soup.findAll(id=maincontent)",
   "body+mined:Baseline": "soup.pop('main-content', None)",
   "body+mined:-Code": "soup.findAll('div', id=main - content)",
   "body+mined:-NL": "soup.pop('div', None)",
   "body+mined:-Blocks": "soup.remove(div, id=main - content)",
   "body+mined:-Inline": "soup.body.filter(div__name__in=['main-content'])"
  },
  "snippet": "soup.find('div', id='main-content').decompose()"
 },
 "27975069.155": {
  "intent": "filter rows containing key word `ball` in column `ids`",
  "body": "Assume we have a data frame in Python Pandas that looks like this:\ndf = pd.DataFrame({'vals': [1, 2, 3, 4], 'ids': [u'aball', u'bball', u'cnut', u'fball']})\n\nOr, in table form:\nids    vals\naball   1\nbball   2\ncnut    3\nfball   4\n\nHow do I filter rows which contain the key word \"ball?\" For example, the output should be:\nids    vals\naball   1\nbball   2\nfball   4\n\n",
  "preds": {
   "base:Baseline": "ids.filter(key=lambda x: x[1])",
   "body:Baseline": "df = pd.DataFrame({'vals': [1, 2, 3, 4], 'ids': ['aball', 'bball', 'cnut',\n    'fball']})",
   "body:-Blocks": "ids.filter(key=lambda x: x['ball'])",
   "body:-Code": "ids.filter(key=lambda x: x['ball']))",
   "body:-Inline": "df.filter(ids, key=lambda x: x['ball']))",
   "body:-NL": "df.filter(ids, key=lambda x: x['bball']))",
   "base:+Mined": "ids.filter(id__in=['ball', 'id'])",
   "body+mined:Baseline": "df['ids'] = df['ball'].apply(lambda x: x.groupby('ball'))",
   "body+mined:-Code": "df[df.columns.contains('ball')]",
   "body+mined:-NL": "df.loc[df['ids'] == 'bball']",
   "body+mined:-Blocks": "df['ids'] = df['ball'].str.contains('ball')",
   "body+mined:-Inline": "df[df['ids']].str.contains('ball')"
  },
  "snippet": "df[df['ids'].str.contains('ball')]"
 },
 "20461165.156": {
  "intent": "convert index at level 0 into a column in dataframe `df`",
  "body": "This seems rather obvious, but I can't seem to figure out how to convert an index of data frame to a column?\nFor example:\ndf=\n        gi       ptt_loc\n 0  384444683      593  \n 1  384444684      594 \n 2  384444686      596  \n\nTo,\ndf=\n    index1    gi       ptt_loc\n 0  0     384444683      593  \n 1  1     384444684      594 \n 2  2     384444686      596  \n\n",
  "preds": {
   "base:Baseline": "df.columns[0:]]",
   "body:Baseline": "df.index1 = df.columns[0]",
   "body:-Blocks": "df['index'] = df['index'].columns",
   "body:-Code": "df['index'] = df['column']",
   "body:-Inline": "df.columns[:, (level 0)]",
   "body:-NL": "df.columns.reset_index(level=0)",
   "base:+Mined": "df.set_index(level=0)",
   "body+mined:Baseline": "df.columns = ['index1', 'gi', 'ptt_loc']",
   "body+mined:-Code": "df['column'] = df['column'].astype(float)",
   "body+mined:-NL": "df.columns = ['index1', 'index2']",
   "body+mined:-Blocks": "df['column'] = df['column'].astype(float)",
   "body+mined:-Inline": "df.columns = ['index1', 'ptt_loc']"
  },
  "snippet": "df.reset_index(level=0, inplace=True)"
 },
 "20461165.157": {
  "intent": "add indexes in a data frame `df` to a column `index1`",
  "body": "This seems rather obvious, but I can't seem to figure out how to convert an index of data frame to a column?\nFor example:\ndf=\n        gi       ptt_loc\n 0  384444683      593  \n 1  384444684      594 \n 2  384444686      596  \n\nTo,\ndf=\n    index1    gi       ptt_loc\n 0  0     384444683      593  \n 1  1     384444684      594 \n 2  2     384444686      596  \n\n",
  "preds": {
   "base:Baseline": "df.index1[index1:]",
   "body:Baseline": "df[index1].index1]",
   "body:-Blocks": "df.index1 = df.columns",
   "body:-Code": "df['index1'] = index1",
   "body:-Inline": "df[index1].index1.columns",
   "body:-NL": "df[index1:] = df.index1",
   "base:+Mined": "df.set_index('index1')",
   "body+mined:Baseline": "df['index1'] = df['ptt_loc']",
   "body+mined:-Code": "df['index1'] = index1",
   "body+mined:-NL": "df['index1'] = df.index.get_level_values(0)",
   "body+mined:-Blocks": "df.set_index('index1')",
   "body+mined:-Inline": "df.columns = ['index1', 'index2']"
  },
  "snippet": "df['index1'] = df.index"
 },
 "20461165.158": {
  "intent": "convert pandas index in a dataframe to columns",
  "body": "This seems rather obvious, but I can't seem to figure out how to convert an index of data frame to a column?\nFor example:\ndf=\n        gi       ptt_loc\n 0  384444683      593  \n 1  384444684      594 \n 2  384444686      596  \n\nTo,\ndf=\n    index1    gi       ptt_loc\n 0  0     384444683      593  \n 1  1     384444684      594 \n 2  2     384444686      596  \n\n",
  "preds": {
   "base:Baseline": "df['index'] = df['index'].columns",
   "body:Baseline": "df.to_columns().tolist()",
   "body:-Blocks": "pd.concat([df.index, df.columns])",
   "body:-Code": "df['index'] = df['columns']",
   "body:-Inline": "df.to_columns().index()",
   "body:-NL": "df.columns.reset_index()",
   "base:+Mined": "pd.concat([df1, df2], axis=1)",
   "body+mined:Baseline": "df.columns = ['index1', 'gi', 'ptt_loc']",
   "body+mined:-Code": "df['column'] = df['column'].astype(float)",
   "body+mined:-NL": "df.columns = ['index1', 'index2']",
   "body+mined:-Blocks": "df['col'] = df['col'].astype(float)",
   "body+mined:-Inline": "df.columns = ['gi', 'ptt_loc']"
  },
  "snippet": "df.reset_index(level=['tick', 'obs'])"
 },
 "4685571.159": {
  "intent": "get reverse of list items from list 'b' using extended slicing",
  "body": "b=[('spam',0), ('eggs',1)]\n[reversed(x) for x in b]\n[ <reversed object at 0x7fbf07de7090>, <reversed object at 0x7fbf07de70d0>]\n\nBummer. I expected to get a list of reversed tuples!\nSure I can do:\n[tuple(reversed(x)) for x in b]\n[(0, 'spam'), (1, 'eggs')]\n\nBut I hoped for something generic? Smth that when being handed over a list of tuples, returns a list of reversed tuples, and when handed over a list of lists, returns a list of reversed lists.\nSure, an ugly hack with isinstance() is always available but I kind of hoped avoiding going that route.\n",
  "preds": {
   "base:Baseline": "[x[0] for x in b]",
   "body:Baseline": "[tuple(x) for x in b]",
   "body:-Blocks": "[(x, y) for x, y in zip(b, b)]",
   "body:-Code": "[item[0] for item in b]",
   "body:-Inline": "[tuple(reversed(x) for x in b]",
   "body:-NL": "[tuple(x) for x in b]",
   "base:+Mined": "[x[0] for x in a]",
   "body+mined:Baseline": "[tuple(x) for x in b for y in reversed(x)]",
   "body+mined:-Code": "[x[::-1] for x in b]",
   "body+mined:-NL": "[tuple(x) for x in b]",
   "body+mined:-Blocks": "[x[::-1] for x in a]",
   "body+mined:-Inline": "[tuple(x) for x in b for y in b]"
  },
  "snippet": "[x[::-1] for x in b]"
 },
 "17960441.160": {
  "intent": "join each element in array `a` with element at the same index in array `b` as a tuple",
  "body": "For example I have 2 arrays\na = array([[0, 1, 2, 3],\n           [4, 5, 6, 7]])\nb = array([[0, 1, 2, 3],\n           [4, 5, 6, 7]])\n\nHow can I zip\na  and b  so I get\nc = array([[(0,0), (1,1), (2,2), (3,3)],\n           [(4,4), (5,5), (6,6), (7,7)]])\n\n?\n",
  "preds": {
   "base:Baseline": "[x[0] for x in zip(a, b)]",
   "body:Baseline": "[(x, y) for x, y in a, b)]",
   "body:-Blocks": "zip(a, b, c)",
   "body:-Code": "[(x, y) for x, y in zip(a, b)]",
   "body:-Inline": "[(x, y) for x, y in zip(a, b)]",
   "body:-NL": "[(x, y) for x, y in zip(a, b)]",
   "base:+Mined": "a, b = zip(a[i], b[i])",
   "body+mined:Baseline": "c = zip(*a, b)",
   "body+mined:-Code": "tuple(zip(a, b))",
   "body+mined:-NL": "a[np.arange(b)] = zip(*a)",
   "body+mined:-Blocks": "zip(a, b, c)",
   "body+mined:-Inline": "[[(0, 0), (1, 1), (2, 2), (3, 3), (4, 5, 6, 7]])"
  },
  "snippet": "np.array([zip(x, y) for x, y in zip(a, b)])"
 },
 "17960441.161": {
  "intent": "zip two 2-d arrays `a` and `b`",
  "body": "For example I have 2 arrays\na = array([[0, 1, 2, 3],\n           [4, 5, 6, 7]])\nb = array([[0, 1, 2, 3],\n           [4, 5, 6, 7]])\n\nHow can I zip\na  and b  so I get\nc = array([[(0,0), (1,1), (2,2), (3,3)],\n           [(4,4), (5,5), (6,6), (7,7)]])\n\n?\n",
  "preds": {
   "base:Baseline": "zip(a, b, c)",
   "body:Baseline": "zip(a, b, c)",
   "body:-Blocks": "zip([a, b]) for a, b in zip(A, B)]",
   "body:-Code": "zip([a, b]) for a, b in zip(A, B)]",
   "body:-Inline": "zip(a, b, c)",
   "body:-NL": "zip(a, b, c)",
   "base:+Mined": "zip(a, b, c)",
   "body+mined:Baseline": "zip(zip(a, b), reverse=True)",
   "body+mined:-Code": "zip(a, b, axis=1)",
   "body+mined:-NL": "zip([0, 0), (1, 1), (2, 2), (3, 3)],",
   "body+mined:-Blocks": "zip(a, b, c)",
   "body+mined:-Inline": "zip(a, b, c)"
  },
  "snippet": "np.array(zip(a.ravel(), b.ravel()), dtype='i4,i4').reshape(a.shape)"
 },
 "438684.162": {
  "intent": "convert list `list_of_ints` into a comma separated string",
  "body": "I'm new to python, and have a list of longs which I want to join together into a comma separated string.\nIn PHP I'd do something like this:\n$output = implode(\",\", $array)\n\nIn Python, I'm not sure how to do this. I've tried using join, but this doesn't work since the elements are the wrong type (i.e., not strings). Do I need to create a copy of the list and convert each element in the copy from a long into a string? Or is there a simpler way to do it?\n",
  "preds": {
   "base:Baseline": "\"\"\"\"\"\".join(map(list_of_ints))",
   "body:Baseline": "\"\"\"\"\"\".join(list_of_ints)",
   "body:-Blocks": "\"\"\".join(list_of_ints)",
   "body:-Code": "\"\"\"\"\"\".join(list_of_ints)",
   "body:-Inline": "\"\"\"\"\"\".join(list_of_ints)",
   "body:-NL": "print(list_of_ints.split())",
   "base:+Mined": "\"\"\" \"\"\".join(map(str, list_of_ints))",
   "body+mined:Baseline": "\"\"\"\"\"\".join(list_of_ints)",
   "body+mined:-Code": "\"\"\"\"\"\".join(list_of_ints)",
   "body+mined:-NL": "\"\"\" \"\"\".join(map(str, list_of_ints))",
   "body+mined:-Blocks": "\"\"\"\"\"\".join(map(str, list_of_ints))",
   "body+mined:-Inline": "\"\"\"\"\"\".join(map(str, list_of_ints))"
  },
  "snippet": "\"\"\",\"\"\".join([str(i) for i in list_of_ints])"
 },
 "8519922.163": {
  "intent": "send a post request with raw data `data` and basic authentication with `username` and `password`",
  "body": "I'm playing around with the Google Checkout API and I want to pull it into a Django app. I need to post data to Google using basic http authentication. I've been testing this with curl  like this:\ncurl -d \"$(cat mytest.xml)\" -u username:password https://url\n\nAnd that posts the content of my test XML file to Google. And it works fine!\nBut I'm having problems porting that simple line to Python. I've managed several different ways (httplib2, urllib2, pycurl) of connecting with a password and posting something but the respose is always 400 BAD REQUEST.\nIs there a python equivalent for posting block of text to a HTTP Basic auth server? I'm running out of walls to bang my head against.\n\nApologies for not adding any code. Here are some of my greatest hits. In each, DATA  is an XML string. URL , USERNAME  and PASSWORD  are constant.\nreq = urllib2.Request(URL)\nreq.add_header(\"Authorization\", \"Basic %s\" % base64.encodestring('%s:%s'%(USERNAME, PASSWORD)))\nu = urllib2.urlopen(req, DATA)\n\nGives me a lovely HTTP Error 400: Bad Request\n\npassman = urllib2.HTTPPasswordMgrWithDefaultRealm()\npassman.add_password(None, URL, USERNAME, PASSWORD)\nauthhandler = urllib2.HTTPBasicAuthHandler(passman)\nopener = urllib2.build_opener(authhandler)\nurllib2.install_opener(opener)\npagehandle = urllib2.urlopen(URL, DATA)\n\nGives HTTP Error 401: Unauthorized\n\npycurl.global_init(pycurl.GLOBAL_DEFAULT)\nc = pycurl.Curl()\nc.setopt(pycurl.URL, URL)\nc.setopt(pycurl.USERPWD, \"%s:%s\" % (USERNAME,PASSWORD))\nc.setopt(pycurl.POST, 1)\nc.setopt(pycurl.HTTPHEADER, [\"Content-type: text/xml\"])\nc.setopt(pycurl.POSTFIELDS, DATA)\nb = StringIO.StringIO()\nc.setopt(pycurl.WRITEFUNCTION, b.write)\nc.perform()\n\nSeems to struggle with passing the DATA  string as a POSTFIELD. I've tried urllib.urlencode() ing DATA in several different ways but \n\nh = httplib2.Http()\nh.add_credentials(USERNAME, PASSWORD)\nprint = h.request(URL, \"POST\", body=base64.encodestring(DATA))\n\nThe credentials don't seem to do anything - I get an unauthorised message back from Google.\nThere are more but they're all based on these.\n",
  "preds": {
   "base:Baseline": "r = requests.post(data, verify=False)",
   "body:Baseline": "urllib2.request.urlopen(URL, DATA)",
   "body:-Blocks": "r = requests.post(data, auth={'username': 'password'})",
   "body:-Code": "requests.get('data', headers={'username': 'password'})",
   "body:-Inline": "urllib2.request.urlopen(URL, DATA)",
   "body:-NL": "urllib2.request(URL, 'POST', body=base64.encodestring(DATA))",
   "base:+Mined": "r = requests.post(url, data=data, password=password)",
   "body+mined:Baseline": "r = requests.post(url, data=data)",
   "body+mined:-Code": "r = requests.post(url, headers={'username': 'password'})",
   "body+mined:-NL": "r = requests.post(url, data=data)",
   "body+mined:-Blocks": "urllib.request.urlencode('HTTP/1.0 200 OK')",
   "body+mined:-Inline": "requests.get('http://google.com', auth=('username', 'password'))"
  },
  "snippet": "requests.post(url, data=DATA, headers=HEADERS_DICT, auth=(username, password))"
 },
 "26443308.164": {
  "intent": "find last occurrence of character '}' in string \"abcd}def}\"",
  "body": "How would I find the last occurrence of a character in a string?\nstring = \"abcd}def}\"\nstring = string.find('}',last) # Want something like this\n\n",
  "preds": {
   "base:Baseline": "re.findall('{}', 'abcd}def}\"",
   "body:Baseline": "string = string.find('}', last)",
   "body:-Blocks": "\"\"\"abcd}def\"\"\".last()",
   "body:-Code": "'}'.last(abcd}def}\"",
   "body:-Inline": "string = string.find('}', last)",
   "body:-NL": "string = string.find('}', last)",
   "base:+Mined": "\"\"\"abcd}def\"\"\".rstrip('}')",
   "body+mined:Baseline": "string = string.find('{}', 1)",
   "body+mined:-Code": "\"\"\"abcd}def\"\"\".index('}')",
   "body+mined:-NL": "string = string.find('}', last)",
   "body+mined:-Blocks": "len('{}'.format('abcd}def}\"))",
   "body+mined:-Inline": "'}' + 'abcd}def'"
  },
  "snippet": "\"\"\"abcd}def}\"\"\".rfind('}')"
 },
 "22365172.165": {
  "intent": "iterate ove list `[1, 2, 3]` using list comprehension",
  "body": "I am experiencing a bit of confusion with how to place a for loop at the end of a line in python, for instance \nfor i in x:\n    print i\n\nproduces the expected result but if I run\nprint i for i in x\n\nI get a syntax error. Could someone explain a little more about how one goes about putting your for loops at the end of a line like this. \n",
  "preds": {
   "base:Baseline": "for i in [1, 2, 3])",
   "body:Baseline": "for i in [1, 2, 3]",
   "body:-Blocks": "for i in [1, 2, 3])",
   "body:-Code": "for line in [1, 2, 3])",
   "body:-Inline": "for i in [1, 2, 3])",
   "body:-NL": "for i in [1, 2, 3])",
   "base:+Mined": "[i for i in range(0, len(i), [1, 2, 3])]",
   "body+mined:Baseline": "for i in [1, 2, 3]]",
   "body+mined:-Code": "for (i in range(1, 2, 3) if i % 2 == 0)",
   "body+mined:-NL": "for i in x:\n    pass",
   "body+mined:-Blocks": "[i for i in [1, 2, 3]]",
   "body+mined:-Inline": "print(list(range(1, 2, 3))"
  },
  "snippet": "print([item for item in [1, 2, 3]])"
 },
 "12300912.166": {
  "intent": "extract all the values with keys 'x' and 'y' from a list of dictionaries `d` to list of tuples",
  "body": "I have a list of dictionaries like this:\n data = [{'x': 1, 'y': 10},\n         {'x': 3, 'y': 15},\n         {'x': 2, 'y': 1},\n          ]\n\nI have a function (for example matplotlib.axis.plot ) which needs lists of x  and y  values. So I have to \"transpose\" the dictionary\".\nFirst question: what do you call this operation? Is \"transpose\" the correct term?\nI've tried this, but I'm searching for an efficient way (maybe there are some special numpy  function):\nx = range(100)\ny = reversed(range(100))\nd = [dict((('x',xx), ('y', yy))) for (xx, yy) in zip(x,y)]\n# d is [{'y': 99, 'x': 0}, {'y': 98, 'x': 1}, ]\n\ntimeit.Timer(\"[dd['x'] for dd in d]\", \"from __main__ import d\").timeit()\n# 6.803985118865967\n\nfrom operator import itemgetter\ntimeit.Timer(\"map(itemgetter('x'), d)\", \"from __main__ import d, itemgetter\").timeit()\n# 7.322326898574829\n\ntimeit.Timer(\"map(f, d)\", \"from __main__ import d, itemgetter; f=itemgetter('x')\").timeit()\n# 7.098556041717529\n\n# quite dangerous\ntimeit.Timer(\"[dd.values()[1] for dd in d]\", \"from __main__ import d\").timeit()\n# 19.358459949493408\n\nIs there a better solution? My doubt is: in these cases the hash of the string 'x' is recomputed every time?\n",
  "preds": {
   "base:Baseline": "[(k, v) for k, v in d.items() if 'x' in k]",
   "body:Baseline": "timeit.Timer(\"[d.values()[1] for dd in d]', 'from __main__ import d\").timeit()",
   "body:-Blocks": "[d['x'] for d in d.items()]",
   "body:-Code": "[d['x'] for d in zip(d.items()], d['y'])]",
   "body:-Inline": "[d['x'] for d in zip(x, y)]",
   "body:-NL": "[d['x'], d['y'] for d in zip(x, y])",
   "base:+Mined": "[(d['x'], d['y'] for d in d]",
   "body+mined:Baseline": "[dict((x, y) for x, y in zip(zip(x, Y))) for y in data]",
   "body+mined:-Code": "[(v, k) for k, v in d.items()]",
   "body+mined:-NL": "[d['x'] for d in zip(x, y)]",
   "body+mined:-Blocks": "[{k: v for k, v in d.items() if v.isdigit()} for d in d]",
   "body+mined:-Inline": "[(x, y) for x, y in zip(d, data)]"
  },
  "snippet": "[(x['x'], x['y']) for x in d]"
 },
 "678236.167": {
  "intent": "get the filename without the extension from file 'hemanth.txt'",
  "body": "How to get the filename without the extension from a path in Python?\nFor instance, if I had \"/path/to/some/file.txt\" , I would want \"file\" .\n",
  "preds": {
   "base:Baseline": "open('hemanth.txt', filename)",
   "body:Baseline": "open('hemanth.txt', filename)",
   "body:-Blocks": "os.path.isfile('hemanth.txt')",
   "body:-Code": "os.path.isfile('hemanth.txt')",
   "body:-Inline": "os.path.splitext('hemanth.txt')",
   "body:-NL": "open('hemanth.txt', filename)",
   "base:+Mined": "os.path.splitext('hemanth.txt')",
   "body+mined:Baseline": "os.path.splitext('hemanth.txt')",
   "body+mined:-Code": "os.path.splitext('hemanth.txt')",
   "body+mined:-NL": "os.path.expanduser('hemanth.txt')",
   "body+mined:-Blocks": "os.path.splitext('hemanth.txt')",
   "body+mined:-Inline": "os.path.splitext('hemanth.txt', filename)"
  },
  "snippet": "print(os.path.splitext(os.path.basename('hemanth.txt'))[0])"
 },
 "2597166.168": {
  "intent": "create a dictionary by adding each two adjacent elements in tuple `x` as key/value pair to it",
  "body": "I need to transform a list into dictionary as follows.\nThe odd elements has the key, and even number elements has the value.\nx = (1,'a',2,'b',3,'c')  -> {1: 'a', 2: 'b', 3: 'c'}\ndef set(self, val_): \n    i = 0 \n    for val in val_: \n        if i == 0: \n            i = 1 \n            key = val \n        else: \n            i = 0 \n            self.dict[key] = val \n\nA better way to get the same results?\nADDED\ni = iter(k)\nprint dict(zip(i,i))\n\nseems to be working\n",
  "preds": {
   "base:Baseline": "dict((k, v) for k, v in x.items())",
   "body:Baseline": "dict(zip(i, i))",
   "body:-Blocks": "dict(zip(x, y))",
   "body:-Code": "dict((k, v) for k, v in x.items())",
   "body:-Inline": "dict(zip(x, key)",
   "body:-NL": "dict((k, v) for k, v in x.items() if v == 0)",
   "base:+Mined": "dict(x + y for x, y in zip(x, y))",
   "body+mined:Baseline": "dict(zip(i, j) for i, j in zip(x, j))",
   "body+mined:-Code": "dict(zip(x, y))",
   "body+mined:-NL": "dict((k, v) for k, v in x.items() if v == 0)",
   "body+mined:-Blocks": "dict(zip(x, y))",
   "body+mined:-Inline": "dict(zip(i, j) for i, j in zip(x, i))"
  },
  "snippet": "dict(x[i:i + 2] for i in range(0, len(x), 2))"
 },
 "7895449.169": {
  "intent": "create a list containing flattened list `[['a', 'b', 'c'], ['d', 'e', 'f'], ['g', 'h', 'i']]`",
  "body": "How do I merge a list of lists?\n[['A', 'B', 'C'], ['D', 'E', 'F'], ['G', 'H', 'I']]\n\ninto\n['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I']\n\nEven better if I can add a value on the beginning and end of each item before merging the lists, like html tags.\ni.e., the end result would be:\n[' <tr>A </tr>', ' <tr>B </tr>', ' <tr>C </tr>', ' <tr>D </tr>', ' <tr>E </tr>', ' <tr>F </tr>', ' <tr>G </tr>', ' <tr>H </tr>', ' <tr>I </tr>']\n\n",
  "preds": {
   "base:Baseline": "[['a', 'b', 'c', ['d', 'e', 'f'], ['g', 'h', 'i']]]",
   "body:Baseline": "[['A', 'B', 'C', 'D', 'E', 'F'], ['G', 'H', 'I']]]",
   "body:-Blocks": "[['a', 'b', 'c', ['d', 'e', 'f'], ['g', 'h', 'i']]]",
   "body:-Code": "[['a', 'b', 'c', ['d', 'e', 'f'], ['g', 'h', 'i']]]",
   "body:-Inline": "[['A', 'B', 'C'], ['D', 'E', 'F'], ('G', 'H', 'I']]",
   "body:-NL": "[['A', 'B', 'C', 'D', 'E', 'F'], ['G', 'H', 'I']]",
   "base:+Mined": "[['a', 'b', 'c', ['d', 'e', 'f'], ['g', 'h', 'i']]",
   "body+mined:Baseline": "[['A', 'B', 'C'], ['D', 'E', 'F', 'G', 'H', 'I']]",
   "body+mined:-Code": "[['a', 'b', 'c', 'd', 'e', 'f'], ['g', 'h', 'i']]",
   "body+mined:-NL": "[['A', 'B', 'C'], ['D', 'E', 'F'], 'G', 'H', 'I']]",
   "body+mined:-Blocks": "[['a', 'b', 'c', 'd', 'e', 'f'], ['g', 'h', 'i']]",
   "body+mined:-Inline": "[['A', 'B', 'C'], ['D', 'E', 'F', 'G', 'H', 'I']]"
  },
  "snippet": "values = sum([['A', 'B', 'C'], ['D', 'E', 'F'], ['G', 'H', 'I']], [])"
 },
 "31617845.170": {
  "intent": "select rows in a dataframe `df` column 'closing_price' between two values 99 and 101",
  "body": "I am trying to modify a DataFrame df  to only contain rows for which the values in the column closing_price  are between 99 and 101 and trying to do this with the code below. \nHowever, I get the error \n\nValueError: The truth value of a Series is ambiguous. Use a.empty, a.bool(), a.item(), a.any() or a.all()\n\nand I am wondering if there is a way to do this without using loops.\ndf = df[(99 <= df['closing_price'] <= 101)]\n\n",
  "preds": {
   "base:Baseline": "df.loc[df['closing_price'] == 100]",
   "body:Baseline": "df[99 <= df['closing_price'] <= 101]",
   "body:-Blocks": "df.loc[df['closing_price'] == 99]",
   "body:-Code": "df.loc[df['closing_price'] == 99]",
   "body:-Inline": "df.loc[df['closing_price'] <= 99]",
   "body:-NL": "df.loc[df['closing_price'] <= 99]",
   "base:+Mined": "df.loc[df['closing_price'] > 99]",
   "body+mined:Baseline": "df[df['closing_price'] > 99]",
   "body+mined:-Code": "df.loc[df['closing_price'] > 99 and 101]",
   "body+mined:-NL": "df[df['closing_price'] > 99]",
   "body+mined:-Blocks": "df.loc[df['closing_price'] > 99]",
   "body+mined:-Inline": "df[(99 <= df['closing_price'] <= 101)"
  },
  "snippet": "df = df[(df['closing_price'] >= 99) & (df['closing_price'] <= 101)]"
 },
 "25698710.171": {
  "intent": "replace all occurences of newlines `\\n` with `<br>` in dataframe `df`",
  "body": "I have a pandas dataframe with about 20 columns.\nIt is possible to replace all occurrences of a string (here a newline) by manually writing all column names:\ndf['columnname1'] = df['columnname1'].str.replace(\"\\n\",\" <br>\")\ndf['columnname2'] = df['columnname2'].str.replace(\"\\n\",\" <br>\")\ndf['columnname3'] = df['columnname3'].str.replace(\"\\n\",\" <br>\")\n<console_out>\ndf['columnname20'] = df['columnname20'].str.replace(\"\\n\",\" <br>\")\n\nThis unfortunately does not work:\ndf = df.replace(\"\\n\",\" <br>\")\n\nIs there any other, more elegant solution?\n",
  "preds": {
   "base:Baseline": "df.replace('\\n', '<br>')",
   "body:Baseline": "df['columnname1'].replace('\\n', '<br>')",
   "body:-Blocks": "df.replace('\\n', '<br>')",
   "body:-Code": "df.replace('\\n', '<br>')",
   "body:-Inline": "df.replace('\\n', '<br>')",
   "body:-NL": "df.replace('\\n', '<br>')",
   "base:+Mined": "df.replace('\\n', '<br>')",
   "body+mined:Baseline": "df['columnname1'].str.replace('\\\\n', '<br>')",
   "body+mined:-Code": "df.replace('\\n', '<br>')",
   "body+mined:-NL": "df['columnname1'].str.replace('\\n', '<br>')",
   "body+mined:-Blocks": "df.replace('\\n', '<br>')",
   "body+mined:-Inline": "df['columnname1'].str.replace('\\n', '<br>')"
  },
  "snippet": "df.replace({'\\n': '<br>'}, regex=True)"
 },
 "25698710.172": {
  "intent": "replace all occurrences of a string `\\n` by string `<br>` in a pandas data frame `df`",
  "body": "I have a pandas dataframe with about 20 columns.\nIt is possible to replace all occurrences of a string (here a newline) by manually writing all column names:\ndf['columnname1'] = df['columnname1'].str.replace(\"\\n\",\" <br>\")\ndf['columnname2'] = df['columnname2'].str.replace(\"\\n\",\" <br>\")\ndf['columnname3'] = df['columnname3'].str.replace(\"\\n\",\" <br>\")\n<console_out>\ndf['columnname20'] = df['columnname20'].str.replace(\"\\n\",\" <br>\")\n\nThis unfortunately does not work:\ndf = df.replace(\"\\n\",\" <br>\")\n\nIs there any other, more elegant solution?\n",
  "preds": {
   "base:Baseline": "df.replace('\\n', '<br>')",
   "body:Baseline": "df['columnname1'].str.replace('\\n', '<br>')",
   "body:-Blocks": "df.replace('\\n', '<br>')",
   "body:-Code": "df.replace('\\n', '<br>')",
   "body:-Inline": "df['columnname1'].str.replace('\\n', '<br>')",
   "body:-NL": "df.replace('\\n', '<br>')",
   "base:+Mined": "df.replace('\\n', '<br>', '\\n')",
   "body+mined:Baseline": "df['columnname1'].str.replace('\\\\n', '<br>')",
   "body+mined:-Code": "df.replace('\\n', '<br>')",
   "body+mined:-NL": "df['columnname1'].str.replace('\\\\n', '<br>')",
   "body+mined:-Blocks": "df['col'] = df['col'].replace('\\n', '<br>')",
   "body+mined:-Inline": "df['columnname1'].str.replace('\\\\n', '<br>')"
  },
  "snippet": "df.replace({'\\n': '<br>'}, regex=True)"
 },
 "41923858.173": {
  "intent": "create a list containing each two adjacent letters in string `word` as its elements",
  "body": "I have a for loop that iterates through a string and returns pairs of each character and the next following one:\nword = 'abcdef'\nfor i in range(len(word)-1):\n    print word[i:i+2]\n<console_out>\nab\nbc\ncd\nde\nef\n\nIs it possible to write this using a map/filter combination instead? I'm having a problem figuring out how to get the next character instead of using i+2 .\nI've tried to pass the word twice to map them together like this:\nword = 'abcdef'\nmap(lambda x, y: x+y, word, word[1:])\n\nBut I'm unsure how to avoid the concatenation error with a str and None:\nmap(lambda x, y: x+y, word, word[1:])\nTraceback (most recent call last):\n  File \" <stdin>\", line 1, in <module>\n  File \" <stdin>\", line 1, in <lambda>\nTypeError: cannot concatenate 'str' and 'NoneType' objects\n\n",
  "preds": {
   "base:Baseline": "[word[i:i + 2] for i in range(2)]",
   "body:Baseline": "map(lambda x, y: x + y, word, word[1:])",
   "body:-Blocks": "list(word.replace(',', ''))",
   "body:-Code": "list(word.split(',')",
   "body:-Inline": "word[i:i + 2]",
   "body:-NL": "[(x + y) for x, y in word]",
   "base:+Mined": "[i.split(' ', 1)[0] for i in word.split()]",
   "body+mined:Baseline": "map(lambda x, y: x + y, word, word[1:])",
   "body+mined:-Code": "[word[i:i + 1] for i in range(len(word), 1)]",
   "body+mined:-NL": "map(lambda x, y: x + y, word, word[1:])",
   "body+mined:-Blocks": "[word[i:i + 2] for i in range(0, len(word), 2)]",
   "body+mined:-Inline": "[(x + y) for x, y in zip(word, word[1:])]"
  },
  "snippet": "[(x + y) for x, y in zip(word, word[1:])]"
 },
 "41923858.174": {
  "intent": "get a list of pairs from a string `word` using lambda function",
  "body": "I have a for loop that iterates through a string and returns pairs of each character and the next following one:\nword = 'abcdef'\nfor i in range(len(word)-1):\n    print word[i:i+2]\n<console_out>\nab\nbc\ncd\nde\nef\n\nIs it possible to write this using a map/filter combination instead? I'm having a problem figuring out how to get the next character instead of using i+2 .\nI've tried to pass the word twice to map them together like this:\nword = 'abcdef'\nmap(lambda x, y: x+y, word, word[1:])\n\nBut I'm unsure how to avoid the concatenation error with a str and None:\nmap(lambda x, y: x+y, word, word[1:])\nTraceback (most recent call last):\n  File \" <stdin>\", line 1, in <module>\n  File \" <stdin>\", line 1, in <lambda>\nTypeError: cannot concatenate 'str' and 'NoneType' objects\n\n",
  "preds": {
   "base:Baseline": "[k for k, v in word.items()]",
   "body:Baseline": "map(lambda x, y: x + y, word, word[1:])",
   "body:-Blocks": "[k for k, v in word.split(',')]",
   "body:-Code": "[k for k, v in word.split()]",
   "body:-Inline": "print(word[i:i + 2])",
   "body:-NL": "print(list(word.items()), key=lambda x: x[1])",
   "base:+Mined": "[(k, v) for k, v in word.items()]",
   "body+mined:Baseline": "map(lambda x, y: x + y, word, word[1:])",
   "body+mined:-Code": "[(x, y) for x, y in word.split(',')]",
   "body+mined:-NL": "map(lambda x, y: x + y, word, word[1:])",
   "body+mined:-Blocks": "[(k, v) for k, v in word.split(',')]",
   "body+mined:-Inline": "[(x + y) for x, y in zip(word, word[1:])]"
  },
  "snippet": "list(map(lambda x, y: x + y, word[:-1], word[1:]))"
 },
 "9760588.175": {
  "intent": "extract a url from a string `mystring`",
  "body": "For example: \nstring = \"This is a link http://www.google.com\"\n\nHow could I extract 'http://www.google.com' ? \n(Each link will be of the same format i.e 'http://')\n",
  "preds": {
   "base:Baseline": "urllib.parse.quote(myString)",
   "body:Baseline": "re.findall('http://www.google.com', mystring)",
   "body:-Blocks": "myString.rfind('http://www.google.com')",
   "body:-Code": "myString.rfind('http://www.google.com')",
   "body:-Inline": "myString.rfindall('http://www.google.com')",
   "body:-NL": "\"\"\"This is a link http://www.google.com\"\".join(mystring)",
   "base:+Mined": "urllib.parse.urlencode('utf-8')",
   "body+mined:Baseline": "urllib.parse.urlretrieve('http://www.google.com', myString)",
   "body+mined:-Code": "urllib.request.urlretrieve('http://www.google.com')",
   "body+mined:-NL": "urllib.request.urlretrieve('http://www.google.com', myString)",
   "body+mined:-Blocks": "urllib.parse.quote('http://www.google.com')",
   "body+mined:-Inline": "urllib.request.urlretrieve('http://www.google.com', myString)"
  },
  "snippet": "print(re.findall('(https?://[^\\\\s]+)', myString))"
 },
 "9760588.176": {
  "intent": "extract a url from a string `mystring`",
  "body": "For example: \nstring = \"This is a link http://www.google.com\"\n\nHow could I extract 'http://www.google.com' ? \n(Each link will be of the same format i.e 'http://')\n",
  "preds": {
   "base:Baseline": "urllib.parse.quote(myString)",
   "body:Baseline": "re.findall('http://www.google.com', mystring)",
   "body:-Blocks": "myString.rfind('http://www.google.com')",
   "body:-Code": "myString.rfind('http://www.google.com')",
   "body:-Inline": "myString.rfindall('http://www.google.com')",
   "body:-NL": "\"\"\"This is a link http://www.google.com\"\".join(mystring)",
   "base:+Mined": "urllib.parse.urlencode('utf-8')",
   "body+mined:Baseline": "urllib.parse.urlretrieve('http://www.google.com', myString)",
   "body+mined:-Code": "urllib.request.urlretrieve('http://www.google.com')",
   "body+mined:-NL": "urllib.request.urlretrieve('http://www.google.com', myString)",
   "body+mined:-Blocks": "urllib.parse.quote('http://www.google.com')",
   "body+mined:-Inline": "urllib.request.urlretrieve('http://www.google.com', myString)"
  },
  "snippet": "print(re.search('(?P<url>https?://[^\\\\s]+)', myString).group('url'))"
 },
 "5843518.177": {
  "intent": "remove all special characters, punctuation and spaces from a string `mystring` using regex",
  "body": "I need to remove all special characters, punctuation and spaces from a string so that I only have letters and numbers.\n",
  "preds": {
   "base:Baseline": "re.sub('[^a-zA-Z]', myString)",
   "body:Baseline": "re.sub('\\\\w+|\\\\W+||\\\\w+)', mystring)",
   "body:-Blocks": "re.sub('\\\\w+', mystring)",
   "body:-Code": "re.sub('\\\\w+', myString)",
   "body:-Inline": "re.sub('[^a-z]', mystring)",
   "body:-NL": "re.sub('\\\\s+', mystring)",
   "base:+Mined": "re.sub('[^a-zA-Z]', '', mystring)",
   "body+mined:Baseline": "re.sub('\\\\s+', '', mystring)",
   "body+mined:-Code": "re.sub('[a-zA-Z]', '', mystring)",
   "body+mined:-NL": "re.sub('[^a-zA-Z]', '', mystring)",
   "body+mined:-Blocks": "re.sub('[^a-zA-Z]', '', mystring)",
   "body+mined:-Inline": "re.sub('(\\\\w+)', '', myString)"
  },
  "snippet": "re.sub('[^A-Za-z0-9]+', '', mystring)"
 },
 "36674519.178": {
  "intent": "create a datetimeindex containing 13 periods of the second friday of each month starting from date '2016-01-01'",
  "body": "I need to get the 2nd Friday of each month in Python.\nI have written the function below that demonstrates what I need. However, I am wondering if there is a more elegant way to do it using Pandas' date_range  function and appropriate offsets.\ndef second_friday_of_month_date_range( start, end ):\n    dr = pd.date_range( start, end, freq='MS' )\n\n    first_weekday_of_month_to_2nd_friday_of_month = np.array( [ 12, 11, 10, 9, 8, 14, 13 ], dtype=int )\n    wd                                            = first_weekday_of_month_to_2nd_friday_of_month[ dr.weekday ]\n    offsets                                       = [ datetime.timedelta( days=int(x)-1 ) for x in wd ]\n    dts                                           = [d+o for d, o in zip( dr, offsets)]\n    return pd.DatetimeIndex( dts )\n\nimport pandas as pd\nimport datetime\nd0 = datetime.datetime(2016,1,1)\nd1 = datetime.datetime(2017,1,1)\ndr = second_friday_of_month_date_range( d0, d1 )\nprint( dr )\n\n>> DatetimeIndex(['2016-01-08', '2016-02-12', '2016-03-11', '2016-04-08',\n               '2016-05-13', '2016-06-10', '2016-07-08', '2016-08-12',\n               '2016-09-09', '2016-10-14', '2016-11-11', '2016-12-09',\n               '2017-01-13'],\n              dtype='datetime64[ns]', freq=None, tz=None)\n\n",
  "preds": {
   "base:Baseline": "datetimeindex.date_range('2016-01-01', 13)",
   "body:Baseline": "datetime.datetime_index(['2016-01-01', '%B-%Y-%M-%H'])",
   "body:-Blocks": "pd.datetimeindex(datetime.date_range='2016-01-01', datetime.timedelta=13)",
   "body:-Code": "pd.datetimeindex(datetime.strptime('2016-01-01', '%Y-%m-%d'))",
   "body:-Inline": "pd.date_index(['2016-01-01', '%Y-%m-%d'])",
   "body:-NL": "pd.datetimeindex(['2016-01-01', '%B-%d-%Y').date_range(13))",
   "base:+Mined": "datetimeindex.date_range(12, '%Y-%m-%d')",
   "body+mined:Baseline": "pd.to_datetime(pd.Timedelta(1970, 1, 1))",
   "body+mined:-Code": "pd.to_datetime(pd.Timestamp('2016-01-01', '%Y-%m-%d').date()",
   "body+mined:-NL": "pd.to_datetime(pd.Timedelta(days=int(x) for x in wd, dts)",
   "body+mined:-Blocks": "df.date_range('2016-01-01', '%Y-%m-%d').date()",
   "body+mined:-Inline": "datetime.datetime(2016, 1, 1) + datetime.timedelta(days=int(x) - 1)"
  },
  "snippet": "pd.date_range('2016-01-01', freq='WOM-2FRI', periods=13)"
 },
 "508657.179": {
  "intent": "create multidimensional array `matrix` with 3 rows and 2 columns in python",
  "body": "I have a little Java problem I want to translate to Python. Therefor I need a multidimensional array. In Java it looks like:\ndouble dArray[][][] = new double[x.length()+1][y.length()+1][x.length()+y.length()+3];\ndArray[0][0][0] = 0;\ndArray[0][0][1] = POSITIVE_INFINITY;\n\nFurther values will be created bei loops and written into the array.\nHow do I instantiate the array?\nPS: There is no matrix multiplication involved...\n",
  "preds": {
   "base:Baseline": "matrix.shape(3, 2)",
   "body:Baseline": "matrix[i:i + j[i] for i in range(3)]",
   "body:-Blocks": "matrix.reshape(3, 2)",
   "body:-Code": "matrix = np.array([3, 2], axis=1)",
   "body:-Inline": "matrix[0][0][1] = np.Matrix(3, columns)",
   "body:-NL": "matrix[3][2] = np.array([x.length() + 2], axis=0)",
   "base:+Mined": "matrix = [[1, 2], [3, 4], [5, 6], [7, 8]]",
   "body+mined:Baseline": "matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]",
   "body+mined:-Code": "matrix = [[(1, 2), (3, 4), (5, 6), (7, 8), (9, 10)]",
   "body+mined:-NL": "matrix = [[1, 2, 3], [4, 5, 6]]",
   "body+mined:-Blocks": "matrix = [[1, 2], [3, 4], [5, 6]]",
   "body+mined:-Inline": "matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]"
  },
  "snippet": "matrix = [[a, b], [c, d], [e, f]]"
 },
 "1007481.180": {
  "intent": "replace spaces with underscore",
  "body": "I want to replace whitespace with underscore in a string to create nice URLs. So that for example:\n\"This should be connected\" becomes \"This_should_be_connected\" \n\nI am using Python with Django. Can this be solved using regular expressions?  \n",
  "preds": {
   "base:Baseline": "re.sub('[^a-zA-Z]', '\\\\1', '', re.sub')",
   "body:Baseline": "re.sub('(?=\\\\w+)\\\\W+)', 'This_should_be_connected')",
   "body:-Blocks": "re.sub('[^a-zA-Z]', '', ''.strip())",
   "body:-Code": "re.sub('\\\\w+', '', '')",
   "body:-Inline": "re.sub('[^a-z]', '', 'This_should_be_connected')",
   "body:-NL": "re.sub('(This_should_be_connected)', 'This_ SHOULD_BE_connected')",
   "base:+Mined": "re.sub('(?<=.)(?=.)', '\\\\1', s)",
   "body+mined:Baseline": "\"\"\"This_should_be_connected\"\"\".replace(' ', '')",
   "body+mined:-Code": "re.sub('(?<=.)(?=.)', '', 'hello world!')",
   "body+mined:-NL": "re.sub('(\\\\w+)', '\\\\1', 'This_should_be_connected')",
   "body+mined:-Blocks": "re.sub('[^a-zA-Z]*', '', s)",
   "body+mined:-Inline": "\"\"\"This_should_be_connected\"\"\".replace(',', '')"
  },
  "snippet": "mystring.replace(' ', '_')"
 },
 "51520.181": {
  "intent": "get an absolute file path of file 'mydir/myfile.txt'",
  "body": "Given a path such as \"mydir/myfile.txt\" , how do I find the file's absolute path relative to the current working directory in Python? E.g. on Windows, I might end up with:\n\"C:/example/cwd/mydir/myfile.txt\"\n\n",
  "preds": {
   "base:Baseline": "os.path.abspath('mydir/myfile.txt')",
   "body:Baseline": "os.path.abspath('C:/example/cwd/mydir/myfile.txt')",
   "body:-Blocks": "os.path.absolute_path('mydir/myfile.txt')",
   "body:-Code": "os.path.abspath('mydir/myfile.txt')",
   "body:-Inline": "os.path.realpath('C:/example/cwd/mydir/myfile.txt')",
   "body:-NL": "os.path.realpath('mydir/myfile.txt')",
   "base:+Mined": "os.path.abspath('mydir/myfile.txt')",
   "body+mined:Baseline": "os.path.abspath('mydir/myfile.txt')",
   "body+mined:-Code": "os.path.abspath('mydir/myfile.txt')",
   "body+mined:-NL": "os.path.abspath('mydir/myfile.txt')",
   "body+mined:-Blocks": "os.path.abspath('mydir/myfile.txt')",
   "body+mined:-Inline": "os.path.abspath('mydir/myfile.txt')"
  },
  "snippet": "os.path.abspath('mydir/myfile.txt')"
 },
 "1249786.182": {
  "intent": "split string `my_string` on white spaces",
  "body": "Is there a cross-platform library function that would collapse a multiline string into a single-line string with no repeating spaces?\nI've come up with some snip below, but I wonder if there is a standard function which I could just import which is perhaps even optimized in C?\ndef collapse(input):\n    import re\n    rn = re.compile(r'(\\r\\n)+')\n    r = re.compile(r'\\r+')\n    n = re.compile(r'\\n+')\n    s = re.compile(r'\\ +')\n    return s.sub(' ',n.sub(' ',r.sub(' ',rn.sub(' ',input))))\n\nP.S. Thanks for good observations. ' '.join(input.split())  seems to be the winner as it actually runs faster about twice in my case compared to search-replace with a precompiled r'\\s+'  regex.\n",
  "preds": {
   "base:Baseline": "my_string.split('\\n')",
   "body:Baseline": "re.compile('\\\\n+', my_string)",
   "body:-Blocks": "re.compile(' '.join(input.split())",
   "body:-Code": "re.sub('\\\\w+', my_string)",
   "body:-Inline": "re.compile('', my_string)",
   "body:-NL": "re.compile('\\\\n+', my_string)",
   "base:+Mined": "my_string.split('\\n')",
   "body+mined:Baseline": "re.compile('\\\\s+', my_string)",
   "body+mined:-Code": "my_string.split(' ', 1)",
   "body+mined:-NL": "re.sub('\\\\s+', my_string)",
   "body+mined:-Blocks": "re.sub('\\\\s+', '', my_string)",
   "body+mined:-Inline": "re.sub('\\\\s+', '', my_string)"
  },
  "snippet": "\"\"\" \"\"\".join(my_string.split())"
 },
 "4444923.183": {
  "intent": "get filename without extension from file `filename`",
  "body": "If I have a filename like one of these:\n1.1.1.1.1.jpg\n\n1.1.jpg\n\n1.jpg\n\nHow could I get only the filename, without the extension? Would a regex be appropriate?\n",
  "preds": {
   "base:Baseline": "os.path.isfile(filename)",
   "body:Baseline": "print(re.sub('(?=\\\\w+)', filename))",
   "body:-Blocks": "filename.rsplit(filename)",
   "body:-Code": "print(os.path.isfile(filename))",
   "body:-Inline": "filename.split()[:-1]",
   "body:-NL": "os.path.splitext(filename)",
   "base:+Mined": "print(os.path.join(filename))",
   "body+mined:Baseline": "print(re.compile('\\\\.join(filename) for filename in filename))",
   "body+mined:-Code": "filename = re.compile('(.*?\\\\w+)')",
   "body+mined:-NL": "os.path.expanduser('filename', filename)",
   "body+mined:-Blocks": "print(re.sub('[filename]', '', filename))",
   "body+mined:-Inline": "print(os.path.splitext(filename))"
  },
  "snippet": "os.path.splitext(filename)[0]"
 },
 "13728486.184": {
  "intent": "get a list containing the sum of each element `i` in list `l` plus the previous elements",
  "body": "I am trying to write a function which maps elements of a list to get sum of the element and the previous elements in the list in a functional style using python e.g. :     \nfunc([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) = [0, 1, 3, 6, 10, 15, 21, 28, 36, 45]\n\nI have tried using recursion, but get RuntimeError: maximum recursion depth exceeded  with a long list.:\ndef recursion_way(inlist, accu, summ):\n    if len(inlist) == 0:\n         return accu\n    else:\n        return recursion_way(inlist[1:], accu + [summ + inlist[0]], summ + inlist[0])\n\n",
  "preds": {
   "base:Baseline": "[sum(i) for i in L]",
   "body:Baseline": "sum(i, j) / j for i, j in l)",
   "body:-Blocks": "[sum(i) for i in L]",
   "body:-Code": "[sum(i) for i in L]",
   "body:-Inline": "[sum(i) for i, j in L]",
   "body:-NL": "[sum(i) for i, j in zip(L, L)]",
   "base:+Mined": "[sum(i) for i in L]",
   "body+mined:Baseline": "[sum(x) for x in L if x[0] == 0]",
   "body+mined:-Code": "[sum(i) for i in l]",
   "body+mined:-NL": "[sum(i) for i in zip(*L)]",
   "body+mined:-Blocks": "sum(i * j for i, j in zip(*l))",
   "body+mined:-Inline": "sum([x for x in L if len(x) == 0])"
  },
  "snippet": "[sum(l[:i]) for i, _ in enumerate(l)]"
 },
 "9743134.185": {
  "intent": "split a string `docs/src/scripts/temp` by `/` keeping `/` in the result",
  "body": "Easiest way to explain this is an example:\nI have this string: 'Docs/src/Scripts/temp'\nWhich I know how to split two different ways:\nre.split('/', 'Docs/src/Scripts/temp') -> ['Docs', 'src', 'Scripts', 'temp']\n\nre.split('(/)', 'Docs/src/Scripts/temp') -> ['Docs', '/', 'src', '/', 'Scripts', '/', 'temp']\n\nIs there a way to split by the forward slash, but keep the slash part of the words?\nFor example, I want the above string to look like this:\n['Docs/', '/src/', '/Scripts/', '/temp']\n\nAny help would be appreciated!\n",
  "preds": {
   "base:Baseline": "results = re.split('/', 'docs/src/scripts/temp')",
   "body:Baseline": "re.findall('/', 'Docs/src/Scripts/temp')",
   "body:-Blocks": "\"\"\"Docs/src/Scripts/Temp\"\"\".split('/')",
   "body:-Code": "\"\"\"Docs/src/scripts/temp\"\"\".split(',/')",
   "body:-Inline": "re.split('/', 'Docs/src/Scripts/temp')",
   "body:-NL": "re.split('/', 'Docs/src/Scripts/temp')",
   "base:+Mined": "result = split(docs/src/scripts/temp.split(',/))",
   "body+mined:Baseline": "re.split('/', 'Docs/src/Scripts/temp')",
   "body+mined:-Code": "re.split('Docs/src/scripts/temp', '/')",
   "body+mined:-NL": "re.split('/', 'Docs/src/scripts/temp')",
   "body+mined:-Blocks": "\"\"\"Docs/src/scripts/temp\"\"\".rsplit('/')",
   "body+mined:-Inline": "re.split('/', 'Docs/src/Scripts/temp')"
  },
  "snippet": "\"\"\"Docs/src/Scripts/temp\"\"\".replace('/', '/\\x00/').split('\\x00')"
 },
 "20546419.186": {
  "intent": "shuffle columns of an numpy array 'r'",
  "body": "Let's say I have an array r  of dimension (n, m) . I would like to shuffle the columns of that array.\nIf I use numpy.random.shuffle(r)  it shuffles the lines. How can I only shuffle the columns? So that the first column become the second one and the third the first, etc, randomly.\nExample:\ninput:\narray([[  1,  20, 100],\n       [  2,  31, 401],\n       [  8,  11, 108]])\n\noutput:\narray([[  20, 1, 100],\n       [  31, 2, 401],\n       [  11,  8, 108]])\n\n",
  "preds": {
   "base:Baseline": "np.shuffle(r, axis=0)",
   "body:Baseline": "np.random.shuffle(np.reshuff(r, n, m))",
   "body:-Blocks": "np.shuffle(r, axis=0)",
   "body:-Code": "np.shuffle(np.shape[0], axis=1)",
   "body:-Inline": "np.shuffle(r, axis=1, reverse=True)",
   "body:-NL": "np.shuffle(r, numpy.random.reshuffle(n, m))",
   "base:+Mined": "np.shuffle(x, y)",
   "body+mined:Baseline": "np.random.shuffle(r, axis=1)",
   "body+mined:-Code": "np.random.shuffle(r, 2)",
   "body+mined:-NL": "np.random.shuffle(r, axis=1)",
   "body+mined:-Blocks": "np.random.shuffle(r, 1, 1)",
   "body+mined:-Inline": "np.random.shuffle(r, 1)"
  },
  "snippet": "np.random.shuffle(np.transpose(r))"
 },
 "32675861.187": {
  "intent": "copy all values in a column 'b' to a new column 'd' in a pandas data frame 'df'",
  "body": "This is a very basic question, I just can not seem to find an answer.\nI have a dataframe like this, called df:\n  A     B     C\n a.1   b.1   c.1\n a.2   b.2   c.2\n a.3   b.3   c.3\n\nThen I extract all the rows from df, where column 'B' has a value of 'b.2'.  I assign these results to df_2.  \ndf_2 = df[df['B'] == 'b.2']\n\ndf_2 becomes:\n  A     B     C\n a.2   b.2   c.2\n\nThen, I copy all the values in column 'B' to a new column named 'D'. Causing df_2 to become: \n  A     B     C     D\n a.2   b.2   c.2   b.2\n\nWhen I preform an assignment like this:\ndf_2['D'] = df_2['B']\n\nI get the following warning:\n\nA value is trying to be set on a copy of a slice from a DataFrame. Try\n  using .loc[row_indexer,col_indexer] = value instead\nSee the the caveats in the documentation:\n  http://pandas.pydata.org/pandas-docs/stable/indexing.html#indexing-view-versus-copy\n\n\nI have also tried using .loc when creating df_2 like this:\ndf_2 = df.loc[df['B'] == 'b.2']\n\nHowever, I still get the warning. \nAny help is greatly appreciated.\n",
  "preds": {
   "base:Baseline": "df['b'] = df['d']",
   "body:Baseline": "df.loc[df['B'] == 'B.2']",
   "body:-Blocks": "df['B'] = df['D'].copy()",
   "body:-Code": "df.copy(df['B'], df['D'], axis=1)",
   "body:-Inline": "df.loc[df['B'] == 'b.2']",
   "body:-NL": "df['B'] = df['C']",
   "base:+Mined": "df['b'] = df['d']",
   "body+mined:Baseline": "df.loc[df['B'] == 'b.2']",
   "body+mined:-Code": "df['B'] = df['D'].loc[row_indexer == 'B'].astype(int)",
   "body+mined:-NL": "df.loc[df['B'] == 'b.2']",
   "body+mined:-Blocks": "df['B'] = df['D'].loc[row['B'].isin(col_index)]",
   "body+mined:-Inline": "df.loc[df['B'].isin(['B', 'C'])]"
  },
  "snippet": "df['D'] = df['B']"
 },
 "14227561.188": {
  "intent": "find a value within nested json 'data' where the key inside another key 'b' is unknown.",
  "body": "From the following json, in python, I'd like to extract the value \"TEXT\". All the keys are constant except for unknown. Unknown could be any string like \"a6784t66\" or \"hobvp*nfe\". The value of unknown is not known , only that it will be in that position in each json response.\n{\n  \"A\": {\n    \"B\": {\n      \"unknown\": {\n        \"1\": \"F\",\n        \"maindata\": [\n          {\n            \"Info\": \"TEXT\"\n          }\n        ]\n      }\n    }\n  }\n}\n\none line json\n'{\"A\":{\"B\":{\"unknown\":{\"1\":\"F\",\"maindata\":[{\"Info\":\"TEXT\"}]}}}}'\n\nHow would you get the value of \"Text\"? (I know how to load the json with json.loads)..but I'm not sure how to get the value of \"Text\". Thanks.\n(I'm not sure what the best title is.)\n",
  "preds": {
   "base:Baseline": "print([k for k, v in data.items() if 'b' not in k])",
   "body:Baseline": "json.loads(['A': 'B'], 'B': 'TEXT'))",
   "body:-Blocks": "json.loads('data', key=lambda x: x['b'] == 'TEXT')",
   "body:-Code": "json.loads('data', key=lambda x: x['b'])",
   "body:-Inline": "[k for k, v in data.items() if 'B' is unknown]",
   "body:-NL": "{{k for k, v in data.items() if 'B' is unknown}",
   "base:+Mined": "data['b'] = json.loads(data['a'])",
   "body+mined:Baseline": "{k: v for k, v in data.items() if k != 'TEXT'}",
   "body+mined:-Code": "print(data['a6784t66']['hobvp*nfe'])",
   "body+mined:-NL": "{k: v for k, v in data.items() if 'A' in k}",
   "body+mined:-Blocks": "print(data['b']['c'])",
   "body+mined:-Inline": "{k: v for k, v in list(data.items()) if 'ab' in k}"
  },
  "snippet": "list(data['A']['B'].values())[0]['maindata'][0]['Info']"
 },
 "14858916.189": {
  "intent": "check characters of string `string` are true predication of function `predicate`",
  "body": "In Python 3, what's the shortest way to check whether a predicate is true for all characters of a string?\n",
  "preds": {
   "base:Baseline": "print('predicate'.join(string))",
   "body:Baseline": "print(dict((k, v) for k, v in predicate.items()))",
   "body:-Blocks": "print(string.encode('predicate')))",
   "body:-Code": "print(predicate.__dict__ for _ in string)",
   "body:-Inline": "print(predicate.__dict__).isnull()",
   "body:-NL": "print(string.__predicate__).issubset(string)",
   "base:+Mined": "\"\"\"\"\"\".join(str(predicate))",
   "body+mined:Baseline": "print(predicate(s) for s in string.values())",
   "body+mined:-Code": "predicate(string).isalpha()",
   "body+mined:-NL": "print(re.sub('(?<predicate)', '', string))",
   "body+mined:-Blocks": "print(predicate(string, None)",
   "body+mined:-Inline": "predicate(s, key=lambda x: x[1])"
  },
  "snippet": "all(predicate(x) for x in string)"
 },
 "574236.190": {
  "intent": "determine number of files on a drive with python",
  "body": "I have been trying to figure out how to retrieve (quickly) the number of files on a given HFS+ drive with python.\nI have been playing with os.statvfs and such, but can't quite get anything (that seems helpful to me).\nAny ideas?\nEdit:  Let me be a bit more specific. =]\nI am writing a timemachine-like wrapper around rsync for various reasons, and would like a very fast estimate (does not have to be perfect) of the number of files on the drive rsync is going to scan. This way I can watch the progress from rsync (if you call it like rsync -ax --progress , or with the -P  option) as it builds its initial file list, and report a percentage and/or ETA back to the user.\nThis is completely separate from the actual backup, which is no problem tracking progress. But with the drives I am working on with several million files, it means the user is watching a counter of the number of files go up with no upper bound for a few minutes.\nI have tried playing with os.statvfs with exactly the method described in one of the answers so far, but the results do not make sense to me.\nimport os\nos.statvfs('/').f_files - os.statvfs('/').f_ffree\n64171205L\n\nThe more portable way gives me around 1.1 million on this machine, which is the same as every other indicator I have seen on this machine, including rsync running its preparations:\nsum(len(filenames) for path, dirnames, filenames in os.walk(\"/\"))\n1084224\n\nNote that the first method is instantaneous, while the second one made me come back 15 minutes later to update because it took just that long to run.\nDoes anyone know of a similar way to get this number, or what is wrong with how I am treating/interpreting the os.statvfs numbers?\n",
  "preds": {
   "base:Baseline": "print(os.path.getmtime(filename))",
   "body:Baseline": "sum(len(f_files) for f in os.statvfs('/').read()))",
   "body:-Blocks": "print(os.statvfs.count('file'))",
   "body:-Code": "sys.statvfs.count()",
   "body:-Inline": "sum(len(os.statvfs('/').f_files) for os in os.walk('/'))",
   "body:-NL": "os.statvfs('/').f_files()",
   "base:+Mined": "sum(os.path.abspath(file))",
   "body+mined:Baseline": "sum(f_files - os.statvfs('/').f_ffree)",
   "body+mined:-Code": "return sum(os.statvfs(file_list))",
   "body+mined:-NL": "os.statvfs('/').f_files",
   "body+mined:-Blocks": "return sum(os.statvfs(open('/tmp/test.hstack', 'rb'))",
   "body+mined:-Inline": "sum(len(filenames) for path, dirnames, filenames in os.walk('/'))"
  },
  "snippet": "os.statvfs('/').f_files - os.statvfs('/').f_ffree"
 },
 "7011291.191": {
  "intent": "how to get a single result from a sqlite query in python?",
  "body": "Is there an elegant way of getting a single result from an SQLite SELECT query when using python 2.7?\nfor example:\nconn = sqlite3.connect('db_path.db')\ncursor=conn.cursor()\ncursor.execute(\"SELECT MAX(value) FROM table\")\n\nfor row in cursor:\n    for elem in row:\n        maxVal = elem\n\nis there a way to avoid those nested for s and get the value directly? I've tried\nmaxVal = cursor[0][0]\n\nwithout any success.\n",
  "preds": {
   "base:Baseline": "result = sqlite.query(lambda x: x[1])",
   "body:Baseline": "cursor.execute('SELECT MAX(value) FROM table')",
   "body:-Blocks": "results = sqlite.query(lambda x: x[1])",
   "body:-Code": "result = sqlite.query(lambda x: x[1])",
   "body:-Inline": "cursor.execute('SELECT MAX(value) FROM table')",
   "body:-NL": "cursor.execute('SELECT MAX(value) FROM table')",
   "base:+Mined": "cursor.execute('INSERT INTO table VALUES (%s, %s)', (1, 2, 3))",
   "body+mined:Baseline": "cursor.execute('SELECT MAX(value) FROM table')",
   "body+mined:-Code": "cursor.execute('SELECT * FROM records WHERE email LIKE ')",
   "body+mined:-NL": "cursor.execute('SELECT MAX(value) FROM table')",
   "body+mined:-Blocks": "cursor.execute('SELECT * FROM table WHERE index=False')",
   "body+mined:-Inline": "cursor.execute('SELECT MAX(value) FROM table')"
  },
  "snippet": "cursor.fetchone()[0]"
 },
 "6378889.192": {
  "intent": "convert string `user_input` into a list of integers `user_list`",
  "body": "In my python Script I have:\nuser = nuke.getInput(\"Frames Turned On\")\nuserLst = [user]\nprint userLst\n\nResult: \n['12,33,223']\n\nI was wondering How I would remove the '  in the list, or somehow convert it into int?\n",
  "preds": {
   "base:Baseline": "user_input = [int(x) for x in user_list]",
   "body:Baseline": "user_list = nuke.getInput('Frames Turned On')",
   "body:-Blocks": "user_list = [int(x) for x in user_input]",
   "body:-Code": "user_input = [int(x) for x in user_list]",
   "body:-Inline": "user_list = nuke.input('Frames Turned On')",
   "body:-NL": "user_list = nuke.getInput('Frames Turned On')",
   "base:+Mined": "user_list = [int(i) for i in user_input]",
   "body+mined:Baseline": "nuke.getInput('Frames Turned On')",
   "body+mined:-Code": "user_list = [int(i) for i in user_input]",
   "body+mined:-NL": "nuke.getInput('Frames Turned On')",
   "body+mined:-Blocks": "user_list = [int(x) for x in input]",
   "body+mined:-Inline": "user_list = [int(x) for x in user_input]"
  },
  "snippet": "user_list = [int(number) for number in user_input.split(',')]"
 },
 "6378889.193": {
  "intent": "get a list of integers by splitting  a string `user` with comma",
  "body": "In my python Script I have:\nuser = nuke.getInput(\"Frames Turned On\")\nuserLst = [user]\nprint userLst\n\nResult: \n['12,33,223']\n\nI was wondering How I would remove the '  in the list, or somehow convert it into int?\n",
  "preds": {
   "base:Baseline": "[int(x) for x in user.split(',')]",
   "body:Baseline": "userLst = [int(x) for x in user]",
   "body:-Blocks": "[int(x) for x in user.split()]",
   "body:-Code": "[int(x) for x in user]",
   "body:-Inline": "user = nuke.split(',')",
   "body:-NL": "user = nuke.split(',')",
   "base:+Mined": "[int(x) for x in User.split(',')]",
   "body+mined:Baseline": "nuke.getInput('Frames Turned On')",
   "body+mined:-Code": "[int(x) for x in user.split(',')]",
   "body+mined:-NL": "[int(x) for x in user.split()]",
   "body+mined:-Blocks": "[int(x) for x in user.split()]",
   "body+mined:-Inline": "[int(x) for x in userLst]"
  },
  "snippet": "[int(s) for s in user.split(',')]"
 },
 "5212870.194": {
  "intent": "sorting a python list by two criteria",
  "body": "I have the following list created from a sorted csv\nlist1 = sorted(csv1, key=operator.itemgetter(1))\n\nI would actually like to sort the list by two criteria: first by the value in field 1 and then by the value in field 2. How do I do this?\n",
  "preds": {
   "base:Baseline": "sorted(list(itertools.chain.from_iterable(1)))",
   "body:Baseline": "sorted(list1, key=operator.itemgetter(1))",
   "body:-Blocks": "sorted(list(csv.items()), key=lambda x: x[1])",
   "body:-Code": "sorted(list(range(1)), key=lambda x: x[1])",
   "body:-Inline": "sorted(list1, key=operator.itemgetter(1))",
   "body:-NL": "sorted(list1, key=operator.itemgetter(1))",
   "base:+Mined": "sorted(lst, key=lambda x: x[1])",
   "body+mined:Baseline": "sorted(csv1, key=operator.itemgetter(1))",
   "body+mined:-Code": "sorted(lst, key=lambda x: x[1])",
   "body+mined:-NL": "sorted(csv1, key=operator.itemgetter(1))",
   "body+mined:-Blocks": "sorted(L, key=lambda x: (x['value'] == x['value'])",
   "body+mined:-Inline": "sorted(list1, key=operator.itemgetter(1))"
  },
  "snippet": "sorted(list, key=lambda x: (x[0], -x[1]))"
 },
 "403421.195": {
  "intent": "sort a list of objects `ut`, based on a function `cmpfun` in descending order",
  "body": "I've got a list of Python objects that I'd like to sort by an attribute of the objects themselves.  The list looks like:\nut\n[ <Tag: 128>, <Tag: 2008>, <Tag: <>, <Tag: actionscript>, <Tag: addresses>,\n <Tag: aes>, <Tag: ajax> <console_out>]\n\nEach object has a count:\nut[1].count\n1L\n\nI need to sort the list by number of counts descending.\nI've seen several methods for this, but I'm looking for best practice in Python.\n",
  "preds": {
   "base:Baseline": "ut.sort(key=lambda x: x[1])",
   "body:Baseline": "ut.sort(key=operator.itemgetter(1))",
   "body:-Blocks": "ut.sort(key=lambda x: x['cmpfun'], reverse=True)",
   "body:-Code": "ut.sort(key=lambda x: x[1])",
   "body:-Inline": "sorted(ut, key=operator.itemgetter(1))",
   "body:-NL": "ut.sort(key=operator.itemgetter('cmpfun', reverse=True)",
   "base:+Mined": "sorted(ut, key=cmpfun)",
   "body+mined:Baseline": "sorted(ut, key=lambda x: int(x['count']))",
   "body+mined:-Code": "sorted(ut, key=cmpfun.get)",
   "body+mined:-NL": "ut.sort(key=lambda x: int(x[1].count()), reverse=True)",
   "body+mined:-Blocks": "sorted(ut, key=cmpfun.index)",
   "body+mined:-Inline": "sorted(ut, key=lambda x: int(x['c']))"
  },
  "snippet": "ut.sort(key=cmpfun, reverse=True)"
 },
 "403421.196": {
  "intent": "reverse list `ut` based on the `count` attribute of each object",
  "body": "I've got a list of Python objects that I'd like to sort by an attribute of the objects themselves.  The list looks like:\nut\n[ <Tag: 128>, <Tag: 2008>, <Tag: <>, <Tag: actionscript>, <Tag: addresses>,\n <Tag: aes>, <Tag: ajax> <console_out>]\n\nEach object has a count:\nut[1].count\n1L\n\nI need to sort the list by number of counts descending.\nI've seen several methods for this, but I'm looking for best practice in Python.\n",
  "preds": {
   "base:Baseline": "ut = [x for x in enumerate(ut.count()])",
   "body:Baseline": "sorted(ut, reverse=True)",
   "body:-Blocks": "ut.sort(key=lambda x: x[1])",
   "body:-Code": "ut.sort(key=lambda x: x[1])",
   "body:-Inline": "sorted(ut, key=ut.count)",
   "body:-NL": "ut[1].apply(lambda x: x[1])",
   "base:+Mined": "ut.reverse(reverse=True)",
   "body+mined:Baseline": "sorted(ut, key=lambda x: int(x.count()))",
   "body+mined:-Code": "sorted(ut, key=lambda x: x.count)",
   "body+mined:-NL": "ut.reverse(1, 1)",
   "body+mined:-Blocks": "sorted(ut, reverse=True)",
   "body+mined:-Inline": "sorted(ut, key=lambda x: int(x['count']))"
  },
  "snippet": "ut.sort(key=lambda x: x.count, reverse=True)"
 },
 "403421.197": {
  "intent": "sort a list of objects `ut` in reverse order by their `count` property",
  "body": "I've got a list of Python objects that I'd like to sort by an attribute of the objects themselves.  The list looks like:\nut\n[ <Tag: 128>, <Tag: 2008>, <Tag: <>, <Tag: actionscript>, <Tag: addresses>,\n <Tag: aes>, <Tag: ajax> <console_out>]\n\nEach object has a count:\nut[1].count\n1L\n\nI need to sort the list by number of counts descending.\nI've seen several methods for this, but I'm looking for best practice in Python.\n",
  "preds": {
   "base:Baseline": "sorted(ut, key=lambda x: x[1])",
   "body:Baseline": "sorted(ut, key=lambda k: k.count)",
   "body:-Blocks": "ut.sort(key=lambda x: x[1])",
   "body:-Code": "sorted(ut, key=lambda x: x[1])",
   "body:-Inline": "sorted(ut, key=ut.count)",
   "body:-NL": "ut.sort(key=lambda x: x[1])",
   "base:+Mined": "sorted(ut, key=lambda x: order.index(x['count']))",
   "body+mined:Baseline": "sorted(ut, reverse=True)",
   "body+mined:-Code": "sorted(ut, key=lambda x: x.count)",
   "body+mined:-NL": "sorted(ut, reverse=True)",
   "body+mined:-Blocks": "sorted(ut, key=lambda tup: tup[1])",
   "body+mined:-Inline": "sorted(ut, key=lambda x: int(x['count']))"
  },
  "snippet": "ut.sort(key=lambda x: x.count, reverse=True)"
 },
 "19601086.198": {
  "intent": "click a href button 'send' with selenium",
  "body": "I have one button from one LinkedIn page with this code:\n<div class=\"primary-action-button\"> <a class=\"primary-action label\" href=\"/requestList?displayProposal=&amp;destID=39959446&amp;creationType=DC&amp;authToken=Yr4_&amp;authType=OUT_OF_NETWORK&amp;trk=vsrp_people_res_pri_act&amp;trkInfo=VSRPsearchId%3A2998448551382744275729%2CVSRPtargetId%3A39959446%2CVSRPcmpt%3Aprimary\">Send InMail </a> </div>\n\nIs there any way to click on an element just by its href link? Thanks\n",
  "preds": {
   "base:Baseline": "driver.find_element_by_css_selector('send')",
   "body:Baseline": "click('send', selenium)",
   "body:-Blocks": "driver.find_element_by_name('send')",
   "body:-Code": "driver.find_element_by_css_selector('send')",
   "body:-Inline": "click('send', selenium)",
   "body:-NL": "s = selenium.click('send', class='primary-action-button')",
   "base:+Mined": "driver.find_element_by_css_selector(\"//div[@ href='send']\").click()",
   "body+mined:Baseline": "button.click('send', 1)",
   "body+mined:-Code": "driver.find_element_by_href('send')",
   "body+mined:-NL": "driver.find_element_by_class_name('send')",
   "body+mined:-Blocks": "driver.find_element_by_href('send')",
   "body+mined:-Inline": "driver.get('http://stackoverflow.com')"
  },
  "snippet": "driver.find_element_by_partial_link_text('Send').click()"
 },
 "19601086.199": {
  "intent": "click a href button having text `send inmail` with selenium",
  "body": "I have one button from one LinkedIn page with this code:\n<div class=\"primary-action-button\"> <a class=\"primary-action label\" href=\"/requestList?displayProposal=&amp;destID=39959446&amp;creationType=DC&amp;authToken=Yr4_&amp;authType=OUT_OF_NETWORK&amp;trk=vsrp_people_res_pri_act&amp;trkInfo=VSRPsearchId%3A2998448551382744275729%2CVSRPtargetId%3A39959446%2CVSRPcmpt%3Aprimary\">Send InMail </a> </div>\n\nIs there any way to click on an element just by its href link? Thanks\n",
  "preds": {
   "base:Baseline": "driver.find_element_by_css_selector('send inmail')",
   "body:Baseline": "click('send InMail', selenium)",
   "body:-Blocks": "driver.find_element_by_id('send inmail')",
   "body:-Code": "driver.find_element_by_css_selector('send inmail')",
   "body:-Inline": "click('send InMail', selenium)",
   "body:-NL": "click a href button having text `send inmail')",
   "base:+Mined": "driver.find_element_by_css_selector('.send inmail').click()",
   "body+mined:Baseline": "link = selenium.Link('Send InMail')",
   "body+mined:-Code": "driver.find_element_by_href('send inmail').click()",
   "body+mined:-NL": "driver.find_element_by_class_name('send inmail')",
   "body+mined:-Blocks": "driver.find_element_by_href('send_inmail')",
   "body+mined:-Inline": "driver.get('http://stackoverflow.com')"
  },
  "snippet": "driver.findElement(By.linkText('Send InMail')).click()"
 },
 "19601086.200": {
  "intent": "click a href button with text 'send inmail' with selenium",
  "body": "I have one button from one LinkedIn page with this code:\n<div class=\"primary-action-button\"> <a class=\"primary-action label\" href=\"/requestList?displayProposal=&amp;destID=39959446&amp;creationType=DC&amp;authToken=Yr4_&amp;authType=OUT_OF_NETWORK&amp;trk=vsrp_people_res_pri_act&amp;trkInfo=VSRPsearchId%3A2998448551382744275729%2CVSRPtargetId%3A39959446%2CVSRPcmpt%3Aprimary\">Send InMail </a> </div>\n\nIs there any way to click on an element just by its href link? Thanks\n",
  "preds": {
   "base:Baseline": "driver.find_element_by_css_selector('send inmail').click()",
   "body:Baseline": "click('send InMail', selenium)",
   "body:-Blocks": "driver.find_element_by_css_name('send inmail')",
   "body:-Code": "driver.find_element_by_css_selector('send inmail')",
   "body:-Inline": "click_button('send inmail', selenium)",
   "body:-NL": "a = selenium.click('send inmail')",
   "base:+Mined": "driver.find_element_by_css_selector('send inmail').click()",
   "body+mined:Baseline": "link = selenium.Link('Send InMail')",
   "body+mined:-Code": "driver.find_element_by_href('send inmail').click()",
   "body+mined:-NL": "driver.find_element_by_class_name('send inmail')",
   "body+mined:-Blocks": "driver.find_element_by_href('send_inmail').click()",
   "body+mined:-Inline": "driver.get('http://stackoverflow.com')"
  },
  "snippet": "driver.find_element_by_link_text('Send InMail').click()"
 },
 "3944876.201": {
  "intent": "cast an int `i` to a string and concat to string 'me'",
  "body": "I want to be able to generate a number of text files with the names fileX.txt where X is some integer:\nfor i in range(key):\n    filename = \"ME\" + i + \".txt\" //Error here! Can't concat a string and int\n    filenum = filename\n    filenum = open(filename , 'w')  \n\nDoes anyone else know how to do the filename = \"ME\" + i  part so I get a list of files with the names: \"ME0.txt\" , \"ME1.txt\" , \"ME2.txt\" , and etc\n",
  "preds": {
   "base:Baseline": "\"\"\"\"\"\".join(str(i)) for i in'me'",
   "body:Baseline": "f = open(filename, 'ME'))",
   "body:-Blocks": "\"\"\"ME\"\"\".join(str(i))",
   "body:-Code": "\"\"\".join(open('ME0.txt', 'ME2.txt'))",
   "body:-Inline": "\"\"\"ME\"\"\".join(str(i))",
   "body:-NL": "\"\"\"ME\"\"\".join(str(i)) for i in range(key))",
   "base:+Mined": "\"\"\", \"\"\".join(i)",
   "body+mined:Baseline": "filename = 'ME' + i + '.txt'",
   "body+mined:-Code": "print(open('ME0.txt', 'ME1.txt'))",
   "body+mined:-NL": "filenum = open(filename, 'w').read()",
   "body+mined:-Blocks": "\"\"\"ME0.txt\"\"\".join('ME1.txt')",
   "body+mined:-Inline": "\"\"\", \"\"\".join(i)"
  },
  "snippet": "'ME' + str(i)"
 },
 "40903174.202": {
  "intent": "sorting data in dataframe pandas",
  "body": "I obtained the following DataFrame:\n    Dis        System_num  Energy\n0   0.9           1       -2.3108\n1   0.7           1       11.8735\n2   1.2           1       -2.3408\n3   2.0           1       -0.3485\n4   2.0           2       -0.9379\n5   0.7           2       7.4776\n6   1.5           2       -2.2877\n7   0.9           2       -4.1789\n8   2.0           3       -3.6596\n9   1.0           3       -18.4582\n10  0.9           3       -16.2202\n11  0.7           3       16.6290\n\nI want to sort values (ascending) in the Dis column for each number in System_num, I mean:\n0   0.7           1       11.8735\n1   0.9           1       -2.3108\n2   1.2           1       -2.3408\n3   2.0           1       -0.3485\n4   0.7           2       7.4776\n5   0.9           2       -4.1789\n6   1.5           2       -2.2877\n7   2.0           2       -0.9379\n8   0.7           3       16.6290\n8   0.9           3       -16.2202\n10  1.0           3       -18.4582\n11  2.0           3       -3.6596\n\n",
  "preds": {
   "base:Baseline": "pd.concat([df.groupby(df.index)], axis=1)",
   "body:Baseline": "df.sort(['Dis'], axis=1)",
   "body:-Blocks": "df.sorted(dataFrame, key=lambda x: x[1])",
   "body:-Code": "df.sort_values('ascending')",
   "body:-Inline": "df.sorted(DataFrame, columns=['Dis'], key=lambda x: x[1])",
   "body:-NL": "df.sorted(df.index.values()), axis=0)",
   "base:+Mined": "df.sort(key=lambda x: x[1])",
   "body+mined:Baseline": "df.sort(key=lambda x: x.astype(int) for x in System_num)",
   "body+mined:-Code": "df.sort_values(inplace=True)",
   "body+mined:-NL": "df.sort(key=lambda x: x[1])",
   "body+mined:-Blocks": "df.sort_values(['Dis'], ascending=[True, False])",
   "body+mined:-Inline": "df.sort(['Dis', 'Energy'], ascending=False)"
  },
  "snippet": "df.sort_values(['System_num', 'Dis'])"
 },
 "4454298.203": {
  "intent": "prepend the line '#test firstline\\n' to the contents of file 'infile' and save as the file 'outfile'",
  "body": "I need to add a single line to the first line of a text file and it looks like the only options available to me are more lines of code than I would expect from python. Something like this:\nf = open('filename','r')\ntemp = f.read()\nf.close()\n\nf = open('filename', 'w')\nf.write(\"#testfirstline\")\n\nf.write(temp)\nf.close()\n\nIs there no easier way? Additionally, I see this two-handle example more often than opening a single handle for reading and writing ('r+') - why is that?\n",
  "preds": {
   "base:Baseline": "os.system('#test firstline\\n')",
   "body:Baseline": "f = open('#testfirstline\\n', 'outfile')",
   "body:-Blocks": "os.chmod('#test firstline\\n')",
   "body:-Code": "os.chmod('#test firstline\\n')",
   "body:-Inline": "f.write('#test firstline\\n')",
   "body:-NL": "f.write('#test firstline\\n')",
   "base:+Mined": "os.system('#test firstline\\n')",
   "body+mined:Baseline": "f.write('#test firstline\\n')",
   "body+mined:-Code": "outfile.write('#Test firstline\\n')",
   "body+mined:-NL": "f.write('#test firstline\\n')",
   "body+mined:-Blocks": "outfile.write('#test firstline\\n')",
   "body+mined:-Inline": "f.write('#test firstline\\n')"
  },
  "snippet": "open('outfile', 'w').write('#test firstline\\n' + open('infile').read())"
 },
 "19729928.204": {
  "intent": "sort a list `l` by length of value in tuple",
  "body": "I am having difficulty sorting a list of tuples. I would like to sort by the length of a string in the list.\nFor example:\nl = [(99,'bbc', 121),(33,'abcd', 231),(44,'zb', 148), (23,'abcde',221)]\n\nif I sort by element 1:\nl.sort(key=itemgetter(1), reverse=True)\n\nThis will sort on the alphabetical ranking of the strings, not the length. I would prefer to sort in-place and reverse sort, with longest string first.\nI can use a lambda and cmp, \nl.sort(lambda x,y: cmp(len(x[1]), len(y[1])), reverse=True)\n\nbut is there a more elegant, or pythonic way using key and/or itemgetter?\n",
  "preds": {
   "base:Baseline": "sorted(l, key=lambda x: x[1])",
   "body:Baseline": "l.sort(key=itemgetter(1), reverse=True)",
   "body:-Blocks": "sorted(l, key=lambda x: x[1])",
   "body:-Code": "sorted(l, key=lambda x: x[1])",
   "body:-Inline": "l.sort(key=itemgetter(1), reverse=True)",
   "body:-NL": "l.sort(key=itemgetter(1), reverse=True)",
   "base:+Mined": "sorted(l, key=lambda x: len(x[1])",
   "body+mined:Baseline": "l.sort(key=itemgetter(1), reverse=True)",
   "body+mined:-Code": "sorted(L, key=lambda item: itemgetter(len(item), item))",
   "body+mined:-NL": "l.sort(key=lambda x, y: cmp(len(x[1]), len(y[1]))",
   "body+mined:-Blocks": "sorted(L, key=lambda t: t[len(t[1]))",
   "body+mined:-Inline": "l.sort(key=itemgetter(1))"
  },
  "snippet": "l.sort(key=lambda t: len(t[1]), reverse=True)"
 },
 "31371879.205": {
  "intent": "split string `s` by words that ends with 'd'",
  "body": "I want to split strings only by suffixes. For example, I would like to be able to split dord word  to [dor,wor] .\nI though that \\wd  would search for words that end with d . However this does not produce the expected results\nimport re\nre.split(r'\\wd',\"dord word\")\n['do', ' wo', '']\n\nHow can I split by suffixes?\n",
  "preds": {
   "base:Baseline": "s = s.split('d')",
   "body:Baseline": "re.findall('\\\\d', s)",
   "body:-Blocks": "s.split(',', 'd')",
   "body:-Code": "s.split(',', 'd')",
   "body:-Inline": "re.split('\\\\wd', 'dord word')",
   "body:-NL": "re.findall('\\\\d', s)",
   "base:+Mined": "re.split('\\\\d+', s)",
   "body+mined:Baseline": "re.findall('\\\\w', s)",
   "body+mined:-Code": "s = re.findall('\\\\d+', s)",
   "body+mined:-NL": "re.findall('\\\\d', s)",
   "body+mined:-Blocks": "re.split('[d]', s)",
   "body+mined:-Inline": "re.findall('\\\\d+', s)"
  },
  "snippet": "re.findall('\\\\b(\\\\w+)d\\\\b', s)"
 },
 "9012008.206": {
  "intent": "return `true` if string `foobarrrr` contains regex `ba[rzd]`",
  "body": "I have a regular expression like this:\nregexp = u'ba[r|z|d]'\n\nFunction must return True if word contains bar , baz  or bad .\nIn short, I need regexp analog for Python's\n'any-string' in 'text'\n\nHow can I realize it? Thanks!\n",
  "preds": {
   "base:Baseline": "return False if (foobarrrr.is not regex(ba[rzd]):\n    pass",
   "body:Baseline": "re.findall('\\\\b\\\\b', 'foobarrrr', 'ba[rzd]')",
   "body:-Blocks": "\"\"\"foobarrrr\"\"\".join(re.sub('[^a-zA-Z]', 'ba[rzd]')",
   "body:-Code": "return False if re.sub('(?\\\\b\\\\d]', 'foobarrrr', 'ba[rzd]')",
   "body:-Inline": "return True if (foobarrrr.is_any-string) in re.findall('\\\\b', 'ba[rzd]')",
   "body:-NL": "\"\"\"foobarrrr\"\"\".replace('ba[rzd]', 'any-string')",
   "base:+Mined": "\"\"\"foobarrrr\"\"\".encode('ascii', 'ba[rzd]')",
   "body+mined:Baseline": "re.search('\\\\bba[r|z|d]', 'foobarrrr')",
   "body+mined:-Code": "\"\"\"foobarrrr\"\"\".endswith(ba[rzd])",
   "body+mined:-NL": "\"\"\"ba[r|z|d]\"\"\".encode('utf8')",
   "body+mined:-Blocks": "\"\"\"foobarrrr\"\"\".endswith('bar[rzd]')",
   "body+mined:-Inline": "re.findall('\\\\bba[r|z|d]', 'foobarrrr')"
  },
  "snippet": "bool(re.search('ba[rzd]', 'foobarrrr'))"
 },
 "7961363.207": {
  "intent": "removing duplicates in list `t`",
  "body": "Pretty much I need to write a program that checks if a list has any duplicates and if it does it removes them and returns a new list with the items that weren't duplicated/removed. This is what I have tried but honestly I don't know what to do.\ndef remove_duplicates():\n    t = ['a', 'b', 'c', 'd']\n    t2 = ['a', 'c', 'd']\n    for t in t2:\n        t.append(t.remove())\n    return t\n\n",
  "preds": {
   "base:Baseline": "[x for x in list(t)]",
   "body:Baseline": "t = ['a', 'b', 'c', 'd']",
   "body:-Blocks": "del t[i] for i in list(t)]",
   "body:-Code": "[x for x in t if not duplicates]",
   "body:-Inline": "t = [x for x in t]",
   "body:-NL": "t = [duplicates for duplicates in t]",
   "base:+Mined": "[x for x in list(t.items()) if x != 1]",
   "body+mined:Baseline": "t2 = [x for x in t if x not in list(t)]",
   "body+mined:-Code": "t.sort(key=lambda x: x.duplicates())",
   "body+mined:-NL": "t2 = [t for t in t2 if t.duplicated()]",
   "body+mined:-Blocks": "t = list(set(t))",
   "body+mined:-Inline": "t = list(set(t))"
  },
  "snippet": "list(set(t))"
 },
 "7961363.208": {
  "intent": "removing duplicates in list `source_list`",
  "body": "Pretty much I need to write a program that checks if a list has any duplicates and if it does it removes them and returns a new list with the items that weren't duplicated/removed. This is what I have tried but honestly I don't know what to do.\ndef remove_duplicates():\n    t = ['a', 'b', 'c', 'd']\n    t2 = ['a', 'c', 'd']\n    for t in t2:\n        t.append(t.remove())\n    return t\n\n",
  "preds": {
   "base:Baseline": "[x for x in source_list if x is not duplicates]",
   "body:Baseline": "[x for x in source_list if x not in x]",
   "body:-Blocks": "source_list.remove(key=operator.itemgetter(1))",
   "body:-Code": "[x for x in source_list if not duplicates]",
   "body:-Inline": "[duplicates for duplicates insource_list]",
   "body:-NL": "source_list = [x for x in source_list]",
   "base:+Mined": "[list(source_list) for _ in range(10)]",
   "body+mined:Baseline": "source_list.sort(key=lambda x: abs(x))",
   "body+mined:-Code": "source_list.sort(key=lambda x: x.duplicates())",
   "body+mined:-NL": "t = list(source_list)",
   "body+mined:-Blocks": "source_list.sort(key=lambda x: x.index(x))",
   "body+mined:-Inline": "source_list.sort(key=lambda x: list(x.duplicates())"
  },
  "snippet": "list(set(source_list))"
 },
 "7961363.209": {
  "intent": "removing duplicates in list `abracadabra`",
  "body": "Pretty much I need to write a program that checks if a list has any duplicates and if it does it removes them and returns a new list with the items that weren't duplicated/removed. This is what I have tried but honestly I don't know what to do.\ndef remove_duplicates():\n    t = ['a', 'b', 'c', 'd']\n    t2 = ['a', 'c', 'd']\n    for t in t2:\n        t.append(t.remove())\n    return t\n\n",
  "preds": {
   "base:Baseline": "del my_list(abracadabra)",
   "body:Baseline": "[x for x in abracadabra if x not in x]",
   "body:-Blocks": "del mynew list(abracadabra)",
   "body:-Code": "delicate(abracadabra)",
   "body:-Inline": "for (duplicates in abracadabra):\n    pass",
   "body:-NL": "[duplicates for duplicates in abracadabra]",
   "base:+Mined": "list(set(abracadabra.items()))",
   "body+mined:Baseline": "list(abracadabra.items())",
   "body+mined:-Code": "new_list = list(set(abracadabra.items()))",
   "body+mined:-NL": "t = list(abracadabra.values())",
   "body+mined:-Blocks": "return list(set(abracadabra.items()))",
   "body+mined:-Inline": "list(set(abracadabra.values())"
  },
  "snippet": "list(OrderedDict.fromkeys('abracadabra'))"
 },
 "5183533.210": {
  "intent": "convert array `a` into a list",
  "body": "I using the dot() function from numpy to multiply a matrix of 3x3 with a numpy.array of 1x3. The output is for example this:\n[[ 0.16666667  0.66666667  0.16666667]]\nwhich is of type:\n<class 'numpy.matrixlib.defmatrix.matrix'>\n\nhow can I convert this to a list. Because I know the result will always be a matrix of 1x3 so it should be coverted to a list because I need to be able to loop through it later for calculation the pearson distance of two of those lists.\nSo to summarize: how can I make a list from this matrix?\n",
  "preds": {
   "base:Baseline": "list(itertools.chain.from_iterable(a))",
   "body:Baseline": "list(a, numpy.matrixlib.array(1))",
   "body:-Blocks": "list(a, key=lambda x: x[1])",
   "body:-Code": "list(a).dot(1)",
   "body:-Inline": "list(numpy.matrixlib.defmatrix(a))",
   "body:-NL": "list(a.items()).decode('matrixlib.defmatrix.matrix')",
   "base:+Mined": "list(itertools.chain(*a))",
   "body+mined:Baseline": "list(map(int, a.split())",
   "body+mined:-Code": "list(np.dot(a, [0.166666666667, 0.16666667]]))",
   "body+mined:-NL": "numpy.matrixlib.concatenate((a, a))",
   "body+mined:-Blocks": "list(numpy.dot(a, 1))",
   "body+mined:-Inline": "list(itertools.product([0.16666667, 0.66666667])"
  },
  "snippet": "numpy.array(a).reshape(-1).tolist()"
 },
 "5183533.211": {
  "intent": "convert the first row of numpy matrix `a` to a list",
  "body": "I using the dot() function from numpy to multiply a matrix of 3x3 with a numpy.array of 1x3. The output is for example this:\n[[ 0.16666667  0.66666667  0.16666667]]\nwhich is of type:\n<class 'numpy.matrixlib.defmatrix.matrix'>\n\nhow can I convert this to a list. Because I know the result will always be a matrix of 1x3 so it should be coverted to a list because I need to be able to loop through it later for calculation the pearson distance of two of those lists.\nSo to summarize: how can I make a list from this matrix?\n",
  "preds": {
   "base:Baseline": "[a[0] for a in zip(*a)]",
   "body:Baseline": "list(a, numpy.matrixlib.array(1))",
   "body:-Blocks": "list(a.shape[0])",
   "body:-Code": "list(a.shape[0]",
   "body:-Inline": "list(a.shape[0]",
   "body:-NL": "numpy.matrixlib.defmatrix(a)",
   "base:+Mined": "a = a[:, (0)]",
   "body+mined:Baseline": "numpy.dot(a, 1)",
   "body+mined:-Code": "list(np.dot(a, [0.166666666667, 0.16666667]]))",
   "body+mined:-NL": "numpy.matrixlib.concatenate((a, a))",
   "body+mined:-Blocks": "numpy.dot(a, axis=1)",
   "body+mined:-Inline": "list(itertools.product([0.16666667, 0.66666667])"
  },
  "snippet": "numpy.array(a)[0].tolist()"
 },
 "5999747.212": {
  "intent": "in `soup`, get the content of the sibling of the `td`  tag with text content `address:`",
  "body": "I'm trying to get the content \"My home address\" using the following but got the AttributeError:\naddress = soup.find(text=\"Address:\")\nprint address.nextSibling\n\nThis is my HTML:\n<b>Address: </b> </td>\n<td>My home address </td>\n\nWhat is a good way to navigate down td  tag and pull the content?\n",
  "preds": {
   "base:Baseline": "soup.find_element_by_xpath('//a[address:])')",
   "body:Baseline": "soup.find(text='Address:')",
   "body:-Blocks": "soup.find_element_by_css_name('My Home Address')",
   "body:-Code": "soup.findAll(text={'address':})",
   "body:-Inline": "soup.find(text='Address:')",
   "body:-NL": "soup.find(text='Address:')",
   "base:+Mined": "soup.findAll(text=True)",
   "body+mined:Baseline": "address = soup.find(text='Address:')",
   "body+mined:-Code": "soup.find_element_by_id('address:')",
   "body+mined:-NL": "soup.find(text='Address:')",
   "body+mined:-Blocks": "soup.find_all('td', {'address': 'My home address'})",
   "body+mined:-Inline": "soup.find(text='Address:')"
  },
  "snippet": "print(soup.find(text='Address:').findNext('td').contents[0])"
 },
 "4284648.213": {
  "intent": "convert elements of each tuple in list `l` into a string  separated by character `@`",
  "body": "I've written a function in python that returns a list, for example\n[(1,1),(2,2),(3,3)] \n\nBut i want the output as a string so i can replace the comma with another char so the output would be \n'1@1' '2@2' '3@3' \n\nAny easy way around this?:)\nThanks for any tips in advance\n",
  "preds": {
   "base:Baseline": "\"\"\"\"\"\".join(map(int, x) for x in L)",
   "body:Baseline": "\"\"\"\"\"\".join(str(x) for x in L))",
   "body:-Blocks": "\"\"\"\"\"\".join(str(x) for x in L)",
   "body:-Code": "\"\"\"\"\"\".join(str(x) for x in L)",
   "body:-Inline": "\"\"\"\"\"\".join(str(x) for x in L))",
   "body:-NL": "[x[0] for x in L]",
   "base:+Mined": "\"\"\"\"\"\".join(map(str, L))",
   "body+mined:Baseline": "\"\"\"\"\"\".join(map(str, L))",
   "body+mined:-Code": "\"\"\"\"\"\".join(str(x) for x in L)",
   "body+mined:-NL": "\"\"\"\"\"\".join(map(lambda x: x.split('@'), L))",
   "body+mined:-Blocks": "\"\"\"\"\"\".join(map(str, L))",
   "body+mined:-Inline": "\"\"\"\"\"\".join(map(str, L))"
  },
  "snippet": "\"\"\" \"\"\".join([('%d@%d' % t) for t in l])"
 },
 "4284648.214": {
  "intent": "convert each tuple in list `l` to a string with '@' separating the tuples' elements",
  "body": "I've written a function in python that returns a list, for example\n[(1,1),(2,2),(3,3)] \n\nBut i want the output as a string so i can replace the comma with another char so the output would be \n'1@1' '2@2' '3@3' \n\nAny easy way around this?:)\nThanks for any tips in advance\n",
  "preds": {
   "base:Baseline": "\"\"\"\"\"\".join(l, '@')",
   "body:Baseline": "\"\"\"\"\"\".join(map(lambda x: x.split('@')))",
   "body:-Blocks": "\"\"\"\"\"\".join(str(x) for x in L))",
   "body:-Code": "\"\"\"\"\"\".join(str(x) for x in L)",
   "body:-Inline": "\"\"\"\"\"\".join(str(x) for x in L))",
   "body:-NL": "\"\"\"\"\"\".join(map(lambda x: x[1], x[2]))",
   "base:+Mined": "\"\"\"\"\"\".join(map(str, zip(*l))",
   "body+mined:Baseline": "\"\"\"\"\"\".join(map(str, L))",
   "body+mined:-Code": "\"\"\"\"\"\".join(str(x) for x in L)",
   "body+mined:-NL": "\"\"\"\"\"\".join(map(lambda x: x.split('@'), l))",
   "body+mined:-Blocks": "\"\"\"\"\"\".join(map(str, L))",
   "body+mined:-Inline": "\"\"\"\"\"\".join(map(str, L))"
  },
  "snippet": "\"\"\" \"\"\".join([('%d@%d' % (t[0], t[1])) for t in l])"
 },
 "26809954.215": {
  "intent": "get the html from the current web page of a selenium driver",
  "body": "I'm trying to crawl the website \" http://everydayhealth.com \". However, I found that the page will dynamically rendered. So, when I click the button \"More\", some new news will be shown. However, using splinter to click the button doesn't let \"browser.html\" automatically changes to the current html content. Is there a way to let it get newest html source, using either splinter or selenium? My code in splinter is as follows:\nimport requests\nfrom bs4 import BeautifulSoup\nfrom splinter import Browser\n\nbrowser = Browser()\nbrowser.visit('http://everydayhealth.com')\nbrowser.click_link_by_text(\"More\")\n\nprint(browser.html)\n\n\nBased on @Louis's answer, I rewrote the program as follows:\nfrom selenium import webdriver\nfrom selenium.webdriver.support.ui import WebDriverWait\n\ndriver = webdriver.Firefox()\ndriver.get(\"http://www.everydayhealth.com\")\nmore_xpath = '//a[@class=\"btn-more\"]'\nmore_btn = WebDriverWait(driver, 10).until(lambda driver: driver.find_element_by_xpath(more_xpath))\nmore_btn.click()\nmore_news_xpath = '(//a[@href=\"http://www.everydayhealth.com/recipe-rehab/5-herbs-and-spices-to-intensify-flavor.aspx\"])[2]'\nWebDriverWait(driver, 5).until(lambda driver: driver.find_element_by_xpath(more_news_xpath))\n\nprint(driver.execute_script(\"return document.documentElement.outerHTML;\"))\ndriver.quit()\n\nHowever, in the output text, I still couldn't find the text in the updated page. For example, when I search \"Is Milk Your Friend or Foe?\", it still returns nothing. What's the problem?\n",
  "preds": {
   "base:Baseline": "driver.find_element_by_css_id('html')",
   "body:Baseline": "driver.find_element_by_xpath(http://www.everydayhealth.com')",
   "body:-Blocks": "driver.find_element_by_css_selector('browser.html')",
   "body:-Code": "driver.find_element_by_css_selector('browser.html')",
   "body:-Inline": "driver.set_index('//a[@class=\"btn-more\"]')",
   "body:-NL": "driver.execute_script(\"return document.documentElement.outerHTML;\"))",
   "base:+Mined": "driver.get('http://stackoverflow.com')",
   "body+mined:Baseline": "driver.execute_script(\"return document.documentElement.outerHTML;')",
   "body+mined:-Code": "driver.get('http://everydayhealth.com')",
   "body+mined:-NL": "driver.execute_script('return document.documentElement.outerHTML;')",
   "body+mined:-Blocks": "driver.find_element_by_css_selector(\"http://everydayhealth.com').click()",
   "body+mined:-Inline": "driver.click_link_by_text('More')"
  },
  "snippet": "driver.execute_script('return document.documentElement.outerHTML;')"
 },
 "29696641.216": {
  "intent": "get all matches with regex pattern `\\\\d+[xx]` in list of string `teststr`",
  "body": "So I have this list of strings:\nteststr = ['1 FirstString', '2x Sec String', '3rd String', 'x forString', '5X fifth']\n\nWhat I need to do, is to get all the elements from this list that contain:\nnumber + \"x\" \n\nor \nnumber + \"X\"\n\nFor example if I have the function\ndef SomeFunc(string):\n    #do something\n\nI would like to get an output like this:\n2x Sec String\n5X fifth\n\nI found somewhere here in StackOverflow this function:\ndef CheckIfContainsNumber(inputString):\n    return any(char.isdigit() for char in inputString)\n\nBut this returns each string that has a number.\nHow can I expand the functions to get the desired output?\n",
  "preds": {
   "base:Baseline": "re.findall('\\\\d+[xx]', teststr)",
   "body:Baseline": "re.match('\\\\d+[xx]', teststr)",
   "body:-Blocks": "print(re.findall('\\\\d+[xx]')",
   "body:-Code": "re.findall('\\\\d+[xx]', teststr)",
   "body:-Inline": "re.match('\\\\d+[xx]', teststr)",
   "body:-NL": "re.match('\\\\d+[xx]', teststr)",
   "base:+Mined": "re.findall('\\\\d+[xx]', teststr)",
   "body+mined:Baseline": "[match for match in re.findall('\\\\d+[xx]', teststr)]",
   "body+mined:-Code": "[match for match in re.findall('\\\\d+[xx]', teststr)]",
   "body+mined:-NL": "re.findall('\\\\d+[xx]', teststr)",
   "body+mined:-Blocks": "re.findall('\\\\d+[xx]', teststr)",
   "body+mined:-Inline": "re.findall('\\\\d+[xx]', teststr)"
  },
  "snippet": "[i for i in teststr if re.search('\\\\d+[xX]', i)]"
 },
 "15315452.217": {
  "intent": "select values from column 'a' for which corresponding values in column 'b' will be greater than 50, and in column 'c' - equal 900 in dataframe `df`",
  "body": "For example I have simple DF:\nimport pandas as pd\nfrom random import randint\n\ndf = pd.DataFrame({'A': [randint(1, 9) for x in xrange(10)],\n                   'B': [randint(1, 9)*10 for x in xrange(10)],\n                   'C': [randint(1, 9)*100 for x in xrange(10)]})\n\nCan I select values from 'A' for which corresponding values for 'B' will be greater than 50, and for 'C' - not equal 900, using methods and idioms of Pandas?\n",
  "preds": {
   "base:Baseline": "df.loc[df['A'] == 50, df['C'] != 900]",
   "body:Baseline": "df = pd.DataFrame({'A': [i > 50, 'B': i < 50], 'C': i > 900})",
   "body:-Blocks": "df['A'] = df['C']",
   "body:-Code": "df['A'] = df['C']",
   "body:-Inline": "df.loc[df['A'] != 900]",
   "body:-NL": "df = pd.DataFrame(['A', 'B', 'C'], axis=1)",
   "base:+Mined": "df.loc[df['A'] > 50, 'B'] > 900]",
   "body+mined:Baseline": "df.loc[df['A'].isin(['B', 'C'])]",
   "body+mined:-Code": "df.loc[df['A'] > 50, ['B'] > 900]",
   "body+mined:-NL": "df.loc[df['A'].isin(['B', 'C'])]",
   "body+mined:-Blocks": "df.loc[df['B'] > 50, 'C'] > 900]",
   "body+mined:-Inline": "df[['A', 'B', 'C']].loc[df['C'] > 900]"
  },
  "snippet": "df['A'][(df['B'] > 50) & (df['C'] == 900)]"
 },
 "4642501.218": {
  "intent": "sort dictionary `o` in ascending order based on its keys and items",
  "body": "Can anyone tell me how I can sort this:\n{'a': [1, 2, 3], 'c': ['one', 'two'], 'b': ['blah', 'bhasdf', 'asdf'], 'd': ['asdf', 'wer', 'asdf', 'zxcv']}\n\ninto\n{'a': [1, 2, 3], 'b': ['blah', 'bhasdf', 'asdf'], 'c': ['one', 'two'],'d': ['asdf', 'wer', 'asdf', 'zxcv']}\n\n?\nThanks!\nUPDATE 1, code sample:\nSo I am doing linguistics. One article is broken down to words that are stored in a database and have all kinds of properties including para ID and sentence ID. The task: trying to rebuild the original text.\nGet 500 consecutive words from DB\nwords = Words.objects.all()[wordId:wordId+500]\n# I first create paragraphs, through which I can loop later in my django template,\n# and in each para will be a list of words (also dictionaries). \n# So i am trying to get a dictionary with values that are lists of dictionaries. \n# 'pp' i make just for shorthanding a long-named variable.\nparas={}\npara_high = para_low =  words[0].belongs_to_paragraph\nfor w in words:\n    last_word = w\n    pp = w.belongs_to_paragraph\n    if pp >para_high:\n        para_high = pp\n    if pp < para_low:\n        para_low = pp\n    if pp in paras:\n        paras[pp].append(w)\n    else:\n        list = [w]\n        paras[pp] = list\n# Since there are blank lines between paragraphs, in rebuilding the text as it \n    #  looked originally, I need to insert blank lines. \n    # Since i have the ID's of the paragraphs and they go somewhat like that: 1,3,4,8,9 \n    #(the gaps between 1 & 3 and 4 & 8 i have to fill in with something else, \n    # which is why i had para_low and para_high to loop the range. \nisbr = True\nfor i in range(para_low, para_high+1):\n    if i in paras:\n        isbr = True\n    else:\n        if isbr:\n            paras[i]=['break']\n            isbr = False\n        else:\n            paras[i]=[]\n\nAt this point, however, if I try to loop the dict and rebuild the text, some later id'd paragraphs come before previous ones, and that just doesn't do it.\nUPDATE 2, loop code:\n        {% for k,v in wording.iteritems()  %}\n        {% if v[0] == 'break' %}\n        <br/>\n        {% else %}\n        </div> <div class=\"p\">{% for word in v %}{% if word.special==0%} {% endif %} <span class=\"word {% if word.special == 0%}clickable{% endif%}\" wid=\"{{word.id}}\" special=\"{{word.special}}\" somethingElse={{word.somethingElse}}>{{ word.word }} </span>{% endfor %}\n        {% endif %}\n    {% endfor %}\n\n",
  "preds": {
   "base:Baseline": "sorted(list(o.items()), key=lambda x: x[1])",
   "body:Baseline": "sorted(list(o.items()), key=lambda x: x[1], reverse=True)",
   "body:-Blocks": "sorted(o, key=lambda x: x[1])",
   "body:-Code": "sorted(list(o.items()), key=lambda x: x[1])",
   "body:-Inline": "sorted(o, key=lambda x: x[1])",
   "body:-NL": "sorted(o, key=lambda x: x[1])",
   "base:+Mined": "sorted(list(o.items()), key=lambda x: x[1])",
   "body+mined:Baseline": "sorted(o, key=itemgetter(1), reverse=True)",
   "body+mined:-Code": "sorted(list(o.items()), key=lambda x: x[1])",
   "body+mined:-NL": "sorted(list(o.items()), key=lambda x: x[1])",
   "body+mined:-Blocks": "sorted(list(o.items()), key=lambda x: x[1])",
   "body+mined:-Inline": "sorted(list(o.items()), key=lambda x: x[1])"
  },
  "snippet": "sorted(o.items())"
 },
 "4642501.219": {
  "intent": "get sorted list of keys of dict `d`",
  "body": "Can anyone tell me how I can sort this:\n{'a': [1, 2, 3], 'c': ['one', 'two'], 'b': ['blah', 'bhasdf', 'asdf'], 'd': ['asdf', 'wer', 'asdf', 'zxcv']}\n\ninto\n{'a': [1, 2, 3], 'b': ['blah', 'bhasdf', 'asdf'], 'c': ['one', 'two'],'d': ['asdf', 'wer', 'asdf', 'zxcv']}\n\n?\nThanks!\nUPDATE 1, code sample:\nSo I am doing linguistics. One article is broken down to words that are stored in a database and have all kinds of properties including para ID and sentence ID. The task: trying to rebuild the original text.\nGet 500 consecutive words from DB\nwords = Words.objects.all()[wordId:wordId+500]\n# I first create paragraphs, through which I can loop later in my django template,\n# and in each para will be a list of words (also dictionaries). \n# So i am trying to get a dictionary with values that are lists of dictionaries. \n# 'pp' i make just for shorthanding a long-named variable.\nparas={}\npara_high = para_low =  words[0].belongs_to_paragraph\nfor w in words:\n    last_word = w\n    pp = w.belongs_to_paragraph\n    if pp >para_high:\n        para_high = pp\n    if pp < para_low:\n        para_low = pp\n    if pp in paras:\n        paras[pp].append(w)\n    else:\n        list = [w]\n        paras[pp] = list\n# Since there are blank lines between paragraphs, in rebuilding the text as it \n    #  looked originally, I need to insert blank lines. \n    # Since i have the ID's of the paragraphs and they go somewhat like that: 1,3,4,8,9 \n    #(the gaps between 1 & 3 and 4 & 8 i have to fill in with something else, \n    # which is why i had para_low and para_high to loop the range. \nisbr = True\nfor i in range(para_low, para_high+1):\n    if i in paras:\n        isbr = True\n    else:\n        if isbr:\n            paras[i]=['break']\n            isbr = False\n        else:\n            paras[i]=[]\n\nAt this point, however, if I try to loop the dict and rebuild the text, some later id'd paragraphs come before previous ones, and that just doesn't do it.\nUPDATE 2, loop code:\n        {% for k,v in wording.iteritems()  %}\n        {% if v[0] == 'break' %}\n        <br/>\n        {% else %}\n        </div> <div class=\"p\">{% for word in v %}{% if word.special==0%} {% endif %} <span class=\"word {% if word.special == 0%}clickable{% endif%}\" wid=\"{{word.id}}\" special=\"{{word.special}}\" somethingElse={{word.somethingElse}}>{{ word.word }} </span>{% endfor %}\n        {% endif %}\n    {% endfor %}\n\n",
  "preds": {
   "base:Baseline": "sorted(list(d.keys())",
   "body:Baseline": "sorted(list(d.keys()), key=lambda x: x[1], reverse=True)",
   "body:-Blocks": "sorted(d, key=lambda x: x[1])",
   "body:-Code": "sorted(list(d.items()), key=lambda x: x[1])",
   "body:-Inline": "sorted(list(d.keys()), key=lambda x: x[1])",
   "body:-NL": "sorted(list(d.keys()), key=lambda x: x[1])",
   "base:+Mined": "sorted(d, key=d.get)",
   "body+mined:Baseline": "sorted(list(d.items()), key=lambda x: x[1])",
   "body+mined:-Code": "sorted(list(d.items()), key=lambda x: x[1])",
   "body+mined:-NL": "sorted(list(d.items()), key=lambda x: x[1])",
   "body+mined:-Blocks": "sorted(list(d.items()), key=lambda x: x[1])",
   "body+mined:-Inline": "sorted(d, key=lambda x: x[1])"
  },
  "snippet": "sorted(d)"
 },
 "4642501.220": {
  "intent": "how to sort dictionaries by keys in python",
  "body": "Can anyone tell me how I can sort this:\n{'a': [1, 2, 3], 'c': ['one', 'two'], 'b': ['blah', 'bhasdf', 'asdf'], 'd': ['asdf', 'wer', 'asdf', 'zxcv']}\n\ninto\n{'a': [1, 2, 3], 'b': ['blah', 'bhasdf', 'asdf'], 'c': ['one', 'two'],'d': ['asdf', 'wer', 'asdf', 'zxcv']}\n\n?\nThanks!\nUPDATE 1, code sample:\nSo I am doing linguistics. One article is broken down to words that are stored in a database and have all kinds of properties including para ID and sentence ID. The task: trying to rebuild the original text.\nGet 500 consecutive words from DB\nwords = Words.objects.all()[wordId:wordId+500]\n# I first create paragraphs, through which I can loop later in my django template,\n# and in each para will be a list of words (also dictionaries). \n# So i am trying to get a dictionary with values that are lists of dictionaries. \n# 'pp' i make just for shorthanding a long-named variable.\nparas={}\npara_high = para_low =  words[0].belongs_to_paragraph\nfor w in words:\n    last_word = w\n    pp = w.belongs_to_paragraph\n    if pp >para_high:\n        para_high = pp\n    if pp < para_low:\n        para_low = pp\n    if pp in paras:\n        paras[pp].append(w)\n    else:\n        list = [w]\n        paras[pp] = list\n# Since there are blank lines between paragraphs, in rebuilding the text as it \n    #  looked originally, I need to insert blank lines. \n    # Since i have the ID's of the paragraphs and they go somewhat like that: 1,3,4,8,9 \n    #(the gaps between 1 & 3 and 4 & 8 i have to fill in with something else, \n    # which is why i had para_low and para_high to loop the range. \nisbr = True\nfor i in range(para_low, para_high+1):\n    if i in paras:\n        isbr = True\n    else:\n        if isbr:\n            paras[i]=['break']\n            isbr = False\n        else:\n            paras[i]=[]\n\nAt this point, however, if I try to loop the dict and rebuild the text, some later id'd paragraphs come before previous ones, and that just doesn't do it.\nUPDATE 2, loop code:\n        {% for k,v in wording.iteritems()  %}\n        {% if v[0] == 'break' %}\n        <br/>\n        {% else %}\n        </div> <div class=\"p\">{% for word in v %}{% if word.special==0%} {% endif %} <span class=\"word {% if word.special == 0%}clickable{% endif%}\" wid=\"{{word.id}}\" special=\"{{word.special}}\" somethingElse={{word.somethingElse}}>{{ word.word }} </span>{% endfor %}\n        {% endif %}\n    {% endfor %}\n\n",
  "preds": {
   "base:Baseline": "sorted(list(d.items()), key=lambda x: x[1])",
   "body:Baseline": "sorted(list(d.items()), key=lambda x: x[1], reverse=True)",
   "body:-Blocks": "sorted(list(d.items()), key=lambda x: x[1])",
   "body:-Code": "sorted(list(d.items()), key=lambda x: x[1])",
   "body:-Inline": "sorted(list(d.items()), key=lambda x: x[1])",
   "body:-NL": "sorted(list(d.items()), key=lambda x: x[1])",
   "base:+Mined": "sorted(list(d.items()), key=lambda x: x[1])",
   "body+mined:Baseline": "sorted(list(d.items()), key=lambda x: x[1])",
   "body+mined:-Code": "sorted(list(d.items()), key=lambda x: x[1])",
   "body+mined:-NL": "['a', 'b', 'c', 'd', 'asdf', 'zxcv']",
   "body+mined:-Blocks": "sorted(list(d.items()), key=lambda x: x[1])",
   "body+mined:-Inline": "sorted(words, key=lambda x: x[1])"
  },
  "snippet": "sorted(d.items())"
 },
 "642154.221": {
  "intent": "convert string \"1\" into integer",
  "body": "I have a tuple of tuples from a MySQL query like this:\nT1 = (('13', '17', '18', '21', '32'),\n      ('07', '11', '13', '14', '28'),\n      ('01', '05', '06', '08', '15', '16'))\n\nI'd like to convert all the string elements into integers and put them back into a list of lists:\nT2 = [[13, 17, 18, 21, 32], [7, 11, 13, 14, 28], [1, 5, 6, 8, 15, 16]]\n\nI tried to achieve it with eval  but didn't get any decent result yet.\n",
  "preds": {
   "base:Baseline": "int('1', 1))\nmap(int, re.findall('\\n')",
   "body:Baseline": "map(int, map(map(lambda x: x[1], reverse=True))",
   "body:-Blocks": "map(int, x.split('1')))",
   "body:-Code": "[int(x) for x in enumerate(1, 2)]",
   "body:-Inline": "int(map(int, x, 16))",
   "body:-NL": "int('1').decode('int')",
   "base:+Mined": "int('1' + str(i))",
   "body+mined:Baseline": "[int(x) for x in T2]",
   "body+mined:-Code": "map(int, ['1', '2', '3'])",
   "body+mined:-NL": "ast.literal_eval(\"1\"\")",
   "body+mined:-Blocks": "[int(x) for x in '1']",
   "body+mined:-Inline": "[int(x) for x in T2]"
  },
  "snippet": "int('1')"
 },
 "642154.222": {
  "intent": "function to convert strings into integers",
  "body": "I have a tuple of tuples from a MySQL query like this:\nT1 = (('13', '17', '18', '21', '32'),\n      ('07', '11', '13', '14', '28'),\n      ('01', '05', '06', '08', '15', '16'))\n\nI'd like to convert all the string elements into integers and put them back into a list of lists:\nT2 = [[13, 17, 18, 21, 32], [7, 11, 13, 14, 28], [1, 5, 6, 8, 15, 16]]\n\nI tried to achieve it with eval  but didn't get any decent result yet.\n",
  "preds": {
   "base:Baseline": "int(s) for s in re.findall('\\\\d+', 16)",
   "body:Baseline": "[i for i, j in enumerate(zip(tuple, tuple), tuple)) for tuple in list(T1, T2)]",
   "body:-Blocks": "map(int, x.split())",
   "body:-Code": "map(int, sublist, zip(*map(lambda x: x.split())))",
   "body:-Inline": "map(int, x.split())",
   "body:-NL": "[int(x) for x in zip(T1, T2)]",
   "base:+Mined": "map(int, inputstring.split(','))",
   "body+mined:Baseline": "map(int, T2.split())",
   "body+mined:-Code": "[map(int, x) for x in rows]",
   "body+mined:-NL": "map(int, ['13', '17', '18', '21', '32'])",
   "body+mined:-Blocks": "map(int, [''.join(str(i) for i in rows])",
   "body+mined:-Inline": "[int(x) for x in T2]"
  },
  "snippet": "int()"
 },
 "642154.223": {
  "intent": "convert items in `t1` to integers",
  "body": "I have a tuple of tuples from a MySQL query like this:\nT1 = (('13', '17', '18', '21', '32'),\n      ('07', '11', '13', '14', '28'),\n      ('01', '05', '06', '08', '15', '16'))\n\nI'd like to convert all the string elements into integers and put them back into a list of lists:\nT2 = [[13, 17, 18, 21, 32], [7, 11, 13, 14, 28], [1, 5, 6, 8, 15, 16]]\n\nI tried to achieve it with eval  but didn't get any decent result yet.\n",
  "preds": {
   "base:Baseline": "int(map(int(t1))",
   "body:Baseline": "[i for i, j in zip(t1, t2)]",
   "body:-Blocks": "[int(x) for x in t1]",
   "body:-Code": "map(int, tuple(t1))",
   "body:-Inline": "map(int, x.split())",
   "body:-NL": "[int(x) for x in zip(t1, t2)]",
   "base:+Mined": "int(str(i) for i in t1)",
   "body+mined:Baseline": "[int(x) for x in T1]",
   "body+mined:-Code": "t1 = [int(i) for i in t1]",
   "body+mined:-NL": "ast.literal_eval(t1)",
   "body+mined:-Blocks": "[int(x) for x in t1]",
   "body+mined:-Inline": "map(int, zip(*t1))"
  },
  "snippet": "T2 = [map(int, x) for x in T1]"
 },
 "3777301.224": {
  "intent": "call a shell script `./test.sh` using subprocess",
  "body": "How to call a shell script from python code?\n",
  "preds": {
   "base:Baseline": "subprocess.call('./test.sh', shell=True)",
   "body:Baseline": "subprocess.call('./test.sh', shell=True)",
   "body:-Blocks": "subprocess.call('./test.sh', shell=True)",
   "body:-Code": "subprocess.call('./test.sh', shell=True)",
   "body:-Inline": "subprocess.call('./test.sh', shell=True)",
   "body:-NL": "subprocess.call('./test.sh')",
   "base:+Mined": "subprocess.call('./test.sh', shell=True)",
   "body+mined:Baseline": "subprocess.call('./test.sh', shell=True)",
   "body+mined:-Code": "subprocess.call('./test.sh', shell=True)",
   "body+mined:-NL": "subprocess.call(['./test.sh', shell=True)",
   "body+mined:-Blocks": "subprocess.call('/test.sh', shell=True)",
   "body+mined:-Inline": "subprocess.call('./test.sh', shell=True)"
  },
  "snippet": "subprocess.call(['./test.sh'])"
 },
 "3777301.225": {
  "intent": "call a shell script `notepad` using subprocess",
  "body": "How to call a shell script from python code?\n",
  "preds": {
   "base:Baseline": "subprocess.call('notepad', shell=True)",
   "body:Baseline": "subprocess.call('notepad', shell=True)",
   "body:-Blocks": "subprocess.call('notepad', shell=True)",
   "body:-Code": "subprocess.call('notepad', shell=True)",
   "body:-Inline": "subprocess.call('notepad', shell=True)",
   "body:-NL": "subprocess.call('notepad', shell=True)",
   "base:+Mined": "subprocess.call('notepad', shell=True)",
   "body+mined:Baseline": "subprocess.call(['notepad', 'notepad'])",
   "body+mined:-Code": "subprocess.call('notepad', shell=True)",
   "body+mined:-NL": "subprocess.call(['notepad', 'notepad'])",
   "body+mined:-Blocks": "subprocess.call(['notepad', '/r'])",
   "body+mined:-Inline": "subprocess.call(['notepad', 'notepad'])"
  },
  "snippet": "subprocess.call(['notepad'])"
 },
 "7946798.226": {
  "intent": "combine lists `l1` and `l2`  by alternating their elements",
  "body": "In Python, is there a good way to interleave two lists of the same length?\nSay I'm given [1,2,3]  and [10,20,30] . I'd like to transform those into [1,10,2,20,3,30] .\n",
  "preds": {
   "base:Baseline": "[i for i, j in zip(l1, l2)]",
   "body:Baseline": "[i for i, j in zip(l1, l2)]",
   "body:-Blocks": "[i for i, j in zip(l1, l2)]",
   "body:-Code": "[i for i, j in zip(l1, l2)]",
   "body:-Inline": "zip(l1, l2)",
   "body:-NL": "[i for i, j in zip(l1, l2)]",
   "base:+Mined": "[(x + y) for x, y in zip(l1, l2)]",
   "body+mined:Baseline": "[(x + y) for x, y in zip(l1, l2)]",
   "body+mined:-Code": "[(x + y) for x, y in zip(l1, l2)]",
   "body+mined:-NL": "from functools import reduce\nreduce(lambda x, y: x + y, l1, l2)",
   "body+mined:-Blocks": "[(x + y) for x, y in zip(l1, l2)]",
   "body+mined:-Inline": "[(x + y) for x, y in zip(l1, l2)]"
  },
  "snippet": "[val for pair in zip(l1, l2) for val in pair]"
 },
 "8908287.227": {
  "intent": "encode string 'data to be encoded'",
  "body": "Following this python example , I encode a string as Base64 with:\nimport base64\nencoded = base64.b64encode(b'data to be encoded')\nencoded\nb'ZGF0YSB0byBiZSBlbmNvZGVk'\n\nBut, if I leave out the leading b :\nencoded = base64.b64encode('data to be encoded')\n\nI get the following error:\nTraceback (most recent call last):\n  File \" <stdin>\", line 1, in <module>\n  File \"C:\\Python32\\lib\\base64.py\", line 56, in b64encode\n   raise TypeError(\"expected bytes, not %s\" % s.__class__.__name__)\n   TypeError: expected bytes, not str\n\nWhy is this?\n",
  "preds": {
   "base:Baseline": "\"\"\"data to be encoded\"\"\".encode('utf-8')",
   "body:Baseline": "struct.encode('data to be encoded')",
   "body:-Blocks": "\"\"\"data to be encoded\"\"\".encode('utf-8')",
   "body:-Code": "struct.encode('data to be encoded')",
   "body:-Inline": "struct.encode('data to be encoded')",
   "body:-NL": "struct.encode('data to be encoded')",
   "base:+Mined": "data.encode('utf-8')",
   "body+mined:Baseline": "encoded = base64.b64encode('data to be encoded')",
   "body+mined:-Code": "\"\"\"data to be encoded\"\"\".encode('base64')",
   "body+mined:-NL": "base64.b64encode('data to be encoded')",
   "body+mined:-Blocks": "\"\"\"data to be encoded\"\"\".encode('base64')",
   "body+mined:-Inline": "encoded = base64.b64encode('data to be encoded')"
  },
  "snippet": "encoded = base64.b64encode('data to be encoded')"
 },
 "8908287.228": {
  "intent": "encode a string `data to be encoded` to `ascii` encoding",
  "body": "Following this python example , I encode a string as Base64 with:\nimport base64\nencoded = base64.b64encode(b'data to be encoded')\nencoded\nb'ZGF0YSB0byBiZSBlbmNvZGVk'\n\nBut, if I leave out the leading b :\nencoded = base64.b64encode('data to be encoded')\n\nI get the following error:\nTraceback (most recent call last):\n  File \" <stdin>\", line 1, in <module>\n  File \"C:\\Python32\\lib\\base64.py\", line 56, in b64encode\n   raise TypeError(\"expected bytes, not %s\" % s.__class__.__name__)\n   TypeError: expected bytes, not str\n\nWhy is this?\n",
  "preds": {
   "base:Baseline": "ascii.encode('data to be encoded')",
   "body:Baseline": "struct.encode('data to be encoded')",
   "body:-Blocks": "ascii.encode('data to be encoded')",
   "body:-Code": "ascii.encode('data to be encoded')",
   "body:-Inline": "struct.encode('data to be encoded')",
   "body:-NL": "struct.encode('data to be encoded')",
   "base:+Mined": "encodedata.encode('ascii', 'ignore')",
   "body+mined:Baseline": "encoded = base64.b64encode('data to be encoded')",
   "body+mined:-Code": "ascii.encode('base64')",
   "body+mined:-NL": "base64.b64encode('data to be encoded')",
   "body+mined:-Blocks": "ascii.encode('base64')",
   "body+mined:-Inline": "encoded = base64.b64encode('data to be encoded')"
  },
  "snippet": "encoded = 'data to be encoded'.encode('ascii')"
 },
 "7856296.229": {
  "intent": "parse tab-delimited csv file 'text.txt' into a list",
  "body": "I currently have a CSV file which, when opened in Excel, has a total of 5 columns. Only columns A and C are of any significance to me and the data in the remaining columns is irrelevant.\nStarting on line 8 and then working in multiples of 7 (ie. lines 8, 15, 22, 29, 36 etc...), I am looking to create a dictionary with Python 2.7 with the information from these fields. The data in column A will be the key (a 6-digit integer) and the data in column C being the respective value for the key. I've tried to highlight this below but the formatting isn't the best:-\n    A        B      C          D\n1                           CDCDCDCD  \n2                           VDDBDDB\n3\n4\n5\n6\n7  DDEFEEF                   FEFEFEFE\n8  123456         JONES\n9\n10\n11\n12\n13\n14\n15 293849         SMITH\n\nAs per the above, I am looking to extract the value from A7 (DDEFEEF) as a key in my dictionary and \"FEFEFEFE\" being the respective data and then add another entry to my dictionary, jumping to line 15 with \"2938495\" being my key and \"Smith\" being the respective value.\nAny suggestions? The source file is a .txt file with entries being tab-delimited.\nThanks\nClarification:\nJust to clarify, so far, I have tried the below:-\nimport csv\n\nmydict = {:}\nf = open(\"myfile\", 'rt')\nreader = csv.reader(f)\n    for row in reader:\n        print row\n\nThe above simply prints out all content though a row at a time. I did try \"for row(7) in reader\" but this returned an error. I then researched it and had a go at the below but it didn't work neither:\nimport csv\nfrom itertools import islice\n\nentries = csv.reader(open(\"myfile\", 'rb'))\nmydict = {'key' : 'value'}\n\nfor i in xrange(6):\n    mydict['i(0)] = 'I(2)    # integers representing columns\n    range = islice(entries,6)\n    for entry in range:\n        mydict[entries(0) = entries(2)] # integers representing columns\n\n",
  "preds": {
   "base:Baseline": "list('text.txt', delimiter=',')",
   "body:Baseline": "df = open('text.txt', 'rt')",
   "body:-Blocks": "[open('text.txt', 'rb').read()]",
   "body:-Code": "list('text.txt', delimiter=',')",
   "body:-Inline": "df = open('text.txt', 'rt')",
   "body:-NL": "list('text.txt', delimiter=',')",
   "base:+Mined": "[item for sublist in open('text.txt', 'rb').read()]",
   "body+mined:Baseline": "[row[0] for row in reader]",
   "body+mined:-Code": "[row[0] for row in reader]",
   "body+mined:-NL": "list(open('myfile', 'rb'))",
   "body+mined:-Blocks": "list(open('text.txt', 'rb').read().split()))",
   "body+mined:-Inline": "f = csv.reader(f)"
  },
  "snippet": "lol = list(csv.reader(open('text.txt', 'rb'), delimiter='\\t'))"
 },
 "9035479.230": {
  "intent": "get attribute `my_str` of object `my_object`",
  "body": "my_object.name = 'stuff'\nmy_str = 'name'\nmy_object[my_str] # won't work because it's not a dictionary :)\n\nHow can I access to the fields of my_object  defined on my_str  ?\n",
  "preds": {
   "base:Baseline": "my_object.getattr(my_str)",
   "body:Baseline": "my_object[my_str]",
   "body:-Blocks": "my_object.getattr(my_str)",
   "body:-Code": "my_object.getattr(my_str)",
   "body:-Inline": "my_object[my_str]",
   "body:-NL": "my_object[__name__]",
   "base:+Mined": "my_str = my_object.getattr(my_object)",
   "body+mined:Baseline": "getattr(my_object, my_str)",
   "body+mined:-Code": "getattr(my_object, my_str)",
   "body+mined:-NL": "my_object.getattr(my_str)",
   "body+mined:-Blocks": "getattr(my_object, my_object)",
   "body+mined:-Inline": "getattr(my_object, 'name', None)"
  },
  "snippet": "getattr(my_object, my_str)"
 },
 "5558418.231": {
  "intent": "group a list of dicts `ld` into one dict by key",
  "body": "I am looking to change back and forth between a dictionary of lists (all of the same length):\nDL = {'a': [0, 1], 'b': [2, 3]}\n\nand a list of dictionaries:\nLD = [{'a': 0, 'b': 2}, {'a': 1, 'b': 3}]\n\nI am looking for the cleanest way to switch between the two forms.\n",
  "preds": {
   "base:Baseline": "dict((k, v) for k, v in list(ld.items()))",
   "body:Baseline": "dict((k, v) for k, v in zip(DL, LD)]",
   "body:-Blocks": "dict((k, v) for k, v in list(d.items()))",
   "body:-Code": "dict((k, v) for k, v in list(ld.items()))",
   "body:-Inline": "[d['a'] for d in DL]",
   "body:-NL": "[d['a'] for d in LD]",
   "base:+Mined": "dict((k, v) for k, v in list(ld.items()))",
   "body+mined:Baseline": "[dict(zip(DL, LD)) for x in LD]",
   "body+mined:-Code": "dict((k, v) for k, v in list(d.items()) for d in l)",
   "body+mined:-NL": "[dict(zip(DL, LD)) for x in LD]",
   "body+mined:-Blocks": "dict((k, v) for k, v in list(ld.items()) for v in d.items()))",
   "body+mined:-Inline": "[dict(zip(DL, LD)) for x in list(LD.items())]"
  },
  "snippet": "print(dict(zip(LD[0], zip(*[list(d.values()) for d in LD]))))"
 },
 "638048.232": {
  "intent": "how do i sum the first value in each tuple in a list of tuples in python?",
  "body": "I have a list of tuples (always pairs) like this:\n[(0, 1), (2, 3), (5, 7), (2, 1)]\n\nI'd like to find the sum of the first items in each pair, i.e.:\n0 + 2 + 5 + 2\n\nHow can I do this in Python? At the moment I'm iterating through the list: \nsum = 0\nfor pair in list_of_pairs:\n   sum += pair[0]\n\nI have a feeling there must be a more Pythonic way.\n",
  "preds": {
   "base:Baseline": "sum(x[0] for x in zip(*my_list, my_list))",
   "body:Baseline": "sum(x * y) for x, y in zip(zip(list_of_pairs), reverse=True)",
   "body:-Blocks": "sum(x[0] for x in zip(*tuple(zip(x), x[0]), reverse=True)",
   "body:-Code": "sum(x[0] for x in zip(*my_list))",
   "body:-Inline": "sum(x[0] for x in zip(*my_list)",
   "body:-NL": "sum(x[0] for x in zip(*list_of_pairs)]",
   "base:+Mined": "sum(x[0] for x in l)",
   "body+mined:Baseline": "sum(x[0] for x in list_of_pairs)",
   "body+mined:-Code": "print(sum(x[0] for x in l))",
   "body+mined:-NL": "sum(x[0] for x in list_of_pairs)",
   "body+mined:-Blocks": "sum(x[0] for x in l)",
   "body+mined:-Inline": "sum(x[0] for x in list_of_pairs)"
  },
  "snippet": "sum([pair[0] for pair in list_of_pairs])"
 },
 "14950260.233": {
  "intent": "convert unicode string u\"{'code1':1,'code2':1}\" into dictionary",
  "body": "I have unicode u\"{'code1':1,'code2':1}\"  and I want it in dictionary format.\nI want it in {'code1':1,'code2':1}  format.\nI tried unicodedata.normalize('NFKD', my_data).encode('ascii','ignore')  but it returns string not dictionary.\nCan anyone help me?\n",
  "preds": {
   "base:Baseline": "dict((k, v) for k, v in u.split('{'code1': 1,'code2': 1})",
   "body:Baseline": "dict((k, v) for k, v in unicodedata.normalize('NFKD', {'code1': 1, 'code2': 1})\n    )",
   "body:-Blocks": "dict((k, v) for k, v in unicodedata.normalize('NFKD', my_data).encode('ascii','ignore')",
   "body:-Code": "dict((k, v) for k, v in {'code1': 1, 'code2': 1})",
   "body:-Inline": "dict('{'code1': 1,' 'code2': 1}'.decode('unicode_escape')",
   "body:-NL": "dict((k, v) for k, v in u.items() if v != 1)",
   "base:+Mined": "{'code1': 1, 'code2': 1}",
   "body+mined:Baseline": "{'code1': 1, 'code2': 1}",
   "body+mined:-Code": "dict(k.encode('utf-8') for k in u.decode('unicode-escape'))",
   "body+mined:-NL": "'{'code1': 1,'code2': 1}'.encode('ascii', 'ignore')",
   "body+mined:-Blocks": "unicodedata.normalize('NFKD', my_data).encode('ascii', 'ignore')",
   "body+mined:-Inline": "\"\"\"\"\"\".join(c for c in \"{'code1': 1,'code2': 1}\")"
  },
  "snippet": "d = ast.literal_eval(\"{'code1':1,'code2':1}\")"
 },
 "11416772.234": {
  "intent": "find all words in a string `mystring` that start with the `$` sign",
  "body": "How can I extract all words in a string that start with the $ sign? For example in the string\nThis $string is an $example\n\nI want to extract the words $string  and $example .\nI tried with this regex \\b[$]\\S*  but it works fine only if I use a normal character rather than dollar.\n",
  "preds": {
   "base:Baseline": "re.findall('\\\\d+$', myString)",
   "body:Baseline": "re.findall('\\\\b[$]\\\\S*', mystring)",
   "body:-Blocks": "re.findall('\\\\b[$]\\\\S*', mystring)",
   "body:-Code": "re.findall('\\\\w+)', myString)",
   "body:-Inline": "re.findall('\\\\w+)', mystring)",
   "body:-NL": "re.findall('\\\\b[$]', mystring)",
   "base:+Mined": "re.findall('\\\\w+', mystring)",
   "body+mined:Baseline": "re.findall('\\\\b[$]\\\\S*', mystring)",
   "body+mined:-Code": "re.findall('\\\\b$,', mystring)",
   "body+mined:-NL": "re.findall('\\\\b[$]', mystring)",
   "body+mined:-Blocks": "re.findall('\\\\b[$]\\\\S*', mystring)",
   "body+mined:-Inline": "re.findall('\\\\w(\\\\w+)', mystring)"
  },
  "snippet": "[word for word in mystring.split() if word.startswith('$')]"
 },
 "11331982.235": {
  "intent": "remove any url within string `text`",
  "body": "I want to remove all URLs inside a string (replace them with \"\")\nI searched around but couldn't really find what I want.\nExample:\ntext1\ntext2\nhttp://url.com/bla1/blah1/\ntext3\ntext4\nhttp://url.com/bla2/blah2/\ntext5\ntext6\nhttp://url.com/bla3/blah3/\n\nI want the result to be:\ntext1\ntext2\ntext3\ntext4\ntext5\ntext6\n\n",
  "preds": {
   "base:Baseline": "r = re.sub('[^a-zA-Z]', text)",
   "body:Baseline": "text = re.sub('/', text)",
   "body:-Blocks": "re.sub('(?=)', '', text)",
   "body:-Code": "re.sub('(?=\\\\)', text)",
   "body:-Inline": "re.sub('(?=)', text)",
   "body:-NL": "text = re.sub('[^]', '', text)",
   "base:+Mined": "re.sub('\\\\s+', '', text)",
   "body+mined:Baseline": "text = re.sub('(.*?\\\\)', '\\\\1', text)",
   "body+mined:-Code": "re.sub('[^\"]', '', text)",
   "body+mined:-NL": "text = url.replace('/', '')",
   "body+mined:-Blocks": "re.sub('[^\"]*', '', text)",
   "body+mined:-Inline": "text = re.sub('(.*?\\\\)', '\\\\1', text)"
  },
  "snippet": "text = re.sub('^https?:\\\\/\\\\/.*[\\\\r\\\\n]*', '', text, flags=re.MULTILINE)"
 },
 "34945274.236": {
  "intent": "replace all elements in array `a` that are not present in array `[1, 3, 4]` with zeros",
  "body": "I have a 2-dimensional NumPy array, for example:\narray([[1, 1, 0, 2, 2],\n       [1, 1, 0, 2, 0],\n       [0, 0, 0, 0, 0],\n       [3, 3, 0, 4, 4],\n       [3, 3, 0, 4, 4]])\n\nI would like to get all elements from that array which are in a certain list, for example (1, 3, 4). The desired result in the example case would be:\narray([[1, 1, 0, 0, 0],\n       [1, 1, 0, 0, 0],\n       [0, 0, 0, 0, 0],\n       [3, 3, 0, 4, 4],\n       [3, 3, 0, 4, 4]])\n\nI know that I can just do (as recommended here Numpy: find elements within range ):\nnp.logical_or(\n    np.logical_or(cc_labeled == 1, cc_labeled == 3),\n    cc_labeled == 4\n)\n\n, but this will be only reasonably effective in the example case. In reality iteratively using for loop and numpy.logical_or turned out to be really slow since the list of possible values is in thousands (and numpy array has approximately the dimension of 1000 x 1000).\n",
  "preds": {
   "base:Baseline": "[x for x in a if x not in [1, 3, 4])",
   "body:Baseline": "np.all(a != [1, 3, 4], zeros=1)",
   "body:-Blocks": "np.all(a != [1, 3, 4])",
   "body:-Code": "numpy.replace([1, 3, 4])",
   "body:-Inline": "np.all(a != [1, 3, 4])",
   "body:-NL": "np.all(a == [1, 3, 4], axis=1)",
   "base:+Mined": "np.in1d(a, [1, 3, 4])",
   "body+mined:Baseline": "[x for x in a if x not in [1, 3, 4]]",
   "body+mined:-Code": "a[np.any(a != [1, 3, 4])]",
   "body+mined:-NL": "np.logical_or(a, [1, 3, 4], axis=1)",
   "body+mined:-Blocks": "np.all(a!= [1, 3, 4]]",
   "body+mined:-Inline": "np.logical_or(a[i] for i in a[1, 3, 4]]"
  },
  "snippet": "np.where(np.in1d(A, [1, 3, 4]).reshape(A.shape), A, 0)"
 },
 "15819980.237": {
  "intent": "calculate mean across dimension in a 2d array `a`",
  "body": "I have an array a  like this:\na = [[40, 10], [50, 11]]\n\nI need to calculate the mean for each dimension separately, the result should be this:\n[45, 10.5]\n\n45  being the mean of a[*][0]  and 10.5  the mean of a[*][1] .\nWhat is the most elegant way of solving this without using a loop?\n",
  "preds": {
   "base:Baseline": "np.mean(a, axis=1)",
   "body:Baseline": "sum(np.arange(a), axis=1)",
   "body:-Blocks": "np.mean(a, a[*][1])",
   "body:-Code": "np.mean(a, axis=1)",
   "body:-Inline": "np.mean(a, axis=1)",
   "body:-NL": "sum(np.mean(a))",
   "base:+Mined": "np.mean(a, axis=1)",
   "body+mined:Baseline": "a.mean(axis=1)",
   "body+mined:-Code": "A.mean(axis=1)",
   "body+mined:-NL": "np.mean(a, axis=1)",
   "body+mined:-Blocks": "a.mean(axis=1)",
   "body+mined:-Inline": "A.mean(axis=1)"
  },
  "snippet": "np.mean(a, axis=1)"
 },
 "19894365.238": {
  "intent": "running r script '/pathto/myrscript.r' from python",
  "body": "I searched for this question and found some answers on this, but none of them seem to work. This is the script that I'm using in python to run my R script.\nimport subprocess\nretcode = subprocess.call(\"/usr/bin/Rscript --vanilla -e 'source(\\\"/pathto/MyrScript.r\\\")'\", shell=True)\n\nand I get this error:\nError in read.table(file = file, header = header, sep = sep, quote = quote,  : \n  no lines available in input\nCalls: source withVisible -> eval -> eval -> read.csv -> read.table\nExecution halted\n\nand here is the content of my R script (pretty simple!)\ndata = read.csv('features.csv')\ndata1 = read.csv(\"BagofWords.csv\")\nmerged = merge(data,data1)\nwrite.table(merged, \"merged.csv\",quote=FALSE,sep=\",\",row.names=FALSE)\nfor (i in 1:length(merged$fileName))\n{\n        fileConn <-file(paste(\"output/\",toString(merged$fileName[i]),\".txt\",sep=\"\"))\n        writeLines((toString(merged$BagofWord[i])),fileConn)\n        close(fileConn)\n}\n\nThe r script is working fine, when I use source('MyrScript.r')  in r commandline. Moreover, when I try to use the exact command which I pass to the subprocess.call  function (i.e., /usr/bin/Rscript --vanilla -e 'source(\"/pathto/MyrScript.r\")' ) in my commandline it works find, I don't really get what's the problem.\n",
  "preds": {
   "base:Baseline": "os.system('/pathTo/myrscript.r')",
   "body:Baseline": "subprocess.call('/usr/bin/Rscript --vanilla -e'source('/pathto/MyrScript.r')')",
   "body:-Blocks": "subprocess.call('/pathto/myrscript.r')",
   "body:-Code": "os.system('/pathTo/myrscript.r')",
   "body:-Inline": "subprocess.call('/pathto/myrscript.r')",
   "body:-NL": "subprocess.call('/pathto/myrscript.r')",
   "base:+Mined": "os.system('/pathTo/myrscript.r')",
   "body+mined:Baseline": "subprocess.call('/pathto/myrscript.r', shell=True)",
   "body+mined:-Code": "subprocess.call('/path/to/myrscript.r', shell=True)",
   "body+mined:-NL": "subprocess.call('/pathto/myrscript.r')",
   "body+mined:-Blocks": "subprocess.call('/pathto/myrscript.r', shell=True)",
   "body+mined:-Inline": "subprocess.call('/pathto/myrscript.r', shell=True)"
  },
  "snippet": "subprocess.call(['/usr/bin/Rscript', '--vanilla', '/pathto/MyrScript.r'])"
 },
 "19894365.239": {
  "intent": "run r script '/usr/bin/rscript --vanilla /pathto/myrscript.r'",
  "body": "I searched for this question and found some answers on this, but none of them seem to work. This is the script that I'm using in python to run my R script.\nimport subprocess\nretcode = subprocess.call(\"/usr/bin/Rscript --vanilla -e 'source(\\\"/pathto/MyrScript.r\\\")'\", shell=True)\n\nand I get this error:\nError in read.table(file = file, header = header, sep = sep, quote = quote,  : \n  no lines available in input\nCalls: source withVisible -> eval -> eval -> read.csv -> read.table\nExecution halted\n\nand here is the content of my R script (pretty simple!)\ndata = read.csv('features.csv')\ndata1 = read.csv(\"BagofWords.csv\")\nmerged = merge(data,data1)\nwrite.table(merged, \"merged.csv\",quote=FALSE,sep=\",\",row.names=FALSE)\nfor (i in 1:length(merged$fileName))\n{\n        fileConn <-file(paste(\"output/\",toString(merged$fileName[i]),\".txt\",sep=\"\"))\n        writeLines((toString(merged$BagofWord[i])),fileConn)\n        close(fileConn)\n}\n\nThe r script is working fine, when I use source('MyrScript.r')  in r commandline. Moreover, when I try to use the exact command which I pass to the subprocess.call  function (i.e., /usr/bin/Rscript --vanilla -e 'source(\"/pathto/MyrScript.r\")' ) in my commandline it works find, I don't really get what's the problem.\n",
  "preds": {
   "base:Baseline": "os.system('/usr/bin/rscript --vanilla /pathto/myrscript.r')",
   "body:Baseline": "subprocess.call('/usr/bin/Rscript --vanilla /pathto/MyrScript.r')",
   "body:-Blocks": "subprocess.call('/usr/bin/Rscript --vanilla /pathto/MyrScript.r')",
   "body:-Code": "os.system('/usr/bin/rscript --vanilla /pathto/myrscript.r')",
   "body:-Inline": "subprocess.call('/usr/bin/Rscript --vanilla /pathto/MyrScript.r')",
   "body:-NL": "subprocess.call('/usr/bin/Rscript --vanilla /pathto/myrscript.r')",
   "base:+Mined": "os.system('/usr/bin/rscript --vanilla /pathTo/myrscript.r')",
   "body+mined:Baseline": "subprocess.call('/usr/bin/Rscript --vanilla -e'source('/pathto/MyrScript.r')', shell=True)",
   "body+mined:-Code": "subprocess.call('/usr/bin/rscript --vanilla /pathto/myrscript.r', shell=True)",
   "body+mined:-NL": "subprocess.call('/usr/bin/Rscript --vanilla -e'source('/pathto/MyrScript.r')', shell=True)",
   "body+mined:-Blocks": "subprocess.call('/usr/bin/rscript --vanilla /pathto/myrscript.r')",
   "body+mined:-Inline": "subprocess.call('/usr/bin/Rscript --vanilla -e'source(\\\\/pathto/MyrScript.r')', shell=True)"
  },
  "snippet": "subprocess.call('/usr/bin/Rscript --vanilla /pathto/MyrScript.r', shell=True)"
 },
 "15907200.240": {
  "intent": "add a header to a csv file",
  "body": "I've tried many solutions to add a header to my csv file, but nothing's working properly. Here they are :\n\nI used the writerow method, but my data are overwriting the first row.\nI used the DictWriter method, but I don't know how to fill it correctly. Here is my code:\ncsv = csv.DictWriter(open(directory +'/csv.csv', 'wt'), fieldnames = [\"stuff1\", \"stuff2\", \"stuff3\"], delimiter = ';')\ncsv.writeheader([\"stuff1\", \"stuff2\", \"stuff3\"])\n\n\nI got a \"2 arguments instead of one\" error and I really don't know why.\nAny advice?\n",
  "preds": {
   "base:Baseline": "writer.writerow(os.path.realpath(__file__))",
   "body:Baseline": "csv.writeheader(['stuff1', 'stuff2'], delimiter=';')",
   "body:-Blocks": "df.writeheader('\\\\d+', header=False)",
   "body:-Code": "df.writeheader('\\\\d+', header=False)",
   "body:-Inline": "csv.writeheader(['stuff1', 'stuff2'])",
   "body:-NL": "csv.writeheader(['stuff1', 'stuff2'], delimiter=',')",
   "base:+Mined": "writer.writerows(header=None)",
   "body+mined:Baseline": "csv.writeheader(['{}_{}'.format(x) for x in data])",
   "body+mined:-Code": "writerow(row, header=None)",
   "body+mined:-NL": "csv.writeheader(['stuff1','stuff2', \"stuff3'])",
   "body+mined:-Blocks": "writer.writerow(row, header=None)",
   "body+mined:-Inline": "csv.writeheader('{}'.format(df))"
  },
  "snippet": "writer.writeheader()"
 },
 "33058590.241": {
  "intent": "replacing nan in the dataframe `df` with row average",
  "body": "I am  trying to learn pandas but i have been puzzled with the following please. I want to replace NaNs is a dataframe with the row average. Hence something like df.fillna(df.mean(axis=1))  should work but for some reason it fails for me. Am I missing anything please, something I'm doing wrong? Is is because its not implemented; see link here\nimport pandas as pd\nimport numpy as np\n \npd.__version__\n<console_out>\n'0.15.2'\n\n<console_in>\ndf = pd.DataFrame()\ndf['c1'] = [1, 2, 3]\ndf['c2'] = [4, 5, 6]\ndf['c3'] = [7, np.nan, 9]\ndf\n\n<console_out>\n    c1  c2  c3\n0   1   4   7\n1   2   5   NaN\n2   3   6   9\n\n \ndf.fillna(df.mean(axis=1)) \n\n<console_out>\n    c1  c2  c3\n0   1   4   7\n1   2   5   NaN\n2   3   6   9\n\nHowever something like this looks to work fine\ndf.fillna(df.mean(axis=0)) \n\n<console_out>\n    c1  c2  c3\n0   1   4   7\n1   2   5   8\n2   3   6   9\n\n",
  "preds": {
   "base:Baseline": "df.fillna(axis=1)",
   "body:Baseline": "df.fillna(df.mean(axis=1))",
   "body:-Blocks": "df.fillna(df.mean(axis=1))",
   "body:-Code": "df.fillna(axis=1)",
   "body:-Inline": "df.fillna(df.mean(axis=1))",
   "body:-NL": "df.fillna(df.mean(axis=1))",
   "base:+Mined": "df.fillna(axis=1)",
   "body+mined:Baseline": "df.fillna(df.mean(axis=1)",
   "body+mined:-Code": "df.fillna(axis=1)",
   "body+mined:-NL": "df.fillna(df.mean(axis=1)",
   "body+mined:-Blocks": "df.fillna(df.mean(axis=1))",
   "body+mined:-Inline": "df.fillna(df.mean(axis=0)"
  },
  "snippet": "df.fillna(df.mean(axis=1), axis=1)"
 },
 "12400256.242": {
  "intent": "convert unix timestamp '1347517370' to formatted string '%y-%m-%d %h:%m:%s'",
  "body": "I am getting a response from the rest is an Epoch time format like\nstart_time = 1234566\nend_time = 1234578\n\nI want to convert that epoch seconds in MySQL format time so that I could store the differences in my MySQL database.\nI tried:\nimport time\ntime.gmtime(123456)\ntime.struct_time(tm_year=1970, tm_mon=1, tm_mday=2, tm_hour=10, tm_min=17, tm_sec=36, tm_wday=4, tm_yday=2, tm_isdst=0)\n\nThe above result is not what I am expecting. I want it be like \n2012-09-12 21:00:00\n\nPlease suggest how can I achieve this?\nAlso,\nWhy I am getting TypeError: a float is required  for\ngetbbb_class.end_time = 1347516459425\nmend = time.gmtime(getbbb_class.end_time).tm_hour\nTraceback (most recent call last):\n  <console_out>\nTypeError: a float is required\n\n",
  "preds": {
   "base:Baseline": "struct.unix('1347517370', '%Y-%m-%d %H:%M:%S')",
   "body:Baseline": "time.gmtime(1237517370, '%Y-%m-%d %H:%M:%S')",
   "body:-Blocks": "timestamp('1347517370', '%Y-%m-%d %H:%M:%S')",
   "body:-Code": "timestamp('1347517370', '%Y-%m-%d %H:%M:%S')",
   "body:-Inline": "struct.unix('1347517370', '%Y-%m-%d %H:%M:%S')",
   "body:-NL": "struct.unix('1347517370', '%Y-%m-%d %H:%M:%S')",
   "base:+Mined": "datetime.strptime('1347517370', '%Y-%m-%d %H:%M:%S')",
   "body+mined:Baseline": "time.strftime('%Y-%m-%d %H:%M:%S')",
   "body+mined:-Code": "time.strftime('%Y-%m-%d %H:%M:%S')",
   "body+mined:-NL": "struct.unpack('1347517370', '%Y-%m-%d %H:%M:%S')",
   "body+mined:-Blocks": "time.strptime('1347517370', '%Y-%m-%d %H:%M:%S')",
   "body+mined:-Inline": "'%Y-%m-%d %H:%M:%S')"
  },
  "snippet": "time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(1347517370))"
 },
 "1269217.243": {
  "intent": "call a base class's class method `do` from derived class `derived`",
  "body": "Consider the following code:\nclass Base(object):\n\n    @classmethod\n    def do(cls, a):\n        print cls, a\n\nclass Derived(Base):\n\n    @classmethod\n    def do(cls, a):\n        print 'In derived!'\n        # Base.do(cls, a) -- can't pass `cls`\n        Base.do(a)\n\nif __name__ == '__main__':\n    d = Derived()\n    d.do('hello')\n\n> $ python play.py  \n> In derived! \n> <class '__main__.Base'> msg\n\nFrom Derived.do , how do I call Base.do ? \nI would normally use super  or even the base class name directly if this is a normal object method, but apparently I can't find a way to call the classmethod in the base class. \nIn the above example, Base.do(a)  prints Base  class instead of Derived  class.\n",
  "preds": {
   "base:Baseline": "print(super(name, class) for name, class inderived.__class__))",
   "body:Baseline": "Base.do(a).__class__",
   "body:-Blocks": "base.objects.__class__.__name__",
   "body:-Code": "print(p.class__name__ for p in derived.objects())",
   "body:-Inline": "Base.call(class__name__ == '__main__.Base')",
   "body:-NL": "Base.call(['__main__.Base'])",
   "base:+Mined": "super(MyClass, self).__init__(*args, **kwargs)",
   "body+mined:Baseline": "super(Base, self).__class__.__do__",
   "body+mined:-Code": "print(super(Foo, self).__init__(*args, **kwargs)",
   "body+mined:-NL": "do_list = Base.__init__(*args, **kwargs)",
   "body+mined:-Blocks": "Base.__class__.__name__",
   "body+mined:-Inline": "super(Base, self).__name__"
  },
  "snippet": "super(Derived, cls).do(a)"
 },
 "23359886.244": {
  "intent": "selecting rows in numpy ndarray 'a', where the value in the first column is 0 and value in the second column is 1",
  "body": "I have a big np.ndarray (3600000,3) , the HUE , the VALUE , and an associated CLASS  number. For each pairs of HUE  and VALUE  I would like to find, using this array the corresponding Class  number. I'm a very beginner in Python and have a hard time doing it. Do you know a way to do it? \nThank you in advance!\n",
  "preds": {
   "base:Baseline": "numpy.select(a, key=lambda x: x[1]) == 1",
   "body:Baseline": "np.ndarray(a, key=operator.itemgetter(0, 1))",
   "body:-Blocks": "numpy.array(a, key=lambda x: x[0], reverse=True)",
   "body:-Code": "np.array(a, key=lambda x: -1)",
   "body:-Inline": "numpy.array(a, key=lambda x: x[1])",
   "body:-NL": "numpy.select(a, key=lambda x: np.ndarray(x[1], x[2]]))",
   "base:+Mined": "np.where(a == 0, axis=1)",
   "body+mined:Baseline": "numpy.where(a == 0, a == 1, axis=1)",
   "body+mined:-Code": "np.where(a == 0, axis=1)",
   "body+mined:-NL": "a[np.arange(len(a)) == 1]",
   "body+mined:-Blocks": "a[np.ndarray([[1, 2], [3, 4]])",
   "body+mined:-Inline": "np.where(a == 0, axis=1)"
  },
  "snippet": "a[np.where((a[:, (0)] == 0) * (a[:, (1)] == 1))]"
 },
 "4383082.245": {
  "intent": "separate words delimited by one or more spaces into a list",
  "body": "If I have a string = \"hello world sample text\"\nI want to be able to convert it to a list = [\"hello\", \"world\", \"sample\", \"text\"]\nHow can I do that with regular expressions? (other methods not using re are acceptable)\n",
  "preds": {
   "base:Baseline": "[k for k, v in re.findall('\\\\d+', '', delimiter=',') if v]",
   "body:Baseline": "list(re.findall('\\\\w+)', '\\\\w')",
   "body:-Blocks": "[x for x in re.findall('\\\\w+', 'hello world sample text'])",
   "body:-Code": "list(re.findall('\\\\w', 'hello world sample text')",
   "body:-Inline": "list(re.split('\\\\w', 'hello world sample text')",
   "body:-NL": "list(itertools.org.from_iterable(1, len(word)))",
   "base:+Mined": "[word for word in words if word.strip() != '']",
   "body+mined:Baseline": "['hello', 'world', 'sample', 'text']",
   "body+mined:-Code": "['world', 'sample', 'text']",
   "body+mined:-NL": "list(re.findall('\\\\w+', s))",
   "body+mined:-Blocks": "['hello', 'world', 'sample', 'text']",
   "body+mined:-Inline": "['hello world sample text', 'world', 'sample', 'text']"
  },
  "snippet": "re.split(' +', 'hello world sample text')"
 },
 "14637696.246": {
  "intent": "length of longest element in list `words`",
  "body": "What is the more pythonic way of getting the length of the longest word:\nlen(max(words, key=len))\nOr:\nmax(len(w) for w in words)\nOr.. something else?   words  is a list of strings. \nI am finding I need to do this often and after timing with a few different sample sizes the first way seems to be consistently faster, despite seeming less efficient at face value (the redundancy of len  being called twice seems not to matter - does more happen in C code in this form?).  \n",
  "preds": {
   "base:Baseline": "words[len(x) for x in words]",
   "body:Baseline": "len(max(words, key=len))",
   "body:-Blocks": "words = len(max(words, key=len))",
   "body:-Code": "print(len(word) for word in words)",
   "body:-Inline": "len(words) - len(len(word))",
   "body:-NL": "len(words, key=len))",
   "base:+Mined": "words[len(word) for word in words]",
   "body+mined:Baseline": "len(words, key=lambda x: len(x))",
   "body+mined:-Code": "len(words) - len(word)",
   "body+mined:-NL": "len(words, key=lambda x: len(x))",
   "body+mined:-Blocks": "len(max(words, key=len))",
   "body+mined:-Inline": "[len(word) for word inwords]"
  },
  "snippet": "len(max(words, key=len))"
 },
 "3933478.247": {
  "intent": "get the value associated with unicode key 'from_user' of first dictionary in list `result`",
  "body": "I am writing code that will search twitter for key words and store them in a python dictionary:\n        base_url = 'http://search.twitter.com/search.json?rpp=100&q=4sq.com/'\n        query = '7bOHRP'\n        url_string = base_url + query\n        logging.info(\"url string = \" + url_string)\n        json_text = fetch(url_string)\n        json_response = simplejson.loads(json_text.content)                                              \n        result = json_response['results']\n        print \"Contents\"\n        print result\n\nThe resulting dictionary is :\nContents[{\n    u 'iso_language_code': u 'en',\n    u 'text': u \"I'm at Cafe en Seine (40 Dawson Street, Dublin) w/ 2 others. http://4sq.com/7bOHRP\",\n    u 'created_at': u 'Wed, 06 Oct 2010 23:37:02 +0000',\n    u 'profile_image_url': u 'http://a1.twimg.com/profile_images/573130785/twitterProfilePhoto_normal.jpg',\n    u 'source': u '&lt;a href=&quot;http://foursquare.com&quot; rel=&quot;nofollow&quot;&gt;foursquare&lt;/a&gt;',\n    u 'place': {\n        u 'type': u 'neighborhood',\n        u 'id': u '898cf727ca504e96',\n        u 'full_name': u 'Mansion House B, Dublin'\n    },\n    u 'from_user': u 'pkerssemakers',\n    u 'from_user_id': 60241195,\n    u 'to_user_id': None,\n    u 'geo': None,\n    u 'id': 26597357992,\n    u 'metadata': {\n        u 'result_type': u 'recent'\n    }\n}]\nStatus: 200 OK\nContent - Type: text / html;charset = utf - 8\nCache - Control: no - cache\nExpires: Fri, 01 Jan 1990 00: 00: 00 GMT\nContent - Length: 0\n\nHow can I access the 'from_user' and what is the 'u' before the key and value?\n",
  "preds": {
   "base:Baseline": "result['from_user'] = result[0]",
   "body:Baseline": "dict((k, v) for k, v in urllib.request.urlretrieve(url_string, 'from_user'))",
   "body:-Blocks": "result['from_user'] = {'u': 1}",
   "body:-Code": "result['from_user'] = {}",
   "body:-Inline": "[k for k, v in Result if 'from_user' in k]",
   "body:-NL": "result = json_response['from_user']",
   "base:+Mined": "[x['from_user'] for x in result]",
   "body+mined:Baseline": "result = json_response['results'].encode('utf8')",
   "body+mined:-Code": "result['from_user'] = {'key1': 'value2'}",
   "body+mined:-NL": "result = json_response['results'].encode('utf8')",
   "body+mined:-Blocks": "result['from_user'] = result[0]",
   "body+mined:-Inline": "print(d['from_user']['unicode_escape'])"
  },
  "snippet": "result[0]['from_user']"
 },
 "39112645.248": {
  "intent": "retrieve each line from a file 'file.txt' as a list",
  "body": "file = input('Name: ')\n\nwith open(file) as infile:\n    for line in infile:\n        for name in infile:\n            name\n            print(name[line])\n\nSo if a user were to pass a file of vertical list of sentences, how would I save each sentence to its own list?\nSample input:\n'hi'\n'hello'\n'cat'\n'dog'\n\nOutput:\n['hi']\n['hello']\nand so on...\n\n",
  "preds": {
   "base:Baseline": "[x for x in open('file.txt', 'rb').read()]",
   "body:Baseline": "[line for line in open(file.txt, 'Name: ')]",
   "body:-Blocks": "[x for x in open('file.txt') if x.split()]",
   "body:-Code": "[line for line in open('file.txt').split()]",
   "body:-Inline": "with open(file.txt) as input:\n    pass",
   "body:-NL": "[line for line in open('file.txt')]",
   "base:+Mined": "[line for line in open('file.txt').split()]",
   "body+mined:Baseline": "[line for line in open('file.txt').read()]",
   "body+mined:-Code": "[line.split() for line in open('file.txt').split()]",
   "body+mined:-NL": "[line for line in open(file) if 'hi' in line]",
   "body+mined:-Blocks": "[line for line in open('file.txt').read()]",
   "body+mined:-Inline": "['hi', 'hello', 'cat', 'dog']"
  },
  "snippet": "[line.split() for line in open('File.txt')]"
 },
 "1031851.249": {
  "intent": "swap keys with values in a dictionary `a`",
  "body": "I receive a dictionary as input, and would like to to return a dictionary whose keys will be the input's values and whose value will be the corresponding input keys. Values are unique.\nFor example, say my input is:\na = dict()\na['one']=1\na['two']=2\n\nI would like my output to be:\n{1: 'one', 2: 'two'}\n\nTo clarify I would like my result to be the equivalent of the following:\nres = dict()\nres[1] = 'one'\nres[2] = 'two'\n\nAny neat Pythonic way to achieve this?\n",
  "preds": {
   "base:Baseline": "dict((k, v) for k, v in a.items())",
   "body:Baseline": "dict((k, v) for k, v in a.items()))",
   "body:-Blocks": "{k: v for k, v in a.items()}",
   "body:-Code": "dict((k, v) for k, v in a.items())",
   "body:-Inline": "{k: v for k, v in a.items()}",
   "body:-NL": "dict((k, v) for k, v in a.items())",
   "base:+Mined": "{k: v for k, v in a.items()}",
   "body+mined:Baseline": "{k: v for k, v in list(a.items())}",
   "body+mined:-Code": "{k: v for k, v in a.items()}",
   "body+mined:-NL": "dict((k, v) for k, v in a.items() if v == 2)",
   "body+mined:-Blocks": "dict((k, v) for k, v in a.items())",
   "body+mined:-Inline": "dict((k, v) for k, v in a.items() if v)"
  },
  "snippet": "res = dict((v, k) for k, v in a.items())"
 },
 "8577137.250": {
  "intent": "open a file `path/to/file_name.ext` in write mode",
  "body": "I have this function that references the path of a file:\nsome_obj.file_name(FILE_PATH)\n\nwhere FILE_PATH is a string of the path of a file, i.e. H:/path/FILE_NAME.ext\nI want to create a file FILE_NAME.ext inside my python script with the content of a string:\nsome_string = 'this is some content'\n\nHow to go about this? The Python script will be placed inside a Linux box.\n",
  "preds": {
   "base:Baseline": "write(path / to / file_name.ext)",
   "body:Baseline": "some_obj.file_name(FILE_PATH)",
   "body:-Blocks": "os.path.open('path/to/file_name.ext')",
   "body:-Code": "open('path/to/file_name.ext')",
   "body:-Inline": "open('path/to/file_name.ext')",
   "body:-NL": "os.path.write('path/to/file_name.ext')",
   "base:+Mined": "f = open('path/to/file_name.ext')",
   "body+mined:Baseline": "some_obj.file_name(FILE_PATH)",
   "body+mined:-Code": "f = open('path/to/file_name.ext', 'r')",
   "body+mined:-NL": "open('path/to/file_name.ext', some_string)",
   "body+mined:-Blocks": "f.write('H:/path/to/file_name.ext')",
   "body+mined:-Inline": "os.path.expanduser('path/to/file_name.ext')"
  },
  "snippet": "new_file = open('path/to/FILE_NAME.ext', 'w')"
 },
 "17926273.251": {
  "intent": "how to count distinct values in a column of a pandas group by object?",
  "body": "I have a pandas data frame and group it by two columns (for example col1  and col2 ). For fixed values of col1  and col2  (i.e. for a group) I can have several different values in the col3 . I would like to count the number of distinct values from the third columns.\nFor example, If I have this as my input:\n1  1  1\n1  1  1\n1  1  2\n1  2  3\n1  2  3\n1  2  3\n2  1  1\n2  1  2\n2  1  3\n2  2  3\n2  2  3\n2  2  3\n\nI would like to have this table (data frame) as the output:\n1  1  2\n1  2  1\n2  1  3\n2  2  1\n\n",
  "preds": {
   "base:Baseline": "df.groupby(lambda x: x[1])",
   "body:Baseline": "df.groupby(df.columns, axis=1).sum()",
   "body:-Blocks": "df.groupby(['col1', 'col2'], axis=1)",
   "body:-Code": "df.groupby(lambda x: x[1])",
   "body:-Inline": "df.groupby(df.values())",
   "body:-NL": "df.groupby(df.values())",
   "base:+Mined": "df.groupby(['A', 'B'])['C'].reset_index()",
   "body+mined:Baseline": "df.groupby(['col1', 'col2'], axis=1).sum()",
   "body+mined:-Code": "df.groupby(['a', 'b'])['c'].sum()",
   "body+mined:-NL": "df.groupby(['col1', 'col2'], ascending=[True, False], inplace=True)",
   "body+mined:-Blocks": "df.groupby(['col1', 'col2']).sum()",
   "body+mined:-Inline": "pd.concat([df1, df2], axis=1)"
  },
  "snippet": "df.groupby(['col1', 'col2'])['col3'].nunique().reset_index()"
 },
 "3735814.252": {
  "intent": "check if any key in the dictionary `dict1` starts with the string `emp$$`",
  "body": "    dict1=({\"EMP$$1\":1,\"EMP$$2\":2,\"EMP$$3\":3})\n\nHow to check if EMP exists in the dictionary using python\n   dict1.get(\"EMP##\") ??\n\n",
  "preds": {
   "base:Baseline": "any(dict1.isdigit() == 'emp$$')",
   "body:Baseline": "any(dict1.isdigit() == 'emp$$')",
   "body:-Blocks": "any(dict1.isdigit() == 'emp$$')",
   "body:-Code": "any(dict1.isdigit() == 'emp$$')",
   "body:-Inline": "any(dict1.isdigit() == 'emp$$')",
   "body:-NL": "any(dict1.isdigit() == 'emp$$')",
   "base:+Mined": "any(x in dict1.items() for x in list(dict1.values()))",
   "body+mined:Baseline": "any(x.startswith('emp$$') for x in dict1)",
   "body+mined:-Code": "any(item.startswith('emp$$') for item in dict1)",
   "body+mined:-NL": "any(d.startswith('emp$$') for d in dict1)",
   "body+mined:-Blocks": "any(d.startswith('emp$$') for d in dict1)",
   "body+mined:-Inline": "any(x.startswith('emp$$') for x in dict1)"
  },
  "snippet": "any(key.startswith('EMP$$') for key in dict1)"
 },
 "3735814.253": {
  "intent": "create list of values from dictionary `dict1` that have a key that starts with 'emp$$'",
  "body": "    dict1=({\"EMP$$1\":1,\"EMP$$2\":2,\"EMP$$3\":3})\n\nHow to check if EMP exists in the dictionary using python\n   dict1.get(\"EMP##\") ??\n\n",
  "preds": {
   "base:Baseline": "[k for k, v in dict1.items() if 'emp$$' in k]",
   "body:Baseline": "dict1 = dict1.get('emp$$')",
   "body:-Blocks": "[x for x in dict1 if 'emp$$' in x]",
   "body:-Code": "[x for x in dict1 if 'emp$$' in x]",
   "body:-Inline": "dict1.values('emp$$')",
   "body:-NL": "dict1 = {k: v for k, v in dict1 if 'emp$$' in k}",
   "base:+Mined": "[d['emp$$'] for d in dict1]",
   "body+mined:Baseline": "{k: v for k, v in list(dict1.items()) if 'emp$$' in k}",
   "body+mined:-Code": "[key for key, value in list(dict1.items()) if 'emp$$' in key]",
   "body+mined:-NL": "{k: v for k, v in dict1.items() if 'emp$$' in k}",
   "body+mined:-Blocks": "[key for key, value in dict1 if 'emp$$' in key]",
   "body+mined:-Inline": "{k: v for k, v in list(dict1.items()) if 'emp$$' in k}"
  },
  "snippet": "[value for key, value in list(dict1.items()) if key.startswith('EMP$$')]"
 },
 "26097916.254": {
  "intent": "convert a pandas series `sf` into a pandas dataframe `df` with columns `email` and `list`",
  "body": "I have a Pandas series sf:\nemail\nemail1@email.com    [1.0, 0.0, 0.0]\nemail2@email.com    [2.0, 0.0, 0.0]\nemail3@email.com    [1.0, 0.0, 0.0]\nemail4@email.com    [4.0, 0.0, 0.0]\nemail5@email.com    [1.0, 0.0, 3.0]\nemail6@email.com    [1.0, 5.0, 0.0]\n\nAnd I would like to transform it to the following DataFrame:\nindex | email             | list\n_____________________________________________\n0     | email1@email.com  | [1.0, 0.0, 0.0]\n1     | email2@email.com  | [2.0, 0.0, 0.0]\n2     | email3@email.com  | [1.0, 0.0, 0.0]\n3     | email4@email.com  | [4.0, 0.0, 0.0]\n4     | email5@email.com  | [1.0, 0.0, 3.0]\n5     | email6@email.com  | [1.0, 5.0, 0.0]\n\nI found a way to do it, but I doubt it's the more efficient one:\ndf1 = pd.DataFrame(data=sf.index, columns=['email'])\ndf2 = pd.DataFrame(data=sf.values, columns=['list'])\ndf = pd.merge(df1, df2, left_index=True, right_index=True)\n\n",
  "preds": {
   "base:Baseline": "df.set_index(['email', 'list'])",
   "body:Baseline": "df = pd.DataFrame(data=sf.index, columns=['email'])",
   "body:-Blocks": "df.to_pd.concat([df['email'], df['list'])",
   "body:-Code": "df.concat([df.columns, 'email', 'list'])",
   "body:-Inline": "pd.DataFrame(df.index, columns=['email'])",
   "body:-NL": "df = pd.DataFrame(data=sf.values, columns=['email', 'list'])",
   "base:+Mined": "df.to_pickle(['email', 'list'])",
   "body+mined:Baseline": "df.pivot_table(index='email', columns=['list'])",
   "body+mined:-Code": "pd.concat([df, pd.Series(['email', 'list'])], axis=1)",
   "body+mined:-NL": "pd.merge(df1, df2, left_index=True, right_index='list', how='inner')",
   "body+mined:-Blocks": "pd.concat([df, pd.Series(['email', 'list'])], axis=1)",
   "body+mined:-Inline": "df = pd.DataFrame(df.index, columns=['email', 'list'])"
  },
  "snippet": "pd.DataFrame({'email': sf.index, 'list': sf.values})"
 },
 "4048964.255": {
  "intent": "print elements of list `list` seperated by tabs `\\t`",
  "body": "Here's my current code:\nprint(list[0], list[1], list[2], list[3], list[4], sep = '\\t')\n\nI'd like to write it better. But\nprint('\\t'.join(list))\n\nwon't work because list elements may numbers, other lists, etc., so join  would complain.\n",
  "preds": {
   "base:Baseline": "print(list.split(\\t))",
   "body:Baseline": "print('\\t'.join(list))",
   "body:-Blocks": "print(list.split(\\t))",
   "body:-Code": "print('\\t'.join(list))",
   "body:-Inline": "print('\\t'.join(list))",
   "body:-NL": "print('\\t'.join(list))",
   "base:+Mined": "print('\\t'.join(list))",
   "body+mined:Baseline": "print('\\t'.join(list))",
   "body+mined:-Code": "print(element.finditer('\\t') for element in list))",
   "body+mined:-NL": "print(list(itertools.chain.from_iterable(list)))",
   "body+mined:-Blocks": "print('\\t'.join(str(x) for x in seperated by tabs))",
   "body+mined:-Inline": "print('\\t'.join(list))"
  },
  "snippet": "print('\\t'.join(map(str, list)))"
 },
 "3182716.256": {
  "intent": "print unicode string '\\xd0\\xbf\\xd1\\x80\\xd0\\xb8' with utf-8",
  "body": "I'm getting back from a library what looks to be an incorrect unicode string:\ntitle\nu'Sopet\\xc3\\xb3n'\n\nNow, those two hex escapes there are the UTF-8 encoding for U+00F3 LATIN SMALL LETTER O WITH ACUTE.  So far as I understand, a unicode string in Python should have the actual character, not the the UTF-8 encoding for the character, so I think this is incorrect and presumably a bug either in the library or in my input, right?\nThe question is, how do I (a) recognize that I have UTF-8 encoded text in my unicode string, and (b) convert this to a proper unicode string?\nI'm stumped on (a), as there's nothing wrong, encoding-wise, about that original string (i.e, both are valid characters in their own right, u'\\xc3\\xb3'  == A3, but they're not what's supposed to be there)\nIt looks like I can achieve (b) by eval()ing that repr() output minus the \"u\" in front to get a str and then decoding the str with UTF-8:\neval(repr(title)[1:]).decode(\"utf-8\")\nu'Sopet\\xf3n'\nprint eval(repr(title)[1:]).decode(\"utf-8\")\nSopeton\n\nBut that seems a bit kludgy.  Is there an officially-sanctioned way to get the raw data out of a unicode string and treat that as a regular string?\n",
  "preds": {
   "base:Baseline": "print('\\xd0\\xbf\\xd1\\x80\\xd9\\xb8'.encode('utf8')",
   "body:Baseline": "print(repr(title)[1:]).decode('utf-8')",
   "body:-Blocks": "print('\\xd0\\xbf\\xd1\\x80\\xd 0\\xb8'.encode('utf-8')",
   "body:-Code": "print('\\xd0\\xbf\\xd1\\x80\\xd00\\xb8'.encode('utf-8')",
   "body:-Inline": "print(repr(title)[1:]).decode('utf-8')",
   "body:-NL": "print(repr(title)[1:]).decode('utf8')",
   "base:+Mined": "print(s.encode('utf8'))",
   "body+mined:Baseline": "print(repr(title)[1:]).decode('utf-8')",
   "body+mined:-Code": "print(repr('\u00d0\u00bf\u00d1\\x80\u00d00\u00b8', my_unicode_string))",
   "body+mined:-NL": "print(repr(title)[1:])",
   "body+mined:-Blocks": "print(s.encode('utf-8'))",
   "body+mined:-Inline": "print(u.decode('utf8'))"
  },
  "snippet": "print('\u00d0\u00bf\u00d1\\x80\u00d0\u00b8'.encode('raw_unicode_escape'))"
 },
 "3182716.257": {
  "intent": "encode a latin character in string `sopet\\xc3\\xb3n` properly",
  "body": "I'm getting back from a library what looks to be an incorrect unicode string:\ntitle\nu'Sopet\\xc3\\xb3n'\n\nNow, those two hex escapes there are the UTF-8 encoding for U+00F3 LATIN SMALL LETTER O WITH ACUTE.  So far as I understand, a unicode string in Python should have the actual character, not the the UTF-8 encoding for the character, so I think this is incorrect and presumably a bug either in the library or in my input, right?\nThe question is, how do I (a) recognize that I have UTF-8 encoded text in my unicode string, and (b) convert this to a proper unicode string?\nI'm stumped on (a), as there's nothing wrong, encoding-wise, about that original string (i.e, both are valid characters in their own right, u'\\xc3\\xb3'  == A3, but they're not what's supposed to be there)\nIt looks like I can achieve (b) by eval()ing that repr() output minus the \"u\" in front to get a str and then decoding the str with UTF-8:\neval(repr(title)[1:]).decode(\"utf-8\")\nu'Sopet\\xf3n'\nprint eval(repr(title)[1:]).decode(\"utf-8\")\nSopeton\n\nBut that seems a bit kludgy.  Is there an officially-sanctioned way to get the raw data out of a unicode string and treat that as a regular string?\n",
  "preds": {
   "base:Baseline": "sopet\\xc3\\xb3n.encode('utf-8')",
   "body:Baseline": "rept(repr(title)[1:]).decode('utf-8').encode('Sopet\u00c3\u00b3n')",
   "body:-Blocks": "sopet\\xc3\\xb3n.encode('utf-8')",
   "body:-Code": "sopet\\xc3\\xb3n.encode('utf-8')",
   "body:-Inline": "print(repr(title)[1:]).decode('utf-8')",
   "body:-NL": "\"\"\"Sopet\u00c3\u00b3n\"\"\".encode('utf-8')",
   "base:+Mined": "sopet\\xc3\\xb3n'.encode('latin-1')",
   "body+mined:Baseline": "eval(repr(title)[1:]).decode('utf-8')",
   "body+mined:-Code": "print(sopet\\xc3\\xb3n.decode('utf-8'))",
   "body+mined:-NL": "\"\"\"Sopet\\\\xc3\u00b3n\"\"\".encode('utf8')",
   "body+mined:-Blocks": "sopet\\xc3\\xb3n.encode('utf-8')",
   "body+mined:-Inline": "\"\"\"Sopet\u00c3\u00b3n\"\"\".decode('utf-8')"
  },
  "snippet": "\"\"\"Sopet\u00c3\u00b3n\"\"\".encode('latin-1').decode('utf-8')"
 },
 "1405602.258": {
  "intent": "resized image `image` to width, height of `(x, y)` with filter of `antialias`",
  "body": "I am working on PIL and need to know if the image quality can be adjusted while resizing or thumbnailing an image. From what I have known is the default quality is set to 85. Can this parameter be tweaked during resizing?\nI am currently using the following code:\nimage = Image.open(filename)\nimage.thumbnail((x, y), img.ANTIALIAS)\n\nThe ANTIALIAS  parameter presumably gives the best quality. I need to know if we can get more granularity on the quality option.\n",
  "preds": {
   "base:Baseline": "image.resized(x, y)",
   "body:Baseline": "image.reshape(image.x, y, img.ANTIALIAS)",
   "body:-Blocks": "image.resized(image, width, height='(x, y)', color='antialias')",
   "body:-Code": "image.resize(x, y, filter=antialias)",
   "body:-Inline": "image = Image.open(filename) + Image.filter(antialias)",
   "body:-NL": "image.reshape(x, y), img.ANTIALIAS)",
   "base:+Mined": "imagedata.resize(x, y)",
   "body+mined:Baseline": "image.resize(image.thumbnail((x, y), img.ANTIALIAS)",
   "body+mined:-Code": "imagedata.resize(image, (x, y), (255, 255, 1))",
   "body+mined:-NL": "image.resize(x, y)",
   "body+mined:-Blocks": "im.save('image.png', (x, y))",
   "body+mined:-Inline": "image.thumbnail((x, y), img.ANTIALIAS)"
  },
  "snippet": "image = image.resize((x, y), Image.ANTIALIAS)"
 },
 "35622945.259": {
  "intent": "regex, find \"n\"s only in the middle of string `s`",
  "body": "I am using python 2.6 and trying to find a bunch of repeating characters in a string, let's say a bunch of n 's, e.g. nnnnnnnABCnnnnnnnnnDEF . In any place of the string the number of n 's can be variable.\nIf I construct a regex like this:\nre.findall(r'^(((?i)n)\\2{2,})', s) ,\nI can find occurences of case-insensitive n 's only in the beginning of the string, which is fine. If I do it like this: \nre.findall(r'(((?i)n)\\2{2,}$)', s) ,\nI can detect the ones only in the end of the sequence. But what about just in the middle?\nAt first, I thought of using re.findall(r'(((?i)n)\\2{2,})', s)  and the two previous regex(-ices?) to check the length of the returned list and the presence of n 's either in the beginning or end of the string and make logical tests, but it became an ugly if-else mess very quickly.\nThen, I tried re.findall(r'(?!^)(((?i)n)\\2{2,})', s) , which seems to exlude the beginning just fine but (?!$)  or (?!\\z)  at the end of the regex only excludes the last n  in ABCnnnn . Finally, I tried re.findall(r'(?!^)(((?i)n)\\2{2,})\\w+', s)  which seems to work sometimes, but I get weird results at others. It feels like I need a lookahead or lookbehind, but I can't wrap my head around them.\n",
  "preds": {
   "base:Baseline": "re.findall('n', s)",
   "body:Baseline": "re.findall('((?i)n)\\x02{2,})\\\\w+', s)",
   "body:-Blocks": "re.findall('(?i)n)\\x02{2,})', s)",
   "body:-Code": "re.findall('\\\\n', s)",
   "body:-Inline": "re.findall('n', s)",
   "body:-NL": "re.findall('(?i)n)\\x02{2,})', s)",
   "base:+Mined": "re.findall('\\\\n', s)",
   "body+mined:Baseline": "re.findall('(?!^)(((?i)n)\\\\2{2,}$)', s)",
   "body+mined:-Code": "re.findall('\\\\s+', s)",
   "body+mined:-NL": "re.findall('(?!^)(((?i)n)\\\\2{2,}$)', s)",
   "body+mined:-Blocks": "re.findall('(?!^)(((?i)n)\\x02{2,})\\\\w+', s)",
   "body+mined:-Inline": "regexp = re.compile('[^a-zA-Z]', s)"
  },
  "snippet": "re.findall('n(?<=[^n]n)n+(?=[^n])(?i)', s)"
 },
 "5306756.260": {
  "intent": "display the float `1/3*100` as a percentage",
  "body": "this is my code:\nprint str(float(1/3))+'%'\n\nand it shows:\n0.0%\n\nbut I want to get 33%\nWhat can I do?\n",
  "preds": {
   "base:Baseline": "float(1 / 3 * 100)",
   "body:Baseline": "print(float(1 / 3 * 100))",
   "body:-Blocks": "\"\"\"1/3*100\"\"\".isnull()",
   "body:-Code": "float(1/3*100))",
   "body:-Inline": "print(str(float(1/3*100))",
   "body:-NL": "print(float(1 / 3 * 100))",
   "base:+Mined": "print(float(1 / 3 * 100))",
   "body+mined:Baseline": "print(float(1 / 3 * 100))",
   "body+mined:-Code": "float(1 / 3 * 100)",
   "body+mined:-NL": "print(float(1 / 3 * 100))",
   "body+mined:-Blocks": "\"\"\"{:.2f}\"\"\".format(1 / 3 * 100)",
   "body+mined:-Inline": "print('{0:.0f}'.format(1 / 3 * 100))"
  },
  "snippet": "print('{0:.0f}%'.format(1.0 / 3 * 100))"
 },
 "2878084.261": {
  "intent": "sort a list of dictionary `mylist` by the key `title`",
  "body": "I have a list of dictionaries:\n[{'title':'New York Times', 'title_url':'New_York_Times','id':4},\n {'title':'USA Today','title_url':'USA_Today','id':6},\n {'title':'Apple News','title_url':'Apple_News','id':2}]\n\nI'd like to sort it by the title, so elements with A go before Z:\n[{'title':'Apple News','title_url':'Apple_News','id':2},\n {'title':'New York Times', 'title_url':'New_York_Times','id':4},\n {'title':'USA Today','title_url':'USA_Today','id':6}]\n\nWhat's the best way to do this?\nAlso, is there a way to ensure the order of each dictionary key stays constant, e.g., always title, title_url, then id?\n",
  "preds": {
   "base:Baseline": "mylist.sort(key=lambda x: x[1])",
   "body:Baseline": "sorted(list(mylist.items()), key=lambda x: x[1])",
   "body:-Blocks": "mylist.sort(key=lambda x: x[1])",
   "body:-Code": "mylist.sort(key=lambda x: x[1])",
   "body:-Inline": "sorted(mylist, key=lambda x: x[1])",
   "body:-NL": "mylist.sort(key=lambda x: x[1])",
   "base:+Mined": "mylist.sort(key=operator.itemgetter(1))",
   "body+mined:Baseline": "sorted(mylist, key=lambda x: x['title'], reverse=True)",
   "body+mined:-Code": "sorted(mylist, key=lambda x: x['title'], reverse=True)",
   "body+mined:-NL": "mylist.sort(key=lambda x: x[1]['title'], reverse=True)",
   "body+mined:-Blocks": "mylist.sort(key=lambda x: x[1])",
   "body+mined:-Inline": "sorted(mylist, key=lambda d: d['title'], reverse=True)"
  },
  "snippet": "mylist.sort(key=lambda x: x['title'])"
 },
 "2878084.262": {
  "intent": "sort a list `l` of dicts by dict value 'title'",
  "body": "I have a list of dictionaries:\n[{'title':'New York Times', 'title_url':'New_York_Times','id':4},\n {'title':'USA Today','title_url':'USA_Today','id':6},\n {'title':'Apple News','title_url':'Apple_News','id':2}]\n\nI'd like to sort it by the title, so elements with A go before Z:\n[{'title':'Apple News','title_url':'Apple_News','id':2},\n {'title':'New York Times', 'title_url':'New_York_Times','id':4},\n {'title':'USA Today','title_url':'USA_Today','id':6}]\n\nWhat's the best way to do this?\nAlso, is there a way to ensure the order of each dictionary key stays constant, e.g., always title, title_url, then id?\n",
  "preds": {
   "base:Baseline": "sorted(l, key=lambda x: dicts['title'])",
   "body:Baseline": "sorted(l, key=dict.get('title')))",
   "body:-Blocks": "sorted(l, key=lambda x: x['title']))",
   "body:-Code": "sorted(l, key=dict.get('title')",
   "body:-Inline": "sorted(l, key=lambda x: x['title']))",
   "body:-NL": "sorted(l, key=lambda x: x['title']))",
   "base:+Mined": "l.sort(key=operator.itemgetter('title'))",
   "body+mined:Baseline": "sorted(l, key=lambda x: x['title'], reverse=True)",
   "body+mined:-Code": "sorted(L, key=lambda x: x['title'], reverse=True)",
   "body+mined:-NL": "sorted(l, key=lambda d: d['title'], reverse=True)",
   "body+mined:-Blocks": "sorted(l, key=lambda d: d['title'], reverse=True)",
   "body+mined:-Inline": "sorted(l, key=lambda d: d['title'], reverse=True)"
  },
  "snippet": "l.sort(key=lambda x: x['title'])"
 },
 "2878084.263": {
  "intent": "sort a list of dictionaries by the value of keys 'title', 'title_url', 'id' in ascending order.",
  "body": "I have a list of dictionaries:\n[{'title':'New York Times', 'title_url':'New_York_Times','id':4},\n {'title':'USA Today','title_url':'USA_Today','id':6},\n {'title':'Apple News','title_url':'Apple_News','id':2}]\n\nI'd like to sort it by the title, so elements with A go before Z:\n[{'title':'Apple News','title_url':'Apple_News','id':2},\n {'title':'New York Times', 'title_url':'New_York_Times','id':4},\n {'title':'USA Today','title_url':'USA_Today','id':6}]\n\nWhat's the best way to do this?\nAlso, is there a way to ensure the order of each dictionary key stays constant, e.g., always title, title_url, then id?\n",
  "preds": {
   "base:Baseline": "sorted(list(d.items()), key=lambda x: x['title', 'title_url', 'id'])",
   "body:Baseline": "sorted(list(dictionary.items()), key=lambda k: k.index('title', 'title_url',\n    'id'))",
   "body:-Blocks": "sorted(list(d.items()), key=lambda x: x['title', 'title_url', 'id'])",
   "body:-Code": "sorted(list(d.items()), key=lambda x: x['title', 'title_url', 'id'])",
   "body:-Inline": "sorted(list(d.items()), key=lambda x: x['title', 'title_url', 'id'])",
   "body:-NL": "sorted(list(d.items()), key=lambda x: x['title', 'title_url', 'id']))",
   "base:+Mined": "sorted(list(d.items()), key=lambda x: x['title', 'title_url', 'id'])",
   "body+mined:Baseline": "sorted(d, key=lambda x: x['title'], reverse=True)",
   "body+mined:-Code": "sorted(list_of_dicts, key=lambda x: x['title', 'title_url', 'id']), reverse=True)",
   "body+mined:-NL": "sorted(dic, key=lambda x: x['title'], reverse=True)",
   "body+mined:-Blocks": "sorted(lst, key=lambda x: (x['title', 'title_url'], x['id']))",
   "body+mined:-Inline": "sorted(list(d.items()), key=lambda x: x['title_url'], reverse=True)"
  },
  "snippet": "l.sort(key=lambda x: (x['title'], x['title_url'], x['id']))"
 },
 "9323159.264": {
  "intent": "find 10 largest differences between each respective elements of list `l1` and list `l2`",
  "body": "I have two lists old  and new , with the same number of elements.\nI'm trying to write an efficient function that takes n  as a parameter, compares the elements of two lists at the same locations (by index), finds n  largest differences, and returns the indices of those n  elements.\nI was thinking this would be best solved by a value-sorted dictionary, but one isn't available  in Python (and I'm not aware of any libraries that offer it). Perhaps there's a better solution? \n",
  "preds": {
   "base:Baseline": "[i for i, j in zip(l1, l2)]",
   "body:Baseline": "sum(i, j) for i, j in zip(l1, l2)]",
   "body:-Blocks": "[i for i, j in zip(l1, l2)]",
   "body:-Code": "[i for i, j in zip(l1, l2)]",
   "body:-Inline": "sum(x[0] for x in zip(l1, l2)]",
   "body:-NL": "[i for i, j in zip(l1, l2)]",
   "base:+Mined": "[max(x, y) for x, y in zip(l1, l2)]",
   "body+mined:Baseline": "[i for i, j in zip(l1, l2)]",
   "body+mined:-Code": "zip(list(zip(l1, l2))",
   "body+mined:-NL": "max(l1, l2)",
   "body+mined:-Blocks": "[(x / y) for x, y in zip(old, new)]",
   "body+mined:-Inline": "max(l1, l2)"
  },
  "snippet": "heapq.nlargest(10, range(len(l1)), key=lambda i: abs(l1[i] - l2[i]))"
 },
 "29877663.265": {
  "intent": "beautifulsoup find all 'span' elements in html string `soup` with class of 'stargryb sp'",
  "body": "There are two values that i am looking to scrape from a website. These are present in the following tags:\n<span class=\"sp starBig\">4.1 </span>\n<span class=\"sp starGryB\">2.9 </span>\n\nI need the values sp starBig, sp starGryB.\nThe findAll expression that i am using is - \nsoup.findAll('span', {'class': ['sp starGryB', 'sp starBig']}):\n\nThe code gets executed without any errors yet no results get displayed.\n",
  "preds": {
   "base:Baseline": "soup.findAll(text='Stargryb sp')",
   "body:Baseline": "soup.findAll('span', {'class': ['sp starGryB','sp starBig'})",
   "body:-Blocks": "soup.findAll('span')",
   "body:-Code": "soup.findAll('span')",
   "body:-Inline": "soup.findAll('span', {'class': ['sp starGryB sp'})",
   "body:-NL": "soup.findAll('span', {'class': ['sp starGryB','sp starBig'})",
   "base:+Mined": "soup.findAll('span', class='stargryb sp')",
   "body+mined:Baseline": "soup.findAll('span', {'class': ['sp starGryB','sp starBig']}",
   "body+mined:-Code": "print(soup.findAll('span', class='StargryB sp').all())",
   "body+mined:-NL": "soup.find_all('span', {'class': ['sp starGryB', 'sp starBig']})",
   "body+mined:-Blocks": "soup.findAll('span', class='stargryb sp')",
   "body+mined:-Inline": "soup.findAll('span', {'class': ['sp starGryB', 'sp starBig']})"
  },
  "snippet": "soup.find_all('span', {'class': 'starGryB sp'})"
 },
 "24189150.266": {
  "intent": "write records in dataframe `df` to table 'test' in schema 'a_schema'",
  "body": "I am trying to write a pandas DataFrame to a PostgreSQL database,\nusing a schema-qualified table.\nI use the following code:\nimport pandas.io.sql as psql\nfrom sqlalchemy import create_engine\n\nengine = create_engine(r'postgresql://some:user@host/db')\n\nc = engine.connect()\nconn = c.connection\n\ndf = psql.read_sql(\"SELECT * FROM xxx\", con=conn)    \ndf.to_sql('a_schema.test', engine)\n\nconn.close()\n\nWhat happens is that pandas writes in schema \"public\", in a table named 'a_schema.test',\ninstead of writing in the \"test\" table in the \"a_schema\" schema.\nHow can I instruct pandas to use a schema different than public?\nThanks\n",
  "preds": {
   "base:Baseline": "df.to_test('test')",
   "body:Baseline": "df.to_sql('a_schema.test', engine)",
   "body:-Blocks": "df.set_table('test')",
   "body:-Code": "df.set_index('test')",
   "body:-Inline": "df.to_sql('a_schema.test', engine)",
   "body:-NL": "df.to_sql('a_schema.test', table='test')",
   "base:+Mined": "df.to_csv('test.csv', index=False)",
   "body+mined:Baseline": "df.to_sql('a_schema.test', engine)",
   "body+mined:-Code": "df.set_index('a_schema.test')",
   "body+mined:-NL": "df.to_sql('a_schema.test', engine)",
   "body+mined:-Blocks": "df.set_index('test')",
   "body+mined:-Inline": "df.to_sql('a_schema.test', engine)"
  },
  "snippet": "df.to_sql('test', engine, schema='a_schema')"
 },
 "30766151.267": {
  "intent": "extract brackets from string `s`",
  "body": "I have a string which has multiple brackets. Let says\ns=\"(a(vdwvndw){}]\"\n\nI want to extract all the brackets as a separate string. \nI tried this: \nbrackets=re.search(r\"[(){}[]]+\",s)\nbrackets.group()\n\nBut it is only giving me last two brackets. \n'}]'\n\nWhy is that? Shouldn't it fetch one or more of any of the brackets in the character set?\n",
  "preds": {
   "base:Baseline": "re.sub('\\\\d+', s)",
   "body:Baseline": "re.search(r\"[(){}[]]+', s)",
   "body:-Blocks": "re.findall('\\\\d+', s)",
   "body:-Code": "re.findall('\\\\d+', s)",
   "body:-Inline": "re.search('(\\\\wvvndw){}]', s)",
   "body:-NL": "re.search('(a(vdwvndw){}]\"",
   "base:+Mined": "re.findall('\\\\s+', s)",
   "body+mined:Baseline": "re.findall('\\\\s+', s)",
   "body+mined:-Code": "re.findall('\\\\[\\\\]', s)",
   "body+mined:-NL": "re.search('(a(vdwvndw){}', s)",
   "body+mined:-Blocks": "re.findall('\\\\S+', s)",
   "body+mined:-Inline": "re.findall('\\\\[(\\\\w+)\\\\]', s)"
  },
  "snippet": "brackets = re.sub('[^(){}[\\\\]]', '', s)"
 },
 "1143379.268": {
  "intent": "remove duplicate elements from list 'l'",
  "body": "Can anyone suggest a good solution to remove duplicates from nested lists if wanting to evaluate duplicates based on first element of each nested list?\nThe main list looks like this:\nL = [['14', '65', 76], ['2', '5', 6], ['7', '12', 33], ['14', '22', 46]]\n\nIf there is another list with the same element at first position [k][0]  that had already occurred, then I'd like to remove that list and get this result:\nL = [['14', '65', 76], ['2', '5', 6], ['7', '12', 33]]\n\nCan you suggest an algorithm to achieve this goal?\n",
  "preds": {
   "base:Baseline": "[x for x in L if x not in x]",
   "body:Baseline": "[x[0] for x in L]",
   "body:-Blocks": "l = [x[0] for x in l]",
   "body:-Code": "[k for k, v in l if v != 0]",
   "body:-Inline": "[x for x in L if x not in x]",
   "body:-NL": "[x[0] for x in L]",
   "base:+Mined": "[x for x in L if x not in duplicate]",
   "body+mined:Baseline": "[x for x in L if x[0]]",
   "body+mined:-Code": "set(L).sort(key=lambda x: x[1])",
   "body+mined:-NL": "[x for x in L if x not in l]",
   "body+mined:-Blocks": "result = [x for x in l if x[0] == [k][0] for y in l]",
   "body+mined:-Inline": "[list(x) for x in L if x[0]]"
  },
  "snippet": "list(dict((x[0], x) for x in L).values())"
 },
 "12330522.269": {
  "intent": "read a file `file` without newlines",
  "body": "In Python, calling\ntemp = open(filename,'r').readlines()\n\nresults in a list in which each element is a line in the file. It's a little stupid but still: readlines()  also writes newline character to each element, something I do not wish to happen. \nHow can I avoid it? \n",
  "preds": {
   "base:Baseline": "os.path.isfile(file)",
   "body:Baseline": "Temp = open(filename, 'r').readlines()",
   "body:-Blocks": "os.path.isfile(file)",
   "body:-Code": "print(os.path.isfile(file))",
   "body:-Inline": "Temp = open(filename, 'r').readlines()",
   "body:-NL": "Temp = open(filename, 'r').readlines()",
   "base:+Mined": "file = open('file', 'wb')",
   "body+mined:Baseline": "temp = open(filename, 'r').readlines()",
   "body+mined:-Code": "for line in open(file):\n    pass",
   "body+mined:-NL": "temp = open(filename, 'r').readlines()",
   "body+mined:-Blocks": "for line in open(file):\n    pass",
   "body+mined:-Inline": "temp = open(filename, 'r').readlines()"
  },
  "snippet": "[line.rstrip('\\n') for line in file]"
 },
 "364621.270": {
  "intent": "get the position of item 1 in `testlist`",
  "body": "I am iterating over a list and I want to print out the index of the item if it meets a certain condition. How would I do this?\nExample:  \ntestlist = [1,2,3,5,3,1,2,1,6]\nfor item in testlist:\n    if item == 1:\n        print position\n\n",
  "preds": {
   "base:Baseline": "testlist.get_position(1)",
   "body:Baseline": "[i for i in testlist if i == 1]",
   "body:-Blocks": "print(testlist.index(1))",
   "body:-Code": "print(item in testlist[1]",
   "body:-Inline": "[x for x in testlist if item == 1]",
   "body:-NL": "for item in testlist:\n    pass",
   "base:+Mined": "len(testlist) == (1)[-1]",
   "body+mined:Baseline": "next((1) if item == 1)",
   "body+mined:-Code": "next((1, 1) for item in testlist)",
   "body+mined:-NL": "len(testlist) - 1 - testlist[1]",
   "body+mined:-Blocks": "next((1, 1) for item in testlist)",
   "body+mined:-Inline": "next((1, 1) for item in testlist)"
  },
  "snippet": "[i for i, x in enumerate(testlist) if x == 1]"
 },
 "364621.271": {
  "intent": "get the position of item 1 in `testlist`",
  "body": "I am iterating over a list and I want to print out the index of the item if it meets a certain condition. How would I do this?\nExample:  \ntestlist = [1,2,3,5,3,1,2,1,6]\nfor item in testlist:\n    if item == 1:\n        print position\n\n",
  "preds": {
   "base:Baseline": "testlist.get_position(1)",
   "body:Baseline": "[i for i in testlist if i == 1]",
   "body:-Blocks": "print(testlist.index(1))",
   "body:-Code": "print(item in testlist[1]",
   "body:-Inline": "[x for x in testlist if item == 1]",
   "body:-NL": "for item in testlist:\n    pass",
   "base:+Mined": "len(testlist) == (1)[-1]",
   "body+mined:Baseline": "next((1) if item == 1)",
   "body+mined:-Code": "next((1, 1) for item in testlist)",
   "body+mined:-NL": "len(testlist) - 1 - testlist[1]",
   "body+mined:-Blocks": "next((1, 1) for item in testlist)",
   "body+mined:-Inline": "next((1, 1) for item in testlist)"
  },
  "snippet": "[i for i, x in enumerate(testlist) if x == 1]"
 },
 "364621.272": {
  "intent": "get the position of item 1 in `testlist`",
  "body": "I am iterating over a list and I want to print out the index of the item if it meets a certain condition. How would I do this?\nExample:  \ntestlist = [1,2,3,5,3,1,2,1,6]\nfor item in testlist:\n    if item == 1:\n        print position\n\n",
  "preds": {
   "base:Baseline": "testlist.get_position(1)",
   "body:Baseline": "[i for i in testlist if i == 1]",
   "body:-Blocks": "print(testlist.index(1))",
   "body:-Code": "print(item in testlist[1]",
   "body:-Inline": "[x for x in testlist if item == 1]",
   "body:-NL": "for item in testlist:\n    pass",
   "base:+Mined": "len(testlist) == (1)[-1]",
   "body+mined:Baseline": "next((1) if item == 1)",
   "body+mined:-Code": "next((1, 1) for item in testlist)",
   "body+mined:-NL": "len(testlist) - 1 - testlist[1]",
   "body+mined:-Blocks": "next((1, 1) for item in testlist)",
   "body+mined:-Inline": "next((1, 1) for item in testlist)"
  },
  "snippet": "for i in [i for i, x in enumerate(testlist) if x == 1]:\n    pass"
 },
 "364621.273": {
  "intent": "get the position of item 1 in `testlist`",
  "body": "I am iterating over a list and I want to print out the index of the item if it meets a certain condition. How would I do this?\nExample:  \ntestlist = [1,2,3,5,3,1,2,1,6]\nfor item in testlist:\n    if item == 1:\n        print position\n\n",
  "preds": {
   "base:Baseline": "testlist.get_position(1)",
   "body:Baseline": "[i for i in testlist if i == 1]",
   "body:-Blocks": "print(testlist.index(1))",
   "body:-Code": "print(item in testlist[1]",
   "body:-Inline": "[x for x in testlist if item == 1]",
   "body:-NL": "for item in testlist:\n    pass",
   "base:+Mined": "len(testlist) == (1)[-1]",
   "body+mined:Baseline": "next((1) if item == 1)",
   "body+mined:-Code": "next((1, 1) for item in testlist)",
   "body+mined:-NL": "len(testlist) - 1 - testlist[1]",
   "body+mined:-Blocks": "next((1, 1) for item in testlist)",
   "body+mined:-Inline": "next((1, 1) for item in testlist)"
  },
  "snippet": "for i in (i for i, x in enumerate(testlist) if x == 1):\n    pass"
 },
 "364621.274": {
  "intent": "get the position of item 1 in `testlist`",
  "body": "I am iterating over a list and I want to print out the index of the item if it meets a certain condition. How would I do this?\nExample:  \ntestlist = [1,2,3,5,3,1,2,1,6]\nfor item in testlist:\n    if item == 1:\n        print position\n\n",
  "preds": {
   "base:Baseline": "testlist.get_position(1)",
   "body:Baseline": "[i for i in testlist if i == 1]",
   "body:-Blocks": "print(testlist.index(1))",
   "body:-Code": "print(item in testlist[1]",
   "body:-Inline": "[x for x in testlist if item == 1]",
   "body:-NL": "for item in testlist:\n    pass",
   "base:+Mined": "len(testlist) == (1)[-1]",
   "body+mined:Baseline": "next((1) if item == 1)",
   "body+mined:-Code": "next((1, 1) for item in testlist)",
   "body+mined:-NL": "len(testlist) - 1 - testlist[1]",
   "body+mined:-Blocks": "next((1, 1) for item in testlist)",
   "body+mined:-Inline": "next((1, 1) for item in testlist)"
  },
  "snippet": "gen = (i for i, x in enumerate(testlist) if x == 1)\nfor i in gen:\n    pass"
 },
 "364621.275": {
  "intent": "get the position of item `element` in list `testlist`",
  "body": "I am iterating over a list and I want to print out the index of the item if it meets a certain condition. How would I do this?\nExample:  \ntestlist = [1,2,3,5,3,1,2,1,6]\nfor item in testlist:\n    if item == 1:\n        print position\n\n",
  "preds": {
   "base:Baseline": "print(len(element) for element in testlist)",
   "body:Baseline": "[i for i, j in testlist if i == 1]",
   "body:-Blocks": "print(element.index(1))",
   "body:-Code": "print(element in testlist[:1])",
   "body:-Inline": "[x for x in testlist if item == 1]",
   "body:-NL": "[x for x in testlist if x == 1]",
   "base:+Mined": "[x for x in testlist if x not inelement]",
   "body+mined:Baseline": "next((i, j) for i, j in testlist)",
   "body+mined:-Code": "element.index(level=0)",
   "body+mined:-NL": "[item for item in testlist if item == 1]",
   "body+mined:-Blocks": "element.index(level=0)",
   "body+mined:-Inline": "next(i for i, j in enumerate(testlist) if j == 1)"
  },
  "snippet": "print(testlist.index(element))"
 },
 "364621.276": {
  "intent": "get the position of item `element` in list `testlist`",
  "body": "I am iterating over a list and I want to print out the index of the item if it meets a certain condition. How would I do this?\nExample:  \ntestlist = [1,2,3,5,3,1,2,1,6]\nfor item in testlist:\n    if item == 1:\n        print position\n\n",
  "preds": {
   "base:Baseline": "print(len(element) for element in testlist)",
   "body:Baseline": "[i for i, j in testlist if i == 1]",
   "body:-Blocks": "print(element.index(1))",
   "body:-Code": "print(element in testlist[:1])",
   "body:-Inline": "[x for x in testlist if item == 1]",
   "body:-NL": "[x for x in testlist if x == 1]",
   "base:+Mined": "[x for x in testlist if x not inelement]",
   "body+mined:Baseline": "next((i, j) for i, j in testlist)",
   "body+mined:-Code": "element.index(level=0)",
   "body+mined:-NL": "[item for item in testlist if item == 1]",
   "body+mined:-Blocks": "element.index(level=0)",
   "body+mined:-Inline": "next(i for i, j in enumerate(testlist) if j == 1)"
  },
  "snippet": "try:\n    print(testlist.index(element))\nexcept ValueError:\n    pass"
 },
 "13145368.277": {
  "intent": "find the first element of the tuple with the maximum second element in a list of tuples `lis`",
  "body": "\nPossible Duplicate:\nSorting or Finding Max Value by the second element in a nested list. Python\n\n\nI have a list with ~10^6 tuples in it like this:\n[(101, 153), (255, 827), (361, 961), <console_out>]\n  ^     ^\n  X     Y\n\nI want to find the maximum value of the Ys in this list, but also want to know the X that it is bound to.\nHow do I do this?\n",
  "preds": {
   "base:Baseline": "[max(x[1] for x inlis]",
   "body:Baseline": "max(x, y) == 10",
   "body:-Blocks": "max(lis, key=lambda x: x[1])",
   "body:-Code": "max(zip(lis, key=lambda x: x[1])",
   "body:-Inline": "max(x[1] for x inlis)",
   "body:-NL": "[x[0] for x in l]",
   "base:+Mined": "max(lis, key=lambda x: x[1])",
   "body+mined:Baseline": "max(lis, key=lambda x: x[1])",
   "body+mined:-Code": "max(lis, key=lambda x: x[1])",
   "body+mined:-NL": "[x[0] for x in lst]",
   "body+mined:-Blocks": "max(lis, key=lambda x: x[1])",
   "body+mined:-Inline": "max(lis, key=lambda x: x[1])"
  },
  "snippet": "max(lis, key=lambda item: item[1])[0]"
 },
 "13145368.278": {
  "intent": "get the item at index 0 from the tuple that has maximum value at index 1 in list `lis`",
  "body": "\nPossible Duplicate:\nSorting or Finding Max Value by the second element in a nested list. Python\n\n\nI have a list with ~10^6 tuples in it like this:\n[(101, 153), (255, 827), (361, 961), <console_out>]\n  ^     ^\n  X     Y\n\nI want to find the maximum value of the Ys in this list, but also want to know the X that it is bound to.\nHow do I do this?\n",
  "preds": {
   "base:Baseline": "max(len(lis, key=lambda x: x[1])",
   "body:Baseline": "max(x, y) for x, y in zip(lis, 1)]",
   "body:-Blocks": "max(zip(lis, key=lambda x: x[1])",
   "body:-Code": "max(zip(lis, key=lambda x: x[1])",
   "body:-Inline": "max(zip(lis, 1))",
   "body:-NL": "[max(x, y) for x, y in zip(lis, 1)]",
   "base:+Mined": "max(lis, key=lambda x: x[1])",
   "body+mined:Baseline": "max(lis, key=lambda x: x[1])",
   "body+mined:-Code": "max(lis, key=lambda x: x[1])",
   "body+mined:-NL": "max(lis, key=lambda x: x[1])",
   "body+mined:-Blocks": "max(lis, key=lambda x: x[1])",
   "body+mined:-Inline": "max(lis, key=lambda x: x[1])"
  },
  "snippet": "max(lis, key=itemgetter(1))[0]"
 },
 "2689189.279": {
  "intent": "make a delay of 1 second",
  "body": "My Python program does a series of things and prints some diagnostic output. I would also like to have a progress counter like this:\nPercentage done: 25%\n\nwhere the number increases \"in place\". If I use only string statements I can write separate numbers, but that would clutter the screen. Is there some way to achieve this, for example using some escape char for backspace in order to clear a number and write the next one?\nThanks\n",
  "preds": {
   "base:Baseline": "time.sleep(1, 1)",
   "body:Baseline": "sys.exit(1, 1)",
   "body:-Blocks": "sys.stdout.sleep(1)",
   "body:-Code": "sys.sleep(1)\nsys.exit(0)",
   "body:-Inline": "sys.sleep(1, 1)",
   "body:-NL": "time.sleep(1, 1)",
   "base:+Mined": "time.sleep(0.1)",
   "body+mined:Baseline": "sys.stdout.flush()[0]",
   "body+mined:-Code": "sys.stdout.write('\\r\\n')",
   "body+mined:-NL": "sys.stdout.flush()[0]",
   "body+mined:-Blocks": "sys.stdout.flush()[1]",
   "body+mined:-Inline": "time.sleep(1.1)"
  },
  "snippet": "time.sleep(1)"
 },
 "12485244.280": {
  "intent": "convert list of tuples `l` to a string",
  "body": "I have the following list:\n[('Steve Buscemi', 'Mr. Pink'), ('Chris Penn', 'Nice Guy Eddie'), <console_out>]\n\nI need to convert it to a string in the following format:\n\"(Steve Buscemi, Mr. Pink), (Chris Penn, Nice Guy Eddit), <console_out>\"\n\nI tried doing \nstr = ', '.join(item for item in items)\n\nbut run into the following error:\nTypeError: sequence item 0: expected string, tuple found\n\nHow would I do the above formatting?\n",
  "preds": {
   "base:Baseline": "\"\"\"\"\"\".join(zip(*l))",
   "body:Baseline": "\"\"\"\"\"\".join(item for item in L))",
   "body:-Blocks": "\"\"\"\"\"\".join(str(x) for x in L))",
   "body:-Code": "\"\"\"\"\"\".join(str(x) for x in L)",
   "body:-Inline": "\"\"\"\"\"\".join(item for item in L)",
   "body:-NL": "\"\"\"\"\"\".join(item for item in L)",
   "base:+Mined": "\"\"\"\"\"\".join(map(str, L))",
   "body+mined:Baseline": "str = ', '.join(item for item in items)",
   "body+mined:-Code": "\"\"\"\"\"\".join(str(x) for x in l)",
   "body+mined:-NL": "\"\"\"(Steve Buscemi, Mr. Pink), (Chris Penn, Nice Guy Eddit), \"\"\".join(l)",
   "body+mined:-Blocks": "\"\"\"\"\"\".join(map(str, L))",
   "body+mined:-Inline": "str = ', '.join(item) for item in items)"
  },
  "snippet": "\"\"\", \"\"\".join('(' + ', '.join(i) + ')' for i in L)"
 },
 "755857.281": {
  "intent": "django set default value of field `b` equal to '0000000'",
  "body": "Suppose I have a model:\nclass SomeModel(models.Model):\n    id = models.AutoField(primary_key=True)\n    a = models.CharField(max_length=10)\n    b = models.CharField(max_length=7)\n\nCurrently I am using the default admin to create/edit objects of this type.\nHow do I remove the field b  from the admin so that each object cannot  be created with a value, and rather will receive a default value of 0000000 ?\n",
  "preds": {
   "base:Baseline": "django.setdefault_value(b, '0000000')",
   "body:Baseline": "SomeModel(models.Model).default_value=False)",
   "body:-Blocks": "admin.objects.setdefault_value(b, '0000000')",
   "body:-Code": "b = admin.objects.default('0000000')",
   "body:-Inline": "b.setdefault_value(0, '0000000')",
   "body:-NL": "SomeModel.setdefault('b')",
   "base:+Mined": "Book.objects.default(b=['0000000'])",
   "body+mined:Baseline": "SomeModel.objects.default_value('b')",
   "body+mined:-Code": "admin.site.register(b, '0000000')",
   "body+mined:-NL": "SomeModel.objects.extra(**kwargs)",
   "body+mined:-Blocks": "super(Admin, self).save(*args, **kwargs)",
   "body+mined:-Inline": "SomeModel.objects.default('b', '0000000')"
  },
  "snippet": "b = models.CharField(max_length=7, default='0000000', editable=False)"
 },
 "16193578.282": {
  "intent": "sort lis `list5` in ascending order based on the degrees value of its elements",
  "body": "If i have a list of numbers [4,2,5,1,3] \nI want to sort it first by some function f  and then for numbers with the same value of f  i want it to be sorted by the magnitude of the number.\nThis code does not seem to be working.\nlist5 = sorted(list5)\nlist5 = sorted(list5, key = lambda vertex: degree(vertex)) \n\nSecondary sorting first: list5 is sorted based on magnitude.\nPrimary sorting next: list5 is sorted based on some function of the numbers.  \n",
  "preds": {
   "base:Baseline": "sorted(list5, key=lambda x: x[1])",
   "body:Baseline": "sorted(list5, key=lambda k: k.sum(), reverse=True)",
   "body:-Blocks": "sorted(list5, key=lambda x: x[1], reverse=True)",
   "body:-Code": "sorted(list5, key=lambda x: x[1])",
   "body:-Inline": "list5 = sorted(list5, key=lambda vertex: degree(vertex))",
   "body:-NL": "list5 = sorted(list5, key=lambda x: x[1])",
   "base:+Mined": "sorted(list5, key=lambda x: x.degrees(x))",
   "body+mined:Baseline": "sorted(list5, key=lambda v: (v[1], v[2]))",
   "body+mined:-Code": "sorted(list5, key=lambda x: (int(x[1], x[0]))",
   "body+mined:-NL": "sorted(list5, key=lambda x: (x[0], x[1]))",
   "body+mined:-Blocks": "sorted(list5, key=lambda x: (int(x[1], x[1]))",
   "body+mined:-Inline": "sorted(list5, key=lambda v: v.degrees(v))"
  },
  "snippet": "sorted(list5, lambda x: (degree(x), x))"
 },
 "16193578.283": {
  "intent": "how do i perform secondary sorting in python?",
  "body": "If i have a list of numbers [4,2,5,1,3] \nI want to sort it first by some function f  and then for numbers with the same value of f  i want it to be sorted by the magnitude of the number.\nThis code does not seem to be working.\nlist5 = sorted(list5)\nlist5 = sorted(list5, key = lambda vertex: degree(vertex)) \n\nSecondary sorting first: list5 is sorted based on magnitude.\nPrimary sorting next: list5 is sorted based on some function of the numbers.  \n",
  "preds": {
   "base:Baseline": "sorted(list(range(10)), key=lambda x: x[1])",
   "body:Baseline": "sorted(list5, key=lambda x: x[4, 2, 5, 1, 3])",
   "body:-Blocks": "sorted(list5, key=lambda x: [4, 2, 5, 1, 3])",
   "body:-Code": "sorted(list(range(5)), key=lambda x: x[1])",
   "body:-Inline": "list5 = sorted(list5, key=lambda vertex: degree(vertex))",
   "body:-NL": "list5 = sorted(list5, key=lambda x: x[1])",
   "base:+Mined": "sorted(list(range(10)), key=lambda x: x[1])",
   "body+mined:Baseline": "sorted(list5, key=lambda v: (v[1], v[2]))",
   "body+mined:-Code": "sorted(list5, key=lambda x: (int(x[1], x[2]))",
   "body+mined:-NL": "[4, 2, 5, 1, 3]",
   "body+mined:-Blocks": "sorted(lst, key=lambda x: (x[1], x[1]))",
   "body+mined:-Inline": "sorted(list5, key=lambda vertex: degree(vertex))"
  },
  "snippet": "sorted(list5, key=lambda vertex: (degree(vertex), vertex))"
 },
 "16041405.284": {
  "intent": "convert a list  into a generator object",
  "body": "Say I have a list\ndata = []\ndata.append(\"A\")\ndata.append(\"B\")\ndata.append(\"C\")\ndata.append(\"D\")\n\nHow do I convert this to a generator?\nAny help with sample code would be highly appreciated...\nFound a URL: http://eli.thegreenplace.net/2012/04/05/implementing-a-generatoryield-in-a-python-c-extension/\nIs this what I want to do?\n",
  "preds": {
   "base:Baseline": " generator.from_iterable(key=lambda x: x[1])",
   "body:Baseline": "data = [i for i, v in enumerate(data.items()])]",
   "body:-Blocks": " generator.from_iterable(list, key=lambda x: x[1])",
   "body:-Code": "[item[0] for item in enumerate(list(itertools.product()))]",
   "body:-Inline": "data.append('A')[::-1]",
   "body:-NL": "generator.from_iterable(data)",
   "base:+Mined": "my_list = [i for i in range(10)]",
   "body+mined:Baseline": "print(list(itertools.chain.from_iterable(data)))",
   "body+mined:-Code": "from functools import reduce\nreduce(lambda x, y: x + y, [1, 2, 3])",
   "body+mined:-NL": "list(itertools.chain(*data))",
   "body+mined:-Blocks": "from functools import reduce\nreduce(lambda x, y: x + y, [1, 2, 3, 4, 5, 6, 7]))",
   "body+mined:-Inline": "from functools import reduce\nreduce(lambda x, y: x + y, [1, 2, 3])"
  },
  "snippet": "(n for n in [1, 2, 3, 5])"
 },
 "18837607.285": {
  "intent": "remove elements from list `oldlist` that have an index number mentioned in list `removelist`",
  "body": "So, for example, I got a list: myList=[\"asdf\",\"ghjk\",\"qwer\",\"tyui\"] \nI also have a list of index numbers of the items I want to remove: removeIndexList=[1,3]  (I want to remove items 1 and 3 from the list above)\nWhat would be the best way to do this?\n",
  "preds": {
   "base:Baseline": "[x for x in oldlist if x not inremovelist]",
   "body:Baseline": "[x for x in oldlist if x not in x]",
   "body:-Blocks": "[x for x in oldlist if x not inremovelist]",
   "body:-Code": "[x for x in oldlist if x not inremovelist]",
   "body:-Inline": "[x for x in oldlist if x not inremovelist]",
   "body:-NL": "[x for x in oldlist if x not inremovelist]",
   "base:+Mined": "oldlist = [x for x in oldlist if x not in index]",
   "body+mined:Baseline": "[x for x in oldlist if x.index == 'removelist']",
   "body+mined:-Code": "oldlist = [item for item in oldlist if item.index()]",
   "body+mined:-NL": "removelist = [x for x in oldlist if x not in indexList]",
   "body+mined:-Blocks": "oldlist = [x for x in oldList if x[i] == 2]",
   "body+mined:-Inline": "oldlist = [x for x in oldlist if x != 3]"
  },
  "snippet": "newlist = [v for i, v in enumerate(oldlist) if i not in removelist]"
 },
 "4710067.286": {
  "intent": "open a file `yourfile.txt` in write mode",
  "body": "Let's say I have a text file full of nicknames. How can I delete a specific nickname from this file, using Python?\n",
  "preds": {
   "base:Baseline": "open('yourfile.txt', 'write')",
   "body:Baseline": "open('yourfile.txt', 'write mode')",
   "body:-Blocks": "open('yourfile.txt', 'write')",
   "body:-Code": "open('yourfile.txt', 'write')",
   "body:-Inline": "open('yourfile.txt', 'rb')",
   "body:-NL": "open('yourfile.txt', 'write')",
   "base:+Mined": "f = open('yourfile.txt', 'wb')",
   "body+mined:Baseline": "open('yourfile.txt', 'wb')",
   "body+mined:-Code": "f.write('yourfile.txt', 'r')",
   "body+mined:-NL": "f = open('yourfile.txt', 'rb')",
   "body+mined:-Blocks": "f.write(yourfile.txt)",
   "body+mined:-Inline": "yourfile.txt.write('\\n')"
  },
  "snippet": "f = open('yourfile.txt', 'w')"
 },
 "7373219.287": {
  "intent": "get attribute 'attr' from object `obj`",
  "body": "I vaguely remember learning about some sort of built-in function that would do the equivalent of\nf = lambda x: x.attr\n\nAm I just imagining this or does such a thing exist? \n",
  "preds": {
   "base:Baseline": "obj.getattr('attr', 1)",
   "body:Baseline": "obj = lambda x: x.attr(obj)",
   "body:-Blocks": "obj['attr'] = obj.attr",
   "body:-Code": "obj['attr'] = obj.getattr()",
   "body:-Inline": "f = obj.getattr('attr')",
   "body:-NL": "obj = obj.attribute('attr')",
   "base:+Mined": "obj.getattr(obj, 'attr')",
   "body+mined:Baseline": "f = obj.getattr(obj)",
   "body+mined:-Code": "obj.getattr(__builtins__)",
   "body+mined:-NL": "obj = obj.getattr(obj)",
   "body+mined:-Blocks": "obj.getattr(obj, 'attr')",
   "body+mined:-Inline": "obj.attrgetter('attr')"
  },
  "snippet": "getattr(obj, 'attr')"
 },
 "8171751.288": {
  "intent": "convert tuple of tuples `(('aa',), ('bb',), ('cc',))` to tuple",
  "body": "query = 'select mydata from mytable'\ncursor.execute(query)\nmyoutput = cursor.fetchall() \nprint myoutput\n\n(('aa',), ('bb',), ('cc',))\n\nWhy is it (cursor.fetchall) returning a tuple of tuples instead of a tuple since my query is asking for only one column of data?\nWhat is the best way of converting it to ['aa', 'bb', 'cc']  ?\nI can do something like this :\nmylist = []\nmyoutput = list(myoutput)\nfor each in myoutput:\n   mylist.append(each[0])\n\nI am sure this isn't the best way of doing it. Please enlighten me!\n",
  "preds": {
   "base:Baseline": "tuple(map(lambda x: (('aa', ('bb',), ('cc',))))",
   "body:Baseline": "cursor.execute(query, ('aa', 'bb'), ('cc',))",
   "body:-Blocks": "cursor.fetchall(('aa', ('bb',), ('cc',))",
   "body:-Code": "cursor.fetchall(('aa', (bb',), ('cc',))",
   "body:-Inline": "cursor.set_tuple(('aa', ('bb',), ('cc',))",
   "body:-NL": "cursor.execute(list(myoutput))",
   "base:+Mined": "tuple(map(lambda tup: tup[::-1], (('aa',), ('bb',), 'cc',))])",
   "body+mined:Baseline": "myoutput = tuple(map(lambda t: t[0]))",
   "body+mined:-Code": "tuple(map(lambda x: x[1], ('BB',), ('cc',))",
   "body+mined:-NL": "myoutput = tuple(map(lambda t: t[0]), cursor.fetchall())",
   "body+mined:-Blocks": "tuple(map(lambda tup: tup[1], (('aa',), 'bb',), ('cc',))])",
   "body+mined:-Inline": "tuple(map(lambda t: t[0]) for t in myoutput)"
  },
  "snippet": "from functools import reduce\nreduce(lambda a, b: a + b, (('aa',), ('bb',), ('cc',)))"
 },
 "8171751.289": {
  "intent": "convert tuple of tuples `(('aa',), ('bb',), ('cc',))` to list in one line",
  "body": "query = 'select mydata from mytable'\ncursor.execute(query)\nmyoutput = cursor.fetchall() \nprint myoutput\n\n(('aa',), ('bb',), ('cc',))\n\nWhy is it (cursor.fetchall) returning a tuple of tuples instead of a tuple since my query is asking for only one column of data?\nWhat is the best way of converting it to ['aa', 'bb', 'cc']  ?\nI can do something like this :\nmylist = []\nmyoutput = list(myoutput)\nfor each in myoutput:\n   mylist.append(each[0])\n\nI am sure this isn't the best way of doing it. Please enlighten me!\n",
  "preds": {
   "base:Baseline": "[(('aa',), ('bb',), 'cc',)) for i in range(1)]",
   "body:Baseline": "cursor.execute(query, (('aa', 'bb',), ('cc',))",
   "body:-Blocks": "cursor.fetchall(('aa', ('bb',), ('cc',))",
   "body:-Code": "cursor.fetchall(('aa', (bb',), ('cc',))",
   "body:-Inline": "query = [[(('aa', ('bb',), ('cc',))] for i in range(0)]",
   "body:-NL": "cursor.execute(list(myoutput))",
   "base:+Mined": "map(lambda t: t[(('aa',), ('bb',), 'cc',))]",
   "body+mined:Baseline": "myoutput = list(myoutput)",
   "body+mined:-Code": "cursor.fetchall('(('aa',), ('bb',), 'cc',))",
   "body+mined:-NL": "['aa', 'bb', 'cc']",
   "body+mined:-Blocks": "[tuple(i) for i in (('aa',), ('bb',), 'cc')]",
   "body+mined:-Inline": "myoutput = list(mytable)"
  },
  "snippet": "map(lambda a: a[0], (('aa',), ('bb',), ('cc',)))"
 },
 "28986489.290": {
  "intent": "python pandas: how to replace a characters in a column of a dataframe?",
  "body": "I have a column in my dataframe like this:\nrange\n\"(2,30)\"\n\"(50,290)\"\n\"(400,1000)\"\n\n\nand I want to replace the ,  comma with -  dash. I'm currently using this method but nothing is changed.\norg_info_exc['range'].replace(',', '-', inplace=True)\n\nCan anybody help?\n",
  "preds": {
   "base:Baseline": "df.dropna(df.columns, axis=1)",
   "body:Baseline": "df['range'].replace(',', '-', inplace=True)",
   "body:-Blocks": "df['collections'] = df['Collections']",
   "body:-Code": "df['s'].replace('', '')",
   "body:-Inline": "df['range'].replace(',', '-', inplace=True)",
   "body:-NL": "df['range'].replace(',', '-', inplace=True)",
   "base:+Mined": "df = df.replace(' ', '')",
   "body+mined:Baseline": "df['range'].replace(',', '-', inplace=True)",
   "body+mined:-Code": "df['column_name'].replace('', '')",
   "body+mined:-NL": "df['range'].replace(',', '-', inplace=True)",
   "body+mined:-Blocks": "df['dash'] = df['dash'].replace(' ', '')",
   "body+mined:-Inline": "df['range'].replace(',', '-', inplace=True)"
  },
  "snippet": "df['range'].replace(',', '-', inplace=True)"
 },
 "19339.291": {
  "intent": "unzip the list `[('a', 1), ('b', 2), ('c', 3), ('d', 4)]`",
  "body": "I have a list of 2-item tuples and I'd like to convert them to 2 lists where the first contains the first item in each tuple and the second list holds the second item.\nFor example:\noriginal = [('a', 1), ('b', 2), ('c', 3), ('d', 4)]\n# and I want to become...\nresult = (['a', 'b', 'c', 'd'], [1, 2, 3, 4])\n\nIs there a builtin function that does that?\n",
  "preds": {
   "base:Baseline": "zip([('A', 1), ('B', 2), ('C', 3), ('D', 4)])",
   "body:Baseline": "[('a', 1), ('b', 2), ('c', 3), ('d', 4)]",
   "body:-Blocks": "zip([('A', 1), ('B', 2), ('C', 3), ('D', 4)])",
   "body:-Code": "zip([('A', 1), ('B', 2), ('C', 3), ('D', 4)])",
   "body:-Inline": "zip(*[('a', 1), ('b', 2), ('c', 3), ('d', 4)])",
   "body:-NL": "zip(*[('a', 1), ('b', 2), ('c', 3), ('d', 4)]",
   "base:+Mined": "zip(*([('a', 1), ('b', 2), ('c', 3), ('d', 4)])",
   "body+mined:Baseline": "zip(*[('a', 1), ('b', 2), ('c', 3), ('d', 4)])",
   "body+mined:-Code": "zip(*([('A', 1), ('B', 2), ('C', 3), ('D', 4)])",
   "body+mined:-NL": "new = zip(*[('a', 1), ('b', 2), ('c', 3), ('d', 4)]",
   "body+mined:-Blocks": "zip(*[('a', 1), ('b', 2), ('c', 3), ('d', 4)])",
   "body+mined:-Inline": "zip(*[('a', 1), ('b', 2), ('c', 3), ('d', 4)])"
  },
  "snippet": "zip(*[('a', 1), ('b', 2), ('c', 3), ('d', 4)])"
 },
 "19339.292": {
  "intent": "unzip the list `[('a', 1), ('b', 2), ('c', 3), ('d', 4)]`",
  "body": "I have a list of 2-item tuples and I'd like to convert them to 2 lists where the first contains the first item in each tuple and the second list holds the second item.\nFor example:\noriginal = [('a', 1), ('b', 2), ('c', 3), ('d', 4)]\n# and I want to become...\nresult = (['a', 'b', 'c', 'd'], [1, 2, 3, 4])\n\nIs there a builtin function that does that?\n",
  "preds": {
   "base:Baseline": "zip([('A', 1), ('B', 2), ('C', 3), ('D', 4)])",
   "body:Baseline": "[('a', 1), ('b', 2), ('c', 3), ('d', 4)]",
   "body:-Blocks": "zip([('A', 1), ('B', 2), ('C', 3), ('D', 4)])",
   "body:-Code": "zip([('A', 1), ('B', 2), ('C', 3), ('D', 4)])",
   "body:-Inline": "zip(*[('a', 1), ('b', 2), ('c', 3), ('d', 4)])",
   "body:-NL": "zip(*[('a', 1), ('b', 2), ('c', 3), ('d', 4)]",
   "base:+Mined": "zip(*([('a', 1), ('b', 2), ('c', 3), ('d', 4)])",
   "body+mined:Baseline": "zip(*[('a', 1), ('b', 2), ('c', 3), ('d', 4)])",
   "body+mined:-Code": "zip(*([('A', 1), ('B', 2), ('C', 3), ('D', 4)])",
   "body+mined:-NL": "new = zip(*[('a', 1), ('b', 2), ('c', 3), ('d', 4)]",
   "body+mined:-Blocks": "zip(*[('a', 1), ('b', 2), ('c', 3), ('d', 4)])",
   "body+mined:-Inline": "zip(*[('a', 1), ('b', 2), ('c', 3), ('d', 4)])"
  },
  "snippet": "zip(*[('a', 1), ('b', 2), ('c', 3), ('d', 4)])"
 },
 "19339.293": {
  "intent": "unzip list `original`",
  "body": "I have a list of 2-item tuples and I'd like to convert them to 2 lists where the first contains the first item in each tuple and the second list holds the second item.\nFor example:\noriginal = [('a', 1), ('b', 2), ('c', 3), ('d', 4)]\n# and I want to become...\nresult = (['a', 'b', 'c', 'd'], [1, 2, 3, 4])\n\nIs there a builtin function that does that?\n",
  "preds": {
   "base:Baseline": "original.unzip(key=operator.itemgetter(1))",
   "body:Baseline": "zip(original, key=lambda x: x[1], reverse=True)",
   "body:-Blocks": "original.zip(key=operator.itemgetter(1))",
   "body:-Code": "original.zip(key=operator.itemgetter(1))",
   "body:-Inline": "original = zip(original, key=lambda x: x[1])",
   "body:-NL": "original = [('a', 1), ('b', 2), ('c', 3), ('d', 4)]",
   "base:+Mined": "original = zip(*sorted(original))",
   "body+mined:Baseline": "zip(original, result[:]))",
   "body+mined:-Code": "original.zip(key=operator.itemgetter(1))",
   "body+mined:-NL": "result = [(x[0], x[1] for x in original]",
   "body+mined:-Blocks": "new_list = zip(*original)",
   "body+mined:-Inline": "zip(*original)[::-1]"
  },
  "snippet": "result = [a for a, b in original], [b for a, b in original]"
 },
 "19339.294": {
  "intent": "unzip list `original` and return a generator",
  "body": "I have a list of 2-item tuples and I'd like to convert them to 2 lists where the first contains the first item in each tuple and the second list holds the second item.\nFor example:\noriginal = [('a', 1), ('b', 2), ('c', 3), ('d', 4)]\n# and I want to become...\nresult = (['a', 'b', 'c', 'd'], [1, 2, 3, 4])\n\nIs there a builtin function that does that?\n",
  "preds": {
   "base:Baseline": "original = [i for i in range(0, len(original), 1)]",
   "body:Baseline": "re.unzip(original, key=lambda x: x[1], reverse=True)",
   "body:-Blocks": "original.unzip(key=operator.itemgetter(1))",
   "body:-Code": " generator.unzip(original, key=operator.itemgetter(1))",
   "body:-Inline": "new = [zip(original, key=lambda x: x[1])",
   "body:-NL": "return generator.unzip(original)",
   "base:+Mined": "from functools import reduce\nreduce(lambda x, y: x + y, [1, 2, 3, 4, 5, 6])",
   "body+mined:Baseline": "new = zip(*original, result)",
   "body+mined:-Code": "new_list = zip(*original)",
   "body+mined:-NL": "new_list = [random.sample(list(original.items())) for _ in range(0, len(\n    original), 3)]",
   "body+mined:-Blocks": "new_list = zip(*original)",
   "body+mined:-Inline": "[(x + y) for x, y in zip(original, result)]"
  },
  "snippet": "result = (a for a, b in original), (b for a, b in original)"
 },
 "19339.295": {
  "intent": "unzip list `[('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e', )]`",
  "body": "I have a list of 2-item tuples and I'd like to convert them to 2 lists where the first contains the first item in each tuple and the second list holds the second item.\nFor example:\noriginal = [('a', 1), ('b', 2), ('c', 3), ('d', 4)]\n# and I want to become...\nresult = (['a', 'b', 'c', 'd'], [1, 2, 3, 4])\n\nIs there a builtin function that does that?\n",
  "preds": {
   "base:Baseline": "zip(*[[('A', 1), ('B', 2), ('C', 3), ('D', 4), ('E', 5)])",
   "body:Baseline": "zip(*('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e', )])",
   "body:-Blocks": "zip(*[[('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e', )])]",
   "body:-Code": "zip(*[[('A', 1), ('B', 2), ('C', 3), ('D', 4), ('E', )]))",
   "body:-Inline": "zip(*[('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e', 5)]",
   "body:-NL": "zip(*[('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e',)])",
   "base:+Mined": "zip(*[('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e', 5), ('f', 6), ('g', 7), ('h', 8)]",
   "body+mined:Baseline": "zip(*[('a', 1), ('b', 2), ('c', 3), ('d', 4)])",
   "body+mined:-Code": "zip(*[('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e', 5)]",
   "body+mined:-NL": "new = zip(*new)[::-1]",
   "body+mined:-Blocks": "zip(*[('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e', 5)]",
   "body+mined:-Inline": "zip(*[('a', 1), ('b', 2), ('c', 3), ('d', 4)])"
  },
  "snippet": "zip(*[('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e',)])"
 },
 "19339.296": {
  "intent": "unzip list `[('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e', )]` and fill empty results with none",
  "body": "I have a list of 2-item tuples and I'd like to convert them to 2 lists where the first contains the first item in each tuple and the second list holds the second item.\nFor example:\noriginal = [('a', 1), ('b', 2), ('c', 3), ('d', 4)]\n# and I want to become...\nresult = (['a', 'b', 'c', 'd'], [1, 2, 3, 4])\n\nIs there a builtin function that does that?\n",
  "preds": {
   "base:Baseline": "zip(*[[('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e', 5)])",
   "body:Baseline": "results = [('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e', )]]",
   "body:-Blocks": "zip(*[[('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e',)]])",
   "body:-Code": "zip(*[[('A', 1), ('B', 2), ('C', 3), ('D', 4), ('E', )]))",
   "body:-Inline": "result = [(('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e', 5))",
   "body:-NL": "result = [('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e',)]",
   "base:+Mined": "zip(*[[('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e', 5), ('n'])])",
   "body+mined:Baseline": "zip(*[('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e', 5)]",
   "body+mined:-Code": "zip(*((a', 1), ('b', 2), ('c', 3), ('d', 4), ('e', 5))",
   "body+mined:-NL": "new = [x for x in original if x is not None]",
   "body+mined:-Blocks": "[('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e', 5)]",
   "body+mined:-Inline": "zip(*[('a', 1), ('b', 2), ('c', 3), ('d', 4)])"
  },
  "snippet": "map(None, *[('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e',)])"
 },
 "1960516.297": {
  "intent": "encode `decimal('3.9')` to a json string",
  "body": "I have a Decimal('3.9')  as part of an object, and wish to encode this to a JSON string which should look like {'x': 3.9} . I don't care about precision on the client side, so a float is fine.\nIs there a good way to serialize this? JSONDecoder doesn't accept Decimal objects, and converting to a float beforehand yields {'x': 3.8999999999999999}  which is wrong, and will be a big waste of bandwidth.\n",
  "preds": {
   "base:Baseline": "json.encode('3.9')",
   "body:Baseline": "json.decimal('3.9')",
   "body:-Blocks": "json.decimal('3.9')",
   "body:-Code": "json.decimal('3.9')",
   "body:-Inline": "json.decimal('3.9')",
   "body:-NL": "json.decimal('3.9')",
   "base:+Mined": "json.dumps(decimal('3.9')).encode('utf-8')",
   "body+mined:Baseline": "json.dumps(decimal('3.9')))",
   "body+mined:-Code": "json.dumps(decimal('3.9')).encode('float')",
   "body+mined:-NL": "json.dumps(decimal('3.9')).encode('utf-8')",
   "body+mined:-Blocks": "json.dumps(decimal('3.9').encode('utf-8')",
   "body+mined:-Inline": "json.dumps(decimal('3.9'))"
  },
  "snippet": "json.dumps(Decimal('3.9'))"
 },
 "1024847.298": {
  "intent": "add key \"mynewkey\" to dictionary `d` with value \"mynewvalue\"",
  "body": "Is it possible to add a key to a Python dictionary after it has been created?\nIt doesn't seem to have an .add()  method.\n",
  "preds": {
   "base:Baseline": "d = {'mynewkey': d.get('mynewvalue'})",
   "body:Baseline": "d = list(d.items()))",
   "body:-Blocks": "d = {'mynewkey': d.get('mynewvalue'})",
   "body:-Code": "d = {'mynewkey':'mynewvalue'})",
   "body:-Inline": "d['mynewkey'] = 'mynewvalue'",
   "body:-NL": "d = d.update({'mynewkey': 'mynewvalue'})",
   "base:+Mined": "d = {'mynewkey': 'mynewvalue'}",
   "body+mined:Baseline": "d['mynewkey'] = 'mynewvalue'",
   "body+mined:-Code": "d['mynewkey'] = 'Mynewvalue'",
   "body+mined:-NL": "d.update({'mynewkey': 'mynewvalue'})",
   "body+mined:-Blocks": "d.update({'mynewkey': 'mynewvalue'})",
   "body+mined:-Inline": "d = {'mynewkey': 'mynewvalue'}"
  },
  "snippet": "d['mynewkey'] = 'mynewvalue'"
 },
 "1024847.299": {
  "intent": "add key 'a' to dictionary `data` with value 1",
  "body": "Is it possible to add a key to a Python dictionary after it has been created?\nIt doesn't seem to have an .add()  method.\n",
  "preds": {
   "base:Baseline": "data.update({'a': 1})",
   "body:Baseline": "data.update({'a': 1})",
   "body:-Blocks": "data.update({'a': 1})",
   "body:-Code": "data.update({'a': 1})",
   "body:-Inline": "data.update({'a': 1})",
   "body:-NL": "data.update({'a': 1})",
   "base:+Mined": "data['a'].update({'a': 1})",
   "body+mined:Baseline": "data.update({'a': 1})",
   "body+mined:-Code": "data.update({'a': 1})",
   "body+mined:-NL": "data.update({'a': 1})",
   "body+mined:-Blocks": "data.update({'a': 1, 'b': 1})",
   "body+mined:-Inline": "data.update({'a': 1})"
  },
  "snippet": "data.update({'a': 1})"
 },
 "1024847.300": {
  "intent": "add key 'a' to dictionary `data` with value 1",
  "body": "Is it possible to add a key to a Python dictionary after it has been created?\nIt doesn't seem to have an .add()  method.\n",
  "preds": {
   "base:Baseline": "data.update({'a': 1})",
   "body:Baseline": "data.update({'a': 1})",
   "body:-Blocks": "data.update({'a': 1})",
   "body:-Code": "data.update({'a': 1})",
   "body:-Inline": "data.update({'a': 1})",
   "body:-NL": "data.update({'a': 1})",
   "base:+Mined": "data['a'].update({'a': 1})",
   "body+mined:Baseline": "data.update({'a': 1})",
   "body+mined:-Code": "data.update({'a': 1})",
   "body+mined:-NL": "data.update({'a': 1})",
   "body+mined:-Blocks": "data.update({'a': 1, 'b': 1})",
   "body+mined:-Inline": "data.update({'a': 1})"
  },
  "snippet": "data.update(dict(a=1))"
 },
 "1024847.301": {
  "intent": "add key 'a' to dictionary `data` with value 1",
  "body": "Is it possible to add a key to a Python dictionary after it has been created?\nIt doesn't seem to have an .add()  method.\n",
  "preds": {
   "base:Baseline": "data.update({'a': 1})",
   "body:Baseline": "data.update({'a': 1})",
   "body:-Blocks": "data.update({'a': 1})",
   "body:-Code": "data.update({'a': 1})",
   "body:-Inline": "data.update({'a': 1})",
   "body:-NL": "data.update({'a': 1})",
   "base:+Mined": "data['a'].update({'a': 1})",
   "body+mined:Baseline": "data.update({'a': 1})",
   "body+mined:-Code": "data.update({'a': 1})",
   "body+mined:-NL": "data.update({'a': 1})",
   "body+mined:-Blocks": "data.update({'a': 1, 'b': 1})",
   "body+mined:-Inline": "data.update({'a': 1})"
  },
  "snippet": "data.update(a=1)"
 },
 "35837346.302": {
  "intent": "find maximal value in matrix `matrix`",
  "body": "To find the maximal value in a matrix of numbers, we can code 5 lines to solve the problem:\nans = matrix[0][0]\nfor x in range(len(matrix)):\n    for y in range(len(matrix[0])):\n        ans = max(ans, matrix[x][y])\nreturn ans\n\nIs there a one line solution for this problem?\nThe one that I came up with is pretty awkward actually:\nreturn max(max(matrix, key=max))\n\nor\nreturn max(map(max, matrix))\n\n",
  "preds": {
   "base:Baseline": "max(matrix, key=lambda x: x[1])",
   "body:Baseline": "max(len(matrix, key=max))",
   "body:-Blocks": "max(matrix, key=lambda x: x[1])",
   "body:-Code": "max(matrix, key=lambda x: x[1])",
   "body:-Inline": "max(matrix, key=max)",
   "body:-NL": "max(ans, matrix[x][y])",
   "base:+Mined": "np.max(matrix, axis=1)",
   "body+mined:Baseline": "max(abs, matrix[x][y])",
   "body+mined:-Code": "np.max(matrix, axis=1)",
   "body+mined:-NL": "max(ans, matrix[x][y])",
   "body+mined:-Blocks": "matrix[np.max(matrix, axis=1)]",
   "body+mined:-Inline": "max(abs, matrix[x][y])"
  },
  "snippet": "max([max(i) for i in matrix])"
 },
 "20457038.303": {
  "intent": "round number `answer` to 2 precision after the decimal point",
  "body": "I am getting a lot of decimals in the output of this code (Fahrenheit to Celsius converter).\nMy code currently looks like this:\ndef main():\n    printC(formeln(typeHere()))\n\ndef typeHere():\n    global Fahrenheit\n    try:\n        Fahrenheit = int(raw_input(\"Hi! Enter Fahrenheit value, and get it in Celsius!\\n\"))\n    except ValueError:\n        print \"\\nYour insertion was not a digit!\"\n        print \"We've put your Fahrenheit value to 50!\"\n        Fahrenheit = 50\n    return Fahrenheit\n\ndef formeln(c):\n    Celsius = (Fahrenheit - 32.00) * 5.00/9.00\n    return Celsius\n\ndef printC(answer):\n    answer = str(answer)\n    print \"\\nYour Celsius value is \" + answer + \" C.\\n\"\n\n\n\nmain()\n\nSo my question is, how do I make the program round every answer to the 2nd decimal place?\n",
  "preds": {
   "base:Baseline": "round(answer.round(2))",
   "body:Baseline": "round(answer, 2, 1)",
   "body:-Blocks": "answer.round(2, 2)",
   "body:-Code": "print(answer.round(2))",
   "body:-Inline": "print('{0:.2f}'.format(answer))",
   "body:-NL": "answer = str(answer) + 2",
   "base:+Mined": "round(answer, 2, 2)",
   "body+mined:Baseline": "print('Celsius = (Fahrenheit - 32.00) * 5.00 / 9.00')",
   "body+mined:-Code": "round(answer.split('.')[2])",
   "body+mined:-NL": "print('\\n'.join(round(answer))",
   "body+mined:-Blocks": "print('%.2f' % round(answer))",
   "body+mined:-Inline": "round(Fahrenheit - 32.0, 2)"
  },
  "snippet": "answer = str(round(answer, 2))"
 },
 "2890896.304": {
  "intent": "extract ip address from an html string",
  "body": "I want to extract an IP address from a string (actually a one-line HTML) using Python.\ns = \" <title>Current IP Check </title> </head> <body>Current IP Address: 165.91.15.131 </body> </html>\"\n\n-- '165.91.15.131' is what I want!\nI tried using regular expressions, but so far I can only get to the first number.\nimport re\nip = re.findall( r'([0-9]+)(?:\\.[0-9]+){3}', s )\nip\n['165']\n\nBut I don't have a firm grasp on reg-expression; the above code was found and modified from elsewhere on the web.\n",
  "preds": {
   "base:Baseline": "urllib.parse.unquote(id=0, ip=0)",
   "body:Baseline": " ip = re.findall('([0-9]+)(?:\\.[0- 9]+){3}', s)",
   "body:-Blocks": "urllib.parse.rpath.retrieve(IP address)",
   "body:-Code": "urllib.parse.unquote(IP address, '165.91.15.131')",
   "body:-Inline": "s = re.findall('([0-9]+)(?:\\\\.[0- 9]+){3}', s)",
   "body:-NL": "\"\"\".join(re.findall('([0-9]+)(?:\\.[0- 9]+){3}', s))",
   "base:+Mined": "soup.find_elements_by_xpath('//ip address[@ip address]')",
   "body+mined:Baseline": "s = re.findall('(?<!>[0-9]+)(?:\\\\.[0-10]+){3}', s)",
   "body+mined:-Code": "socket.gethostbyname('168.91.15.131')",
   "body+mined:-NL": "print(s.encode('utf-8'))",
   "body+mined:-Blocks": "urllib.request.urlopen('http://www.google.com')",
   "body+mined:-Inline": "print(s.encode('utf-8'))"
  },
  "snippet": "ip = re.findall('[0-9]+(?:\\\\.[0-9]+){3}', s)"
 },
 "29836836.305": {
  "intent": "filter dataframe `df` by values in column `a` that appear more than once",
  "body": "I'm working in Python with a pandas DataFrame of video games, each with a genre. I'm trying to remove any video game with a genre that appears less than some number of times in the DataFrame, but I have no clue how to go about this. I did find a StackOverflow question  that seems to be related, but I can't decipher the solution at all (possibly because I've never heard of R and my memory of functional programming is rusty at best).\nHelp?\n",
  "preds": {
   "base:Baseline": "df.filter(['a'], axis=1)",
   "body:Baseline": "df.filter(['a'], a)",
   "body:-Blocks": "df.filter(df.columns, 'a' == 0)",
   "body:-Code": "df.filter(df.a)",
   "body:-Inline": "df.filter(['a'], a)",
   "body:-NL": "df.filter(['a'], axis=1)",
   "base:+Mined": "df.filter(lambda x: len(x), axis=1)",
   "body+mined:Baseline": "df.ix[df.genre.str.count('a') > 0]",
   "body+mined:-Code": "df.filter(df.genre == 'genre' > 0)",
   "body+mined:-NL": "df.filter(df.columns, axis=1)",
   "body+mined:-Blocks": "df.filter(df.genre.str.counts(a))",
   "body+mined:-Inline": "df.ix[df.genre.str.count('a') > 1]"
  },
  "snippet": "df.groupby('A').filter(lambda x: len(x) > 1)"
 },
 "2545397.306": {
  "intent": "append each line in file `myfile` into a list",
  "body": "I have a text document that contains a list of numbers and I want to convert it to a list. Right now I can only get the entire list in the 0th entry of the list, but I want each number to be an element of a list. Does anyone know of an easy way to do this in Python?\n1000\n2000\n3000\n4000\n\nto \n['1000','2000','3000','4000']\n\n",
  "preds": {
   "base:Baseline": "myfile.append('\\n'.join(myfile))",
   "body:Baseline": "[x[0] for x in myfile]",
   "body:-Blocks": "[x for x in myfile if not x in x]",
   "body:-Code": "[x for x in myfile]",
   "body:-Inline": "[x for x in myfile]",
   "body:-NL": "[line for line in myfile]",
   "base:+Mined": "myfile = [line[0] for line in myfile]",
   "body+mined:Baseline": "['1000', '2000', '3000', '4000']",
   "body+mined:-Code": "[line for line in open('myfile').read()]",
   "body+mined:-NL": "['1000', '2000', '3000', '4000']",
   "body+mined:-Blocks": "[line for line in open('myfile').read()]",
   "body+mined:-Inline": "[int(x) for x in myfile]"
  },
  "snippet": "[x for x in myfile.splitlines() if x != '']"
 },
 "2545397.307": {
  "intent": "get a list of integers `lst` from a file `filename.txt`",
  "body": "I have a text document that contains a list of numbers and I want to convert it to a list. Right now I can only get the entire list in the 0th entry of the list, but I want each number to be an element of a list. Does anyone know of an easy way to do this in Python?\n1000\n2000\n3000\n4000\n\nto \n['1000','2000','3000','4000']\n\n",
  "preds": {
   "base:Baseline": "[int(x) for x in open('filename.txt')]",
   "body:Baseline": "[int(x) for x in open('filename.txt')]",
   "body:-Blocks": "[int(x) for x in open('filename.txt')]",
   "body:-Code": "[int(x) for x in open('filename.txt')]",
   "body:-Inline": "[int(x) for x in open('filename.txt')]",
   "body:-NL": "[int(x) for x in open('filename.txt')]",
   "base:+Mined": "lst = [int(i) for i in open('filename.txt')]",
   "body+mined:Baseline": "[int(x) for x in open('filename.txt')]",
   "body+mined:-Code": "lst = [int(i) for i in open(filename.txt)]",
   "body+mined:-NL": "lst = [int(x) for x infilename.txt]",
   "body+mined:-Blocks": "lst = [int(i) for i in open('filename.txt')]",
   "body+mined:-Inline": "[int(x) for x in open('filename.txt')]"
  },
  "snippet": "lst = map(int, open('filename.txt').readlines())"
 },
 "35420052.308": {
  "intent": "add color bar with image `mappable` to plot `plt`",
  "body": "I'm trying to add a Colorbar to a spectrogram. I have tried every example and question thread I have found online and none have solved this issue\nNote that 'spl1' (data splice 1) is a trace from ObsPy.\nMy code is:\nfig = plt.figure()\nax1 = fig.add_axes([0.1, 0.75, 0.7, 0.2]) #[left bottom width height]\nax2 = fig.add_axes([0.1, 0.1, 0.7, 0.60], sharex=ax1)\nax3 = fig.add_axes([0.83, 0.1, 0.03, 0.6])\n\nt = np.arange(spl1[0].stats.npts) / spl1[0].stats.sampling_rate\nax1.plot(t, spl1[0].data, 'k')\n\nax,spec = spectrogram(spl1[0].data,spl1[0].stats.sampling_rate, show=False, axes=ax2)\nax2.set_ylim(0.1, 15)\nfig.colorbar(spec, cax=ax3)\n\nIt comes out with the error:\nTraceback (most recent call last):\n\n  File \" <ipython-input-18-61226ccd2d85>\", line 14, in <module>\n    ax,spec = spectrogram(spl1[0].data,spl1[0].stats.sampling_rate, show=False, axes=ax2)\n\nTypeError: 'Axes' object is not iterable\n\nBest result so far:\nReplacing the last 3 lines above with:\nax = spectrogram(spl1[0].data,spl1[0].stats.sampling_rate, show=False, axes=ax2)\nax2.set_ylim(0.1, 15)\nfig.colorbar(ax,cax=ax3)\n\nProduces this:\n\nand this error for the colorbar:\naxes object has no attribute 'autoscale_None'\n\nI don't seem to be able to find a way to get the colorbar on the right to work.\nSolutions?\nOne of the solutions I have seen is that you need to create an 'image' of your data using imshow(), however I don't get an output for that from Spectrogram(), only 'ax'. I have seen places try with the 'ax,spec' output from spectrogram() but that is causing the TypeError.\n\nVery similar code I found but didn't work https://www.nicotrebbin.de/wp-content/uploads/2012/03/bachelorthesis.pdf  (ctrl+f 'colorbar')\nLooked at code examples from a related question\nimshow() suggestions  and example  - can't get an output from spectrogram to turn into an image. That second link, I also can't get the mlpy module to work (it doesn't think there's a mlpy.wavelet function)\nThis problem was addressed in an improvement post for obspy  but the solution he stated he found was not given\n\nI hope someone can give a hand with this - I've been working on this all day now!\n",
  "preds": {
   "base:Baseline": "plt.set_color_bar('mappable')",
   "body:Baseline": "plt.set_ylim(0.1, 15)",
   "body:-Blocks": "plt.set_image_bar('mappable')",
   "body:-Code": "plt.set_colorbar('mappable')",
   "body:-Inline": "plt.colorbar(mappable)",
   "body:-NL": "plt.plot(t, spl1[0].mappable)",
   "base:+Mined": "plt.colorbar(mappable)",
   "body+mined:Baseline": "plt.colorbar(mappable)",
   "body+mined:-Code": "plt.imshow('mappable')",
   "body+mined:-NL": "plt.colorbar(ax, cax=ax3)",
   "body+mined:-Blocks": "plt.imshow('spl1', interpolation='mappable')",
   "body+mined:-Inline": "plt.colorbar(t, spl1[0].data, 'k')"
  },
  "snippet": "plt.colorbar(mappable=mappable, cax=ax3)"
 },
 "29903025.309": {
  "intent": "count most frequent 100 words in column 'text' of dataframe `df`",
  "body": "I have text reviews in one column in Pandas dataframe and I want to count the N-most frequent words with their frequency counts (in whole column - NOT in single cell). One approach is Counting the words using a counter, by iterating through each row. Is there a better alternative?\nRepresentative data.\n0    a heartening tale of small victories and endu\n1    no sophomore slump for director sam mendes  w\n2    if you are an actor who can relate to the sea\n3    it's this memory-as-identity obviation that g\n4    boyd's screenplay ( co-written with guardian\n\n",
  "preds": {
   "base:Baseline": "df['text'] = df['text'].max(100)",
   "body:Baseline": "df['text'] = df['text'].count(100)",
   "body:-Blocks": "df['text'] = df['text'].count()",
   "body:-Code": "df.count_common_words('text')",
   "body:-Inline": "df['text'] = df['text'].sum()",
   "body:-NL": "df['text'].count(100)",
   "base:+Mined": "df.groupby(['text'])['value'].count()",
   "body+mined:Baseline": "df.groupby(['text', 'reaction']).sum()",
   "body+mined:-Code": "df.reindex_words('text', inplace=True)",
   "body+mined:-NL": "df['text'].apply(lambda x: len(x), axis=1)",
   "body+mined:-Blocks": "df['text'] = df['text'].nunique()",
   "body+mined:-Inline": "df.words.apply(lambda x: len(x), axis=1)"
  },
  "snippet": "Counter(' '.join(df['text']).split()).most_common(100)"
 },
 "16330838.310": {
  "intent": "python split a string using regex",
  "body": "I would like to split a string by ':' and ' ' characters. However, i would like to ignore two spaces '  ' and  two colons '::'. for e.g.\ntext = \"s:11011 i:11010 ::110011  :110010 d:11000\"\n\nshould split into\n[s,11011,i,11010,:,110011, ,110010,d,11000]\n\nafter following the Regular Expressions HOWTO on the python website, i managed to comeup with the following \nregx= re.compile('([\\s:]|[^\\s\\s]|[^::])')\nregx.split(text)\n\nHowever this does not work as intended as it splits on the : and spaces, but it still includes the ':' and ' ' in the split. \n[s,:,11011, ,i,:,11010, ,:,:,110011, , :,110010, ,d,:,11000]\n\nHow can I fix this?\nEDIT:  In case of a double space, i only want one space to appear\n",
  "preds": {
   "base:Baseline": "re.split('[^a-zA-Z]', '', shell=True)",
   "body:Baseline": "re.compile('([\\\\s:]|[^\\\\s\\\\s]', '::')",
   "body:-Blocks": "re.findall('\\\\d+', '', '', re.MULTILINE)",
   "body:-Code": "re.split('\\\\', '', re.IGNORECASE)",
   "body:-Inline": "re.compile('([^\\\\s\\\\s]|[^^]\\\\s+', '', text)",
   "body:-NL": "re.compile('([^\\\\s\\\\s]|[^::])', '', text)",
   "base:+Mined": "re.split('(?<=.)(?=.)', s)",
   "body+mined:Baseline": "regx = re.compile('([^\\\\s\\\\s]|[^::])')",
   "body+mined:-Code": "re.findall('\\\\((?:(?:[a-zA-Z]*?)\\\\)', s)",
   "body+mined:-NL": "regx.split('s:11011 i:11010 ::110011  :110010 d:11000')",
   "body+mined:-Blocks": "re.split('(?<=\\\\w+)', s)",
   "body+mined:-Inline": "regx.split(re.compile('([^\\\\s\\\\s]|[^::])')"
  },
  "snippet": "re.findall('(.+?):(.+?)\\\\b?', text)"
 },
 "7378180.311": {
  "intent": "generate all 2-element subsets of tuple `(1, 2, 3)`",
  "body": "I have a set of values and would like to create list of all subsets containing 2 elements. \nFor example, a source set ([1,2,3])  has the following 2-element subsets: \nset([1,2]), set([1,3]), set([2,3])\n\nIs there a way to do this in python?\n",
  "preds": {
   "base:Baseline": "[(1, 2, 3)]",
   "body:Baseline": "set([1, 2, 3])",
   "body:-Blocks": "[(1, 2, 3) for (2, 3)]",
   "body:-Code": "[(1, 2, 3) for k, v in subsets]",
   "body:-Inline": "list(zip(*(1, 2, 3))",
   "body:-NL": "[(1, 2, 3)]",
   "base:+Mined": "[(1, 2, 3) for i in range(0, len(a), 2)]",
   "body+mined:Baseline": "[(1, 2, 3)], (2, 3)]",
   "body+mined:-Code": "[(1, 2, 3), (1, 3, 4)]",
   "body+mined:-NL": "[(1, 2, 3), (2, 3)]",
   "body+mined:-Blocks": "[subset[0] for subset in (1, 2, 3)]",
   "body+mined:-Inline": "list(itertools.chain(*(1, 2, 3))"
  },
  "snippet": "list(itertools.combinations((1, 2, 3), 2))"
 },
 "4530069.312": {
  "intent": "get a value of datetime.today() in the utc time zone",
  "body": "I am trying to subtract one date value from the value of datetime.today()  to calculate how long ago something was. But it complains:\nTypeError: can't subtract offset-naive and offset-aware datetimes\n\nThe value datetime.today()  doesn't seem to be \"timezone aware\", while my other date value is. How do I get a value of datetime.today()  that is timezone aware?\nRight now, it's giving me the time in local time, which happens to be PST, i.e. UTC - 8 hours. Worst case, is there a way I can manually enter a timezone value into the datetime  object returned by datetime.today()  and set it to UTC-8?\nOf course, the ideal solution would be for it to automatically know the timezone.\n",
  "preds": {
   "base:Baseline": "datetime.today() - datetime.timedelta(days=1)",
   "body:Baseline": "datetime.today(), datetime.time.now().date()",
   "body:-Blocks": "datetime.today().strftime('%Y-%m-%d')",
   "body:-Code": "datetime.today().strftime('%B')",
   "body:-Inline": "datetime.today().strftime('%B')",
   "body:-NL": "datetime.today().strftime('%B')",
   "base:+Mined": "datetime.today().strftime('%Y-%m-%d')",
   "body+mined:Baseline": "datetime.today() - datetime.timedelta(hours=1)",
   "body+mined:-Code": "datetime.today().strftime('%Y-%m-%d %H:%M:%S')",
   "body+mined:-NL": "dt = datetime.utcnow().date()",
   "body+mined:-Blocks": "datetime.today().strftime('%Y-%m-%d')",
   "body+mined:-Inline": "datetime.today().strftime('%Y-%m-%d')"
  },
  "snippet": "datetime.now(pytz.utc)"
 },
 "4842956.313": {
  "intent": "get a new list `list2`by removing empty list from a list of lists `list1`",
  "body": "I have a list with empty lists in it:\nlist1 = [[], [], [], [], [], 'text', 'text2', [], 'moreText']\n\nHow can I remove the empty lists so that I get:\nlist2 = ['text', 'text2', 'moreText']\n\nI tried list.remove('') but that doesn't work.\n",
  "preds": {
   "base:Baseline": "[x for x in zip(list1, list2)]",
   "body:Baseline": "[x for x in list1 if x not in list2]",
   "body:-Blocks": "list2 = [x for x in zip(list1, list2)]",
   "body:-Code": "list2 = [x for x in list1]",
   "body:-Inline": "list2 = [x for x in list1]",
   "body:-NL": "list2 = [[], [x for x in list1]",
   "base:+Mined": "list2 = [x for x in list1 if x != []]",
   "body+mined:Baseline": "list2 = [x for x in list1 if x != '']",
   "body+mined:-Code": "list2 = [x for x in list1 if x != '']",
   "body+mined:-NL": "list2 = [x for x in list1 if x != 'moreText']",
   "body+mined:-Blocks": "list2 = [x for x in list1 if x != '']",
   "body+mined:-Inline": "list2 = [x for x in list1 if x != '']"
  },
  "snippet": "list2 = [x for x in list1 if x != []]"
 },
 "4842956.314": {
  "intent": "create `list2` to contain the lists from list `list1` excluding the empty lists from `list1`",
  "body": "I have a list with empty lists in it:\nlist1 = [[], [], [], [], [], 'text', 'text2', [], 'moreText']\n\nHow can I remove the empty lists so that I get:\nlist2 = ['text', 'text2', 'moreText']\n\nI tried list.remove('') but that doesn't work.\n",
  "preds": {
   "base:Baseline": "list2 = [x for x in zip(list1, list2)]",
   "body:Baseline": "[x for x in list1 if x not in list2]",
   "body:-Blocks": "list2 = [x for x in zip(list1, list2)]",
   "body:-Code": "list2 = [item for item in list1 if item in item1]",
   "body:-Inline": "list2 = [[], [], [] for i in range(list1)]",
   "body:-NL": "list2 = [[], [x for x in zip(list1, list2)]",
   "base:+Mined": "list2 = [x for x in list1 if x not in list2]",
   "body+mined:Baseline": "list2 = [x for x in list1 if x is not None]",
   "body+mined:-Code": "list2 = [x for x in list1 if x != '']",
   "body+mined:-NL": "list2 = [x for x in list1 if x != 'moreText']",
   "body+mined:-Blocks": "list2 = [x for x in list1 if x not in list2]",
   "body+mined:-Inline": "list2 = [x for x in list1 if x != '']"
  },
  "snippet": "list2 = [x for x in list1 if x]"
 },
 "9262278.315": {
  "intent": "django response with json `data`",
  "body": "This is related to this question: Django return json and html depending on client python\n\nI have a command line Python API for a Django app. When I access the app through the API it should return JSON and with a browser it should return HTML. I can use different URLs to access the different versions but how do I render the HTML template and JSON in the views.py  with just one template?\nTo render the HTML I would use:\nreturn render_to_response('sample/sample.html....')\n\nBut how would I do the same for JSON without putting a JSON template? (the content-type  should be application/json  instead of text/html )\nWhat would determine the JSON and HTML outputs?\nSo in my views.py :\nif something:\n    return render_to_response('html_template',.....)\nelse:\n    return HttpReponse(jsondata,mimetype='application/json')\n\n",
  "preds": {
   "base:Baseline": "data = json.loads(data)",
   "body:Baseline": "httpReponse(jsondata, mimetype='application/json')",
   "body:-Blocks": "response = json.loads(data)",
   "body:-Code": "response = json.loads(data)",
   "body:-Inline": "return HttpReponse(json, data)",
   "body:-NL": "return HttpReponse(jsondata, mimetype='application/json')",
   "base:+Mined": "return HttpResponse(json.dumps(data))",
   "body+mined:Baseline": "return HttpReponse(jsondata, mimetype='application/json')",
   "body+mined:-Code": "return HttpResponse(json.dumps(data))",
   "body+mined:-NL": "return HttpReponse(jsondata, mimetype='application/json')",
   "body+mined:-Blocks": "return HttpResponse(json.dumps(data))",
   "body+mined:-Inline": "return HttpReponse(jsondata, mimetype='application/json')"
  },
  "snippet": "return HttpResponse(data, mimetype='application/json')"
 },
 "17284947.316": {
  "intent": "get all text that is not enclosed within square brackets in string `example_str`",
  "body": "I'm trying to grab any text outside of brackets with a regex.\nExample string\n\nJosie Smith [3996 COLLEGE AVENUE, SOMETOWN, MD 21003]Mugsy Dog Smith\n  [2560 OAK ST, GLENMEADE, WI 14098]\n\nI'm able to get the text inside  the square brackets successfully with:\naddrs = re.findall(r\"\\[(.*?)\\]\", example_str)\nprint addrs\n[u'3996 COLLEGE AVENUE, SOMETOWN, MD 21003',u'2560 OAK ST, GLENMEADE, WI 14098']    \n\nbut I'm having trouble getting anything outside  of the square brackets.  I've tried something like the following:\nnames = re.findall(r\"(.*?)\\[.*\\]+\", example_str)\n\nbut that only finds the first name:\nprint names\n[u'Josie Smith ']\n\nSo far I've only seen a string containing one to two name [address]  combos, but I'm assuming there could be any number of them in a string.\n",
  "preds": {
   "base:Baseline": "re.findall('\\\\w+', example_str)",
   "body:Baseline": "re.findall('\\\\[.*\\\\]+', example_str)",
   "body:-Blocks": "re.findall('\\\\d+', example_str)",
   "body:-Code": "re.findall('\\\\w+\\\\s+', example_str)",
   "body:-Inline": "re.findall('\\\\[.*\\\\]', example_str)",
   "body:-NL": "re.findall('\\\\[(.*?)\\\\]', example_str)",
   "base:+Mined": "re.findall('\\\\w+', example_str)",
   "body+mined:Baseline": "re.findall('\\\\[(.*?)\\\\]', example_str)",
   "body+mined:-Code": "re.findall('\\\\s+', example_str)",
   "body+mined:-NL": "re.findall('\\\\[(.*?)\\\\]', example_str)",
   "body+mined:-Blocks": "re.findall('\\\\w+', example_str)",
   "body+mined:-Inline": "re.findall('\\\\[(.*?)\\\\[.*\\\\]+', example_str)"
  },
  "snippet": "re.findall('(.*?)\\\\[.*?\\\\]', example_str)"
 },
 "17284947.317": {
  "intent": "use a regex to get all text in a string `example_str` that is not surrounded by square brackets",
  "body": "I'm trying to grab any text outside of brackets with a regex.\nExample string\n\nJosie Smith [3996 COLLEGE AVENUE, SOMETOWN, MD 21003]Mugsy Dog Smith\n  [2560 OAK ST, GLENMEADE, WI 14098]\n\nI'm able to get the text inside  the square brackets successfully with:\naddrs = re.findall(r\"\\[(.*?)\\]\", example_str)\nprint addrs\n[u'3996 COLLEGE AVENUE, SOMETOWN, MD 21003',u'2560 OAK ST, GLENMEADE, WI 14098']    \n\nbut I'm having trouble getting anything outside  of the square brackets.  I've tried something like the following:\nnames = re.findall(r\"(.*?)\\[.*\\]+\", example_str)\n\nbut that only finds the first name:\nprint names\n[u'Josie Smith ']\n\nSo far I've only seen a string containing one to two name [address]  combos, but I'm assuming there could be any number of them in a string.\n",
  "preds": {
   "base:Baseline": "re.findall('\\\\w+', example_str)",
   "body:Baseline": "re.findall('\\\\[.*\\\\]+', example_str)",
   "body:-Blocks": "re.findall('\\\\d+', example_str)",
   "body:-Code": "re.findall('\\\\w+', example_str)",
   "body:-Inline": "re.findall('\\\\[(.*?)\\\\]', example_str)",
   "body:-NL": "re.findall('\\\\[.*\\\\]', example_str)",
   "base:+Mined": "re.findall('\\\\w+', example_str)",
   "body+mined:Baseline": "re.findall('\\\\[(.*?)\\\\]', example_str)",
   "body+mined:-Code": "re.findall('\\\\s+', example_str)",
   "body+mined:-NL": "re.findall('\\\\[(.*?)\\\\]', example_str)",
   "body+mined:-Blocks": "re.findall('\\\\w+', example_str)",
   "body+mined:-Inline": "re.findall('\\\\[(.*?)\\\\[.*\\\\]+', example_str)"
  },
  "snippet": "re.findall('(.*?)(?:\\\\[.*?\\\\]|$)', example_str)"
 },
 "14182339.318": {
  "intent": "get whatever is between parentheses as a single match, and any char outside as an individual match in string '(zyx)bc'",
  "body": "I ran into a small problem using Python Regex.\nSuppose this is the input:\n(zyx)bc\n\nWhat I'm trying to achieve is obtain whatever is between parentheses as a single match, and any char outside as an individual match. The desired result would be along the lines of:\n['zyx','b','c']\n\nThe order of matches should be kept.\nI've tried obtaining this with Python 3.3, but can't seem to figure out the correct Regex. So far I have:\nmatches = findall(r'\\((.*?)\\)|\\w', '(zyx)bc')\n\nprint(matches)  yields the following:\n['zyx','','']\n\nAny ideas what I'm doing wrong?\n",
  "preds": {
   "base:Baseline": "re.findall('\\\\w+', '(zyx)bc')",
   "body:Baseline": "re.findall('\\\\((.*?)\\\\)\\\\)', '(zyx)bc')",
   "body:-Blocks": "re.findall('\\\\w+', '(zyx)bc', re.IGNORECASE)",
   "body:-Code": "re.findall('\\\\w+', '(zyx)bc')",
   "body:-Inline": "re.findall('\\\\((.*?)\\\\)', '(zyx)bc')",
   "body:-NL": "print(re.findall('\\\\((.*?)\\\\)', '(zyx)bc')",
   "base:+Mined": "re.findall('((\\\\w+)', '(zyx)bc')",
   "body+mined:Baseline": "match = re.compile('\\\\((.*?)\\\\)', '(zyx)bc')",
   "body+mined:-Code": "re.findall('\\\\((?<=.)\\\\)', '\\\\1bc', s)",
   "body+mined:-NL": "re.findall('\\\\((.*?)\\\\)|\\\\w', '(zyx)bc')",
   "body+mined:-Blocks": "re.findall('\\\\s+(?<=\\\\s)bc', '', s)",
   "body+mined:-Inline": "match = re.findall('\\\\((.*?)\\\\)|\\\\w', 'zyx)bc')"
  },
  "snippet": "re.findall('\\\\(.+?\\\\)|\\\\w', '(zyx)bc')"
 },
 "14182339.319": {
  "intent": "match regex '\\\\((.*?)\\\\)|(\\\\w)' with string '(zyx)bc'",
  "body": "I ran into a small problem using Python Regex.\nSuppose this is the input:\n(zyx)bc\n\nWhat I'm trying to achieve is obtain whatever is between parentheses as a single match, and any char outside as an individual match. The desired result would be along the lines of:\n['zyx','b','c']\n\nThe order of matches should be kept.\nI've tried obtaining this with Python 3.3, but can't seem to figure out the correct Regex. So far I have:\nmatches = findall(r'\\((.*?)\\)|\\w', '(zyx)bc')\n\nprint(matches)  yields the following:\n['zyx','','']\n\nAny ideas what I'm doing wrong?\n",
  "preds": {
   "base:Baseline": "re.match('\\\\((.*?)\\\\)|(\\\\w)', 'zyx)bc')",
   "body:Baseline": "re.findall('\\\\((.*?)\\\\)|(\\\\w)', '(zyx)bc')",
   "body:-Blocks": "re.match('\\\\((.*?)\\\\)|(\\\\w)', '(zyx)bc')",
   "body:-Code": "re.match('\\\\((.*?)\\\\)|(\\\\w)', '(zyx)bc')",
   "body:-Inline": "match('\\\\((.*?)\\\\)|(\\\\w)', '(zyx)bc')",
   "body:-NL": "match('\\\\((.*?)\\\\)|(\\\\w)', '(zyx)bc')",
   "base:+Mined": "re.match('\\\\((.*?)\\\\)|(\\\\w)', '(zyx)bc')",
   "body+mined:Baseline": "match = re.compile('\\\\((.*?)\\\\)|(\\\\w)', '(zyx)bc')",
   "body+mined:-Code": "match = re.compile('\\\\((.*?)\\\\)|(\\\\w)', '(zyx)bc')",
   "body+mined:-NL": "match = re.match('\\\\((.*?)\\\\)|(\\\\w)', '(zyx)bc')",
   "body+mined:-Blocks": "re.findall('\\\\((.*?)\\\\)|(\\\\w)', '(zyx)bc')",
   "body+mined:-Inline": "match = re.compile('\\\\((.*?)\\\\)|(\\\\w)', 'zyx)bc')"
  },
  "snippet": "re.findall('\\\\((.*?)\\\\)|(\\\\w)', '(zyx)bc')"
 },
 "14182339.320": {
  "intent": "match multiple regex patterns with the alternation operator `|` in a string `(zyx)bc`",
  "body": "I ran into a small problem using Python Regex.\nSuppose this is the input:\n(zyx)bc\n\nWhat I'm trying to achieve is obtain whatever is between parentheses as a single match, and any char outside as an individual match. The desired result would be along the lines of:\n['zyx','b','c']\n\nThe order of matches should be kept.\nI've tried obtaining this with Python 3.3, but can't seem to figure out the correct Regex. So far I have:\nmatches = findall(r'\\((.*?)\\)|\\w', '(zyx)bc')\n\nprint(matches)  yields the following:\n['zyx','','']\n\nAny ideas what I'm doing wrong?\n",
  "preds": {
   "base:Baseline": "re.findall('(zyx)bc', '|')",
   "body:Baseline": "re.findall('\\\\((.*?)\\\\)\\\\)', '(zyx)bc')",
   "body:-Blocks": "re.compile('(zyx)bc', '|')",
   "body:-Code": "re.compile('(zyx)bc)', '|')",
   "body:-Inline": "match(re.findall('\\\\((.*?)\\\\)', '(zyx)bc))",
   "body:-NL": "re.findall('\\\\((.*?)\\\\)', '(zyx)bc')",
   "base:+Mined": "re.findall('(zyx)bc', '|')",
   "body+mined:Baseline": "match = re.compile('\\\\((.*?)\\\\)|(zyx)bc')",
   "body+mined:-Code": "re.findall('\\\\([^|])+|', (zyx)bc)",
   "body+mined:-NL": "match = re.findall('\\\\((.*?)\\\\)|\\\\w', (zyx)bc)",
   "body+mined:-Blocks": "re.findall('\\\\((\\\\w+)\\\\)', '(zyx)bc')",
   "body+mined:-Inline": "match = re.findall('\\\\((.*?)\\\\)|\\\\w', (zyx)bc)"
  },
  "snippet": "re.findall('\\\\(.*?\\\\)|\\\\w', '(zyx)bc')"
 },
 "7126916.321": {
  "intent": "formate each string cin list `elements` into pattern '%{0}%'",
  "body": "I have a list of strings in Python - elements . I would like to edit each element  in elements . See the code below (it doesn't work, but you'll get the idea):\nfor element in elements:\n    element = \"%\" + element + \"%\"\n\nIs there a way to do this?\n",
  "preds": {
   "base:Baseline": "print('%{0}%')",
   "body:Baseline": "print('%{0}%'.format(elements))",
   "body:-Blocks": "pattern = re.compile('%{0}%', elements)",
   "body:-Code": "pattern = re.compile('%{0}%', elelements)",
   "body:-Inline": "print('%{0}%'.join(elements))",
   "body:-NL": "print('%{0}%'.join(elements))",
   "base:+Mined": "print('%{0}%'.format(elements))",
   "body+mined:Baseline": "\"\"\"\"\"\".join(elements)",
   "body+mined:-Code": "print('%{0}%'.format(elements))",
   "body+mined:-NL": "print('%{0}%'.format(element))",
   "body+mined:-Blocks": "print('%{0}%'.format(elements))",
   "body+mined:-Inline": "print('%{0}%'.format(elements))"
  },
  "snippet": "elements = ['%{0}%'.format(element) for element in elements]"
 },
 "3595685.322": {
  "intent": "open a background process 'background-process' with arguments 'arguments'",
  "body": "My python script needs to start a background process and then continue processing to completion without waiting for a return.\nThe background script will process for some time and will not generate any screen output.\nThere is no inter-process data required.\nI have tried using various methods subprocess, multiprocessing but am clearly missing something.\nDoes anyone have a simple example?\nTIA\n",
  "preds": {
   "base:Baseline": "background - process.set_argument('Arguments')",
   "body:Baseline": "sys.system('background-process', args=['Arguments'])",
   "body:-Blocks": "backgroundprocess.call(['background-process', 'arguments'])",
   "body:-Code": "backgroundProcess.call('Arguments')",
   "body:-Inline": "backgroundprocess.call('Arguments')",
   "body:-NL": "backgroundprocess.open('background-process', arguments='Arguments')",
   "base:+Mined": "subprocess.call(['background-process', 'arguments'])",
   "body+mined:Baseline": "subprocess.call(['background-process', 'arguments'])",
   "body+mined:-Code": "p.start_process('background-process', args='arguments')",
   "body+mined:-NL": "process.call(['background-process', 'arguments'])",
   "body+mined:-Blocks": "subprocess.Popen('background-process', args={'arguments': Arguments})",
   "body+mined:-Inline": "subprocess.call('background-process', shell=True)"
  },
  "snippet": "subprocess.Popen(['background-process', 'arguments'])"
 },
 "18453566.323": {
  "intent": "get list of values from dictionary 'mydict' w.r.t. list of keys 'mykeys'",
  "body": "Is there a built-in/quick way to use a list of keys to a dictionary to get a list of corresponding items?\nFor instance I have:\nmydict = {'one': 1, 'two': 2, 'three': 3}\nmykeys = ['three', 'one']\n\nHow can I use mykeys  to get the corresponding values in the dictionary as a list?\nmydict.WHAT_GOES_HERE(mykeys)\n[3, 1]\n\n",
  "preds": {
   "base:Baseline": "[k for k, v in list(mydict.keys()) if v != 'mykeys']",
   "body:Baseline": "dict((k, v) for k, v in list(mydict.items()))",
   "body:-Blocks": "[item for item in list(mydict.items()) if item in item]",
   "body:-Code": "[k for k, v in list(mydict.keys()) if v in k]",
   "body:-Inline": "[v for k, v in list(mydict.items()) if v in mykeys]",
   "body:-NL": "dict((k, v) for k, v in list(mydict.items()))",
   "base:+Mined": "[key for key, value in list(mydict.items()) if 'mykeys' in value]",
   "body+mined:Baseline": "[list(mydict.keys() for _ in range(len(mykeys))]",
   "body+mined:-Code": "[key for key, value in list(mydict.items()) if 'mykeys' in value]",
   "body+mined:-NL": "{k: v for k, v in list(mydict.items()) if v}",
   "body+mined:-Blocks": "[k for k, v in list(mydict.items()) for k in mykeys]",
   "body+mined:-Inline": "list(mydict.get(key) for key in mykeys)"
  },
  "snippet": "[mydict[x] for x in mykeys]"
 },
 "12692135.324": {
  "intent": "convert list `[('name', 'joe'), ('age', 22)]` into a dictionary",
  "body": "I have two lists:\nheader = [\"Name\", \"Age\"]\ndetail = [\"Joe\", 22, \"Dave\", 43, \"Herb\", 32]\n\nAnd would like to create a list of dictonaries like this:\n[{\"Name\": \"Joe\", \"Age\": 22}, {\"Name\": \"Dave\", \"Age\": 32}, {\"Name\": \"Herb\", \"Age\": 32}]\n\nThis method zip  gets me partially there, but only adds the first set of values to the dictionary:\ndict(zip(header, detail))\n{'Age': 22, 'Name': 'Joe'}\n\nHow can I output as one dictionary for all values in the detail  list? I found this answer , but this depends on detail  containing nested lists.\n",
  "preds": {
   "base:Baseline": "dict([('name', 'joe'), ('age', 22)]",
   "body:Baseline": "dict(zip(list(name', 'Joe'), ('Age', 22)]",
   "body:-Blocks": "dict([('name', 'joe'), ('age', 22)]",
   "body:-Code": "dict((k, v) for k, v in ['name', 'joe'), ('age', 22)]",
   "body:-Inline": "dict(zip(header, detail) for key, value in [('name', 'joe'), ('age', 22)]",
   "body:-NL": "dict(zip(header, detail))",
   "base:+Mined": "dict(zip(*('name', 'joe'), ('age', 22))",
   "body+mined:Baseline": "dict(zip(header, detail))",
   "body+mined:-Code": "zip([('name', 'joe'), ('age', 22)]",
   "body+mined:-NL": "dict(zip(header, detail))",
   "body+mined:-Blocks": "{k: v for k, v in [('name', 'joe'), ('age', 22)]}",
   "body+mined:-Inline": "dict(zip(header, detail))"
  },
  "snippet": "dict([('Name', 'Joe'), ('Age', 22)])"
 },
 "14401047.325": {
  "intent": "average each two columns of array `data`",
  "body": "Right now I am doing this by iterating, but there has to be a way to accomplish this task using numpy functions.  My goal is to take a 2D array and average J columns at a time, producing a new array with the same number of rows as the original, but with columns/J columns.\nSo I want to take this:\nJ = 2 // two columns averaged at a time\n\n[[1 2 3 4]\n [4 3 7 1]\n [6 2 3 4]\n [3 4 4 1]]\n\nand produce this:\n[[1.5 3.5]\n [3.5 4.0]\n [4.0 3.5]\n [3.5 2.5]]\n\nIs there a simple way to accomplish this task?  I also need a way such that if I never end up with an unaveraged remainder column.  So if, for example, I have an input array with 5 columns and J=2, I would average the first two columns, then the last three columns.\nAny help you can provide would be great.\n",
  "preds": {
   "base:Baseline": "np.arange(data, axis=1)",
   "body:Baseline": "np.sqrt(np.arange(data, axis=1), reverse=True)",
   "body:-Blocks": "np.arange(data, axis=1).sum()",
   "body:-Code": "np.arange(data, axis=2).sum()",
   "body:-Inline": "np.arange(data, axis=2)",
   "body:-NL": "np.sqrt(np.arange(data, axis=2), axis=1)",
   "base:+Mined": "data.mean(axis=1)",
   "body+mined:Baseline": "data[:, ([1, 2])]",
   "body+mined:-Code": "data[:, (0)] = np.array([[1, 2], [3, 4]])",
   "body+mined:-NL": "np.mean(data, axis=1)",
   "body+mined:-Blocks": "data[:, ([1, 2], [3, 4]])",
   "body+mined:-Inline": "data[(np.arange(len(data)) - len(data), axis=1)]"
  },
  "snippet": "data.reshape(-1, j).mean(axis=1).reshape(data.shape[0], -1)"
 },
 "18886596.326": {
  "intent": "double backslash escape all double quotes in string `s`",
  "body": "Given a string in python, such as:\ns = 'This sentence has some \"quotes\" in it\\n'\n\nI want to create a new copy of that string with any quotes escaped (for further use in Javascript). So, for example, what I want is to produce this:\n'This sentence has some \\\"quotes\\\" in it\\n'\n\nI tried using replace() , such as:\ns.replace('\"', '\\\"')\n\nbut that returns the same string. So then I tried this:\ns.replace('\"', '\\\\\"')\n\nbut that returns double-escaped quotes, such as:\n'This sentence has some \\\\\"quotes\\\\\" in it.\\n'\n\nHow to replace \"  with \\\" ?\nUPDATE:\nI need as output from this copyable text that shows both the quotes and the newlines as escaped.  In other words, I want to be able to copy:\n'This sentence has some \\\"quotes\\\" in it.\\n'\n\nIf I use the raw string and print  the result I get the correctly escaped quote, but the escaped newline doesn't print. If I don't use print  then I get my newlines but double-escaped quotes. How can I create a string I can copy that shows both newline and quote escaped?\n",
  "preds": {
   "base:Baseline": "re.sub('\\\\w+', s)",
   "body:Baseline": "re.sub('\\\\\"\\\\n', s)",
   "body:-Blocks": "re.sub('(\\\\w+)', '', s)",
   "body:-Code": "re.compile('\\\\w+\\\\s+', s)",
   "body:-Inline": "re.sub('\\\\n\\\\s\\\\n', s)",
   "body:-NL": "re.sub('\\\\n', s)",
   "base:+Mined": "re.sub('\\\\s+', '', s)",
   "body+mined:Baseline": "\"\"\"This sentence has some \"quotes\" in it\\\\n\"\"\"",
   "body+mined:-Code": "print(re.sub('[^\"]*', '', s))",
   "body+mined:-NL": "s.replace('\"', '\\\\\"')",
   "body+mined:-Blocks": "re.sub('\\\\(\\\\w+)', '', s)",
   "body+mined:-Inline": "\"\"\"This sentence has some \"quotes\" in it\"\"\".replace('\"', '\"')"
  },
  "snippet": "print(s.encode('unicode-escape').replace('\"', '\\\\\"'))"
 },
 "5932059.327": {
  "intent": "split a string into a list of words and whitespace",
  "body": "I need to split a string into an array on word boundaries (whitespace) while maintaining the whitespace.\nFor example:\n'this is  a\\nsentence'\n\nWould become\n['this', ' ', 'is', '  ', 'a' '\\n', 'sentence']\n\nI know about str.partition  and re.split , but neither of them quite do what I want and there is no re.partition .\nHow should I partition strings on whitespace in Python with reasonable efficiency?\n",
  "preds": {
   "base:Baseline": "\"\"\"{0:.2f}\"\"\".format(map(int, x))",
   "body:Baseline": "re.findall('\\\\n', '\\\\n')",
   "body:-Blocks": "re.split('\\\\w+', '', str)",
   "body:-Code": "re.split('\\\\w+', '', str)",
   "body:-Inline": "re.split('\\\\n', '\\\\n')",
   "body:-NL": "re.split('\\\\n', \"\"\"This is  a\nsentence\"\"\")",
   "base:+Mined": "[word.split() for word in s.split(',')]",
   "body+mined:Baseline": "['this', '', 'is', ' ', 'a\\n', 'sentence']",
   "body+mined:-Code": "['a', 'b', 'c', 'd', 'e', 'f']",
   "body+mined:-NL": "re.findall('\\\\n', s)",
   "body+mined:-Blocks": "\"\"\" \"\"\".join(['a', 'b', 'c', 'd'])",
   "body+mined:-Inline": "['this', '', 'is', ' ', 'a', '\\n', 'sentence']"
  },
  "snippet": "re.split('(\\\\W+)', s)"
 },
 "9938130.328": {
  "intent": "plotting stacked barplots on a panda data frame",
  "body": "This is my first attempt at playing with Pandas library after attending Wesley's tutorial at pycon.\nAfter poking around a bit with the dataframe I am glad I was able to massage the data in the way I wanted but having trouble in plotting it. I guess it also points to my naiveness with the matplotlib library.\nWhat I have is pandas Series object with the following data. I would like to plot as a barplot with col 1 ('file') as the labels oriented vertically.\nsample data here:\nhttp://pastebin.com/y2w0uJPQ \n\n",
  "preds": {
   "base:Baseline": "pd.concat([x, y], axis=1)",
   "body:Baseline": "pandas.set_to_barplot('', 1)",
   "body:-Blocks": "pandas.set_barplots('barplot', cols=1)",
   "body:-Code": "df.set_barplots('file')",
   "body:-Inline": "pandas.set_barplots()",
   "body:-NL": "df = panda.plot(df, axis=1)",
   "base:+Mined": "df.plot(kind='bar')",
   "body+mined:Baseline": "df.plot(x, y, 'file')",
   "body+mined:-Code": "df.plot(kind='bar', stacked=True)",
   "body+mined:-NL": "df.groupby('col').size().plot(kind='bar')",
   "body+mined:-Blocks": "ax.set_xticklabels([])",
   "body+mined:-Inline": "df.set_index('file')"
  },
  "snippet": "df.plot(kind='barh', stacked=True)"
 },
 "35945473.329": {
  "intent": "reverse the keys and values in a dictionary `mydictionary`",
  "body": "I would like to write a function that receives a dictionary as input argument and returns a reverse of the input dictionary where the values of the original dictionary are used as keys for the returned dictionary and the keys of the original dictionary are used as value for the returned dictionary as explained below: \ndict = {'Accurate': ['exact', 'precise'], \n        'exact': ['precise'], \n        'astute': ['Smart', 'clever'], \n        'smart': ['clever', 'bright', 'talented']}\n\nto\ndict = {'precise': ['accurate', 'exact'], \n        'clever': ['astute', 'smart'], \n        'talented': ['smart'], \n        'bright': ['smart'],\n        'exact': ['accurate'],\n        'smart': ['astute']}\n\nThe list of values in the returned dictionary should be sorted in ascending order.  Capitalization does not matter. This means that all the words should be converted to lower case letters. For example the word \"Accurate\" is capitalized in the original dictionary but in the returned dictionary it is written with all lower case letters.\n#My code is:\nfrom collections import defaultdict\ndef reverse_dictionary(input_dict):\n   d = defaultdict(list)\n   for v,k in input_dict.items():\n       d[k].append(v)\n       return d\n\nBut it returns this error though:\nError in evaluating function:\nTypeError at line 6\nunhashable type: 'list'\n\n",
  "preds": {
   "base:Baseline": "dict((k, v) for k, v in myDictionary.items())",
   "body:Baseline": "dict((k, v) for k, v in list(mydictionary.items()))",
   "body:-Blocks": "dict((k, v) for k, v in list(mydictionary.items()))",
   "body:-Code": "dict((k, v) for k, v in list(myDictionary.items()))",
   "body:-Inline": "dict((k, v) for k, v in mydictionary.items())",
   "body:-NL": "dict((k, v) for k, v in mydictionary.items())",
   "base:+Mined": "dict((k, v) for k, v in myDict.items())",
   "body+mined:Baseline": "dict((v, k) for v, k in list(mydictionary.items()))",
   "body+mined:-Code": "dict((k, v) for k, v in myDict.items())",
   "body+mined:-NL": "{k: v for k, v in list(d.items()) for d in v}",
   "body+mined:-Blocks": "dict((k, v) for k, v in list(mydictionary.items()))",
   "body+mined:-Inline": "{k: v for k, v in list(mydictionary.items()) if v}"
  },
  "snippet": "{i[1]: i[0] for i in list(myDictionary.items())}"
 },
 "30729735.330": {
  "intent": "finding the index of elements containing substring 'how' and 'what' in a list of strings 'mylist'.",
  "body": "I have a list \nmyList = [\"what is your name\", \"Hi, how are you\",\n          \"What about you\", \"How about a coffee\", \"How are you\"]\n\nNow I want to search index of all occurrence of \"How\"  and \"what\" . How can I do this in Pythonic way?\n",
  "preds": {
   "base:Baseline": "mylist.index(['how', 'what'], key=lambda x: x[1])",
   "body:Baseline": "[i for i, j in enumerate(myList, 'How', 'What']) if i not in j]",
   "body:-Blocks": "mylist.index(key=lambda x: x['how'], x['what']))",
   "body:-Code": "mylist.index('how', 'what')",
   "body:-Inline": "myList.index('how', 'what')",
   "body:-NL": "myList.index('how', 'what')",
   "base:+Mined": "[i for i in myList if 'how' in i]",
   "body+mined:Baseline": "[x for x in myList if x.startswith('How')]",
   "body+mined:-Code": "[x for x in myList if 'how' and 'what' in x]",
   "body+mined:-NL": "[i for i, j in enumerate(myList) if j == 'How']",
   "body+mined:-Blocks": "[x for x in mylist if 'How' in x]",
   "body+mined:-Inline": "[x for x in myList if 'how' in x]"
  },
  "snippet": "[i for i, j in enumerate(myList) if 'how' in j.lower() or 'what' in j.lower()]"
 },
 "1303243.331": {
  "intent": "check if object `obj` is a string",
  "body": "How can I check if a Python object is a string (either regular or Unicode)?\n",
  "preds": {
   "base:Baseline": "if obj == string:\n    pass",
   "body:Baseline": "if obj.isString():\n    pass",
   "body:-Blocks": "isinstance(obj, 'a')",
   "body:-Code": "print(obj.__string__))",
   "body:-Inline": "if (obj.isString())):\n    pass",
   "body:-NL": "if (obj.isString())):\n    pass",
   "base:+Mined": "obj.isalpha().isalpha()",
   "body+mined:Baseline": "isinstance(obj, 'string')",
   "body+mined:-Code": "isinstance(obj, 'a')",
   "body+mined:-NL": "if obj.isalpha()):\n    pass",
   "body+mined:-Blocks": "obj.str.isdigit()",
   "body+mined:-Inline": "isinstance(obj, 'unicode_escape')"
  },
  "snippet": "isinstance(obj, str)"
 },
 "1303243.332": {
  "intent": "check if object `o` is a string",
  "body": "How can I check if a Python object is a string (either regular or Unicode)?\n",
  "preds": {
   "base:Baseline": "if not 'o':\n    pass",
   "body:Baseline": "if (o not a string):\n    pass",
   "body:-Blocks": "if (o =='string':\n    pass",
   "body:-Code": "if (not a string):\n    pass",
   "body:-Inline": "if not 'o':\n    pass",
   "body:-NL": "if o.isdigit():\n    pass",
   "base:+Mined": "isinstance(o, 'string')",
   "body+mined:Baseline": "if o.isdigit():\n    pass",
   "body+mined:-Code": "isinstance(o, 'a')",
   "body+mined:-NL": "if o.isdigit():\n    pass",
   "body+mined:-Blocks": "if o.isalpha():\n    pass",
   "body+mined:-Inline": "isinstance(o, 'unicode_escape')"
  },
  "snippet": "isinstance(o, str)"
 },
 "1303243.333": {
  "intent": "check if object `o` is a string",
  "body": "How can I check if a Python object is a string (either regular or Unicode)?\n",
  "preds": {
   "base:Baseline": "if not 'o':\n    pass",
   "body:Baseline": "if (o not a string):\n    pass",
   "body:-Blocks": "if (o =='string':\n    pass",
   "body:-Code": "if (not a string):\n    pass",
   "body:-Inline": "if not 'o':\n    pass",
   "body:-NL": "if o.isdigit():\n    pass",
   "base:+Mined": "isinstance(o, 'string')",
   "body+mined:Baseline": "if o.isdigit():\n    pass",
   "body+mined:-Code": "isinstance(o, 'a')",
   "body+mined:-NL": "if o.isdigit():\n    pass",
   "body+mined:-Blocks": "if o.isalpha():\n    pass",
   "body+mined:-Inline": "isinstance(o, 'unicode_escape')"
  },
  "snippet": "type(o) is str"
 },
 "1303243.334": {
  "intent": "check if object `o` is a string",
  "body": "How can I check if a Python object is a string (either regular or Unicode)?\n",
  "preds": {
   "base:Baseline": "if not 'o':\n    pass",
   "body:Baseline": "if (o not a string):\n    pass",
   "body:-Blocks": "if (o =='string':\n    pass",
   "body:-Code": "if (not a string):\n    pass",
   "body:-Inline": "if not 'o':\n    pass",
   "body:-NL": "if o.isdigit():\n    pass",
   "base:+Mined": "isinstance(o, 'string')",
   "body+mined:Baseline": "if o.isdigit():\n    pass",
   "body+mined:-Code": "isinstance(o, 'a')",
   "body+mined:-NL": "if o.isdigit():\n    pass",
   "body+mined:-Blocks": "if o.isalpha():\n    pass",
   "body+mined:-Inline": "isinstance(o, 'unicode_escape')"
  },
  "snippet": "isinstance(o, str)"
 },
 "1303243.335": {
  "intent": "check if `obj_to_test` is a string",
  "body": "How can I check if a Python object is a string (either regular or Unicode)?\n",
  "preds": {
   "base:Baseline": "if obj_to_test == string:\n    pass",
   "body:Baseline": "if obj_to_test.isString():\n    pass",
   "body:-Blocks": "if obj_to_test:\n    pass",
   "body:-Code": "if obj_to_test:\n    pass",
   "body:-Inline": "obj_to_test.is_string()",
   "body:-NL": "if obj_to_test == string:\n    pass",
   "base:+Mined": "isinstance(obj_to_test, bool)",
   "body+mined:Baseline": "obj_to_test.isdigit()",
   "body+mined:-Code": "obj_to_test.isdigit()",
   "body+mined:-NL": "obj_to_test.isdigit()",
   "body+mined:-Blocks": "obj_to_test.isdigit()",
   "body+mined:-Inline": "obj_to_test.isdigit()"
  },
  "snippet": "isinstance(obj_to_test, str)"
 },
 "8177079.336": {
  "intent": "append list `list1` to `list2`",
  "body": "I am trying to understand if it makes sense to take the content of a list and append it to another list.\nI have the first list created through a loop function, that will get specific lines out of a file and will save them in a list.\nThen a second list is used to save these lines, and start a new cycle over another file.\nMy idea was to get the list once that the for cycle is done, dump it into the second list, then start a new cycle, dump the content of the first list again into the second but appending it, so the second list will be the sum of all the smaller list files created in my loop. The list has to be appended only if certain conditions met. \nIt looks like something similar to this:\n# This is done for each log in my directory, i have a loop running\nfor logs in mydir:\n\n    for line in mylog:\n        #...if the conditions are met\n        list1.append(line)\n\n    for item in list1:\n        if \"string\" in item: #if somewhere in the list1 i have a match for a string\n            list2.append(list1) # append every line in list1 to list2\n            del list1 [:] # delete the content of the list1\n            break\n        else:\n            del list1 [:] # delete the list content and start all over\n\nDoes this makes sense or should I go for a different route?\nI need something efficient that would not take up too many cycles, since the list of logs is long and each text file is pretty big; so I thought that the lists would fit the purpose.\n",
  "preds": {
   "base:Baseline": "list2 = [x for x in zip(list1, list2)]",
   "body:Baseline": "list1.append(list1, list2)",
   "body:-Blocks": "list2 = [i for i in list1]",
   "body:-Code": "list1 = list2.append(list1)",
   "body:-Inline": "list1.append(list2)",
   "body:-NL": "list1.append(list1, list2)",
   "base:+Mined": "list2.append(list1, list2)",
   "body+mined:Baseline": "list1.append(list2)",
   "body+mined:-Code": "list2.append(list1)",
   "body+mined:-NL": "list1.append(list1)",
   "body+mined:-Blocks": "list2.append(list1, list2)",
   "body+mined:-Inline": "list2.append(list1)"
  },
  "snippet": "list2.extend(list1)"
 },
 "8177079.337": {
  "intent": "append list `mylog` to `list1`",
  "body": "I am trying to understand if it makes sense to take the content of a list and append it to another list.\nI have the first list created through a loop function, that will get specific lines out of a file and will save them in a list.\nThen a second list is used to save these lines, and start a new cycle over another file.\nMy idea was to get the list once that the for cycle is done, dump it into the second list, then start a new cycle, dump the content of the first list again into the second but appending it, so the second list will be the sum of all the smaller list files created in my loop. The list has to be appended only if certain conditions met. \nIt looks like something similar to this:\n# This is done for each log in my directory, i have a loop running\nfor logs in mydir:\n\n    for line in mylog:\n        #...if the conditions are met\n        list1.append(line)\n\n    for item in list1:\n        if \"string\" in item: #if somewhere in the list1 i have a match for a string\n            list2.append(list1) # append every line in list1 to list2\n            del list1 [:] # delete the content of the list1\n            break\n        else:\n            del list1 [:] # delete the list content and start all over\n\nDoes this makes sense or should I go for a different route?\nI need something efficient that would not take up too many cycles, since the list of logs is long and each text file is pretty big; so I thought that the lists would fit the purpose.\n",
  "preds": {
   "base:Baseline": "list1 = [item for item in mylog]",
   "body:Baseline": "list1.append(mylog)",
   "body:-Blocks": "list1.append(mylog)",
   "body:-Code": "list1.append(mylog)",
   "body:-Inline": "list1.append(mylog)",
   "body:-NL": "list1.append(mylog)",
   "base:+Mined": "list1.append(mylog)",
   "body+mined:Baseline": "list1.append(mylog)",
   "body+mined:-Code": "list1.append(mylog)",
   "body+mined:-NL": "list1.append(mylog)",
   "body+mined:-Blocks": "list1.append(mylog)",
   "body+mined:-Inline": "list1 = [line for line in mylog if 'string' in line]"
  },
  "snippet": "list1.extend(mylog)"
 },
 "8177079.338": {
  "intent": "append list `a` to `c`",
  "body": "I am trying to understand if it makes sense to take the content of a list and append it to another list.\nI have the first list created through a loop function, that will get specific lines out of a file and will save them in a list.\nThen a second list is used to save these lines, and start a new cycle over another file.\nMy idea was to get the list once that the for cycle is done, dump it into the second list, then start a new cycle, dump the content of the first list again into the second but appending it, so the second list will be the sum of all the smaller list files created in my loop. The list has to be appended only if certain conditions met. \nIt looks like something similar to this:\n# This is done for each log in my directory, i have a loop running\nfor logs in mydir:\n\n    for line in mylog:\n        #...if the conditions are met\n        list1.append(line)\n\n    for item in list1:\n        if \"string\" in item: #if somewhere in the list1 i have a match for a string\n            list2.append(list1) # append every line in list1 to list2\n            del list1 [:] # delete the content of the list1\n            break\n        else:\n            del list1 [:] # delete the list content and start all over\n\nDoes this makes sense or should I go for a different route?\nI need something efficient that would not take up too many cycles, since the list of logs is long and each text file is pretty big; so I thought that the lists would fit the purpose.\n",
  "preds": {
   "base:Baseline": "c = [a[i] for i in c]",
   "body:Baseline": "c = [a[:] for a in c]",
   "body:-Blocks": "c = [a[i] for i in c]",
   "body:-Code": "c = [a.append(c))",
   "body:-Inline": "c = [a[:] for a in c]",
   "body:-NL": "c = list(a.append(c))",
   "base:+Mined": "c = c.append(a)",
   "body+mined:Baseline": "list(a) + list(c)",
   "body+mined:-Code": "c = [i for i in a]",
   "body+mined:-NL": "list1.append(a, c)",
   "body+mined:-Blocks": "c.append(a, c)",
   "body+mined:-Inline": "c = [i for i in a if 'string' in i]"
  },
  "snippet": "c.extend(a)"
 },
 "8177079.339": {
  "intent": "append items in list `mylog` to `list1`",
  "body": "I am trying to understand if it makes sense to take the content of a list and append it to another list.\nI have the first list created through a loop function, that will get specific lines out of a file and will save them in a list.\nThen a second list is used to save these lines, and start a new cycle over another file.\nMy idea was to get the list once that the for cycle is done, dump it into the second list, then start a new cycle, dump the content of the first list again into the second but appending it, so the second list will be the sum of all the smaller list files created in my loop. The list has to be appended only if certain conditions met. \nIt looks like something similar to this:\n# This is done for each log in my directory, i have a loop running\nfor logs in mydir:\n\n    for line in mylog:\n        #...if the conditions are met\n        list1.append(line)\n\n    for item in list1:\n        if \"string\" in item: #if somewhere in the list1 i have a match for a string\n            list2.append(list1) # append every line in list1 to list2\n            del list1 [:] # delete the content of the list1\n            break\n        else:\n            del list1 [:] # delete the list content and start all over\n\nDoes this makes sense or should I go for a different route?\nI need something efficient that would not take up too many cycles, since the list of logs is long and each text file is pretty big; so I thought that the lists would fit the purpose.\n",
  "preds": {
   "base:Baseline": "list1 = [item for item in mylog]",
   "body:Baseline": "list1 = [i for i in mylog]",
   "body:-Blocks": "list1 = [item for item in mylog]",
   "body:-Code": "list1 = [item for item in mylog]",
   "body:-Inline": "list1 = list1.append(line)",
   "body:-NL": "list1 = [item for item in mylog]",
   "base:+Mined": "list1 = [item for item in mylog]",
   "body+mined:Baseline": "list1 = [line for line in mylog if 'string' in line]",
   "body+mined:-Code": "list1 = [i for i in mylog]",
   "body+mined:-NL": "list1 = [line for line in mylog if 'string' in line]",
   "body+mined:-Blocks": "list1.append(myLog)",
   "body+mined:-Inline": "list1 = [line for line in mylog if 'string' in line]"
  },
  "snippet": "for line in mylog:\n    list1.append(line)"
 },
 "4126227.340": {
  "intent": "append a tuple of elements from list `a` with indexes '[0][0] [0][2]' to list `b`",
  "body": "What's the proper syntax for adding a recomposed tuple to a list?\nFor example, if I had two lists:\na = [(1,2,3),(4,5,6)]\nb = [(0,0)]\n\nThen I would expect the following to work:\nb.append((a[0][0],a[0,2]))\nTraceback (most recent call last):\n  File \" <stdin>\", line 1, in <module>\nTypeError: list indices must be integers, not tuple\n\nFurthermore, when it informs me that indices must be integers, how come this works?\nb.append((7,7))\nb\n[(0, 0), (7, 7)]\n\n",
  "preds": {
   "base:Baseline": "b = [[0][0][0][2]]",
   "body:Baseline": "b = [(a[0][0], (0, 2])",
   "body:-Blocks": "b = [(i, j) for i, j in zip(a, b)]",
   "body:-Code": "b = [(i, j) for i, j in [(0][0] [0][2]]",
   "body:-Inline": "b = [(a[0][0] [0][2])",
   "body:-NL": "b = [(a[0][0] [0][2])",
   "base:+Mined": "b = [i[0] for i in range(0, len(a), 2)]",
   "body+mined:Baseline": "b = [(0, 0], (7, 7)]",
   "body+mined:-Code": "b = [(i + j) for i, j in zip(a, b)]",
   "body+mined:-NL": "b = [(x[0] for x in a]",
   "body+mined:-Blocks": "b = [(i + j) for i, j in zip(a, b)]",
   "body+mined:-Inline": "b.append((a[0][0], b[0]), (7, 7))"
  },
  "snippet": "b.append((a[0][0], a[0][2]))"
 },
 "34902378.341": {
  "intent": "initialize `secret_key` in flask config with `your_secret_string `",
  "body": "I am trying to set up Flask-Debugtoolbar, but I get the message \"DebugToolBar requires a SECRET_KEY\".  Where do I get the secret key?\n",
  "preds": {
   "base:Baseline": "config.initialize('secret_key')",
   "body:Baseline": "your_secret_string = config.get('SECRET_KEY')",
   "body:-Blocks": "your_secret_key = auth.SECRET_KEY",
   "body:-Code": "your_secret_string = Flask.config('DebugToolBar requires a SECRET_KEY')",
   "body:-Inline": "your_secret_string = 'SECRET_KEY'",
   "body:-NL": "your_secret_string = config.initialize('secret_key')",
   "base:+Mined": "app.config['secret_key'] = 'your_secret_string'",
   "body+mined:Baseline": "app.run(debug=True)",
   "body+mined:-Code": "app.run(debug=True)",
   "body+mined:-NL": "app.run(debug=True)",
   "body+mined:-Blocks": "app.config['SECRET_KEY']",
   "body+mined:-Inline": "app.run(debug=True)"
  },
  "snippet": "app.config['SECRET_KEY'] = 'Your_secret_string'"
 },
 "22799300.342": {
  "intent": "unpack a series of tuples in pandas into a dataframe with column names 'out-1' and 'out-2'",
  "body": "Sometimes I end up with a series of tuples/lists when using Pandas. This is common when, for example, doing a group-by and passing a function that has multiple return values:\nimport numpy as np\nfrom scipy import stats\ndf = pd.DataFrame(dict(x=np.random.randn(100),\n                       y=np.repeat(list(\"abcd\"), 25)))\nout = df.groupby(\"y\").x.apply(stats.ttest_1samp, 0)\nprint out\n\ny\na       (1.3066417476, 0.203717485506)\nb    (0.0801133382517, 0.936811414675)\nc      (1.55784329113, 0.132360504653)\nd     (0.267999459642, 0.790989680709)\ndtype: object\n\nWhat is the correct way to \"unpack\" this structure so that I get a DataFrame with two columns?\nA related question is how I can unpack either this structure or the resulting dataframe into two Series/array objects. This almost works:\nt, p = zip(*out)\n\nbut it t  is\n (array(1.3066417475999257),\n array(0.08011333825171714),\n array(1.557843291126335),\n array(0.267999459641651))\n\nand one needs to take the extra step of squeezing it.\n",
  "preds": {
   "base:Baseline": "df.groupby(['out-1', 'out-2'])",
   "body:Baseline": "df = pd.groupby('n').apply(list('out-1', 'out-2'))",
   "body:-Blocks": "pd.concat([['out-1', 'out-2']], axis=1)",
   "body:-Code": "pd.concat([['out-1', 'out-2'])",
   "body:-Inline": "pd.DataFrame(['out-1', 'out-2'])",
   "body:-NL": "df.groupby('y').apply(list('out-1', 'out-2')",
   "base:+Mined": "pd.concat([df['Out-1', 'Out-2']], axis=1)",
   "body+mined:Baseline": "df.groupby('y').apply(stats.ttest_1samp, 0)",
   "body+mined:-Code": "pd.concat([df1, df2], axis=1)",
   "body+mined:-NL": "df.groupby('stats').apply(stats.ttest_1samp, 0)",
   "body+mined:-Blocks": "pd.concat([df1, df2], axis=1)",
   "body+mined:-Inline": "df.groupby('y').apply(stats.ttest_1samp, 0)"
  },
  "snippet": "pd.DataFrame(out.tolist(), columns=['out-1', 'out-2'], index=out.index)"
 },
 "1762484.343": {
  "intent": "find the index of an element 'msft' in a list `stocks_list`",
  "body": "for s in stocks_list:\n    print s\n\nhow do I know what \"position\" s is in? So that I can do stocks_list[4]  in the future?\n",
  "preds": {
   "base:Baseline": "[x['msft'] for x instocks_list]",
   "body:Baseline": "print(s.index('msft') for s in stocks_list))",
   "body:-Blocks": "stock_list.index('msft')",
   "body:-Code": "stock_list.index('msft')",
   "body:-Inline": "print(stock_list.index('msft') for i in stocks_list))",
   "body:-NL": "print('msft'.index(stocks_list))",
   "base:+Mined": "[index for index instocks_list if'msft' in index]",
   "body+mined:Baseline": "stocks_list[i:i + 1]",
   "body+mined:-Code": "stock_list.index('msft')",
   "body+mined:-NL": "print(s[i:i + 1] for i in stocks_list))",
   "body+mined:-Blocks": "sorted(stocks_list, key=itemgetter('msft'))",
   "body+mined:-Inline": "print(s[i:i + 1] for i in stocks_list))"
  },
  "snippet": "[x for x in range(len(stocks_list)) if stocks_list[x] == 'MSFT']"
 },
 "3464359.344": {
  "intent": "rotate the xtick labels of matplotlib plot `ax` by `45` degrees to make long labels readable",
  "body": "Anyone know if it is possible to wrap the xtick labels in matplotlib? Right now I've got the following code (kind of messy -- been hacking at it for a while): \ndef plotResults(request, question_id):\n responses = ResponseOption.objects.filter(question__id=question_id).order_by('order').annotate(response_num=Count('response'))\n\n counts = []\n labels = [] \n\n for response in responses:\n  counts.append(response.response_num)\n  labels.append(smart_truncate('$'+response.text+'$'))\n\n N = len(labels)\n labels = tuple(labels)\n counts = tuple(counts)\n ind = na.array(range(N))+0.5\n width = .35\n fig = Figure(facecolor='white',edgecolor='white')\n ax = fig.add_subplot(1,1,1)\n\n\n rects1 = ax.bar(ind, counts,linewidth=0)\n\n ax.set_ylabel('$Count$')\n\n ax.set_title('$Response Historgram$')\n ax.set_xticks(ind+width)\n ax.set_xticklabels(labels)\n\n print mpl.matplotlib_fname()\n\n canvas = FigureCanvas(fig)\n response = HttpResponse(content_type='image/png')\n\n canvas.print_png(response)\n\n return response\n\nThat generates this plot:\n\nAs you can see the xticks are boned. Any ideas on how to wrap them, or baring that make them readable? Thanks again!\nPS: This is part of a Django project. I return the plot as a png image -- normally call them from img tags in various views. \n",
  "preds": {
   "base:Baseline": "ax.set_xticklabels(45)",
   "body:Baseline": "ax.set_xticklabels(45)",
   "body:-Blocks": "ax.set_xtick_labels(45)",
   "body:-Code": "ax.set_xticklabels('45')",
   "body:-Inline": "ax.set_xticklabels(length=45)",
   "body:-NL": "ax.set_xticklabels(labels)",
   "base:+Mined": "ax.set_xticklabels(45)",
   "body+mined:Baseline": "ax.set_xticklabels(labels)",
   "body+mined:-Code": "ax.set_xticklabels(45)",
   "body+mined:-NL": "ax.set_xticklabels(labels)",
   "body+mined:-Blocks": "ax.set_xticklabels(45)",
   "body+mined:-Inline": "ax.set_xticklabels(labels)"
  },
  "snippet": "ax.set_xticklabels(labels, rotation=45)"
 },
 "875968.345": {
  "intent": "remove symbols from a string `s`",
  "body": "I'm a beginner with both Python and RegEx, and I would like to know how to make a string that takes symbols and replaces them with spaces. Any help is great.\nFor example:\nhow much for the maple syrup? $20.99? That's ricidulous!!!\n\ninto:\nhow much for the maple syrup 20 99 That s ridiculous\n\n",
  "preds": {
   "base:Baseline": "s = re.sub('\\\\d+', '', s)",
   "body:Baseline": "s = s.replace('\\\\w', '')",
   "body:-Blocks": "s = re.sub('\\\\w+', '', s)",
   "body:-Code": "s = re.sub('\\\\d+', '', s)",
   "body:-Inline": "s = s.replace('', '')",
   "body:-NL": "s = s.split()[::-1]",
   "base:+Mined": "s = s.replace(',', '')",
   "body+mined:Baseline": "s = s.replace('\\\\s', '')",
   "body+mined:-Code": "s = re.sub('\\\\s+', '', s)",
   "body+mined:-NL": "s = s.replace(' ', '')",
   "body+mined:-Blocks": "re.sub('\\\\s+', '', s)",
   "body+mined:-Inline": "s = re.sub('(?<=.)(?=.)', '', s)"
  },
  "snippet": "re.sub('[^\\\\w]', '', s)"
 },
 "31258561.346": {
  "intent": "get the current directory of a script",
  "body": "I know I can use this to get the full file path\nos.path.dirname(os.path.realpath(__file__))\n\nBut I want just the name of the folder, my scrip is in. SO if I have my_script.py and it is located at\n/home/user/test/my_script.py\n\nI want to return \"test\" How could I do this?\nThanks\n",
  "preds": {
   "base:Baseline": "os.chdir(os.path.realpath(__file__))",
   "body:Baseline": "os.path.dirname(os.Path.realpath(__file__))",
   "body:-Blocks": "os.path.dirname(__file__)",
   "body:-Code": "os.path.realpath(__file__)",
   "body:-Inline": "os.path.dirname(__file__))",
   "body:-NL": "os.path.dirname(os.Path.realpath(__file__))",
   "base:+Mined": "os.chdir(os.path.dirname(__file__))",
   "body+mined:Baseline": "os.path.dirname(os.file.realpath(__file__))",
   "body+mined:-Code": "os.path.abspath(__file__)",
   "body+mined:-NL": "os.chdir(os.path.dirname(__file__))",
   "body+mined:-Blocks": "os.path.abspath(__file__)",
   "body+mined:-Inline": "os.path.realpath(__file__)"
  },
  "snippet": "os.path.basename(os.path.dirname(os.path.realpath(__file__)))"
 },
 "34750084.347": {
  "intent": "find octal characters matches from a string `str` using regex",
  "body": "I'm attempting to write a regex that captures octal characters.\nFor example, if the line I'm comparing to my regex is:\nchar x = '\\077';\n\nI want my regex to capture '\\077'\nI attempted to do this via the re module and a regex of the form:\n\"'\\\\[0-7]{1-3}'\"\n\nBut this doesn't capture the octal character.  How can octal characters be identified using regex in Python?\nEdit:\nAs an example of what I mean, consider the C code:\nchar x = '\\077'; \nprintf(\"%c\", x);\n\nI would like to capture '\\077'  from the first line.\nEdit:\nAfter testing some of the suggestions in this thread, I have a case that works.  I realize that after adding the octal regex to a larger regex, I needed to prefix with r for raw input, or escape each backslash, for a total of four backslashes.\nFor example, both of these solve the problem:\nregex = re.compile(r\"\\s*(\"                  \n                        r\"'\\\\0[0-7]{1,2}'\"          # octal\n                        \"|[a-zA-Z_][a-zA-Z_\\d]*\"    # identifer\n                        \")\")\nregex.findall(line)\n\nand\nregex = re.compile(r\"\\s*(\"                  \n                        \"'\\\\\\\\0[0-7]{1,2}'\"         # octal\n                        \"|[a-zA-Z_][a-zA-Z_\\d]*\"    # identifer\n                        \")\")\nregex.findall(line)\n\nWhich will produce '\\077'  if line is: char = '\\077';\nThanks for the help everyone.\n",
  "preds": {
   "base:Baseline": "re.findall('\\\\w+', str)",
   "body:Baseline": "re.compile('\\\\[0-7]{1-3}', str)",
   "body:-Blocks": "re.findall('\\\\077', str)",
   "body:-Code": "re.findall('\\\\w+', str)",
   "body:-Inline": "re.compile('\\\\[0-7]{1,2}')",
   "body:-NL": "re.findall('\\\\[0-7]{1,2}', str)",
   "base:+Mined": "re.findall('[a-zA-Z]', str)",
   "body+mined:Baseline": "regex = re.compile('\\\\[0-7]{1-3}')",
   "body+mined:-Code": "re.findall('(?<=.)(?=.)', str)",
   "body+mined:-NL": "re.findall('\\\\[0-7]{1,2}', str)",
   "body+mined:-Blocks": "re.findall('\\\\077', str)",
   "body+mined:-Inline": "regex = re.compile('\\\\[0-7]{1-3}')"
  },
  "snippet": "print(re.findall(\"'\\\\\\\\[0-7]{1,3}'\", str))"
 },
 "13209288.348": {
  "intent": "split string `input` based on occurrences of regex pattern '[ ](?=[a-z]+\\\\b)'",
  "body": "What is the best way to split a string like \"HELLO there HOW are YOU\"  by upper case words (in Python)? \nSo I'd end up with an array like such: results = ['HELLO there', 'HOW are', 'YOU']\n\nEDIT: \nI have tried: \np = re.compile(\"\\b[A-Z]{2,}\\b\")\nprint p.split(page_text)\n\nIt doesn't seem to work, though.\n",
  "preds": {
   "base:Baseline": "re.split('[ ](?=[A-Z]+\\\\b)', input)",
   "body:Baseline": "re.compile('(?=[A-Z]+\\\\b)', input)",
   "body:-Blocks": "re.split('[ ](?=[A-Z]+\\\\b)', input)",
   "body:-Code": "re.split('[ ](?=[A-Z]+\\\\b)', input)",
   "body:-Inline": "re.compile('[ ](?=[A-Z]+\\\\b)', input)",
   "body:-NL": "re.compile('[ ](?=[A-Z]+\\\\b)', input)",
   "base:+Mined": "re.split('(?=[A-Z]+\\\\b)', input)",
   "body+mined:Baseline": "results = re.compile('\\\\b[A-Z]{2,}\\x08')",
   "body+mined:-Code": "re.split('[ ](?=[A-Z]+\\\\b)', input)",
   "body+mined:-NL": "re.compile('\\\\b[A-Z]+\\\\b', input)",
   "body+mined:-Blocks": "results = re.findall('[ ](?=[A-Z]+\\\\b)', input)",
   "body+mined:-Inline": "p = re.compile('\\\\b[A-Z]{2,}\\x08')"
  },
  "snippet": "re.split('[ ](?=[A-Z]+\\\\b)', input)"
 },
 "13209288.349": {
  "intent": "split string `input` at every space followed by an upper-case letter",
  "body": "What is the best way to split a string like \"HELLO there HOW are YOU\"  by upper case words (in Python)? \nSo I'd end up with an array like such: results = ['HELLO there', 'HOW are', 'YOU']\n\nEDIT: \nI have tried: \np = re.compile(\"\\b[A-Z]{2,}\\b\")\nprint p.split(page_text)\n\nIt doesn't seem to work, though.\n",
  "preds": {
   "base:Baseline": "input = re.sub('\\\\w+', '', input)",
   "body:Baseline": "re.compile('\\\\b[A-Z]{2,}\\x08')",
   "body:-Blocks": "input.split('HELLO there', 'HOW are', 'YOU')",
   "body:-Code": "input.split(',', 1)[0]",
   "body:-Inline": "re.compile('\\x08[A-Z]{2,}\\x08')",
   "body:-NL": "re.compile('\\\\b[A-Z]\\\\b', input)",
   "base:+Mined": "\"\"\" \"\"\".join(input.split())",
   "body+mined:Baseline": "results = re.compile('\\\\b[A-Z]{2,}\\x08')",
   "body+mined:-Code": "re.split('\\\\W+', input)",
   "body+mined:-NL": "re.compile('\\\\b[A-Z]{2,}\\x08', input)",
   "body+mined:-Blocks": "results = results.split(',')[-1]",
   "body+mined:-Inline": "print(re.compile('\\\\b[A-Z]{2,}\\b')"
  },
  "snippet": "re.split('[ ](?=[A-Z])', input)"
 },
 "24642040.350": {
  "intent": "send multipart encoded file `files` to url `url` with headers `headers` and metadata `data`",
  "body": "I'm trying to POST to an API (Build using SlimPHP) which accepts an image along with additional image meta data in the form of JSON.  \nI've verified the API works correctly using a REST client tool and can successfully POST to the service. All data is stored correctly.\nI'm now trying to POST using Python - however my JSON data doesn't appear to be saving.\nMy code:\n    data = {'key1': 'value1', 'key2': 'value2'}\n    url = 'http://mydomain.com/api/endpoint'\n    headers = {'Authorization': 'my-api-key'}\n    files = {'file': (FILE, open(PATH, 'rb'), 'image/jpg', {'Expires': '0'})}\n    r = requests.post(url, files=files, headers=headers, data=data)\n\n--\nI've attempted to set additional headers,\nie:/\nheaders = {'Authorization': 'unique-auth-key', 'Content-type': 'multipart/form-data'}\n\nor\nheaders = {'Authorization': 'unique-auth-key', 'Content-type': 'application/json'}\n\nThese result in a 500 error.\n\nUPDATE 14/07/2014:\nUsing a chrome extension (Advanced Rest Client) my POST is successful - here's what the console shows as the payload:\n------WebKitFormBoundarysBpiwrA3hnGPUbMA\nContent-Disposition: form-data; name=\"data\"\ntest\n------WebKitFormBoundarysBpiwrA3hnGPUbMA\nContent-Disposition: form-data; name=\"file\"; filename=\"image.jpg\"\nContent-Type: image/jpeg\n------WebKitFormBoundarysBpiwrA3hnGPUbMA--\n\nI'm not quite sure what this signifies...\n",
  "preds": {
   "base:Baseline": "urllib.parse.unquote(files, headers={'headers': 'data'})",
   "body:Baseline": "requests.post(url, files=files, headers=headers, data=data)",
   "body:-Blocks": "urllib.request.urlopen('files', headers={'meta': data})",
   "body:-Code": "urllib.request.urlopen('files', headers={'headers': 'data'})",
   "body:-Inline": "r = requests.post(url, files={'headers': headers, data={'Content-Type': 'application/json'})",
   "body:-NL": "requests.post(url, files={'Authorization': 'my-api-key'})",
   "base:+Mined": "urllib.parse.unquote(files).decode('utf-8')",
   "body+mined:Baseline": "r = requests.post(url, files=files, headers=headers, data=data)",
   "body+mined:-Code": "urllib.request.urlopen(files, headers=headers, metadata=data)",
   "body+mined:-NL": "r = requests.post(url, files=files, headers=headers, data=data)",
   "body+mined:-Blocks": "urllib.parse.quote(files).decode('utf-8')",
   "body+mined:-Inline": "r = requests.post(url, files=files, headers=headers, data=data)"
  },
  "snippet": "r = requests.post(url, files=files, headers=headers, data=data)"
 },
 "4290716.351": {
  "intent": "write bytes `bytes_` to a file `filename` in python 3",
  "body": "In Python 2.x with 'file-like' object:\nsys.stdout.write(bytes_)\ntempfile.TemporaryFile().write(bytes_)\nopen('filename', 'wb').write(bytes_)\nStringIO().write(bytes_)\n\nHow to do the same in Python 3?\nHow to write equivalent of this Python 2.x code:\ndef write(file_, bytes_):\n    file_.write(bytes_)\n\nNote: sys.stdout  is not always semantically a text stream. It might be beneficial to consider it as a stream of bytes sometimes. For example, make encrypted archive of dir/ on remote machine :\ntar -c dir/ | gzip | gpg -c | ssh user@remote 'dd of=dir.tar.gz.gpg'\n\nThere is no point to use Unicode in this case.\n",
  "preds": {
   "base:Baseline": "print(filename.write(bytes_))",
   "body:Baseline": "sys.stdout.write(bytes_)",
   "body:-Blocks": "filename = os.stdout.write(bytes_)",
   "body:-Code": "print(filename.write(bytes_))",
   "body:-Inline": "sys.stdout.write(bytes_)",
   "body:-NL": "tempfile.TemporaryFile().write(bytes_)",
   "base:+Mined": "f.write('\\n'.join(bytes_))",
   "body+mined:Baseline": "filename = open('filename', 'wb').write(bytes_)",
   "body+mined:-Code": "f.write(bytes_).encode('utf-8')",
   "body+mined:-NL": "open('filename', 'wb').write(bytes_)",
   "body+mined:-Blocks": "filename = open('filename.txt', 'r')",
   "body+mined:-Inline": "file_.write('\\n'.join(bytes_))"
  },
  "snippet": "open('filename', 'wb').write(bytes_)"
 },
 "33078554.352": {
  "intent": "get a list from a list `lst` with values mapped into a dictionary `dct`",
  "body": "Given the following dictionary:\ndct = {'a':3, 'b':3,'c':5,'d':3}\n\nHow can I apply these values to a list such as:\nlst = ['c', 'd', 'a', 'b', 'd']\n\nin order to get something like:\nlstval = [5, 3, 3, 3, 3]\n\n",
  "preds": {
   "base:Baseline": "[dct for dct in lst]",
   "body:Baseline": "[k for k, v in lst.items() if v]",
   "body:-Blocks": "[dct for dct in lst]",
   "body:-Code": "[dct for dct in lst]",
   "body:-Inline": "[dct for dct, dct in lst]",
   "body:-NL": "[dct for dct in lst]",
   "base:+Mined": "dct = [dct[key] for key in lst]",
   "body+mined:Baseline": "[x for x in lst for y in dct]",
   "body+mined:-Code": "[dct[i] for i in lst]",
   "body+mined:-NL": "dct = dict((k, v) for k, v in lst.items())",
   "body+mined:-Blocks": "[dct[i] for i in lst]",
   "body+mined:-Inline": "[dct[k] for k in lst]"
  },
  "snippet": "[dct[k] for k in lst]"
 },
 "15247628.353": {
  "intent": "find duplicate names in column 'name' of the dataframe `x`",
  "body": "I have a pandas.DataFrame  with a column called name  containing strings.\nI would like to get a list of the names which occur more than once in the column. How do I do that?\nI tried:\nfuncs_groups = funcs.groupby(funcs.name)\nfuncs_groups[(funcs_groups.count().name>1)]\n\nBut it doesn't filter out the singleton names.\n",
  "preds": {
   "base:Baseline": "x.groupby(['name'])",
   "body:Baseline": "df['name'] = funcs.groupby(funcs.name)",
   "body:-Blocks": "df['name'] = df['name'].duplicates()",
   "body:-Code": "x.groupby('name')['name']",
   "body:-Inline": "x = funcs.groupby(funcs.name)",
   "body:-NL": "x = funcs.groupby(funcs.name, names)",
   "base:+Mined": "x.groupby(level=1).agg(['name', 'name'])",
   "body+mined:Baseline": "df.groupby(['name', 'name'])['name'].distinct()",
   "body+mined:-Code": "df.groupby('name').apply(lambda x: len(x), axis=1)",
   "body+mined:-NL": "df.groupby(['name', 'name'])['name'].apply(lambda x: x.name)",
   "body+mined:-Blocks": "df['name'] = df['name'].apply(lambda x: x.replace(' ', ''))",
   "body+mined:-Inline": "df.find_all('name', inplace=True)"
  },
  "snippet": "x.set_index('name').index.get_duplicates()"
 },
 "783897.354": {
  "intent": "truncate float 1.923328437452 to 3 decimal places",
  "body": "I want to remove digits from a float to have a fixed number of digits after the dot, like:\n1.923328437452 - 1.923\n\nI need to output as a string to another function, not print.\nAlso I want to ignore the lost digits, not round them.\n",
  "preds": {
   "base:Baseline": "\"\"\"{0:.3f}\"\"\".format(1.923328437452)",
   "body:Baseline": "float(1.923328437452 - 1.923)",
   "body:-Blocks": "print('%.3f' % 1.923328437452)",
   "body:-Code": "print('%.3f' % 1.923328437452)",
   "body:-Inline": "print('{0:.923f}'.format(1.923328437452))",
   "body:-NL": "float('{0:.3f}'.format(1.923328437452))",
   "base:+Mined": "\"\"\"{0:.3f}\"\"\".format(1.923328437452)",
   "body+mined:Baseline": "\"\"\"{:.3f}\"\"\".format(1.923328437452)",
   "body+mined:-Code": "print('{0:.3f}'.format(1.923328437452))",
   "body+mined:-NL": "\"\"\"{0:.3f}\"\"\".format(1.923328437452 - 1.923)",
   "body+mined:-Blocks": "print('{0:.3f}'.format(1.923328437452))",
   "body+mined:-Inline": "\"\"\"{:.3f}\"\"\".format(1.923328437452)"
  },
  "snippet": "round(1.923328437452, 3)"
 },
 "22859493.355": {
  "intent": "sort list `li` in descending order based on the date value in second element of each list in list `li`",
  "body": "import csv,operator\nfrom datetime import datetime\n\nli = [['name','01/03/2012','job'],\n      ['name','02/05/2013','job'],\n      ['name','03/08/2014','job']]\n\nSorted Method:\nsorted(li,key=lambda x:datetime.strptime(row[1],'%d/%m/%Y'), reverse=True)\n\nOutput:\nNo error, but simply not ordered\nItemgetter Method:\nfor x in range(1,len(li)):\n    li[x][6]=datetime.strptime(li[x][6],'%d/%m/%Y')\n\nli.sort(key=operator.itemgetter(6))\n\nOutput:\nTraceback (most recent call last):\n  File \"U:/rmarshall/Work For Staff/ROB/_Python/__Python Projects Code/April Signed Terms.py\", line 35, in <module>\n    li.sort(key=operator.itemgetter(6))\nTypeError: unorderable types: datetime.datetime() < str()\n\nCould someone supply an example of ordering a the list li by date.  For educational purposes I would appreciate examples of both the sorted method and itemgetter method with a comparison of efficiency.\nAlso, by the error on the itemgetter approach, is itemgetter simply not able to handle datetime objects.\nNote:  I presume the ascending or descending order doesn't matter too much in this example as it can be simply flipped with reverse=True .\n",
  "preds": {
   "base:Baseline": "li.sort(key=lambda x: (x[1], x[2]))",
   "body:Baseline": "li.sort(key=lambda x: datetime.strptime(row[1]], reverse=True)",
   "body:-Blocks": "sorted(li, key=lambda x: x[1])",
   "body:-Code": "sorted(li, key=lambda x: x[1])",
   "body:-Inline": "li.sort(key=operator.itemgetter(6))",
   "body:-NL": "li.sort(key=lambda x: reverse=True)",
   "base:+Mined": "li.sort(key=lambda x: x[2])",
   "body+mined:Baseline": "li.sort(key=operator.itemgetter(6))",
   "body+mined:-Code": "li.sort(key=lambda x: (x[1], x[0]))",
   "body+mined:-NL": "li.sort(key=operator.itemgetter(6))",
   "body+mined:-Blocks": "li.sort(key=lambda x: (x[1], x[2]))",
   "body+mined:-Inline": "li.sort(key=operator.itemgetter(6))"
  },
  "snippet": "sorted(li, key=lambda x: datetime.strptime(x[1], '%d/%m/%Y'), reverse=True)"
 },
 "29394552.356": {
  "intent": "place the radial ticks in plot `ax` at 135 degrees",
  "body": "From matplotlib examples :\nimport numpy as np\nimport seaborn as sbs\nimport matplotlib.pyplot as plt\n\nr = np.arange(0, 3.0, 0.01)\ntheta = 2 * np.pi * r\n\nax = plt.subplot(111, polar=True)\nax.plot(theta, r, color='r', linewidth=3)\nax.set_rmax(2.0)\nax.grid(True)\n\nax.set_title(\"A line plot on a polar axis\", va='bottom')\nplt.show()\n\n\nHow to move the radial tick labels (0.5, 1.0, 1.5, 2.0) to a different angle, say 120 deg?\n",
  "preds": {
   "base:Baseline": "ax.set_index(135)",
   "body:Baseline": "ax.set_title('A line plot')",
   "body:-Blocks": "ax.set_radigit()",
   "body:-Code": "ax.set_radigit()",
   "body:-Inline": "ax.set_title('A line plot on a polar axis', 135)",
   "body:-NL": "ax.set_title('A line plot on a polar axis', 135)",
   "base:+Mined": "ax.set_xticklabels([])",
   "body+mined:Baseline": "ax.plot(theta, r, color='r', linewidth=3)",
   "body+mined:-Code": "ax.set_xlim([0, 100])",
   "body+mined:-NL": "ax.plot(theta, r, color='r', linewidth=3)",
   "body+mined:-Blocks": "ax.set_xlim(0.5)",
   "body+mined:-Inline": "ax.plot(theta, r, color='r', linewidth=3)"
  },
  "snippet": "ax.set_rlabel_position(135)"
 },
 "3320406.357": {
  "intent": "check if path `my_path` is an absolute path",
  "body": "UNIX absolute path starts with '/', whereas Windows starts with alphabet 'C:' or '\\'.\nDoes python has a standard function to check if a path is absolute or relative? \n",
  "preds": {
   "base:Baseline": "print(os.path.abspath(my_path))",
   "body:Baseline": "print(os.path.realpath(my_path))",
   "body:-Blocks": "print(os.path.abspath(my_path))",
   "body:-Code": "print(os.path.abspath(my_path))",
   "body:-Inline": "print(os.path.abspath(my_path))",
   "body:-NL": "print(os.path.realpath(my_path))",
   "base:+Mined": "os.path.abspath(my_path)",
   "body+mined:Baseline": "print(os.path.realpath(my_path))",
   "body+mined:-Code": "os.path.abspath(my_path)",
   "body+mined:-NL": "print(os.path.abspath(my_path))",
   "body+mined:-Blocks": "os.path.abspath(my_path)",
   "body+mined:-Inline": "print(os.path.abspath(my_path))"
  },
  "snippet": "os.path.isabs(my_path)"
 },
 "2212433.358": {
  "intent": "get number of keys in dictionary `yourdict`",
  "body": "I have a list of words in a dictionary with the value = the repetition of the keyword but I only want a list of distinct words so I wanted to count the number of keywords. Is there a way to count the number of keywords or is there another way I should look for distinct words?\n",
  "preds": {
   "base:Baseline": "sum(key for key, value in list(yourdict.items()))",
   "body:Baseline": "sum(key for key, value in list(yourdict.items()))",
   "body:-Blocks": "len(key) for key in list(yourdict.items())",
   "body:-Code": "sum(key for key, value in list(yourdict.items())",
   "body:-Inline": "sum(yourdict.keys()))",
   "body:-NL": "sum(key for key, value in list(yourdict.items())",
   "base:+Mined": "sum(len(yourDict))",
   "body+mined:Baseline": "sum(1 for word in list(yourdict.items())",
   "body+mined:-Code": "sum(1 for key, value in list(yourdict.items()) if value == 1)",
   "body+mined:-NL": "sum(key for key, value in list(yourdict.items()))",
   "body+mined:-Blocks": "sum(1 for key, value in list(yourdict.items()))",
   "body+mined:-Inline": "sum(key for key, value in list(yourdict.items()))"
  },
  "snippet": "len(list(yourdict.keys()))"
 },
 "2212433.359": {
  "intent": "count the number of keys in dictionary `yourdictfile`",
  "body": "I have a list of words in a dictionary with the value = the repetition of the keyword but I only want a list of distinct words so I wanted to count the number of keywords. Is there a way to count the number of keywords or is there another way I should look for distinct words?\n",
  "preds": {
   "base:Baseline": "sum(key for key, value in list(yourdictfile.items()))",
   "body:Baseline": "sum(key for key, value in list(yourdictfile.items()))",
   "body:-Blocks": "sum(key for key, value in list(yourdictfile.items()))",
   "body:-Code": "sum(key for key, value in list(yourdictfile.items())",
   "body:-Inline": "sum(yourdictfile.keys())",
   "body:-NL": "count(key=lambda x: x[1])",
   "base:+Mined": "sum(len(yourdictfile))",
   "body+mined:Baseline": "sum(1 for word in list(yourdictfile.keys())",
   "body+mined:-Code": "sum(1 for key, value in list(yourdictfile.items()) if value == 1)",
   "body+mined:-NL": "sum(1 for key, value in list(yourdictfile.values()))",
   "body+mined:-Blocks": "sum(1 for key, value in list(yourdictfile.items()))",
   "body+mined:-Inline": "len(yourdictfile.values())"
  },
  "snippet": "len(set(open(yourdictfile).read().split()))"
 },
 "20067636.360": {
  "intent": "pandas dataframe get first row of each group by 'id'",
  "body": "I have a pandas DataFrame  like following.\ndf = pd.DataFrame({'id' : [1,1,1,2,2,3,3,3,3,4,4,5,6,6,6,7,7],\n                'value'  : [\"first\",\"second\",\"second\",\"first\",\n                            \"second\",\"first\",\"third\",\"fourth\",\n                            \"fifth\",\"second\",\"fifth\",\"first\",\n                            \"first\",\"second\",\"third\",\"fourth\",\"fifth\"]})\n\nI want to group this by [\"id\",\"value\"] and get the first row of each group.\n        id   value\n0        1   first\n1        1  second\n2        1  second\n3        2   first\n4        2  second\n5        3   first\n6        3   third\n7        3  fourth\n8        3   fifth\n9        4  second\n10       4   fifth\n11       5   first\n12       6   first\n13       6  second\n14       6   third\n15       7  fourth\n16       7   fifth\n\nExpected outcome\n    id   value\n     1   first\n     2   first\n     3   first\n     4  second\n     5  first\n     6  first\n     7  fourth\n\nI tried following which only gives the first row of the DataFrame . Any help regarding this is appreciated.\nfor index, row in df.iterrows():\n  <console_out>.:     df2 = pd.DataFrame(df.groupby(['id','value']).reset_index().ix[0])\n\n",
  "preds": {
   "base:Baseline": "df.groupby('id').apply(lambda x: x[1])",
   "body:Baseline": "df = pd.DataFrame(['id'], axis=1)",
   "body:-Blocks": "df.groupby('id')['value']",
   "body:-Code": "df['id'] = df['value']",
   "body:-Inline": "df['id'] = df['value'].groupby('id')",
   "body:-NL": "pd.DataFrame(['id'], axis=1)",
   "base:+Mined": "df.groupby('id').apply(lambda x: x['id'], axis=1)",
   "body+mined:Baseline": "df.groupby(['id', 'value']).head(1)",
   "body+mined:-Code": "df.groupby('id').head()",
   "body+mined:-NL": "df.groupby(['id', 'value'])['value'].first()",
   "body+mined:-Blocks": "df.groupby('id').first()",
   "body+mined:-Inline": "df.groupby('id')['value'].apply(lambda x: x['id'].tolist())"
  },
  "snippet": "df.groupby('id').first()"
 },
 "40924332.361": {
  "intent": "split a list in first column  into multiple columns keeping other columns as well in pandas data frame",
  "body": "I have a really simple Pandas\ndataframe  where each cell contains a list. I'd like to split each element of the list into it's own column. I can do that by exporting the values and then creating a new dataframe . This doesn't seem like a good way to do this especially, if my dataframe  had a column aside from the list column.\nimport pandas as pd\n\ndf = pd.DataFrame(data=[[[8,10,12]],\n                        [[7,9,11]]])\n\ndf = pd.DataFrame(data=[x[0] for x in df.values])\n\nDesired output:\n   0   1   2\n0  8  10  12\n1  7   9  11\n\nFollow-up based on @Psidom answer:\nIf I did have a second column:\ndf = pd.DataFrame(data=[[[8,10,12], 'A'],\n                        [[7,9,11], 'B']])\n\nHow do I not loose the other column?\nDesired output:\n   0   1   2  3 \n0  8  10  12  A\n1  7   9  11  B\n\n",
  "preds": {
   "base:Baseline": "pd.concat([df[1], df[2], axis=1)",
   "body:Baseline": "df = pd.DataFrame(data=[x[0] for x in df.values])",
   "body:-Blocks": "pd.concat([df[1], df[2], axis=1)",
   "body:-Code": "pd.concat([df['1'], df['2'], axis=1)",
   "body:-Inline": "df = pd.DataFrame(data=[x[0] for x in df.values])",
   "body:-NL": "df = pd.DataFrame(data=[x[0] for x in df.values])",
   "base:+Mined": "pd.concat([df1, df2], axis=1)",
   "body+mined:Baseline": "df['A'].apply(lambda x: x.apply(pd.Series).astype(int)",
   "body+mined:-Code": "df['A'] = df['B'].apply(pd.Series)",
   "body+mined:-NL": "pd.concat([df, pd.DataFrame(data=[x[0] for x in df.values])",
   "body+mined:-Blocks": "pd.concat([df1, df2], axis=1)",
   "body+mined:-Inline": "df[['A', 'B']].apply(pd.Series)"
  },
  "snippet": "pd.concat([df[0].apply(pd.Series), df[1]], axis=1)"
 },
 "30759776.362": {
  "intent": "extract attributes 'src=\"js/([^\"]*\\\\bjquery\\\\b[^\"]*)\"' from string `data`",
  "body": "I want to get JS file names from the input content which contains jquery  as a substring by RE.\nThis is my code:\nStep 1: Extract JS file from the content.\ndata = \"\"\"    <script type=\"text/javascript\" src=\"js/jquery-1.9.1.min.js\"/>\n    <script type=\"text/javascript\" src=\"js/jquery-migrate-1.2.1.min.js\"/>\n    <script type=\"text/javascript\" src=\"js/jquery-ui.min.js\"/>\n    <script type=\"text/javascript\" src=\"js/abc_bsub.js\"/>\n    <script type=\"text/javascript\" src=\"js/abc_core.js\"/>\n    <script type=\"text/javascript\" src=\"js/abc_explore.js\"/>\n    <script type=\"text/javascript\" src=\"js/abc_qaa.js\"/>\"\"\"\nimport re\nre.findall('src=\"js/([^\"]+)\"', data)\n['jquery-1.9.1.min.js', 'jquery-migrate-1.2.1.min.js', 'jquery-ui.min.js', 'abc_bsub.js', 'abc_core.js', 'abc_explore.js', 'abc_qaa.js']\n\nStep 2: Get JS file which have sub string as jquery\n[ii for ii in re.findall('src=\"js/([^\"]+)\"', data) if \"jquery\" in ii]\n['jquery-1.9.1.min.js', 'jquery-migrate-1.2.1.min.js', 'jquery-ui.min.js']\n\nCan I do above Step 2 in the Step 1 means RE Pattern to get result?\n",
  "preds": {
   "base:Baseline": "data = data.extract('src=\"js/([^\"]*\\\\bjquery\\\\b[^]*)\"')",
   "body:Baseline": "re.findall('src=\"js/([^]*\\\\bjquery\\\\b[^\"]*)\"', data)",
   "body:-Blocks": "data.translate(re.compile('src=\"js/([^\"]*\\\\bjquery\\\\b[^]*)\"))",
   "body:-Code": "data = re.compile('src=\"js/([^\"]*\\\\bjquery\\\\b[^]*)\"",
   "body:-Inline": "data = re.findall('src=\"js/([^\"]*\\\\bjquery\\\\b[^]*)\"', data)",
   "body:-NL": "re.findall('src=\"js/([^]*\\\\bjquery\\\\b[^\"]*)\"', data)",
   "base:+Mined": "data.extract('src=\"js/([^\"]*\\\\bjquery\\\\b[^\"]*))\"",
   "body+mined:Baseline": "re.findall('src=\"js/([^\"]+\\\\bjquery\\\\b[^\"]*)\"', data)",
   "body+mined:-Code": "re.compile('src=\"js/([^\"]*\\\\bjquery\\\\b[^]*)\"",
   "body+mined:-NL": "[ii for i in re.findall('src=\"js/([^\"]+)\"', data) if 'jquery' in i]",
   "body+mined:-Blocks": "re.compile('src=\"js/([^\"]*\\\\bjquery\\\\b[^]*)')",
   "body+mined:-Inline": "re.findall('src=\"js/([^\"]+)\"', data)"
  },
  "snippet": "re.findall('src=\"js/([^\"]*\\\\bjquery\\\\b[^\"]*)\"', data)"
 },
 "25388796.363": {
  "intent": "sum integers contained in strings in list `['', '3.4', '', '', '1.0']`",
  "body": "I'm doing something like this to sum up a number of elements of a line:   \nfor line in open(filename, 'r'):\n   big_list = line.strip().split(delim)\n   a = sum(int(float(item)) for item in big_list[start:end] if item)  \n   # do some other stuff\n\nthis is done line by line with a big file, where some items may be missing, i.e., equal to ''. If I use the statement above to compute a, the script becomes much slower than without it. Is there a way to speed it up? \n",
  "preds": {
   "base:Baseline": "sum(map(int, ['', '3.4', '', '\", '1.0'])",
   "body:Baseline": "sum(int(float(item)) for item in [', '3.4', '', '1.0'])",
   "body:-Blocks": "sum(int(x) for x in ['', '3.4', '', '\", '1.0'])",
   "body:-Code": "sum(map(int, x) for x in ['', '3.4', '', '\", '1.0'])",
   "body:-Inline": "sum(int(float(item)) for item in ['', '3.4', '', '1.0'])",
   "body:-NL": "sum(int(x) for x in ['', '3.4', '', '1.0'])",
   "base:+Mined": "sum(map(int, x))",
   "body+mined:Baseline": "sum(int(float(item)) for item in big_list[start:end] if item)",
   "body+mined:-Code": "sum(map(int, x.split('.')))",
   "body+mined:-NL": "sum(int(float(item)) for item in big_list[start:end] if item)",
   "body+mined:-Blocks": "sum(map(int, ['', '3.4', '', '1.0'])",
   "body+mined:-Inline": "sum(int(float(item)) for item in big_list[start:end])"
  },
  "snippet": "sum(int(float(item)) for item in [_f for _f in ['', '3.4', '', '', '1.0'] if\n    _f])"
 },
 "804995.364": {
  "intent": "call a subprocess with arguments `c:\\\\program files\\\\vmware\\\\vmware server\\\\vmware-cmd.bat` that may contain spaces",
  "body": "I'm working on a wrapper script that will exercise a vmware executable, allowing for the automation of virtual machine startup/shutdown/register/deregister actions.  I'm trying to use subprocess to handle invoking the executable, but the spaces in the executables path and in parameters of the executable are not being handled correctly by subprocess.  Below is a code fragment:\nvmrun_cmd = r\"c:/Program Files/VMware/VMware Server/vmware-cmd.bat\"\ndef vm_start(target_vm):\n    list_arg = \"start\"\n    list_arg2 = \"hard\"\n    if vm_list(target_vm):\n            p = Popen([vmrun_cmd, target_vm, list_arg, list_arg2],   stdout=PIPE).communicate()[0]\n            print p\n    else:\n            vm_register(target_vm)\n            vm_start(target_vm)\ndef vm_list2(target_vm):\n    list_arg = \"-l\"\n    p = Popen([vmrun_cmd, list_arg], stdout=PIPE).communicate()[0]\n    for line in p.split('\\n'):\n            print line\n\nIf I call the vm_list2 function, I get the following output:\n$ ./vmware_control.py --list                                                \nC:\\Virtual Machines\\QAW2K3Server\\Windows Server 2003 Standard Edition.vmx\nC:\\Virtual Machines\\ubunturouter\\Ubuntu.vmx\nC:\\Virtual Machines\\vacc\\vacc.vmx\nC:\\Virtual Machines\\EdgeAS-4.4.x\\Other Linux 2.4.x kernel.vmx\nC:\\Virtual Machines\\UbuntuServer1\\Ubuntu.vmx\nC:\\Virtual Machines\\Other Linux 2.4.x kernel\\Other Linux 2.4.x kernel.vmx\nC:\\Virtual Machines\\QAClient\\Windows XP Professional.vmx\n\nIf I call the vm_start function, which requires a path-to-vm parameter, I get the following output:\n$ ./vmware_control.py --start \"C:\\Virtual Machines\\ubunturouter\\Ubuntu.vmx\"\n'c:\\Program' is not recognized as an internal or external command,\noperable program or batch file.\n\nApparently, the presence of a second parameter with embedded spaces is altering the way that subprocess is interpreting the first parameter.  Any suggestions on how to resolve this?\npython2.5.2/cygwin/winxp\n",
  "preds": {
   "base:Baseline": "subprocess.call('c:\\\\program files\\\\vmware\\\\vmWARE server\\\\vmWare-cmd.bat',\n    shell=True)",
   "body:Baseline": "subprocess.call('C:\\\\Program Files\\\\vmware\\\\VMware Server/vmware-cmd.bat',\n    shell=True)",
   "body:-Blocks": "subprocess.call(['c:\\\\program files\\\\vmware\\\\vmWARE server\\\\VMware-cmd.bat', shell=True)",
   "body:-Code": "subprocess.call('c:\\\\program files\\\\vmware\\\\vmWare server\\\\vmWARE-cmd.bat',\n    shell=True)",
   "body:-Inline": "subprocess.call(['c:\\\\Program Files\\\\vmware\\\\VMware Server/vmware-cmd.bat'])",
   "body:-NL": "subprocess.call('c:\\\\Program Files\\\\vmware\\\\vmWare Server\\\\vmWARE-cmd.bat',\n    shell=True)",
   "base:+Mined": "subprocess.call(['c:\\\\program files\\\\vmware\\\\vmWARE server\\\\vmvmware-cmd.bat', shell=True)",
   "body+mined:Baseline": "subprocess.call(['c:\\\\Program Files\\\\vmware\\\\VMware Server\\\\vmvmware-cmd.bat', shell=True)",
   "body+mined:-Code": "subprocess.call(['c:\\\\program files\\\\vmware\\\\VMware server\\\\mvmware-cmd.bat', shell=True)",
   "body+mined:-NL": "subprocess.call(['c:\\\\Program Files\\\\vmware\\\\n', '-l', 'vmware-cmd.bat'])",
   "body+mined:-Blocks": "subprocess.Popen([\n    'c:\\\\program files\\\\vmware\\\\VMware server\\\\vmWARE-cmd.bat', 'exec'],\n    shell=True)",
   "body+mined:-Inline": "subprocess.call(['c:\\\\Program Files/VMware\\\\VMware Server\\\\vmware-cmd.bat', shell=True)"
  },
  "snippet": "subprocess.Popen(['c:\\\\Program Files\\\\VMware\\\\VMware Server\\\\vmware-cmd.bat'])"
 },
 "26441253.365": {
  "intent": "reverse a priority queue `q` in python without using classes",
  "body": "I am just learning the priority queues in Python, and I have made the following code:\ndef main():\n    q=Queue.PriorityQueue()\n    while True:\n        n=input(\"numbre?\")\n        if n==0:\n            break\n        else:\n            q.put(n)\n            print n\n\nwhile not q.empty():\n        print q.get()\n\nwhen I input data like: 9, 1, 4, 5\nit prints 1,4,5,9 which it seems correct, but I would like to know how can I do to deque in reverse order, I mean: 9,5,4,1\nI know how to do that with a class, but in this case it seems the following extra code:\ndef __cmp__():\n        -cmp(q.get(),q.get())\n\ndoes not work, any help?\n",
  "preds": {
   "base:Baseline": "[(k, v) for k, v in queue.items()]",
   "body:Baseline": "Queue.PriorityQueue(Q).reset_index()",
   "body:-Blocks": "q.dequeue(key=operator.itemgetter(1))",
   "body:-Code": "q.reverse_queue(key=lambda x: x[1])",
   "body:-Inline": "queue.reverse_queue(q)",
   "body:-NL": "q.reverse_queue(0)",
   "base:+Mined": "priority_queue = queue.reverse(Q, reverse=True)",
   "body+mined:Baseline": "rdd.reverse(q, reverse=True)",
   "body+mined:-Code": "q.queue(reverse=True)",
   "body+mined:-NL": "Queue.PriorityQueue(queue_name, queue_name)",
   "body+mined:-Blocks": "q.queue(reverse=True)",
   "body+mined:-Inline": "queue.reverse_queue(q)"
  },
  "snippet": "q.put((-n, n))"
 },
 "18897261.366": {
  "intent": "make a barplot of data in column `group` of dataframe `df` colour-coded according to list `color`",
  "body": "I would like to use pandas to plot a barplot with diffrent colors for category in column.\nHere is a simple example: (index is variable)\ndf:\n         value   group\nvariable               \na             10      1\nb              9      1\nc              8      1\nd              7      2\nf              6      2\ng              5      3\nh              4      3\n\nI would like to make a barplot with coloring on group. I would also like to specify the colors. In my original dataset I have many goups.\nCould someone help me with this?\n",
  "preds": {
   "base:Baseline": "df.groupby(color='green')",
   "body:Baseline": "df.colour_coded_by='color')",
   "body:-Blocks": "df.group.colour_coded().barplot(index='color')",
   "body:-Code": "df.group.colour_coded('color')",
   "body:-Inline": "df.colour_coded().barplot(group='color')",
   "body:-NL": "df.group.colour_coded().barrier_by('color')",
   "base:+Mined": "df.groupby(['color']).plot(kind='bar')",
   "body+mined:Baseline": "df.group.color.diffrent('greyscale')",
   "body+mined:-Code": "df.groupby('color').plot(kind='bar')",
   "body+mined:-NL": "df.colour.pivot(index='group', columns='color', aggfunc='value', fill_value=0)",
   "body+mined:-Blocks": "df.groupby('color').plot(kind='bar')",
   "body+mined:-Inline": "df.colour_list('color')"
  },
  "snippet": "df['group'].plot(kind='bar', color=['r', 'g', 'b', 'r', 'g', 'b', 'r'])"
 },
 "373194.367": {
  "intent": "find all matches of regex pattern '([a-fa-f\\\\d]{32})' in string `data`",
  "body": "I've come up with:\nre.findall(\"([a-fA-F\\d]*)\", data)\n\nbut it's not very fool proof, is there a better way to grab all MD5-hash codes?\n",
  "preds": {
   "base:Baseline": "re.findall('([A-F\\\\d]{32})', data)",
   "body:Baseline": "re.findall('([a-fa-f\\\\d]{32})', data)",
   "body:-Blocks": "print(re.findall('([A-fa-f\\\\d]{32})', data))",
   "body:-Code": "print(re.findall('([A-fa-f\\\\d]{32})', data))",
   "body:-Inline": "re.findall('([a-fa-f\\\\d]{32})', data)",
   "body:-NL": "re.findall('([a-fa-f\\\\d]{32})', data)",
   "base:+Mined": "re.findall('([A-fa-f\\\\d]{32})', data)",
   "body+mined:Baseline": "re.findall('([a-fa-f\\\\d]{32})', data)",
   "body+mined:-Code": "re.findall('([A-fa-f\\\\d]{32})', data)",
   "body+mined:-NL": "re.findall('([a-fa-f\\\\d]{32})', data)",
   "body+mined:-Blocks": "re.findall('([A-fa-f\\\\d]{32})', data)",
   "body+mined:-Inline": "re.findall('([a-fa-f\\\\d]{32})', data)"
  },
  "snippet": "re.findall('([a-fA-F\\\\d]{32})', data)"
 },
 "518021.368": {
  "intent": "get the length of list `my_list`",
  "body": "In Python , is the following the only way to get the number of elements?\narr.__len__()\n\nIf so, why the strange syntax?\n",
  "preds": {
   "base:Baseline": "len(len(my_list))",
   "body:Baseline": "len(len(my_list))",
   "body:-Blocks": "len(len(my_list))",
   "body:-Code": "len(len(my_list))",
   "body:-Inline": "len(len(my_list))",
   "body:-NL": "len(my_list, 16)",
   "base:+Mined": "len(set(my_list))",
   "body+mined:Baseline": "len(my_list) - my_list",
   "body+mined:-Code": "len(my_list):\n    pass",
   "body+mined:-NL": "[len(my_list) for _ in range(length)]",
   "body+mined:-Blocks": "length = len(my_list)",
   "body+mined:-Inline": "len([x for x in my_list if x != 'len'])"
  },
  "snippet": "len(my_list)"
 },
 "518021.369": {
  "intent": "getting the length of array `l`",
  "body": "In Python , is the following the only way to get the number of elements?\narr.__len__()\n\nIf so, why the strange syntax?\n",
  "preds": {
   "base:Baseline": "len(l, len(l))",
   "body:Baseline": "len(L) == len(len(l))",
   "body:-Blocks": "len(len(l) + 1",
   "body:-Code": "len(l) + len(l))",
   "body:-Inline": "len(l) - L[::-1]",
   "body:-NL": "len(l) + L[::-1]",
   "base:+Mined": "L[len(l)) == len(l)",
   "body+mined:Baseline": "len(L) - len(l)",
   "body+mined:-Code": "len(L) - len(len(l))",
   "body+mined:-NL": "L[::-1].length()",
   "body+mined:-Blocks": "len(l) - len(l))",
   "body+mined:-Inline": "len([x for x in L])"
  },
  "snippet": "len(l)"
 },
 "518021.370": {
  "intent": "getting the length of array `s`",
  "body": "In Python , is the following the only way to get the number of elements?\narr.__len__()\n\nIf so, why the strange syntax?\n",
  "preds": {
   "base:Baseline": "np.len(s).sum()",
   "body:Baseline": "len(s, len(s))",
   "body:-Blocks": "len(s, len(s))",
   "body:-Code": "len(s, len(s))",
   "body:-Inline": "sum(len(s) for _ in range(0, len(s))",
   "body:-NL": "[len(s)) for s in range(0, len(s)]",
   "base:+Mined": "np.len(s), -1)",
   "body+mined:Baseline": "len([x for x in s if x not in s])",
   "body+mined:-Code": "len(s) - len(s - 1",
   "body+mined:-NL": "arr[::-1].length()",
   "body+mined:-Blocks": "len(s) - len(s))",
   "body+mined:-Inline": "len([x for x in s if x != 0])"
  },
  "snippet": "len(s)"
 },
 "518021.371": {
  "intent": "getting the length of `my_tuple`",
  "body": "In Python , is the following the only way to get the number of elements?\narr.__len__()\n\nIf so, why the strange syntax?\n",
  "preds": {
   "base:Baseline": "len(len(my_tuple))",
   "body:Baseline": "len(len(my_tuple))",
   "body:-Blocks": "len(len(my_tuple))",
   "body:-Code": "len(len(my_tuple))",
   "body:-Inline": "len(len(my_tuple))",
   "body:-NL": "len(my_tuple, 16)",
   "base:+Mined": "len(my_tuple):\n    pass",
   "body+mined:Baseline": "len(len(my_tuple))",
   "body+mined:-Code": "len(my_tuple) - 1",
   "body+mined:-NL": "len(my_tuple) - len(my-tuple))",
   "body+mined:-Blocks": "sum(len(my_tuple))",
   "body+mined:-Inline": "len(arr) - my_tuple[::-1]"
  },
  "snippet": "len(my_tuple)"
 },
 "518021.372": {
  "intent": "getting the length of `my_string`",
  "body": "In Python , is the following the only way to get the number of elements?\narr.__len__()\n\nIf so, why the strange syntax?\n",
  "preds": {
   "base:Baseline": "len(len(my_string))",
   "body:Baseline": "len(len(my_string))",
   "body:-Blocks": "len(len(my_string))",
   "body:-Code": "len(len(my_string))",
   "body:-Inline": "len(len(my_string))",
   "body:-NL": "len(my_string).__len__()",
   "base:+Mined": "len(my_string):\n    pass",
   "body+mined:Baseline": "len(my_string) - my_string",
   "body+mined:-Code": "len(my_string):\n    pass",
   "body+mined:-NL": "print(len(my_string))",
   "body+mined:-Blocks": "len(my_string) - len(my - string)",
   "body+mined:-Inline": "len(arr) - my_string"
  },
  "snippet": "len(my_string)"
 },
 "40452956.373": {
  "intent": "remove escape character from string \"\\\\a\"",
  "body": "I would like to turn this string:\na = '\\\\a'\n\ninto this one \nb = '\\a'\n\nIt doesn't seem like there is an obvious way to do this with replace ?\nEDIT: To be more precise, I want to change the escaping of the backslash to escape the character a\n",
  "preds": {
   "base:Baseline": "re.sub('\\\\a', '\\\\a')",
   "body:Baseline": "a = '\\\\a'.replace('\\\\a', '')",
   "body:-Blocks": "re.sub('\\\\a', '\\\\a')",
   "body:-Code": "re.sub('\\\\A', '\\\\A')",
   "body:-Inline": "\"\"\"\\\\a\"\"\".encode('escape')",
   "body:-NL": "\"\"\"\\\\a\"\"\".encode('escape')",
   "base:+Mined": "re.sub('\\\\a', '', '\\\\a')",
   "body+mined:Baseline": "a.replace('\\\\a', '')",
   "body+mined:-Code": "\"\"\"\\\\a\"\"\".replace('\\\\', '')",
   "body+mined:-NL": "a.replace('\\\\a', '')",
   "body+mined:-Blocks": "a.replace('\\\\A', '')",
   "body+mined:-Inline": "\"\"\"\\\\a\"\"\".encode('ascii', 'ignore')"
  },
  "snippet": "\"\"\"\\\\a\"\"\".decode('string_escape')"
 },
 "8687018.374": {
  "intent": "replace each 'a' with 'b' and each 'b' with 'a' in the string 'obama' in a single pass.",
  "body": "Say I have a string, \"ab\" .\nI want to replace \"a\"  with \"b\"  and \"b\"  with \"a\"  in one swoop.\nSo in the end, the string should be \"ba\"  and not \"aa\"  or \"bb\"  and not use more than one line. Is this doable?\n",
  "preds": {
   "base:Baseline": "\"\"\"obama\"\"\".replace('a', 'b', 'a')",
   "body:Baseline": "obama.replace('a', 'b', 'a')",
   "body:-Blocks": "\"\"\"obama\"\"\".replace('a', 'b', 'a')",
   "body:-Code": "\"\"\"obama\"\"\".replace('a', 'b')",
   "body:-Inline": "\"\"\"obama\"\"\".replace('a', 'b', 'a')",
   "body:-NL": "\"\"\"\"\"\".join(['a', 'b'], 'a' in 'b')",
   "base:+Mined": "\"\"\"\"\"\".join(['a', 'b', 'a'])",
   "body+mined:Baseline": "\"\"\"a\"\"\".replace('a', 'b', 'a')",
   "body+mined:-Code": "\"\"\"obama\"\"\".replace('a', 'b', 'a')",
   "body+mined:-NL": "\"\"\"ab\"\"\".replace('a', 'b', 'a')",
   "body+mined:-Blocks": "\"\"\"obama\"\"\".replace('a', 'b', 'a')",
   "body+mined:-Inline": "\"\"\"\"\"\".join(['a', 'b'], ['b', 'a'])"
  },
  "snippet": "\"\"\"obama\"\"\".replace('a', '%temp%').replace('b', 'a').replace('%temp%', 'b')"
 },
 "303200.375": {
  "intent": "remove directory tree '/folder_name'",
  "body": "I am getting an 'access is denied' error when I attempt to delete a folder that is not empty. I used the following command in my attempt: os.remove(\"/folder_name\") . \nWhat is the most effective way of removing/deleting a folder/directory that is not empty?\n",
  "preds": {
   "base:Baseline": "os.path.realpath('/folder_name')",
   "body:Baseline": "os.remove('/folder_name')",
   "body:-Blocks": "os.pop('/folder_name')",
   "body:-Code": "os.path.remove('/folder_name')",
   "body:-Inline": "os.path.remove_folder('folder_name')",
   "body:-NL": "os.remove('/folder_name')",
   "base:+Mined": "os.chdir('/folder_name')",
   "body+mined:Baseline": "os.remove('/folder_name')",
   "body+mined:-Code": "os.path.exists('/folder_name')",
   "body+mined:-NL": "os.path.expanduser('/folder_name')",
   "body+mined:-Blocks": "os.remove('/folder_name')",
   "body+mined:-Inline": "os.path.exists('/folder_name')"
  },
  "snippet": "shutil.rmtree('/folder_name')"
 },
 "13740672.376": {
  "intent": "create a new column `weekday` in pandas data frame `data` based on the values in column `my_dt`",
  "body": "I'd like to filter out weekend data and only look at data for weekdays (mon(0)-fri(4)).  I'm new to pandas, what's the best way to accomplish this in pandas?\nimport datetime\nfrom pandas import *\n\ndata = read_csv(\"data.csv\")\ndata.my_dt \n\n<console_out>\n0     2012-10-01 02:00:39\n1     2012-10-01 02:00:38\n2     2012-10-01 02:01:05\n3     2012-10-01 02:01:07\n4     2012-10-01 02:02:03\n5     2012-10-01 02:02:09\n6     2012-10-01 02:02:03\n7     2012-10-01 02:02:35\n8     2012-10-01 02:02:33\n9     2012-10-01 02:03:01\n10    2012-10-01 02:08:53\n11    2012-10-01 02:09:04\n12    2012-10-01 02:09:09\n13    2012-10-01 02:10:20\n14    2012-10-01 02:10:45\n<console_out>\n\nI'd like to do something like:\nweekdays_only = data[data.my_dt.weekday() < 5]\n\nAttributeError: 'numpy.int64' object has no attribute 'weekday'\nbut this doesn't work, I haven't quite grasped how column datetime objects are accessed.\nThe eventual goal being to arrange hierarchically to weekday hour-range, something like:\nmonday, 0-6, 7-12, 13-18, 19-23\ntuesday, 0-6, 7-12, 13-18, 19-23\n\n",
  "preds": {
   "base:Baseline": "pd.concat([data['weekday'], axis=1)",
   "body:Baseline": "pd.merge(df['weekday'], axis=1)",
   "body:-Blocks": "df['weekday'] = df['My_dt'].strftime('%B')",
   "body:-Code": "pd.concat([data['weekday'], axis=1)",
   "body:-Inline": "pd.concat([data.my_dt.weekday()], axis=1)",
   "body:-NL": "pd.concat([data.my_dt.weekday()], axis=1)",
   "base:+Mined": "pd.concat([df['weekday'], axis=1)",
   "body+mined:Baseline": "df['weekday'].str[0]",
   "body+mined:-Code": "pd.to_datetime(data['my_dt'], how='weekday')",
   "body+mined:-NL": "df['weekday'].apply(lambda x: x.dt.weekday() < 5).astype(float)",
   "body+mined:-Blocks": "data['weekday'].apply(lambda x: datetime.datetime.weekday(x['my_dt'])",
   "body+mined:-Inline": "df['weekday'].apply(lambda x: x.weekday() < 5).astype(float)"
  },
  "snippet": "data['weekday'] = data['my_dt'].apply(lambda x: x.weekday())"
 },
 "20950650.377": {
  "intent": "reverse sort counter `x` by values",
  "body": "Other than doing list comprehensions of reversed list comprehension, is there a pythonic way to sort Counter by value? If so, it is faster than this:\nfrom collections import Counter\nx = Counter({'a':5, 'b':3, 'c':7})\nsorted(x)\n['a', 'b', 'c']\nsorted(x.items())\n[('a', 5), ('b', 3), ('c', 7)]\n[(l,k) for k,l in sorted([(j,i) for i,j in x.items()])]\n[('b', 3), ('a', 5), ('c', 7)]\n[(l,k) for k,l in sorted([(j,i) for i,j in x.items()], reverse=True)]\n[('c', 7), ('a', 5), ('b', 3)\n\n",
  "preds": {
   "base:Baseline": "sorted(x, key=lambda x: x[1])",
   "body:Baseline": "sorted(x, key=lambda x: reverse=True)",
   "body:-Blocks": "sorted(x, key=lambda x: x[1])",
   "body:-Code": "sorted(x, key=operator.itemgetter(x))",
   "body:-Inline": "x.sort(key=lambda x: reverse=True)",
   "body:-NL": "sorted(x, key=lambda x: reverse=True)",
   "base:+Mined": "sorted(x, key=lambda x: x[1])",
   "body+mined:Baseline": "sorted(x, reverse=True)",
   "body+mined:-Code": "sorted(x, key=lambda x: x[1])",
   "body+mined:-NL": "sorted(Counter({'a': 5, 'b': 3, 'c': 7}, reverse=True)",
   "body+mined:-Blocks": "sorted(x, key=Counter.get)",
   "body+mined:-Inline": "sorted(x, key=lambda x: reverse=True)"
  },
  "snippet": "sorted(x, key=x.get, reverse=True)"
 },
 "20950650.378": {
  "intent": "reverse sort counter `x` by value",
  "body": "Other than doing list comprehensions of reversed list comprehension, is there a pythonic way to sort Counter by value? If so, it is faster than this:\nfrom collections import Counter\nx = Counter({'a':5, 'b':3, 'c':7})\nsorted(x)\n['a', 'b', 'c']\nsorted(x.items())\n[('a', 5), ('b', 3), ('c', 7)]\n[(l,k) for k,l in sorted([(j,i) for i,j in x.items()])]\n[('b', 3), ('a', 5), ('c', 7)]\n[(l,k) for k,l in sorted([(j,i) for i,j in x.items()], reverse=True)]\n[('c', 7), ('a', 5), ('b', 3)\n\n",
  "preds": {
   "base:Baseline": "sorted(x, key=lambda x: x[1])",
   "body:Baseline": "sorted(x, key=lambda x: reverse=True)",
   "body:-Blocks": "sorted(x, key=lambda x: x[1])",
   "body:-Code": "sorted(x, key=operator.itemgetter(x))",
   "body:-Inline": "x.sort(key=lambda x: reverse=True)",
   "body:-NL": "sorted(x, key=lambda x: reverse=True)",
   "base:+Mined": "sorted(x, key=lambda x: x[1])",
   "body+mined:Baseline": "sorted(x, reverse=True)",
   "body+mined:-Code": "sorted(x, key=lambda x: x[1])",
   "body+mined:-NL": "sorted(Counter({'a': 5, 'b': 3, 'c': 7})",
   "body+mined:-Blocks": "sorted(x, key=Counter.get)",
   "body+mined:-Inline": "sorted(x, key=lambda x: reverse=True)"
  },
  "snippet": "sorted(list(x.items()), key=lambda pair: pair[1], reverse=True)"
 },
 "9775297.379": {
  "intent": "append a numpy array 'b' to a numpy array 'a'",
  "body": "I have a numpy_array. Something like [ a b c ] .\nAnd then I want to concatenate it with another NumPy array (just like we create a list of lists). How do we create a NumPy array containing NumPy arrays?\nI tried to do the following without any luck\nM = np.array([])\nM\narray([], dtype=float64)\nM.append(a,axis=0)\nTraceback (most recent call last):\n File \" <stdin>\", line 1, in <module>\nAttributeError: 'numpy.ndarray' object has no attribute 'append'\na\narray([1, 2, 3])\n\n",
  "preds": {
   "base:Baseline": "a.append(b, a)",
   "body:Baseline": "numpy.ndarray(a, axis=0)",
   "body:-Blocks": "a = np.array([a, b])",
   "body:-Code": "np.array([a, b])",
   "body:-Inline": "M.append(a, axis=0)",
   "body:-NL": "M.append(a, axis=0)",
   "base:+Mined": "a.append(b, a)",
   "body+mined:Baseline": "M = np.array([1, 2, 3])",
   "body+mined:-Code": "np.concatenate((a, b))",
   "body+mined:-NL": "M = np.append(a, dtype=float64)",
   "body+mined:-Blocks": "a.append(b, axis=1)",
   "body+mined:-Inline": "numpy.ndarray([1, 2, 3])"
  },
  "snippet": "np.vstack((a, b))"
 },
 "21887754.380": {
  "intent": "numpy concatenate two arrays `a` and `b` along the first axis",
  "body": "I tried the following:\na = np.array([1,2,3])\nb = np.array([4,5,6])\nnp.concatenate((a,b), axis=0)\narray([1, 2, 3, 4, 5, 6])\nnp.concatenate((a,b), axis=1)\narray([1, 2, 3, 4, 5, 6])\n\nHowever, I'd expect at least that one result looks like this\narray([[1, 2, 3],\n       [4, 5, 6]])\n\nWhy is it not concatenated vertically?\n",
  "preds": {
   "base:Baseline": "numpy.concat([a, b])",
   "body:Baseline": "np.concatenate((a, b), axis=1)",
   "body:-Blocks": "numpy.concat([a, b])",
   "body:-Code": "numpy.concat([a, b])",
   "body:-Inline": "np.concatenate(a, b), axis=1)",
   "body:-NL": "np.concatenate((a, b), axis=1)",
   "base:+Mined": "np.concatenate((a, b), axis=1)",
   "body+mined:Baseline": "np.concatenate((a, b), axis=1)",
   "body+mined:-Code": "np.concatenate(a, b), axis=1)",
   "body+mined:-NL": "np.concatenate((a, b), axis=1)",
   "body+mined:-Blocks": "np.concatenate(a, b, axis=0)",
   "body+mined:-Inline": "np.concatenate((a, b), axis=1)"
  },
  "snippet": "print(concatenate((a, b), axis=0))"
 },
 "21887754.381": {
  "intent": "numpy concatenate two arrays `a` and `b` along the second axis",
  "body": "I tried the following:\na = np.array([1,2,3])\nb = np.array([4,5,6])\nnp.concatenate((a,b), axis=0)\narray([1, 2, 3, 4, 5, 6])\nnp.concatenate((a,b), axis=1)\narray([1, 2, 3, 4, 5, 6])\n\nHowever, I'd expect at least that one result looks like this\narray([[1, 2, 3],\n       [4, 5, 6]])\n\nWhy is it not concatenated vertically?\n",
  "preds": {
   "base:Baseline": "numpy.concat([a, b])",
   "body:Baseline": "np.concatenate((a, b), axis=1)",
   "body:-Blocks": "numpy.concat([a, b])",
   "body:-Code": "numpy.concat([a, b])",
   "body:-Inline": "np.concatenate(a, b), axis=1)",
   "body:-NL": "np.concatenate((a, b), axis=1)",
   "base:+Mined": "np.concatenate((a, b), axis=1)",
   "body+mined:Baseline": "np.concatenate((a, b), axis=1)",
   "body+mined:-Code": "np.concatenate(a, b), axis=1)",
   "body+mined:-NL": "np.concatenate((a, b), axis=1)",
   "body+mined:-Blocks": "np.concatenate(a, b, axis=1)",
   "body+mined:-Inline": "np.concatenate((a, b), axis=1)"
  },
  "snippet": "print(concatenate((a, b), axis=1))"
 },
 "21887754.382": {
  "intent": "numpy concatenate two arrays `a` and `b` along the first axis",
  "body": "I tried the following:\na = np.array([1,2,3])\nb = np.array([4,5,6])\nnp.concatenate((a,b), axis=0)\narray([1, 2, 3, 4, 5, 6])\nnp.concatenate((a,b), axis=1)\narray([1, 2, 3, 4, 5, 6])\n\nHowever, I'd expect at least that one result looks like this\narray([[1, 2, 3],\n       [4, 5, 6]])\n\nWhy is it not concatenated vertically?\n",
  "preds": {
   "base:Baseline": "numpy.concat([a, b])",
   "body:Baseline": "np.concatenate((a, b), axis=1)",
   "body:-Blocks": "numpy.concat([a, b])",
   "body:-Code": "numpy.concat([a, b])",
   "body:-Inline": "np.concatenate(a, b), axis=1)",
   "body:-NL": "np.concatenate((a, b), axis=1)",
   "base:+Mined": "np.concatenate((a, b), axis=1)",
   "body+mined:Baseline": "np.concatenate((a, b), axis=1)",
   "body+mined:-Code": "np.concatenate(a, b), axis=1)",
   "body+mined:-NL": "np.concatenate((a, b), axis=1)",
   "body+mined:-Blocks": "np.concatenate(a, b, axis=0)",
   "body+mined:-Inline": "np.concatenate((a, b), axis=1)"
  },
  "snippet": "c = np.r_[a[(None), :], b[(None), :]]"
 },
 "21887754.383": {
  "intent": "numpy concatenate two arrays `a` and `b` along the first axis",
  "body": "I tried the following:\na = np.array([1,2,3])\nb = np.array([4,5,6])\nnp.concatenate((a,b), axis=0)\narray([1, 2, 3, 4, 5, 6])\nnp.concatenate((a,b), axis=1)\narray([1, 2, 3, 4, 5, 6])\n\nHowever, I'd expect at least that one result looks like this\narray([[1, 2, 3],\n       [4, 5, 6]])\n\nWhy is it not concatenated vertically?\n",
  "preds": {
   "base:Baseline": "numpy.concat([a, b])",
   "body:Baseline": "np.concatenate((a, b), axis=1)",
   "body:-Blocks": "numpy.concat([a, b])",
   "body:-Code": "numpy.concat([a, b])",
   "body:-Inline": "np.concatenate(a, b), axis=1)",
   "body:-NL": "np.concatenate((a, b), axis=1)",
   "base:+Mined": "np.concatenate((a, b), axis=1)",
   "body+mined:Baseline": "np.concatenate((a, b), axis=1)",
   "body+mined:-Code": "np.concatenate(a, b), axis=1)",
   "body+mined:-NL": "np.concatenate((a, b), axis=1)",
   "body+mined:-Blocks": "np.concatenate(a, b, axis=0)",
   "body+mined:-Inline": "np.concatenate((a, b), axis=1)"
  },
  "snippet": "np.array((a, b))"
 },
 "2805231.384": {
  "intent": "fetch address information for host 'google.com' ion port 80",
  "body": "dnspython  will do my DNS lookups very nicely, but it entirely ignores the contents of /etc/hosts .\nIs there a python library call which will do the right thing? ie check first in etc/hosts , and only fall back to DNS lookups otherwise?\n",
  "preds": {
   "base:Baseline": "fetch('google.com', port=80)",
   "body:Baseline": "dnspython.findall('google.com', 80)",
   "body:-Blocks": "dnspython.find('google.com', port=80)",
   "body:-Code": "fetch('google.com', port 80)",
   "body:-Inline": "fetch('google.com', port 80)",
   "body:-NL": "fetch('google.com', shell=True)",
   "base:+Mined": "server.serve_forever()",
   "body+mined:Baseline": "dnspython.fetchhostname('google.com', port 80)",
   "body+mined:-Code": "fetch('google.com', port 80)",
   "body+mined:-NL": "os.environ['google.com'][0]",
   "body+mined:-Blocks": "fetchaddr('google.com', 80)",
   "body+mined:-Inline": "print(os.environ['google.com'][0]))"
  },
  "snippet": "print(socket.getaddrinfo('google.com', 80))"
 },
 "17552997.385": {
  "intent": "add a column 'day' with value 'sat' to dataframe `df`",
  "body": "I'm using a MultiIndexed pandas DataFrame and would like to multiply a subset of the DataFrame by a certain number.\nIt's the same as this  but with a MultiIndex.\nd = pd.DataFrame({'year':[2008,2008,2008,2008,2009,2009,2009,2009], \n                     'flavour':['strawberry','strawberry','banana','banana',\n                      'strawberry','strawberry','banana','banana'],\n                      'day':['sat','sun','sat','sun','sat','sun','sat','sun'],\n                      'sales':[10,12,22,23,11,13,23,24]})\n\nd = d.set_index(['year','flavour','day'])                  \n\nd\n                    sales\nyear flavour    day       \n2008 strawberry sat     10\n                sun     12\n     banana     sat     22\n                sun     23\n2009 strawberry sat     11\n                sun     13\n     banana     sat     23\n                sun     24\n\nSo far, so good. But let's say I spot that all the Saturday figures are only half what they should be! I'd like to multiply all sat  sales by 2.\nMy first attempt at this was:\nsat = d.xs('sat', level='day')\nsat = sat * 2\nd.update(sat)\n\nbut this doesn't work because the variable sat  has lost the day  level of the index:\nsat\n                sales\nyear flavour          \n2008 strawberry     20\n     banana         44\n2009 strawberry     22\n     banana         46\n\nso pandas doesn't know how to join the new sales figures back onto the old dataframe.\nI had a quick stab at:\nsat = d.xs('sat', level='day', copy=False)\nTraceback (most recent call last):\n  File \" <stdin>\", line 1, in <module>\n  File \"C:\\Python27\\lib\\site-packages\\pandas\\core\\frame.py\", line 2248, in xs\n    raise ValueError('Cannot retrieve view (copy=False)')\nValueError: Cannot retrieve view (copy=False)\n\nI have no idea what that error means, but I feel like I'm making a mountain out of a molehill. Does anyone know the right way to do this?\nThanks in advance,\nRob\n",
  "preds": {
   "base:Baseline": "df['Day'].strftime('sat')",
   "body:Baseline": "df['day'].set_index(['sat'])",
   "body:-Blocks": "df['Day'].strftime('sat')",
   "body:-Code": "df['Day'].strftime('sat')",
   "body:-Inline": "df.set_index(['day', 'sat'])",
   "body:-NL": "df['day'] = df['sat', level='day')",
   "base:+Mined": "df['day'] = df['sat'].astype(float)",
   "body+mined:Baseline": "df.ix['day'].apply(lambda x: x.strftime('sat'))",
   "body+mined:-Code": "df['Sales'].fillna(0)",
   "body+mined:-NL": "df['day'] = df['year'].apply(lambda x: x['day'], axis=1)",
   "body+mined:-Blocks": "df.ix[(df.index.day == 2).sum()]",
   "body+mined:-Inline": "df.loc[df['day'].isin(['year', 'day'])]"
  },
  "snippet": "df.xs('sat', level='day', drop_level=False)"
 },
 "4356842.386": {
  "intent": "return a 401 unauthorized in django",
  "body": "Instead of doing this:\nres = HttpResponse(\"Unauthorized\")\nres.status_code = 401\nreturn res\n\nIs there a way to do it without typing it every time?\n",
  "preds": {
   "base:Baseline": "return a 401(0, 1)",
   "body:Baseline": "res.status_code = 401 unauthorized)",
   "body:-Blocks": "return (401)(None)\nreturn (401)()",
   "body:-Code": "return (401)(expand=False)",
   "body:-Inline": "res = HttpResponse('Unauthorized')",
   "body:-NL": "res.Response('Unauthorized')",
   "base:+Mined": "return HttpResponse(status=401, error=False)",
   "body+mined:Baseline": "return HttpResponse('Unauthorized')",
   "body+mined:-Code": "return super(MyModel, self).save(*args, **kwargs)",
   "body+mined:-NL": "return HttpResponse('Unauthorized')",
   "body+mined:-Blocks": "return HttpResponse(status=401)",
   "body+mined:-Inline": "return HttpResponse('Unauthorized', 401)"
  },
  "snippet": "return HttpResponse('Unauthorized', status=401)"
 },
 "13598363.387": {
  "intent": "flask set folder 'wherever' as the default template folder",
  "body": "By default flask uses template files stored in \"template\" directory :\n/flaskapp\n    /application.py\n    /templates\n        /hello.html\n\nIs there any way to dynamically choose template directory according to user logged in? This is how I want the directory structure to be :\n/flaskapp\n    /application.py\n    /templates (default template goes here)\n        /hello.html\n    /userdata\n        /user1\n            /template1\n                 hello.html\n            /template2\n                 hello.html\n        /user2\n            /template1\n                 hello.html\n            /template2\n                 hello.html\n\nNow if I have the username of logged in user and the name of template activated by user, is it possible to dynamically select the directory to load template files? For example, \n/userdata/ <username>/ <activated template name>/\n\ninstead of fixed\n/templates/\n\nWhat I am trying to achieve is a wordpress like theme system for my web application where users can upload/select themes for his website.\n",
  "preds": {
   "base:Baseline": "flask.set_folder('wherever')",
   "body:Baseline": "flaskapp.set_default_folder('wherever')",
   "body:-Blocks": "flask.set_folder('wherever')",
   "body:-Code": "flask.set_folder('wherever')",
   "body:-Inline": "flaskapp.set_folder('wherever')",
   "body:-NL": "flask.set_folder('wherever')",
   "base:+Mined": "app.run(host='wherever')",
   "body+mined:Baseline": "app.config['wherever'] = os.path.expanduser('template')",
   "body+mined:-Code": "app.run(host='wherever')",
   "body+mined:-NL": "os.path.expanduser('wherever')",
   "body+mined:-Blocks": "app.run(host='wherever')",
   "body+mined:-Inline": "app.run(folder='wherever')"
  },
  "snippet": "Flask(__name__, template_folder='wherever')"
 },
 "1849375.388": {
  "intent": "how do i insert into t1 (select * from t2) in sqlalchemy?",
  "body": "In SQLAlchemy, how do I populate or update a table from a SELECT  statement?\n",
  "preds": {
   "base:Baseline": "driver.find_element_by_xpath('select * from t2')",
   "body:Baseline": "sqlAlchemy.insert(select * FROM t2))",
   "body:-Blocks": "cursor.execute('INSERT INTO t1, SELECT * FROM t2')",
   "body:-Code": "del table(select * from t2))",
   "body:-Inline": "print([item[0] for item in t1 if item[2] not in t2])",
   "body:-NL": "[(select * from t2) for sublist in sqlalchemy]",
   "base:+Mined": "session.query(select * FROM t2)",
   "body+mined:Baseline": "cursor.execute('SELECT * FROM t2')",
   "body+mined:-Code": "print(engine.execute('SELECT * FROM t2')",
   "body+mined:-NL": "cursor.execute('SELECT * FROM t2')",
   "body+mined:-Blocks": "session.query('select * from t2')",
   "body+mined:-Inline": "session.query(select([1, 2, 3], [4, 5, 6]]))"
  },
  "snippet": "session.execute('INSERT INTO t1 (SELECT * FROM t2)')"
 },
 "3398589.389": {
  "intent": "sort a list of lists 'c2' such that third row comes first",
  "body": "c2=[]\nrow1=[1,22,53]\nrow2=[14,25,46]\nrow3=[7,8,9]\n\nc2.append(row2)\nc2.append(row1)\nc2.append(row3)\n\nc2  is now:\n[[14, 25, 46], [1, 22, 53], [7, 8, 9]]\n\nhow do i sort c2  in such a way that for example:\nfor row in c2:\n\nsort on row[2]\n\nthe result would be:\n[[7,8,9],[14,25,46],[1,22,53]]\n\nthe other question is how do i first sort by row[2] and within that set by row[1]\n",
  "preds": {
   "base:Baseline": "sorted(c2, key=lambda x: x[1])",
   "body:Baseline": "sorted(list(c2.items()), key=lambda x: x[2], reverse=True)",
   "body:-Blocks": "sorted(list(c2, key=lambda x: x[1])",
   "body:-Code": "sorted(c2, key=lambda x: x[2])",
   "body:-Inline": "sorted(list(c2.items()), key=lambda x: x[1])",
   "body:-NL": "sorted(c2, key=lambda x: x[1])",
   "base:+Mined": "sorted(c2, key=lambda x: x[1])",
   "body+mined:Baseline": "sorted(c2, key=lambda x: x[2], reverse=True)",
   "body+mined:-Code": "sorted(c2, key=lambda row: row[1])",
   "body+mined:-NL": "c2.sort(key=lambda x: x[1])",
   "body+mined:-Blocks": "sorted(c2, key=lambda row: (row[1], row[2]))",
   "body+mined:-Inline": "sorted(c2, key=lambda x: (x[2], x[3]))"
  },
  "snippet": "c2.sort(key=lambda row: row[2])"
 },
 "3398589.390": {
  "intent": "sorting a list of lists in python",
  "body": "c2=[]\nrow1=[1,22,53]\nrow2=[14,25,46]\nrow3=[7,8,9]\n\nc2.append(row2)\nc2.append(row1)\nc2.append(row3)\n\nc2  is now:\n[[14, 25, 46], [1, 22, 53], [7, 8, 9]]\n\nhow do i sort c2  in such a way that for example:\nfor row in c2:\n\nsort on row[2]\n\nthe result would be:\n[[7,8,9],[14,25,46],[1,22,53]]\n\nthe other question is how do i first sort by row[2] and within that set by row[1]\n",
  "preds": {
   "base:Baseline": "sorted(list, key=lambda x: x[1])",
   "body:Baseline": "sorted(list(c2.items()), key=lambda x: x[1], reverse=True)",
   "body:-Blocks": "sorted(list, key=lambda x: x[1])",
   "body:-Code": "sorted(list, key=lambda x: x[1])",
   "body:-Inline": "sorted(list(range(1)), key=lambda x: x[1])",
   "body:-NL": "sorted(list(c2.items()), key=lambda x: x[1])",
   "base:+Mined": "sorted(lst, key=lambda x: x[1])",
   "body+mined:Baseline": "c2.sort(key=lambda x: x[2])",
   "body+mined:-Code": "sorted(a, key=lambda x: x[1])",
   "body+mined:-NL": "c2.sort(key=lambda x: x[1])",
   "body+mined:-Blocks": "sorted(c2, key=lambda x: (x[1], x[1]))",
   "body+mined:-Inline": "sorted(c2, key=lambda x: (x[2], x[1]))"
  },
  "snippet": "c2.sort(key=lambda row: (row[2], row[1], row[0]))"
 },
 "3398589.391": {
  "intent": "sorting a list of lists in python",
  "body": "c2=[]\nrow1=[1,22,53]\nrow2=[14,25,46]\nrow3=[7,8,9]\n\nc2.append(row2)\nc2.append(row1)\nc2.append(row3)\n\nc2  is now:\n[[14, 25, 46], [1, 22, 53], [7, 8, 9]]\n\nhow do i sort c2  in such a way that for example:\nfor row in c2:\n\nsort on row[2]\n\nthe result would be:\n[[7,8,9],[14,25,46],[1,22,53]]\n\nthe other question is how do i first sort by row[2] and within that set by row[1]\n",
  "preds": {
   "base:Baseline": "sorted(list, key=lambda x: x[1])",
   "body:Baseline": "sorted(list(c2.items()), key=lambda x: x[1], reverse=True)",
   "body:-Blocks": "sorted(list, key=lambda x: x[1])",
   "body:-Code": "sorted(list, key=lambda x: x[1])",
   "body:-Inline": "sorted(list(range(1)), key=lambda x: x[1])",
   "body:-NL": "sorted(list(c2.items()), key=lambda x: x[1])",
   "base:+Mined": "sorted(lst, key=lambda x: x[1])",
   "body+mined:Baseline": "c2.sort(key=lambda x: x[2])",
   "body+mined:-Code": "sorted(a, key=lambda x: x[1])",
   "body+mined:-NL": "c2.sort(key=lambda x: x[1])",
   "body+mined:-Blocks": "sorted(c2, key=lambda x: (x[1], x[1]))",
   "body+mined:-Inline": "sorted(c2, key=lambda x: (x[2], x[1]))"
  },
  "snippet": "c2.sort(key=lambda row: (row[2], row[1]))"
 },
 "10960463.392": {
  "intent": "set font `arial` to display non-ascii characters in matplotlib",
  "body": "I have a problem displaying non- ASCII  characters in Matplotlib, these characters are rendered as small boxes instead of a proper font, it looks like (I filled these boxes with red paint to hightlight them): \n\nHow do I fix it? \nA related question is Accented characters in Matplotlib .\n",
  "preds": {
   "base:Baseline": "ax.set_font('arial')",
   "body:Baseline": "matplotlib.set_font('arial')",
   "body:-Blocks": "ax.set_font('arial')",
   "body:-Code": "matplotlib.set_font('arial')",
   "body:-Inline": "matplotlib.set_font('arial')",
   "body:-NL": "arial.set_font('ignore')",
   "base:+Mined": "plt.savefig('arial.png')",
   "body+mined:Baseline": "matplotlib.use('font', 'arial')",
   "body+mined:-Code": "matplotlib.rcParams.set_face(arial)",
   "body+mined:-NL": "ax.set_font('arial')",
   "body+mined:-Blocks": "matplotlib.rcParams.set_xlabel('arial')",
   "body+mined:-Inline": "matplotlib.set_xticklabels(arial)"
  },
  "snippet": "matplotlib.rc('font', **{'sans-serif': 'Arial', 'family': 'sans-serif'})"
 },
 "20576618.393": {
  "intent": "convert  datetime column 'date' of pandas dataframe 'df' to ordinal",
  "body": "I'm trying to create a new Pandas dataframe column with ordinal day from a datetime column:\nimport pandas as pd\nfrom datetime import datetime\n\nprint df.ix[0:5]\n                              date\nfile                              \ngom3_197801.nc 2011-02-16 00:00:00\ngom3_197802.nc 2011-02-16 00:00:00\ngom3_197803.nc 2011-02-15 00:00:00\ngom3_197804.nc 2011-02-17 00:00:00\ngom3_197805.nc 2011-11-14 00:00:00\n\ndf['date'][0].toordinal()\n\n<console_out>\n734184\n\ndf['date'].toordinal()\n\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\n<ipython-input-7-dbfd5e8b60f0> in <module>()\n----> 1 df['date'].toordinal()\n\nAttributeError: 'Series' object has no attribute 'toordinal'\n\nI guess this is a basic question, but I've struggled reading docs for last 30 minutes. \nHow can I create an ordinal time column for my dataframe?\n",
  "preds": {
   "base:Baseline": "df['date'].strftime('%Y')",
   "body:Baseline": "df['date'].toordinal()",
   "body:-Blocks": "df['date'].strftime('%B')",
   "body:-Code": "df['Date'] = df['OrderedDay']",
   "body:-Inline": "df['date'].toordinal()",
   "body:-NL": "df['date'].toordinal()",
   "base:+Mined": "df['Date'].astype('int')",
   "body+mined:Baseline": "df['date'].toordinal()",
   "body+mined:-Code": "df['date'] = df['date'].astype('OrderedDict')",
   "body+mined:-NL": "df['date'].toordinal()",
   "body+mined:-Blocks": "df['date'] = df['date'].astype(' ordinal')",
   "body+mined:-Inline": "df['date'].toordinal()"
  },
  "snippet": "df['date'].apply(lambda x: x.toordinal())"
 },
 "7263824.394": {
  "intent": "get html source of selenium webelement `element`",
  "body": "I'm using the Python bindings to run Selenium WebDriver:\nfrom selenium import webdriver\nwd = webdriver.Firefox()\n\nI know I can grab a webelement like so:\nelem = wd.find_element_by_css_selector('#my-id')\n\nAnd I know I can get the full page source with...\nwd.page_source\n\nBut is there a way to get the \"element source\"?\nelem.source   # <-- returns the HTML as a string\n\nThe Selenium WebDriver documentation for Python are basically non-existent and I don't see anything in the code that seems to enable that functionality.\nWhat is the best way to access the HTML of an element (and its children)?\n",
  "preds": {
   "base:Baseline": "element.find_element_by_css_id()",
   "body:Baseline": "webbrowser.find_element_by_css_selector('#my-id')",
   "body:-Blocks": "driver.find_element_source(element)",
   "body:-Code": "driver.find_element_by_css_selector(element)",
   "body:-Inline": "webbrowser.find_element(element)",
   "body:-NL": "wd.find_element_by_css_selector('#my-id')",
   "base:+Mined": "element = webdriver.find_element_by_css_selector(\"//div[@class='class']\"\n    ).find_elements()",
   "body+mined:Baseline": "element = webdriver.get('http://www.google.com')",
   "body+mined:-Code": "print(element.find('http://www.google.com').read())",
   "body+mined:-NL": "webbrowser.find_element_by_css_selector('#my-id')",
   "body+mined:-Blocks": "driver.get('http://stackoverflow.com')",
   "body+mined:-Inline": "element = driver.get('http://stackoverflow.com')"
  },
  "snippet": "element.get_attribute('innerHTML')"
 },
 "31793195.395": {
  "intent": "get the integer location of a key `bob` in a pandas data frame",
  "body": "How can I get the integer location of a key to a pandas index as quickly as possible?\neg, given pd.DataFrame(data=np.asarray([[1,2,3],[4,5,6],[7,8,9]]), index=['alice', 'bob', 'charlie'])\nwhat is the fastest way to go from 'bob' to 1\n",
  "preds": {
   "base:Baseline": "df['bob'].loc[0]",
   "body:Baseline": "df['bob'] = np.array([1, 2, 3], index=['charlie'])",
   "body:-Blocks": "df.loc[:, (np.asarray([['bob'], 'charlie'])]",
   "body:-Code": "df['bob'].loc[0]",
   "body:-Inline": "df['bob'] = df['id']",
   "body:-NL": "df['bob'] = df['Alice']",
   "base:+Mined": "df.loc[df['bob'] == 1]",
   "body+mined:Baseline": "df['a'] = df['bob'].loc[0]",
   "body+mined:-Code": "df['bob'] = df['location']",
   "body+mined:-NL": "pd.concat([df['bob']], axis=1)",
   "body+mined:-Blocks": "df['bob'] = df['index']",
   "body+mined:-Inline": "df.loc[df['bob'] == 1]"
  },
  "snippet": "df.index.get_loc('bob')"
 },
 "7574841.396": {
  "intent": "open a 'gnome' terminal from python script and run  'sudo apt-get update' command.",
  "body": "I'm developing a program that has a button. When pressed, I want to open a terminal that runs:  \nsudo apt-get update\n\nI'm using:\nos.system(\"gnome-terminal -e 'sudo apt-get update'\")\n\nThis works fine. The only problem is that when the update is finished, the terminal closes.\nWhat can I do to leave the terminal open?\n",
  "preds": {
   "base:Baseline": "os.system('gnome', shell=True)",
   "body:Baseline": "os.system('gnome-terminal -e'sudo apt-get update'')",
   "body:-Blocks": "os.system('gnome', shell=True)",
   "body:-Code": "os.system('gnome', shell=True)",
   "body:-Inline": "os.system('gnome-terminal -e'sudo apt-get update'')",
   "body:-NL": "os.system('gnome-terminal -e'sudo apt-get update'\")",
   "base:+Mined": "os.system('sudo apt-get update')",
   "body+mined:Baseline": "os.system('gnome-terminal -e'sudo apt-get update')",
   "body+mined:-Code": "os.system('sudo apt-get update')",
   "body+mined:-NL": "os.system('gnome-terminal -e'sudo apt-get update'\")",
   "body+mined:-Blocks": "os.system('sudo apt-get update')",
   "body+mined:-Inline": "os.system('gnome-terminal -e'sudo apt-get update'')"
  },
  "snippet": "os.system('gnome-terminal -e \\'bash -c \"sudo apt-get update; exec bash\"\\'')"
 },
 "10487278.397": {
  "intent": "add an item with key 'third_key' and value 1 to an dictionary `my_dict`",
  "body": "I'm trying to add items to an array in python.\nI run \narray = {}\n\nThen, I try to add something to this array by doing:\narray.append(valueToBeInserted)\n\nThere doesn't seem to be a .append  method for this.  How do I add items to an array?\n",
  "preds": {
   "base:Baseline": "my_dict.update({'third_key': 1})",
   "body:Baseline": "my_dict.update({'third_key': 1})",
   "body:-Blocks": "my_dict.items()[1]",
   "body:-Code": "my_dict.update({'third_key': 1})",
   "body:-Inline": "my_dict.update({'third_key': 1})",
   "body:-NL": "my_dict.update({'third_key': 1})",
   "base:+Mined": "my_dict.update({'third_key': 1})",
   "body+mined:Baseline": "array = {'third_key': 1, 'value1': 1}",
   "body+mined:-Code": "my_dict.append(1, 1)",
   "body+mined:-NL": "my_dict.append({'third_key': '1'})",
   "body+mined:-Blocks": "my_dict.append(1)",
   "body+mined:-Inline": "array = {'third_key': '1'}"
  },
  "snippet": "my_dict.update({'third_key': 1})"
 },
 "10487278.398": {
  "intent": "declare an array",
  "body": "I'm trying to add items to an array in python.\nI run \narray = {}\n\nThen, I try to add something to this array by doing:\narray.append(valueToBeInserted)\n\nThere doesn't seem to be a .append  method for this.  How do I add items to an array?\n",
  "preds": {
   "base:Baseline": "np.array([0, 1], axis=1)",
   "body:Baseline": "array = [item for item in array]",
   "body:-Blocks": "np.array([i for i in range(0, len(i), len(j))])",
   "body:-Code": "np.array([0, 1], axis=1)",
   "body:-Inline": "array = {}\n    pass",
   "body:-NL": "numpy.append(valueToBeInserted)",
   "base:+Mined": "array([[1, 2], [3, 4], [5, 6], [7, 8]])",
   "body+mined:Baseline": "array = [[1, 2, 3], [4, 5, 6]]",
   "body+mined:-Code": "array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])",
   "body+mined:-NL": "array.append(valueToBeInserted)",
   "body+mined:-Blocks": "array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])",
   "body+mined:-Inline": "array = [[1, 2, 3], [4, 5, 6]]"
  },
  "snippet": "my_list = []"
 },
 "10487278.399": {
  "intent": "insert item `12` to a list `my_list`",
  "body": "I'm trying to add items to an array in python.\nI run \narray = {}\n\nThen, I try to add something to this array by doing:\narray.append(valueToBeInserted)\n\nThere doesn't seem to be a .append  method for this.  How do I add items to an array?\n",
  "preds": {
   "base:Baseline": "my_list.insert(12)",
   "body:Baseline": "my_list.append(12)",
   "body:-Blocks": "my_list.pop(12)",
   "body:-Code": "my_list.insert(12)",
   "body:-Inline": "my_list = [item for item in my_list]",
   "body:-NL": "my_list.pop(12)",
   "base:+Mined": "my_list.insert(12)",
   "body+mined:Baseline": "my_list.append(12)",
   "body+mined:-Code": "my_list = my_list[12:]",
   "body+mined:-NL": "my_list.append(12)",
   "body+mined:-Blocks": "my_list.append(12)",
   "body+mined:-Inline": "array = [item for item in my_list]"
  },
  "snippet": "my_list.append(12)"
 },
 "10155684.400": {
  "intent": "add an entry 'wuggah' at the beginning of list `mylist`",
  "body": "I have a list  of about 40 entries. And I frequently want to append an item to the start of the list (with id 0) and want to delete the last  entry (with id 40) of the list.\nHow do I do this the best?\nExample with 5 entries:\n[0] = \"herp\"\n[1] = \"derp\"\n[2] = \"blah\"\n[3] = \"what\"\n[4] = \"da...\"\n\nafter adding \"wuggah\"  and deleting last it should be like:\n[0] = \"wuggah\"\n[1] = \"herp\"\n[2] = \"derp\"\n[3] = \"blah\"\n[4] = \"what\"\n\nAnd I don't want to end up manually moving them one after another all of the entries to the next id.\n",
  "preds": {
   "base:Baseline": "myList[0].startswith('wuggah')",
   "body:Baseline": "mylist[0] = 'wuggah'",
   "body:-Blocks": "mylist.pop('wuggah')",
   "body:-Code": "mylist.pop('wuggah')",
   "body:-Inline": "mylist.pop('wuggah')",
   "body:-NL": "mylist[0].startswith('wuggah')",
   "base:+Mined": "mylist.append('wuggah')",
   "body+mined:Baseline": "mylist.pop('wuggah')",
   "body+mined:-Code": "myList.insert(0, 'wuggah')",
   "body+mined:-NL": "mylist.append('wuggah')",
   "body+mined:-Blocks": "mylist.pop('wuggah')",
   "body+mined:-Inline": "mylist.pop('wuggah')"
  },
  "snippet": "myList.insert(0, 'wuggah')"
 },
 "3519125.401": {
  "intent": "convert a hex-string representation to actual bytes",
  "body": "i need to load the third column of this text file as a hex string\nhttp://www.netmite.com/android/mydroid/1.6/external/skia/emoji/gmojiraw.txt\nopen('gmojiraw.txt').read().split('\\n')[0].split('\\t')[2]\n'\\\\xF3\\\\xBE\\\\x80\\\\x80'\n\nhow do i open the file so that i can get the third column as hex string:\n'\\xF3\\xBE\\x80\\x80'\n\ni also tried binary mode and hex mode, with no success.\n",
  "preds": {
   "base:Baseline": "struct.unpack('hex-string', 16)",
   "body:Baseline": "open('gmojiraw.txt').read().split('\\n')[2]",
   "body:-Blocks": "[int(x) for x in open('mydroid', 'gmojiraw'])",
   "body:-Code": "struct.unpack('hex', 3)",
   "body:-Inline": "struct.unpack('\\n')[0].decode('hex')",
   "body:-NL": "[int(x) for x in open('gmojiraw.txt').read().split('\\n')]",
   "base:+Mined": "struct.unpack('b', 16)[0]",
   "body+mined:Baseline": "hex_string = ''.join(open('gmojiraw.txt').read().split('\\n')[0])",
   "body+mined:-Code": "\"\"\"\"\"\".join(chr(ord(c)) for c in open('mydroid.txt').read())",
   "body+mined:-NL": "\"\"\"\"\"\".join(struct.unpack('Q', s))",
   "body+mined:-Blocks": "struct.unpack('<I', stdout=subprocess.PIPE)",
   "body+mined:-Inline": "hex_string.decode('hex')"
  },
  "snippet": "\"\"\"\\\\xF3\\\\xBE\\\\x80\\\\x80\"\"\".replace('\\\\x', '').decode('hex')"
 },
 "40144769.402": {
  "intent": "select the last column of dataframe `df`",
  "body": "I have done some searching for the answer to this question, but all I can figure out is this: \ndf[df.columns[len(df.columns)-1]]\n\nwhich to me seems unweildy, and un-pythonic (and slow?). \nWhat is the easiest way to select the data for the last column in a pandas dataframe without specifying the name of the column?\n",
  "preds": {
   "base:Baseline": "df.columns[:-1]",
   "body:Baseline": "df[df].columns[len(df.columns)-1]]",
   "body:-Blocks": "df.loc[:, (df.columns)]",
   "body:-Code": "df.loc[:, (df.columns)]",
   "body:-Inline": "df[df].columns[len(df.columns)-1]]",
   "body:-NL": "df[df.loc[len(df.columns)] - 1]",
   "base:+Mined": "df.loc[:, (df.columns[:-1])]",
   "body+mined:Baseline": "df[df.columns[len(df)] - 1]",
   "body+mined:-Code": "df.drop(len(df.columns), axis=1)",
   "body+mined:-NL": "df[df.columns[len(df.values), -1]]",
   "body+mined:-Blocks": "df.loc[df.columns[:-1]",
   "body+mined:-Inline": "df[df.columns[len(df)) - 1]"
  },
  "snippet": "df[df.columns[-1]]"
 },
 "30787901.403": {
  "intent": "get the first value from dataframe `df` where column 'letters' is equal to 'c'",
  "body": "Say I have the following DataFrame\n\nLetter    Number\nA          1\nB          2\nC          3\nD          4\n\nWhich can be obtained through the following code\nimport pandas as pd\n\nletters=pd.Series(('A', 'B', 'C', 'D'))\nnumbers=pd.Series((1, 2, 3, 4))\nkeys=('Letters', 'Numbers')\ndf=pd.concat((letters, numbers), axis=1, keys=keys)\n\nNow I want to get the value C from the column Letters.\nThe command line\ndf[df.Letters=='C'].Letters\n\nwill return\n\n2    C\nName: Letters, dtype: object\n\nHow can I get only the value C and not the whole two line output?\n",
  "preds": {
   "base:Baseline": "df[df['letters'] == 'C']",
   "body:Baseline": "df[df.C] == 'C']",
   "body:-Blocks": "df[df['letters'] == 'C']",
   "body:-Code": "df[df['letters'] == 'C']",
   "body:-Inline": "df[df.Letters == 'C')",
   "body:-NL": "df[df.Letters == 'C')",
   "base:+Mined": "df.loc[df['letters'] == 'c']",
   "body+mined:Baseline": "df[df.Letters == 'C']",
   "body+mined:-Code": "df.loc[df['Letter'] == 'C']",
   "body+mined:-NL": "df[df.C.isin(['A', 'B', 'C'])]",
   "body+mined:-Blocks": "df.loc[df['Letter'] == 'C']",
   "body+mined:-Inline": "df[df.Letters == 'C'].C"
  },
  "snippet": "df.loc[df['Letters'] == 'C', 'Letters'].values[0]"
 },
 "18730044.404": {
  "intent": "converting two lists `[1, 2, 3]` and `[4, 5, 6]` into a matrix",
  "body": "I'll try to be as clear as possible, and I'll start by explaining why I want to transform two arrays into a matrix.\nTo plot the performance of a portfolio vs an market index I need a data structure like in this format:\n[[portfolio_value1, index_value1]\n [portfolio_value2, index_value2]]\n\nBut I have the the data as two separate 1-D arrays:\nportfolio = [portfolio_value1, portfolio_value2, <console_out>]\nindex = [index_value1, index_value2, <console_out>]\n\nSo how do I transform the second scenario into the first. I've tried np.insert  to add the second array to a test matrix I had in a python shell, my problem was to transpose the first array into a single column matrix.\nAny help on how to achieve this without an imperative loop would be great.\n",
  "preds": {
   "base:Baseline": "np.concat([1, 2, 3], [4, 5, 6])",
   "body:Baseline": "np.insert([1, 2, 3], [4, 5, 6])",
   "body:-Blocks": "np.concat([1, 2, 3], [4, 5, 6])",
   "body:-Code": "np.concat([1, 2, 3], [4, 5, 6])",
   "body:-Inline": "np.matrix([1, 2, 3], [4, 5, 6])",
   "body:-NL": "np.concat([1, 2, 3], [4, 5, 6])",
   "base:+Mined": "matrix([1, 2, 3], [4, 5, 6])",
   "body+mined:Baseline": "np.concatenate(([[1, 2, 3]], [4, 5, 6]))",
   "body+mined:-Code": "matrix([1, 2, 3], [4, 5, 6])",
   "body+mined:-NL": "numpy.concat([1, 2, 3], axis=1)",
   "body+mined:-Blocks": "np.concatenate([1, 2, 3], [4, 5, 6])",
   "body+mined:-Inline": "numpy.concat([1, 2, 3], [4, 5, 6])"
  },
  "snippet": "np.column_stack(([1, 2, 3], [4, 5, 6]))"
 },
 "402504.405": {
  "intent": "get the type of `i`",
  "body": "How do I see the type of a variable whether it is unsigned 32 bit, signed 16 bit, etc.?\nHow do I view it?\n",
  "preds": {
   "base:Baseline": "print(i.type(1))",
   "body:Baseline": "print(i.__class__)",
   "body:-Blocks": "print(i.__str__(16))",
   "body:-Code": "print(i.__str__)",
   "body:-Inline": "print(i.type(0, 16))",
   "body:-NL": "print(i.getType(key=lambda x: x[1])",
   "base:+Mined": "print(i[i] + str(i))",
   "body+mined:Baseline": "print(type(i.__str__))",
   "body+mined:-Code": "isinstance(i, 16)[0]",
   "body+mined:-NL": "print(i.__type__)",
   "body+mined:-Blocks": "i.__str__(16)",
   "body+mined:-Inline": "print(i.__signal__(16))"
  },
  "snippet": "type(i)"
 },
 "402504.406": {
  "intent": "determine the type of variable `v`",
  "body": "How do I see the type of a variable whether it is unsigned 32 bit, signed 16 bit, etc.?\nHow do I view it?\n",
  "preds": {
   "base:Baseline": "print(v.__dict__)",
   "body:Baseline": "v.sort(key=operator.itemgetter(16))",
   "body:-Blocks": "v.__str__(*(16))",
   "body:-Code": "v.__str__(float)",
   "body:-Inline": "print(v.type() for v in range(16))",
   "body:-NL": "print(v.type(v))",
   "base:+Mined": "var1, var2 = str(v)",
   "body+mined:Baseline": "globals().unstack(v)",
   "body+mined:-Code": "v == str(32)[0]",
   "body+mined:-NL": "globals().set_type('v')",
   "body+mined:-Blocks": "v.isinstance(int, 16)",
   "body+mined:-Inline": "print(type(v.__signal__))"
  },
  "snippet": "type(v)"
 },
 "402504.407": {
  "intent": "determine the type of variable `v`",
  "body": "How do I see the type of a variable whether it is unsigned 32 bit, signed 16 bit, etc.?\nHow do I view it?\n",
  "preds": {
   "base:Baseline": "print(v.__dict__)",
   "body:Baseline": "v.sort(key=operator.itemgetter(16))",
   "body:-Blocks": "v.__str__(*(16))",
   "body:-Code": "v.__str__(float)",
   "body:-Inline": "print(v.type() for v in range(16))",
   "body:-NL": "print(v.type(v))",
   "base:+Mined": "var1, var2 = str(v)",
   "body+mined:Baseline": "globals().unstack(v)",
   "body+mined:-Code": "v == str(32)[0]",
   "body+mined:-NL": "globals().set_type('v')",
   "body+mined:-Blocks": "v.isinstance(int, 16)",
   "body+mined:-Inline": "print(type(v.__signal__))"
  },
  "snippet": "type(v)"
 },
 "402504.408": {
  "intent": "determine the type of variable `v`",
  "body": "How do I see the type of a variable whether it is unsigned 32 bit, signed 16 bit, etc.?\nHow do I view it?\n",
  "preds": {
   "base:Baseline": "print(v.__dict__)",
   "body:Baseline": "v.sort(key=operator.itemgetter(16))",
   "body:-Blocks": "v.__str__(*(16))",
   "body:-Code": "v.__str__(float)",
   "body:-Inline": "print(v.type() for v in range(16))",
   "body:-NL": "print(v.type(v))",
   "base:+Mined": "var1, var2 = str(v)",
   "body+mined:Baseline": "globals().unstack(v)",
   "body+mined:-Code": "v == str(32)[0]",
   "body+mined:-NL": "globals().set_type('v')",
   "body+mined:-Blocks": "v.isinstance(int, 16)",
   "body+mined:-Inline": "print(type(v.__signal__))"
  },
  "snippet": "type(v)"
 },
 "402504.409": {
  "intent": "determine the type of variable `v`",
  "body": "How do I see the type of a variable whether it is unsigned 32 bit, signed 16 bit, etc.?\nHow do I view it?\n",
  "preds": {
   "base:Baseline": "print(v.__dict__)",
   "body:Baseline": "v.sort(key=operator.itemgetter(16))",
   "body:-Blocks": "v.__str__(*(16))",
   "body:-Code": "v.__str__(float)",
   "body:-Inline": "print(v.type() for v in range(16))",
   "body:-NL": "print(v.type(v))",
   "base:+Mined": "var1, var2 = str(v)",
   "body+mined:Baseline": "globals().unstack(v)",
   "body+mined:-Code": "v == str(32)[0]",
   "body+mined:-NL": "globals().set_type('v')",
   "body+mined:-Blocks": "v.isinstance(int, 16)",
   "body+mined:-Inline": "print(type(v.__signal__))"
  },
  "snippet": "type(v)"
 },
 "402504.410": {
  "intent": "get the type of variable `variable_name`",
  "body": "How do I see the type of a variable whether it is unsigned 32 bit, signed 16 bit, etc.?\nHow do I view it?\n",
  "preds": {
   "base:Baseline": "variable_name = variable_name[0]",
   "body:Baseline": "print(variable_name.__class__))",
   "body:-Blocks": "variable_name.__str__()",
   "body:-Code": "variable_name.__str__()",
   "body:-Inline": "print(variable_name.type())",
   "body:-NL": "print(variable_name.type())",
   "base:+Mined": "variable_name.getType(bool)",
   "body+mined:Baseline": "variable_name.strftime('NFKD')",
   "body+mined:-Code": "variable_name.isdigit()",
   "body+mined:-NL": "variable_name.__get__(__builtins__)",
   "body+mined:-Blocks": "variable_name.isdigit()",
   "body+mined:-Inline": "variable_name.strftime('32 bit')"
  },
  "snippet": "print(type(variable_name))"
 },
 "2300756.411": {
  "intent": "get the 5th item of a generator",
  "body": "Is there a more syntactically concise way of writing the following?\ngen = (i for i in xrange(10))\nindex = 5\nfor i, v in enumerate(gen):\n    if i is index:\n        return v\n\nIt seems almost natural that a generator should have a gen[index]  expression, that acts as a list, but is functionally identical to the above code.\n",
  "preds": {
   "base:Baseline": " generator.itemgetter(5)",
   "body:Baseline": "for i, v in enumerate(gen):\n    pass",
   "body:-Blocks": "[i[0] for i in range(5)]",
   "body:-Code": "[item[5] for item in generator]",
   "body:-Inline": "[i[0] for i in enumerate(gen)]",
   "body:-NL": "[i[0] for i in enumerate(gen)]",
   "base:+Mined": "next((5, 5), 5)",
   "body+mined:Baseline": "[i for i, j in enumerate(gen) if i == j]",
   "body+mined:-Code": "list(itertools.product(*list(range(10)), repeat=5))",
   "body+mined:-NL": "next(i for i, v in enumerate(gen) if i == 5)",
   "body+mined:-Blocks": "[i for i in range(5)]",
   "body+mined:-Inline": "[i[0] for i in enumerate(gen) if i == index]"
  },
  "snippet": "next(itertools.islice(range(10), 5, 5 + 1))"
 },
 "20056548.412": {
  "intent": "print a string `word` with string format",
  "body": "For instance, we have:\nword = 'Some Random Word'\nprint '\"' + word + '\"'\n\nis there a better way to print double quotes around a variable?\n",
  "preds": {
   "base:Baseline": "print(word.split('\\n'))[0]",
   "body:Baseline": "print('\"' + word + '\"' + 'Some Random Word'",
   "body:-Blocks": "print('word'.format(word))",
   "body:-Code": "print('word'.format(word))",
   "body:-Inline": "print(''.join(word for word in str(format(word)))",
   "body:-NL": "print('Some Random Word'.format(word))",
   "base:+Mined": "print('Word is {}'.format(word))",
   "body+mined:Baseline": "print('\"' + word + '\"'')",
   "body+mined:-Code": "print('Value is \"' + word)",
   "body+mined:-NL": "print('\"' + ''.join(word))",
   "body+mined:-Blocks": "print('word with string format ')",
   "body+mined:-Inline": "print('\"' + word + '\"')"
  },
  "snippet": "print('\"{}\"'.format(word))"
 },
 "8546245.413": {
  "intent": "join a list of strings `list` using a space ' '",
  "body": "I wanted to build a string from a list.\nI used the string.join() command, but if I have :\n['hello', 'good', 'morning']\n\nI get : hellogoodmorning\nIs there a method that allows me to put a space between every word ? (without the need to write a for loop)\nkind regards.\n",
  "preds": {
   "base:Baseline": "list = [x for x in list if x.isdigit()]",
   "body:Baseline": "list.join(key=lambda x: x.split())",
   "body:-Blocks": "list = [x for x in list if x.split(' ']]",
   "body:-Code": "list = [x for x in list if x.split(' ']",
   "body:-Inline": "list = [x for x in re.findall(' '])",
   "body:-NL": "list.join('  ['hello', 'good','morning'])",
   "base:+Mined": "list = [x for x in list if '' in x]",
   "body+mined:Baseline": "list.join(map(str, ''.join(list)))",
   "body+mined:-Code": "list = [s.split(' ') for s in list]",
   "body+mined:-NL": "list.join(['hello', 'good', 'morning'])",
   "body+mined:-Blocks": "list.join(map(lambda x: x.split(' '))",
   "body+mined:-Inline": "list.join(map(str, ''))"
  },
  "snippet": "\"\"\" \"\"\".join(list)"
 },
 "2276416.414": {
  "intent": "create list `y` containing two empty lists",
  "body": "I might be missing something about the intended behavior of list extend, but why does the following happen?\nx = [[],[]]\ny = [[]] * 2\n\nprint x       # [[],[]]\nprint y       # [[],[]]\nprint x == y  # True\n\nx[0].extend([1])\ny[0].extend([1])\n\nprint x    # [[1],[]], which is what I'd expect\nprint y    # [[1],[1]], wtf?\n\nI would guess that the *  operator is doing something unexpected here, though I'm not exactly sure what.  It seems like something is going on under the hood that's making the original x and y (prior to calling extend) not actually be equal even though the ==  operator and repr  both would make it seem as though they were identical.\nI only came across this because I wanted to pre-populate a list of empty lists of a size determined at runtime, and then realized that it wasn't working the way I imagined.  I can find a better way to do the same thing, but now I'm curious as to why this didn't work.  This is Python 2.5.2 BTW - I don't have a newer version installed so if this is a bug I'm not sure if it's already fixed.\n",
  "preds": {
   "base:Baseline": "y = [i for i in range(2)]",
   "body:Baseline": "y = [[] for i in range(2)]",
   "body:-Blocks": "y = [i for i in range(0, len(x), y)]",
   "body:-Code": "y = [i for i in range(2)]",
   "body:-Inline": "y = [[] for i in range(2)]",
   "body:-NL": "y = [[] for i in range(2)]",
   "base:+Mined": "y = [list(i) for i in range(0, len(i), 2)]",
   "body+mined:Baseline": "y = [[] for i in range(2)]",
   "body+mined:-Code": "y = [[] for i in range(10)]",
   "body+mined:-NL": "y = [[] for i in range(2)]",
   "body+mined:-Blocks": "y = [x for x in range(10)]",
   "body+mined:-Inline": "y = [[] for i in range(2)]"
  },
  "snippet": "y = [[] for n in range(2)]"
 },
 "3925614.415": {
  "intent": "read a file 'c:/name/mydocuments/numbers' into a list `data`",
  "body": "I want to prompt a user for a number of random numbers to be generated and saved to a file. He gave us that part. The part we have to do is to open that file, convert the numbers into a list, then find the mean, standard deviation, etc. without using the easy built-in Python tools.\nI've tried using open  but it gives me invalid syntax (the file name I chose was \"numbers\" and it saved into \"My Documents\"  automatically, so I tried open(numbers, 'r')  and open(C:\\name\\MyDocuments\\numbers, 'r')  and neither one worked).\n",
  "preds": {
   "base:Baseline": "data = open('c:/name/mydocuments/numbers')",
   "body:Baseline": "data = open('C:/name/MyDocuments/numbers', 'r')",
   "body:-Blocks": "data = open('C:/name/myDocuments/numbers', 'r')",
   "body:-Code": "data = open('c:/name/mydocuments/numbers')",
   "body:-Inline": "data = open('c:/name/mydocuments/numbers')",
   "body:-NL": "data = open('C:/name/myDocuments/numbers')",
   "base:+Mined": "data = open('c:/name/mydocuments/numbers', 'r')",
   "body+mined:Baseline": "data = open('C:/name/mydocuments/numbers')",
   "body+mined:-Code": "data = open('c:/name/mydocuments/numbers')",
   "body+mined:-NL": "data = open('C:/name/mydocuments/numbers', 'r')",
   "body+mined:-Blocks": "data = open('C:/name/mydocuments/numbers', 'r')",
   "body+mined:-Inline": "data = open('c:/name/mydocuments/numbers')"
  },
  "snippet": "data = [line.strip() for line in open('C:/name/MyDocuments/numbers', 'r')]"
 },
 "22187233.416": {
  "intent": "delete all occurrences of character 'i' in string 'it is icy'",
  "body": "How do I delete all the instances of a character in this string? Here is my code:\ndef findreplace(char, string):\n    place = string.index(char)\n    string[place] = ''\n    return string\n\nHowever, if I run this, this is what happens:\nfindreplace('i', 'it is icy')\nTraceback (most recent call last):\n  File \" <stdin>\", line 1, in <module>\n  File \" <stdin>\", line 3, in findreplace\nTypeError: 'str' object does not support item assignment\n\nWhy is this?\n",
  "preds": {
   "base:Baseline": "re.sub('[^a-zA-Z]', 'it is icy')",
   "body:Baseline": "re.sub('I', 'it is icy')",
   "body:-Blocks": "'it is icy'.join(c for c in 'I', 'It is icy')",
   "body:-Code": "\"\"\"it is icy\"\"\".replace('I', '')",
   "body:-Inline": "re.sub('I', 'it is icy')",
   "body:-NL": "re.sub('(i)', 'it is icy')",
   "base:+Mined": "re.sub('(?<=\\\\I)', 'It is icy')",
   "body+mined:Baseline": "findreplace('i', 'it is icy')",
   "body+mined:-Code": "\"\"\"IT is icy\"\"\".replace('I', '')",
   "body+mined:-NL": "re.sub('\\\\b', 'I', 'It is icy')",
   "body+mined:-Blocks": "\"\"\"\"\"\".join(c for c in itertools.chain.from_iterable(c))",
   "body+mined:-Inline": "findreplace('i', 'it is icy')"
  },
  "snippet": "\"\"\"\"\"\".join([char for char in 'it is icy' if char != 'i'])"
 },
 "22187233.417": {
  "intent": "delete all instances of a character 'i' in a string 'it is icy'",
  "body": "How do I delete all the instances of a character in this string? Here is my code:\ndef findreplace(char, string):\n    place = string.index(char)\n    string[place] = ''\n    return string\n\nHowever, if I run this, this is what happens:\nfindreplace('i', 'it is icy')\nTraceback (most recent call last):\n  File \" <stdin>\", line 1, in <module>\n  File \" <stdin>\", line 3, in findreplace\nTypeError: 'str' object does not support item assignment\n\nWhy is this?\n",
  "preds": {
   "base:Baseline": "re.sub('[^a-zA-Z]', 'it is icy')",
   "body:Baseline": "re.sub('I', 'it is icy')",
   "body:-Blocks": "\"\"\"it is icy\"\"\".join(lambda x: x[1])",
   "body:-Code": "'it is icy'.join(lambda x: x.split('I', 'I')))",
   "body:-Inline": "re.sub('I', 'it is icy')",
   "body:-NL": "re.sub('(i)', 'it is icy')",
   "base:+Mined": "re.sub('[^I]', 'It is icy')",
   "body+mined:Baseline": "findreplace('i', 'it is icy')",
   "body+mined:-Code": "\"\"\"It is icy\"\"\".join(c for c in itertools.groupby('i') if c != 'I')",
   "body+mined:-NL": "re.sub('\\\\b', 'it is icy', 'I', 'It is icy')",
   "body+mined:-Blocks": "\"\"\"\"\"\".join([i for i in itertools.chain.from_iterable(i)) if i!= 'I')",
   "body+mined:-Inline": "findreplace('i', 'it is icy')"
  },
  "snippet": "re.sub('i', '', 'it is icy')"
 },
 "22187233.418": {
  "intent": "delete all characters \"i\" in string \"it is icy\"",
  "body": "How do I delete all the instances of a character in this string? Here is my code:\ndef findreplace(char, string):\n    place = string.index(char)\n    string[place] = ''\n    return string\n\nHowever, if I run this, this is what happens:\nfindreplace('i', 'it is icy')\nTraceback (most recent call last):\n  File \" <stdin>\", line 1, in <module>\n  File \" <stdin>\", line 3, in findreplace\nTypeError: 'str' object does not support item assignment\n\nWhy is this?\n",
  "preds": {
   "base:Baseline": "re.sub('it is icy')",
   "body:Baseline": "re.sub('I', 'it is icy')",
   "body:-Blocks": "re.sub('(i)', 'it is icy')",
   "body:-Code": "\"\"\"it is icy\"\"\".replace('i', '')",
   "body:-Inline": "re.sub('i', 'it is icy')",
   "body:-NL": "re.sub('(i)', 'it is icy')",
   "base:+Mined": "re.sub('[^a-zA-Z]', 'it is icy')",
   "body+mined:Baseline": "findreplace('i', 'it is icy')",
   "body+mined:-Code": "'IT is icy'.join(c for c in 'I', i)",
   "body+mined:-NL": "re.sub('\\\\b', 'it is icy', '', place)",
   "body+mined:-Blocks": "\"\"\"\"\"\".join([i for i in 'It is icy' if i])",
   "body+mined:-Inline": "findreplace('i', 'it is icy')"
  },
  "snippet": "\"\"\"it is icy\"\"\".replace('i', '')"
 },
 "22187233.419": {
  "intent": "how to delete all instances of a character in a string in python?",
  "body": "How do I delete all the instances of a character in this string? Here is my code:\ndef findreplace(char, string):\n    place = string.index(char)\n    string[place] = ''\n    return string\n\nHowever, if I run this, this is what happens:\nfindreplace('i', 'it is icy')\nTraceback (most recent call last):\n  File \" <stdin>\", line 1, in <module>\n  File \" <stdin>\", line 3, in findreplace\nTypeError: 'str' object does not support item assignment\n\nWhy is this?\n",
  "preds": {
   "base:Baseline": "re.sub('[^a-zA-Z]', '\\\\1', '', text)",
   "body:Baseline": "re.sub('\\\\w+', '')",
   "body:-Blocks": "[x for x in re.sub('[^a-zA-Z]', '', x)",
   "body:-Code": "re.sub('[^a-zA-Z]', '', ''.join(lambda x: x.split())",
   "body:-Inline": "\"\"\"\"\"\".join(str.replace('i', 'it is icy')",
   "body:-NL": "re.sub('\\\\d+', '', place)",
   "base:+Mined": "new_string = re.sub('\\\\d+', '', old_string)",
   "body+mined:Baseline": "s = s.replace('i', 'it is icy')",
   "body+mined:-Code": "s = s.replace('*', '')",
   "body+mined:-NL": "re.sub('\\\\b', '\\\\1', '', place)",
   "body+mined:-Blocks": "s = s.replace(' ', '')",
   "body+mined:-Inline": "re.sub('(?<=\\\\w+)', '', 'it is icy')"
  },
  "snippet": "\"\"\"\"\"\".join([char for char in 'it is icy' if char != 'i'])"
 },
 "13413590.420": {
  "intent": "drop rows of pandas dataframe `df` having nan in column at index \"1\"",
  "body": "I have this DataFrame  and want only the records whose EPS  column is not NaN :\ndf\n                STK_ID  EPS  cash\nSTK_ID RPT_Date                   \n601166 20111231  601166  NaN   NaN\n600036 20111231  600036  NaN    12\n600016 20111231  600016  4.3   NaN\n601009 20111231  601009  NaN   NaN\n601939 20111231  601939  2.5   NaN\n000001 20111231  000001  NaN   NaN\n\n<console_out>i.e. something like df.drop(....)  to get this resulting dataframe:\n                  STK_ID  EPS  cash\nSTK_ID RPT_Date                   \n600016 20111231  600016  4.3   NaN\n601939 20111231  601939  2.5   NaN\n\nHow do I do that?\n",
  "preds": {
   "base:Baseline": "df.loc[df.index(1)]",
   "body:Baseline": "df.drop(['1'], axis=1)",
   "body:-Blocks": "df.drop(['1'], axis=1)",
   "body:-Code": "df.dropna(df.columns, axis=1)",
   "body:-Inline": "df.dropna(df.columns, axis=1, inplace=True)",
   "body:-NL": "df.drop(['1'], axis=1)",
   "base:+Mined": "df.drop(df.columns, axis=1)",
   "body+mined:Baseline": "df.drop(df.isnull().drop([' EPS'], axis=1)",
   "body+mined:-Code": "df.dropna(df.columns, axis=1)",
   "body+mined:-NL": "df.drop(df.columns, axis=1)",
   "body+mined:-Blocks": "df.drop(df.isnan(['1'], axis=1)",
   "body+mined:-Inline": "df.loc[df.columns[1].isin(['a', 'b'])]"
  },
  "snippet": "df.dropna(subset=[1])"
 },
 "598398.421": {
  "intent": "get elements from list `mylist`, that have a field `n` value 30",
  "body": "Let's assume I'm creating a simple class to work similar to a C-style struct, to just hold data elements.  I'm trying to figure out how to search a list of objects for objects with an attribute equaling a certain value.  Below is a trivial example to illustrate what I'm trying to do.\nFor instance:\nclass Data:\n    pass\n\nmyList = []\n\nfor i in range(20):\n    data = Data()\n    data.n = i\n    data.n_squared = i * i\n    myList.append(data)\n\nHow would I go about searching the myList list to determine if it contains an element with n == 5?\nI've been Googling and searching the Python docs, and I think I might be able to do this with a list comprehension, but I'm not sure.  I might add that I'm having to use Python 2.4.3 by the way, so any new gee-whiz 2.6 or 3.x features aren't available to me.\n",
  "preds": {
   "base:Baseline": "[x for x in mylist if x != 30]",
   "body:Baseline": "[i for i, n in myList if i == 30]",
   "body:-Blocks": "[x for x in myList if x == 30]",
   "body:-Code": "[x for x in myList if x == 30]",
   "body:-Inline": "[x for x in myList if x == 5]",
   "body:-NL": "[x for x in myList if x != 30]",
   "base:+Mined": "[i for i, n in enumerate(myList) if n != 30]",
   "body+mined:Baseline": "[x for x in myList if x.n == 5]",
   "body+mined:-Code": "[x for x in myList if x == 5]",
   "body+mined:-NL": "[x for x in myList if x.n_squared]",
   "body+mined:-Blocks": "[x for x in myList if x[n] == 30]",
   "body+mined:-Inline": "[item for item in myList if n == 30]"
  },
  "snippet": "[x for x in myList if x.n == 30]"
 },
 "10351772.422": {
  "intent": "converting list of strings `intstringlist` to list of integer `nums`",
  "body": "How do I convert a space separated integer input into a list of integers?\nExample input:\nlist1 = list(input(\"Enter the unfriendly numbers: \"))\n\nExample conversion:\n['1', '2', '3', '4', '5']  to  [1, 2, 3, 4, 5]\n\n",
  "preds": {
   "base:Baseline": "[int(x) for x in int(nums)]",
   "body:Baseline": "list(intstringlist, nums)",
   "body:-Blocks": "nums = [int(x) for x in intstringlist]",
   "body:-Code": "nums = [int(x) for x in zip(intStringList, nums)]",
   "body:-Inline": "nums = [int(x) for x in enumerate(intstringlist, nums)]",
   "body:-NL": "nums = [int(x) for x in intstringlist]",
   "base:+Mined": "[int(nums) for nums in intstringlist]",
   "body+mined:Baseline": "nums = [int(x) for x in intstringlist]",
   "body+mined:-Code": "nums = [int(x) for x in intstringlist]",
   "body+mined:-NL": "nums = [int(x) for x in intstringlist]",
   "body+mined:-Blocks": "nums = [int(i) for i in s.split()]",
   "body+mined:-Inline": "nums = [int(x) for x in intstringlist]"
  },
  "snippet": "nums = [int(x) for x in intstringlist]"
 },
 "10351772.423": {
  "intent": "convert list of string numbers into list of integers",
  "body": "How do I convert a space separated integer input into a list of integers?\nExample input:\nlist1 = list(input(\"Enter the unfriendly numbers: \"))\n\nExample conversion:\n['1', '2', '3', '4', '5']  to  [1, 2, 3, 4, 5]\n\n",
  "preds": {
   "base:Baseline": "[int(x) for x in re.findall('\\\\d+', '', 2)]",
   "body:Baseline": "list(map(int, re.findall('\\\\d+\\\\b', '\\\\1', '2', '3', '4', '5'))",
   "body:-Blocks": "[int(x) for x in re.split('\\n')]",
   "body:-Code": "[int(x) for x in re.findall('\\n')]",
   "body:-Inline": "[int(x) for x in list1]",
   "body:-NL": "[int(x) for x in list1]",
   "base:+Mined": "[int(x) for x in lst]",
   "body+mined:Baseline": "list(map(int, input('Enter the unfriendly numbers: ')))",
   "body+mined:-Code": "[int(x) for x in lst]",
   "body+mined:-NL": "map(int, input('Enter the unfriendly numbers: '))",
   "body+mined:-Blocks": "[int(i) for i in s.split()]",
   "body+mined:-Inline": "map(int, ['1', '2', '3', '4', '5'])"
  },
  "snippet": "map(int, eval(input('Enter the unfriendly numbers: ')))"
 },
 "493386.424": {
  "intent": "print \".\" without newline",
  "body": "I'd like to do it in  python . What I'd like to do in this example in c :\nIn C:\n#include <stdio.h>\n\nint main() {\n    int i;\n    for (i=0; i <10; i++) printf(\".\");\n    return 0;\n}\n\nOutput:\n<console_out>.......\n\nIn Python:\nfor i in range(10): print('.')\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\nprint('.', '.', '.', '.', '.', '.', '.', '.', '.', '.')\n. . . . . . . . . .\n\nIn Python print  will add a \\n  or space, how can I avoid that? Now, it's just an example, don't tell me I can first build a string then print it. I'd like to know how to \"append\" strings to stdout .\n",
  "preds": {
   "base:Baseline": "print('.' + re.sub('\\\\d+', '.')",
   "body:Baseline": "print('. without newline.replace('.'))",
   "body:-Blocks": "print('.' + stdout.stdout.replace('.'))",
   "body:-Code": "print('.').replace('.')",
   "body:-Inline": "print('.').replace('.')",
   "body:-NL": "print('.' without newline.\n    pass",
   "base:+Mined": "print(' '.join(str(i) for i in '.'))",
   "body+mined:Baseline": "print('.' + str(i) + '.')",
   "body+mined:-Code": "print('.' + '.join(c))",
   "body+mined:-NL": "print('.'.join(str(i) for i in range(10))",
   "body+mined:-Blocks": "print('\\n'.join(str(c)) for c in c.split())",
   "body+mined:-Inline": "print('.'.join(['.') for i in range(10))"
  },
  "snippet": "sys.stdout.write('.')"
 },
 "6569528.425": {
  "intent": "round off the float that is the product of `2.52 * 100` and convert it to an int",
  "body": "Basically, I'm converting a float to an int, but I don't always have the expected value.\nHere's the code I'm executing:\nx = 2.51\nprint(\"--------- 251.0\")\ny = 251.0\nprint(y)\nprint(int(y))\n\nprint(\"--------- 2.51 * 100\")\ny = x * 100\nprint(y)\nprint(int(y))\n\nprint(\"--------- 2.51 * 1000 / 10\")\ny = x * 1000 / 10\nprint(y)\nprint(int(y))\n\nprint(\"--------- 2.51 * 100 * 10 / 10\")\ny = x * 100 * 10 / 10\nprint(y)\nprint(int(y))\n\nx = 4.02\nprint(\"--------- 402.0\")\ny = 402.0\nprint(y)\nprint(int(y))\n\nprint(\"--------- 4.02 * 100\")\ny = x * 100\nprint(y)\nprint(int(y))\n\nprint(\"--------- 4.02 * 1000 / 10\")\ny = x * 1000 / 10\nprint(y)\nprint(int(y))\n\nprint(\"--------- 4.02 * 100 * 10 / 10\")\ny = x * 100 * 10 / 10\nprint(y)\nprint(int(y))\n\nAnd here's the result (first value is the result of the operation, second value is int() of the same operation):\n--------- 251.0\n251.0\n251\n--------- 2.51 * 100\n251.0\n250\n--------- 2.51 * 1000 / 10\n251.0\n251\n--------- 2.51 * 100 * 10 / 10\n251.0\n250\n--------- 402.0\n402.0\n402\n--------- 4.02 * 100\n402.0\n401\n--------- 4.02 * 1000 / 10\n402.0\n401\n--------- 4.02 * 100 * 10 / 10\n402.0\n401\n\n2.51 and 4.02 are the only values that lead to that strange behaviour on the 2.50 -> 5.00 range. Every other two digits value in that range converts to int without any problem when given the same operations.\nSo, what am I missing that leads to those results? I'm using Python 2.7.2 by the way.\n",
  "preds": {
   "base:Baseline": "float(2.52 * 100)",
   "body:Baseline": "int(float(2.52 * 100))",
   "body:-Blocks": "int(round(2.52 * 100))",
   "body:-Code": "int(float(2.52 * 100))",
   "body:-Inline": "int(2.52 * 100)",
   "body:-NL": "int(2.52 * 100)",
   "base:+Mined": "int(round(2.52 * 100))",
   "body+mined:Baseline": "int(float(2.52 * 100))",
   "body+mined:-Code": "int(float(2.52 * 100))",
   "body+mined:-NL": "int(2.52 * 100)",
   "body+mined:-Blocks": "int(float(2.52 * 100))",
   "body+mined:-Inline": "int(float(2.52 * 100))"
  },
  "snippet": "int(round(2.51 * 100))"
 },
 "3964681.426": {
  "intent": "find all files in directory \"/mydir\" with extension \".txt\"",
  "body": "How can I find all the files in a directory having the extension .txt  in python?\n",
  "preds": {
   "base:Baseline": "print(os.path.isfile('/mydir', \".txt')",
   "body:Baseline": "print(os.path.dirname('/mydir'))",
   "body:-Blocks": "print(os.path.dirname('/mydir'))",
   "body:-Code": "print(os.path.exists('/mydir', \".txt')",
   "body:-Inline": "print(os.path.dirname('/mydir'))",
   "body:-NL": "os.path.exists('/mydir', '.txt')",
   "base:+Mined": "print(os.listdir('/mydir'))",
   "body+mined:Baseline": "[x for x in os.listdir('/mydir' if x.endswith('.txt'))]",
   "body+mined:-Code": "[x for x in os.listdir('/mydir') if x.endswith('.')]",
   "body+mined:-NL": "[x for x in os.walk('mydir') if x.endswith(' '.txt')]",
   "body+mined:-Blocks": "[x for x in os.listdir('/mydir' if x.endswith('.'))]",
   "body+mined:-Inline": "print(os.path.exists('/mydir'))"
  },
  "snippet": "os.chdir('/mydir')\nfor file in glob.glob('*.txt'):\n    pass"
 },
 "3964681.427": {
  "intent": "find all files in directory \"/mydir\" with extension \".txt\"",
  "body": "How can I find all the files in a directory having the extension .txt  in python?\n",
  "preds": {
   "base:Baseline": "print(os.path.isfile('/mydir', \".txt')",
   "body:Baseline": "print(os.path.dirname('/mydir'))",
   "body:-Blocks": "print(os.path.dirname('/mydir'))",
   "body:-Code": "print(os.path.exists('/mydir', \".txt')",
   "body:-Inline": "print(os.path.dirname('/mydir'))",
   "body:-NL": "os.path.exists('/mydir', '.txt')",
   "base:+Mined": "print(os.listdir('/mydir'))",
   "body+mined:Baseline": "[x for x in os.listdir('/mydir' if x.endswith('.txt'))]",
   "body+mined:-Code": "[x for x in os.listdir('/mydir') if x.endswith('.')]",
   "body+mined:-NL": "[x for x in os.walk('mydir') if x.endswith(' '.txt')]",
   "body+mined:-Blocks": "[x for x in os.listdir('/mydir' if x.endswith('.'))]",
   "body+mined:-Inline": "print(os.path.exists('/mydir'))"
  },
  "snippet": "for file in os.listdir('/mydir'):\n    if file.endswith('.txt'):\n        pass"
 },
 "3964681.428": {
  "intent": "find all files in directory \"/mydir\" with extension \".txt\"",
  "body": "How can I find all the files in a directory having the extension .txt  in python?\n",
  "preds": {
   "base:Baseline": "print(os.path.isfile('/mydir', \".txt')",
   "body:Baseline": "print(os.path.dirname('/mydir'))",
   "body:-Blocks": "print(os.path.dirname('/mydir'))",
   "body:-Code": "print(os.path.exists('/mydir', \".txt')",
   "body:-Inline": "print(os.path.dirname('/mydir'))",
   "body:-NL": "os.path.exists('/mydir', '.txt')",
   "base:+Mined": "print(os.listdir('/mydir'))",
   "body+mined:Baseline": "[x for x in os.listdir('/mydir' if x.endswith('.txt'))]",
   "body+mined:-Code": "[x for x in os.listdir('/mydir') if x.endswith('.')]",
   "body+mined:-NL": "[x for x in os.walk('mydir') if x.endswith(' '.txt')]",
   "body+mined:-Blocks": "[x for x in os.listdir('/mydir' if x.endswith('.'))]",
   "body+mined:-Inline": "print(os.path.exists('/mydir'))"
  },
  "snippet": "for root, dirs, files in os.walk('/mydir'):\n    for file in files:\n        if file.endswith('.txt'):\n            pass"
 },
 "20865487.429": {
  "intent": "plot dataframe `df` without a legend",
  "body": "Using the pandas library in python and using \n.plot()\n\non a dataframe,  how do I display the plot without a legend?\n",
  "preds": {
   "base:Baseline": "df.plot(legend=True)",
   "body:Baseline": "df.set_index(' legend')",
   "body:-Blocks": "df.plot(legend=True)",
   "body:-Code": "df.plot(legend=True)",
   "body:-Inline": "df.plot(key=lambda x: x.legend()",
   "body:-NL": "df.plot(key=lambda x: x[1])",
   "base:+Mined": "df.plot(kind='bar')",
   "body+mined:Baseline": "df.plot(not a legend)",
   "body+mined:-Code": "df.plot(kind='bar')",
   "body+mined:-NL": "df.plot(x, y, 'bo')",
   "body+mined:-Blocks": "df.plot(kind='bar')",
   "body+mined:-Inline": "df.plot(kind='bar')"
  },
  "snippet": "df.plot(legend=False)"
 },
 "13368659.430": {
  "intent": "loop through the ip address range \"192.168.x.x\"",
  "body": "How can I loop through an IP address range in python? Lets say I want to loop through every IP from 192.168.1.1 to 192.168. How can this be done?\n",
  "preds": {
   "base:Baseline": "os.system('192.168.x.x', shell=True)",
   "body:Baseline": "os.system('192.168.x.x').read()",
   "body:-Blocks": "os.system('192.168.x.x')",
   "body:-Code": "os.system('192.168.x.x')",
   "body:-Inline": "loop((192.168).x.x)",
   "body:-NL": "os.system('192.168.x.x', shell=True)",
   "base:+Mined": "os.system('192.168.x.x')",
   "body+mined:Baseline": "loop((192.168).x.x)",
   "body+mined:-Code": "print(list(open('192.168.x.x').read())",
   "body+mined:-NL": "print(os.environ['192.168.x.x'])",
   "body+mined:-Blocks": "print(os.environ['192.168.x.x'])",
   "body+mined:-Inline": "print(open('192.168.x.x').read())"
  },
  "snippet": "for i in range(256):\n    for j in range(256):\n        ip = '192.168.%d.%d' % (i, j)\n        print(ip)"
 },
 "13368659.431": {
  "intent": "loop through the ip address range \"192.168.x.x\"",
  "body": "How can I loop through an IP address range in python? Lets say I want to loop through every IP from 192.168.1.1 to 192.168. How can this be done?\n",
  "preds": {
   "base:Baseline": "os.system('192.168.x.x', shell=True)",
   "body:Baseline": "os.system('192.168.x.x').read()",
   "body:-Blocks": "os.system('192.168.x.x')",
   "body:-Code": "os.system('192.168.x.x')",
   "body:-Inline": "loop((192.168).x.x)",
   "body:-NL": "os.system('192.168.x.x', shell=True)",
   "base:+Mined": "os.system('192.168.x.x')",
   "body+mined:Baseline": "loop((192.168).x.x)",
   "body+mined:-Code": "print(list(open('192.168.x.x').read())",
   "body+mined:-NL": "print(os.environ['192.168.x.x'])",
   "body+mined:-Blocks": "print(os.environ['192.168.x.x'])",
   "body+mined:-Inline": "print(open('192.168.x.x').read())"
  },
  "snippet": "for i, j in product(list(range(256)), list(range(256))):\n    pass"
 },
 "13368659.432": {
  "intent": "loop through the ip address range \"192.168.x.x\"",
  "body": "How can I loop through an IP address range in python? Lets say I want to loop through every IP from 192.168.1.1 to 192.168. How can this be done?\n",
  "preds": {
   "base:Baseline": "os.system('192.168.x.x', shell=True)",
   "body:Baseline": "os.system('192.168.x.x').read()",
   "body:-Blocks": "os.system('192.168.x.x')",
   "body:-Code": "os.system('192.168.x.x')",
   "body:-Inline": "loop((192.168).x.x)",
   "body:-NL": "os.system('192.168.x.x', shell=True)",
   "base:+Mined": "os.system('192.168.x.x')",
   "body+mined:Baseline": "loop((192.168).x.x)",
   "body+mined:-Code": "print(list(open('192.168.x.x').read())",
   "body+mined:-NL": "print(os.environ['192.168.x.x'])",
   "body+mined:-Blocks": "print(os.environ['192.168.x.x'])",
   "body+mined:-Inline": "print(open('192.168.x.x').read())"
  },
  "snippet": "generator = iter_iprange('192.168.1.1', '192.168.255.255', step=1)"
 },
 "4065737.433": {
  "intent": "sum the corresponding decimal values for binary values of each boolean element in list `x`",
  "body": "\nWhat is the fastest (or most \"Pythonic\") way to convert\nx = [False, False, True, True]\n\ninto 12 ? (If there is such a way.)\nWhat if x  were instead a numpy.array  of bools? Is there a special command for that?\n\nI have a large m-by-n array of booleans, where each n-element row represents a single low-dimensional hash of a high-dimensional feature vector. (In the example above, n = 4.) I would like to know the answer in order to compress my data as much as possible. Thank you.\n\nEdit : Thank you for the responses! Using the following test code, \nt = 0\nfor iter in range(500):\n    B = scipy.signbit(scipy.randn(1000,20))\n    for b in B:\n        t0 = time.clock()\n        # test code here\n        t1 = time.clock()\n        t += (t1-t0)\nprint t\n\n<console_out>here were the runtimes on my Thinkpad laptop:\n\nMy answer : 4.26 sec\nSven Marnach 1 : 7.88\nEmil H : 8.51\nSven Marnach 2 : 8.72\ndelnan : 10.14\nliori : 53.49\n\nOf course, I welcome any independent tests that may confirm or refute my data!\n\nEdit : In my answer below, changing int(j)  to simply j  still works, but runs six times as slow! Then perhaps the other answers would become faster if the bool was casted using int . But I'm too lazy to test everything again.\n\nEdit : liori posted results of independent tests here .\n",
  "preds": {
   "base:Baseline": "[int(x) for x in bin(x)]",
   "body:Baseline": "sum(i, j) for i, j in zip(x, b))",
   "body:-Blocks": "np.sum(int(x))",
   "body:-Code": "sum(x[0] for x in bin(x))",
   "body:-Inline": "[int(x) for x in range(500)]",
   "body:-NL": "sum(x.decode('hex') for x in binascii.values())",
   "base:+Mined": "[(int(x) / float(y)) for x in L]",
   "body+mined:Baseline": "x = [(int(i) for i in range(0, len(x))])",
   "body+mined:-Code": "[(float(i) for i in range(len(x))]",
   "body+mined:-NL": "numpy.array(list(range(1000)), dtype=bool)",
   "body+mined:-Blocks": "np.concatenate((i, j))",
   "body+mined:-Inline": "x = [(int(i) for i in x) if i == 0]"
  },
  "snippet": "sum(1 << i for i, b in enumerate(x) if b)"
 },
 "8691311.434": {
  "intent": "write multiple strings `line1`, `line2` and `line3` in one line in a file `target`",
  "body": "I've started to learn Python with LPTHW and I've gotten to exercise 16:\nhttp://learnpythonthehardway.org/book/ex16.html\nAnd feel like an idiot because I can't figure out one of the seemingly simple \"extra credit\" assignments that wants the following:\ntarget.write(line1)\ntarget.write('\\n')\ntarget.write(line2)\ntarget.write('\\n') \ntarget.write(line3)\ntarget.write('\\n') \n\nTo be condensed to one line of code. I've tried some of the following:\ntarget.write(line1 \\n, line2 \\n, line3 \\n)\n\nOr:\ntarget.write('line1 \\n, line2 \\n, line3 \\n')\n\nOr:\ntarget.write(%r \\n, %r \\n, %r \\n) % (line1, line2, line3)\n\nI just can't get it to rewrite the line1, line2, and line3 strings all in the same line.  And I've tried various other combinations with and without commas, quotes, etc. I keep getting varying errors, like Invalid Syntax or that I have too many arguments.\n",
  "preds": {
   "base:Baseline": "target.write(line1, line2, line3)",
   "body:Baseline": "target.write(line1, line2, line3)",
   "body:-Blocks": "print(target.write(line1, line2, line3))",
   "body:-Code": "print(target.write(line1, line2, line3))",
   "body:-Inline": "target.write(line1, line2, line3)",
   "body:-NL": "target.write(line1, line2, line3)",
   "base:+Mined": "f.write('\\n'.join(line1, line2))",
   "body+mined:Baseline": "target.write(line1, line2, line3)",
   "body+mined:-Code": "f.write('\\n'.join(line1, line2, line3))",
   "body+mined:-NL": "target.write(line1, line2, line3)",
   "body+mined:-Blocks": "f.write('\\n'.join(line1, line2, line3))",
   "body+mined:-Inline": "target.write(line1, line2, line3)"
  },
  "snippet": "target.write('%r\\n%r\\n%r\\n' % (line1, line2, line3))"
 },
 "10632111.435": {
  "intent": "convert list of lists `data` into a flat list",
  "body": "I have a list of objects where objects can be lists or scalars. I want an flattened list with only scalars.\nEg:\nL = [35,53,[525,6743],64,63,[743,754,757]]\noutputList = [35,53,525,6743,64,63,743,754,757]\n\nP.S. The answers in this question does not work for heterogeneous lists. Flattening a shallow list in Python\n",
  "preds": {
   "base:Baseline": "[list(data)) for i in data]",
   "body:Baseline": "list(data, key=operator.itemgetter(1))",
   "body:-Blocks": "[x for x in data if x is scalar]",
   "body:-Code": "map(list, zip(*data))",
   "body:-Inline": "map(list, zip(*data))",
   "body:-NL": "list(data.items()), key=lambda x: x[1])",
   "base:+Mined": "map(list, zip(*data))",
   "body+mined:Baseline": "[[35, 53, 525, 6743, 64, 63, 743, 754, 757]]",
   "body+mined:-Code": "[x for x in data for y in sorted(data)]",
   "body+mined:-NL": "list(itertools.chain(*data))",
   "body+mined:-Blocks": "[x for x in data for y in x]",
   "body+mined:-Inline": "[[35, 53, 525, 6743, 64, 63, 743, 754, 757]]"
  },
  "snippet": "[y for x in data for y in (x if isinstance(x, list) else [x])]"
 },
 "15392730.436": {
  "intent": "print new line character as `\\n` in a string `foo\\nbar`",
  "body": "I want the newline \\n  to show up explicitly when printing a string retrieved from elsewhere. So if the string is 'abc\\ndef' I don't want this to happen:\nprint(line)\nabc\ndef\n\nbut instead this:\nprint(line)\nabc\\ndef\n\nIs there a way to modify print, or modify the argument, or maybe another function entirely, to accomplish this?\n",
  "preds": {
   "base:Baseline": "print('\\n', 'foo\\nbar')",
   "body:Baseline": "print('foo\\nbar'.format(\\n))",
   "body:-Blocks": "print('foo\\nbar'.rstrip('\\n')",
   "body:-Code": "print('\\n', 'foo\\nbar')",
   "body:-Inline": "print('\\n'.join(line) for line in 'foo\\nbar')",
   "body:-NL": "print(('foo\\nbar', '\\n')",
   "base:+Mined": "print('\\n'.join(foo\\nbar))",
   "body+mined:Baseline": "print('\\n'.join(foo\\nbar))",
   "body+mined:-Code": "print('\\n'.join(foo\\nbar))",
   "body+mined:-NL": "print('\\n'.join(foo))",
   "body+mined:-Blocks": "print('\\n'.join(foo\\nbar))",
   "body+mined:-Inline": "print('\\n'.join(foo\\nbar))"
  },
  "snippet": "print('foo\\nbar'.encode('string_escape'))"
 },
 "1010961.437": {
  "intent": "remove last comma character ',' in string `s`",
  "body": "I have a string, example:\ns = \"this is a string, a\"\n\nWhere a ','  (comma) will always be the 3rd to the last character, aka s[-3] .\nI am thinking of ways to remove the ',' but can only think of converting the string into a list, deleting it, and converting it back to a string. This however seems a bit too much for simple task. \nHow can I accomplish this in a simpler way?\n",
  "preds": {
   "base:Baseline": "s = s.replace(',')",
   "body:Baseline": "s = s.replace(',', '')",
   "body:-Blocks": "s.replace(',', '')",
   "body:-Code": "s = s.replace(',', '')",
   "body:-Inline": "s = s.replace(',', '')",
   "body:-NL": "s = s.replace(',', ',')",
   "base:+Mined": "s = s.replace(',', '')",
   "body+mined:Baseline": "s = s.replace(',', '')",
   "body+mined:-Code": "s.replace(',', '')",
   "body+mined:-NL": "s = s.replace(',', '')",
   "body+mined:-Blocks": "s.replace(',', '')",
   "body+mined:-Inline": "s = s.replace(',', '')"
  },
  "snippet": "\"\"\"\"\"\".join(s.rsplit(',', 1))"
 },
 "23855976.438": {
  "intent": "calculate the mean of each element in array `x` with the element previous to it",
  "body": "I have an array of the form:\nx = np.array([ 1230.,  1230.,  1227.,  1235.,  1217.,  1153.,  1170.])\nand I would like to produce another array where the values are the mean of each pair of values within my original array:\nxm = np.array([ 1230.,  1228.5,  1231.,  1226.,  1185.,  1161.5])\nSomeone knows the easiest and fast way to do it without using loops? \n",
  "preds": {
   "base:Baseline": "np.mean(x, y)",
   "body:Baseline": "np.array([sum(x)) / np.mean(x, y))",
   "body:-Blocks": "np.array([x[0], x[0] - x[1]))",
   "body:-Code": "np.mean(x, y)",
   "body:-Inline": "x = np.mean(np.arange(x))",
   "body:-NL": "np.mean(np.arange(x, axis=1).mean(axis=1))",
   "base:+Mined": "np.mean(x, y)",
   "body+mined:Baseline": "x.mean(axis=1)",
   "body+mined:-Code": "np.mean(x, y)",
   "body+mined:-NL": "x = np.mean(np.arange(x.shape[0]), xm)",
   "body+mined:-Blocks": "np.mean(x, y)",
   "body+mined:-Inline": "x.mean(axis=1)"
  },
  "snippet": "(x[1:] + x[:-1]) / 2"
 },
 "23855976.439": {
  "intent": "get an array of the mean of each two consecutive values in numpy array `x`",
  "body": "I have an array of the form:\nx = np.array([ 1230.,  1230.,  1227.,  1235.,  1217.,  1153.,  1170.])\nand I would like to produce another array where the values are the mean of each pair of values within my original array:\nxm = np.array([ 1230.,  1228.5,  1231.,  1226.,  1185.,  1161.5])\nSomeone knows the easiest and fast way to do it without using loops? \n",
  "preds": {
   "base:Baseline": "np.arange(x, y)",
   "body:Baseline": "np.array([sum(x, y)) / np.mean(y))",
   "body:-Blocks": "np.array([np.mean(x, y)) / np.mean([2, 3], axis=1)]",
   "body:-Code": "np.mean(x, y)",
   "body:-Inline": "np.mean(x, y)",
   "body:-NL": "np.arange(np.mean(x, y))",
   "base:+Mined": "np.mean(x, y, axis=1)",
   "body+mined:Baseline": "x = np.mean(x[:, (np.arange(1), x[2]))",
   "body+mined:-Code": "np.mean(x, axis=1)",
   "body+mined:-NL": "np.mean(x[:, (np.arange(len(x)) - len(x), -1)]",
   "body+mined:-Blocks": "np.mean(x, y)",
   "body+mined:-Inline": "x = np.mean(axis=1)"
  },
  "snippet": "x[:-1] + (x[1:] - x[:-1]) / 2"
 },
 "6375343.440": {
  "intent": "load data containing `utf-8` from file `new.txt` into numpy array `arr`",
  "body": "Consider a text file called \"new.txt\" containing the following elements:\nmm\nr\nl\n\nIn Python 2.7, I can read the file by typing:\nimport codecs\nf = codecs.open('new.txt', encoding='utf-8')\nlines = [line.strip() for line in f2.readlines()]\nlines\n[u'\\u03bcm', u'\\u2202r', u'\\u2206\\u03bb']\nprint lines[0]\nmm\n\nSo far so good. I can easily convert this list to a numpy array via:\nimport numpy as np\narr = np.array(lines)\narr\narray([u'\\u03bcm', u'\\u2202r', u'\\u2206\\u03bb'], \n      dtype=' <U2')\n\nThe issue is, I can't read this file directly via numpy's loadtxt function:\nnp.loadtxt('new.txt', dtype=np.unicode_)\nTraceback (most recent call last):\n  File \" <stdin>\", line 1, in <module>\n  File \"/usr/lib64/python2.7/site-packages/numpy/lib/npyio.py\", line 805, in loadtxt\n    X = np.array(X, dtype)\nUnicodeDecodeError: 'ascii' codec can't decode byte 0xce in position 0: ordinal not in range(128)\n\nWhat is the correct way to read this file into numpy directly?\nThanks.\n",
  "preds": {
   "base:Baseline": "arr.load(new.txt, encoding='utf-8')",
   "body:Baseline": "np.loadtxt('new.txt', encoding='utf-8')",
   "body:-Blocks": "arr = numpy.loadtxt('new.txt')",
   "body:-Code": "arr = numpy.loadtxt(open('new.txt', 'utf-8')",
   "body:-Inline": "arr.loadtxt('new.txt', encoding='utf-8')",
   "body:-NL": "arr = np.loadtxt('new.txt', encoding='utf-8')",
   "base:+Mined": "arr = numpy.loadtxt(new.txt, encoding='utf-8')",
   "body+mined:Baseline": "arr = np.loadtxt('new.txt', encoding='utf-8')",
   "body+mined:-Code": "arr = numpy.loadtxt(new.txt)",
   "body+mined:-NL": "np.loadtxt('new.txt', dtype='\u2206\u03bb')",
   "body+mined:-Blocks": "arr = numpy.loadtxt(open('new.txt', 'rb').read())",
   "body+mined:-Inline": "arr = np.loadtxt('new.txt', encoding='utf-8')"
  },
  "snippet": "arr = numpy.fromiter(codecs.open('new.txt', encoding='utf-8'), dtype='<U2')"
 },
 "1547733.441": {
  "intent": "reverse sort list of dicts `l` by value for key `time`",
  "body": "[ {'time':33}, {'time':11}, {'time':66} ]\nHow to sort by the \"time\" element, DESC.\n",
  "preds": {
   "base:Baseline": "sorted(l, key=lambda x: x[1])",
   "body:Baseline": "sorted(L, key=itemgetter(time))",
   "body:-Blocks": "sorted(l, key=lambda x: [{'time': 33}, {'time': 11}, {'Time': 66}])",
   "body:-Code": "l.sort(key=lambda x: (x[1], x[1])",
   "body:-Inline": "sorted(l, key=lambda x: x[1])",
   "body:-NL": "sorted(L, key=lambda t: t.time)",
   "base:+Mined": "sorted(l, key=lambda t: t.time)",
   "body+mined:Baseline": "sorted(l, key=itemgetter(1), reverse=True)",
   "body+mined:-Code": "sorted(l, key=lambda t: t.time())",
   "body+mined:-NL": "sorted(L, key=time.itemgetter(1))",
   "body+mined:-Blocks": "sorted(l, key=lambda x: (x['time'], x['time']))",
   "body+mined:-Inline": "sorted(L, key=lambda t: t[1])"
  },
  "snippet": "l = sorted(l, key=itemgetter('time'), reverse=True)"
 },
 "1547733.442": {
  "intent": "sort a list of dictionary `l` based on key `time` in descending order",
  "body": "[ {'time':33}, {'time':11}, {'time':66} ]\nHow to sort by the \"time\" element, DESC.\n",
  "preds": {
   "base:Baseline": "sorted(l, key=lambda x: (x[1], reverse=True)",
   "body:Baseline": "sorted(list(L.items()), key=lambda x: x[1], reverse=True)",
   "body:-Blocks": "sorted(l, key=lambda x: (x[1], x[1]), reverse=True)",
   "body:-Code": "sorted(l, key=lambda x: (x[1], x[1]), reverse=True)",
   "body:-Inline": "sorted(l, key=lambda x: x['time'])",
   "body:-NL": "sorted(L, key=operator.itemgetter(time))",
   "base:+Mined": "sorted(l, key=lambda x: (x[1], x[0]))",
   "body+mined:Baseline": "sorted(l, key=itemgetter(1), reverse=True)",
   "body+mined:-Code": "sorted(l, key=lambda x: x['time'] == 'time')",
   "body+mined:-NL": "sorted(L, key=lambda x: x[1])",
   "body+mined:-Blocks": "sorted(l, key=lambda item: item[1]['time'], reverse=True)",
   "body+mined:-Inline": "sorted(L, key=lambda x: (x['time'] == 'time'])"
  },
  "snippet": "l = sorted(l, key=lambda a: a['time'], reverse=True)"
 },
 "37080612.443": {
  "intent": "get rows of dataframe `df` that match regex '(hel|just)'",
  "body": "I don't understand pandas\nDataFrame\nfilter .\nSetup\nimport pandas as pd\n\ndf = pd.DataFrame(\n    [\n        ['Hello', 'World'],\n        ['Just', 'Wanted'],\n        ['To', 'Say'],\n        ['I\\'m', 'Tired']\n    ]\n)\n\nProblem\ndf.filter([0], regex=r'(Hel|Just)', axis=0)\n\nI'd expect the [0]  to specify the 1st column as the one to look at and axis=0  to specify filtering rows.  What I get is this:\n       0      1\n0  Hello  World\n\nI was expecting\n       0       1\n0  Hello   World\n1   Just  Wanted\n\nQuestion\n\nWhat would have gotten me what I expected?\n\n",
  "preds": {
   "base:Baseline": "df.groupby(['hel|just'])",
   "body:Baseline": "df.filter([0], regex='(Hel|Just)', axis=0)",
   "body:-Blocks": "df.groupby(['hel|just'])",
   "body:-Code": "df.filter(re.search('hel|just)'))",
   "body:-Inline": "df.groupby('(Hel|Just)', axis=0)",
   "body:-NL": "df.set_index('(Hel|Just)', axis=0)",
   "base:+Mined": "df.loc[df.groupby('hel|just)']",
   "body+mined:Baseline": "df.filter([0], regex='(Hel|Just)', axis=0)",
   "body+mined:-Code": "df.query('(hel|just)')",
   "body+mined:-NL": "df[df.groupby('Just')['Wanted'].apply(lambda x: x.Tired)",
   "body+mined:-Blocks": "df.groupby(['hel|just']).apply(lambda x: x[1])",
   "body+mined:-Inline": "df.filter([0], regex=r('(Hel|Just)', axis=0)"
  },
  "snippet": "df.loc[df[0].str.contains('(Hel|Just)')]"
 },
 "14716342.444": {
  "intent": "find the string in `your_string` between two special characters \"[\" and \"]\"",
  "body": "For example, I need everything in between the two square brackets.\nFile1\n[Home sapiens]\n[Mus musculus 1]\n[virus 1 [isolated from china]]\n\nSo considering the above example, I need everything in between the first and last square brackets.\n",
  "preds": {
   "base:Baseline": "your_string.split(' ', '')",
   "body:Baseline": "your_string.replace(' ', '')",
   "body:-Blocks": "your_string.replace(' ', '')",
   "body:-Code": "your_string.replace(' ', '')",
   "body:-Inline": "your_string.replace(' ', '')",
   "body:-NL": "print(your_string.split(', ', '))",
   "base:+Mined": "your_string.find(string)",
   "body+mined:Baseline": "re.findall('\\\\[\\\\]', your_string)",
   "body+mined:-Code": "your_string.find('[^\"]+)', your_string)",
   "body+mined:-NL": "re.findall('\\\\s+', your_string)",
   "body+mined:-Blocks": "your_string.find_all('[\"[\" and ']\"])",
   "body+mined:-Inline": "your_string.split(',')[1]"
  },
  "snippet": "re.search('\\\\[(.*)\\\\]', your_string).group(1)"
 },
 "18684076.445": {
  "intent": "how to create a list of date string in 'yyyymmdd' format with python pandas?",
  "body": "I want a list of date range in which each element is 'yyyymmdd'  format string, such as : ['20130226','20130227','20130228','20130301','20130302']  .\nI can use pandas to do so:\npandas.date_range('20130226','20130302')\n<class 'pandas.tseries.index.DatetimeIndex'>\n[2013-02-26 00:00:00, <console_out>, 2013-03-02 00:00:00]\nLength: 5, Freq: D, Timezone: None\n\nBut it is DatetimeIndex and I need to do some extra format transform, so how to do that in a neat way ? \n",
  "preds": {
   "base:Baseline": "df['Date'].strftime('yyyymmdd')",
   "body:Baseline": "pandas.date_range('yyyymmdd').strftime('%Y-%m-%d')",
   "body:-Blocks": "df = pd.datetime.strptime('yyyymmdd')",
   "body:-Code": "df = datetime.datetime.strptime('yyyymmdd')",
   "body:-Inline": "df.strftime('yyyymmdd')",
   "body:-NL": "pandas.date_range('yyyymmdd').strftime('%Y-%m-%d')",
   "base:+Mined": "df['Date'].strftime('%Y-%m-%d')",
   "body+mined:Baseline": "pandas.date_range('20130226', '20130302')",
   "body+mined:-Code": "df.date.strftime('%Y%m%d')",
   "body+mined:-NL": "df.date_range('20130226', '20130302')",
   "body+mined:-Blocks": "df['%Y%m%d'].strftime('%H:%M%S')",
   "body+mined:-Inline": "pandas.tseries.index.date_range('20130226', '20130302')"
  },
  "snippet": "[d.strftime('%Y%m%d') for d in pandas.date_range('20130226', '20130302')]"
 },
 "1666700.446": {
  "intent": "count number of times string 'brown' occurred in string 'the big brown fox is brown'",
  "body": "In python, I remember there is a function to do this.\n.count? \n\"The big brown fox is brown\"\nbrown = 2.\n",
  "preds": {
   "base:Baseline": "\"\"\"The big brown fox is brown\"\"\".count('brown')",
   "body:Baseline": "count('The big brown fox is brown')",
   "body:-Blocks": "\"\"\"The big brown fox is brown\"\"\".count('brown')",
   "body:-Code": "\"\"\"The big brown fox is brown\"\"\".count('brown')",
   "body:-Inline": "\"\"\"The big brown fox is brown\"\"\".count('brown')",
   "body:-NL": "\"\"\"The big brown fox is brown\"\"\".count('b')",
   "base:+Mined": "len('the big brown fox is brown')",
   "body+mined:Baseline": "\"\"\"The big brown fox is brown\"\"\".count()",
   "body+mined:-Code": "\"\"\"The big brown fox is brown\"\"\".count('brown')",
   "body+mined:-NL": "len('the big brown fox is brown') - len('brown')",
   "body+mined:-Blocks": "\"\"\"The big brown fox is brown\"\"\".count('brown')",
   "body+mined:-Inline": "len('The big brown fox is brown').count()"
  },
  "snippet": "\"\"\"The big brown fox is brown\"\"\".count('brown')"
 },
 "18979111.447": {
  "intent": "decode json string `request.body` to python dict",
  "body": "I have a request like this:\n$http({ \n    method: 'POST', \n    url: '/url/', \n    data: 'test=data'\n})\n\nIn my django views:\nclass SomeClass(View):\n    def get(self, request):\n        return HttpResponse(\"Hello\")\n    def post(self, request):\n        print request.post\n        print request.body\n        return HttpResponse(\"Done\")\n\nSo when I do request.POST   I get an empty query dict : <QueryDict: {}>\nBut my request.body  has: test=data\nSo I believe django receives the data as url-encoded parameters and not as a dictionary.\nHow do I send or receive this data as JSON/Dict ?\n",
  "preds": {
   "base:Baseline": "dict(request.body.decode('utf-8'))",
   "body:Baseline": "request.body.decode('json')",
   "body:-Blocks": "request.body.decode('json')",
   "body:-Code": "dict(request.body.decode('utf-8'))",
   "body:-Inline": "request.body.decode('json')",
   "body:-NL": "request.body.decode('json')",
   "base:+Mined": "json.dumps(request.body, ensure_ascii=False)",
   "body+mined:Baseline": "dict(request.body.decode('utf-8'))",
   "body+mined:-Code": "request.body.decode('json')",
   "body+mined:-NL": "print(request.body.decode('json'))",
   "body+mined:-Blocks": "json.dumps(request.body.decode('utf-8'))",
   "body+mined:-Inline": "{'data': 'test=data'}"
  },
  "snippet": "json.loads(request.body)"
 },
 "7243750.448": {
  "intent": "download the file from url `url` and save it under file `file_name`",
  "body": "I am creating a program that will download a .jar (java) file from a web server, by reading the URL that is specified in the .jad file of the same game/application. I'm using Python 3.2.1\nI've managed to extract the URL of the JAR file from the JAD file (every JAD file contains the URL to the JAR file), but as you may imagine, the extracted value is type() string. \nHere's the relevant function:\ndef downloadFile(URL=None):\n    import httplib2\n    h = httplib2.Http(\".cache\")\n    resp, content = h.request(URL, \"GET\")\n    return content\n\ndownloadFile(URL_from_file)\n\nHowever I always get an error saying that the type in the function above has to be bytes, and not string. I've tried using the URL.encode('utf-8'), and also bytes(URL,encoding='utf-8'), but I'd always get the same or similar error.\nSo basically my question is how to download a file from a server when the URL is stored in a string type?\n",
  "preds": {
   "base:Baseline": "urllib.request.urlretrieve(url)",
   "body:Baseline": "urllib.request.url, filename_name=file_name)",
   "body:-Blocks": "urllib.request.urlopen('file_name')",
   "body:-Code": "open('file_name', url)",
   "body:-Inline": "urllib.request.urlretrieve(file_name)",
   "body:-NL": "urllib.request.urlretrieve(file_name)",
   "base:+Mined": "file_name = open('url', 'rb').read()",
   "body+mined:Baseline": "urllib.request.urlretrieve('http://example.com', file_name)",
   "body+mined:-Code": "urllib.request.urlretrieve('download.jar', file_name)",
   "body+mined:-NL": "urllib.request.urlretrieve('http://stackoverflow.com', filename)",
   "body+mined:-Blocks": "urllib.request.urlopen(url, 'file_name').read()",
   "body+mined:-Inline": "urllib.request.urlretrieve('http://example.com', file_name)"
  },
  "snippet": "urllib.request.urlretrieve(url, file_name)"
 },
 "743806.449": {
  "intent": "split string `text` by space",
  "body": "I want my Python function to split a sentence (input) and store each word in a list. My current code splits the sentence, but does not store the words as a list. How do I do that?\ndef split_line(text):\n\n    # split the text\n    words = text.split()\n\n    # for each word in the line:\n    for word in words:\n\n        # print the word\n        print(words)\n\n",
  "preds": {
   "base:Baseline": "re.split('\\\\w+', text)",
   "body:Baseline": "s = text.split(',', text)",
   "body:-Blocks": "[x for x in text if x.split()]",
   "body:-Code": "re.split('\\\\w+', text)",
   "body:-Inline": "text = text.split(',')",
   "body:-NL": "print(text.split()).split()",
   "base:+Mined": "re.split('\\\\s+', text)",
   "body+mined:Baseline": "words = text.split(',')",
   "body+mined:-Code": "re.split('\\\\s+', text)",
   "body+mined:-NL": "re.split('\\\\s+', text)",
   "body+mined:-Blocks": "re.split('\\\\s+', text)",
   "body+mined:-Inline": "words = text.split(',')"
  },
  "snippet": "text.split()"
 },
 "743806.450": {
  "intent": "split string `text` by \",\"",
  "body": "I want my Python function to split a sentence (input) and store each word in a list. My current code splits the sentence, but does not store the words as a list. How do I do that?\ndef split_line(text):\n\n    # split the text\n    words = text.split()\n\n    # for each word in the line:\n    for word in words:\n\n        # print the word\n        print(words)\n\n",
  "preds": {
   "base:Baseline": "text = re.sub('(?)', ',')",
   "body:Baseline": "s = text.split(',', text)",
   "body:-Blocks": "text = re.split(',\")",
   "body:-Code": "re.split('(?=,)', text)",
   "body:-Inline": "text = text.split(',')",
   "body:-NL": "print(text.split()).split()",
   "base:+Mined": "re.split('(.)', text)",
   "body+mined:Baseline": "words = text.split(',')",
   "body+mined:-Code": "re.split('(?<=.)', text)",
   "body+mined:-NL": "re.split('\\\\s+', text)",
   "body+mined:-Blocks": "re.split('(?<=.)', text)",
   "body+mined:-Inline": "words = text.split(',')"
  },
  "snippet": "text.split(',')"
 },
 "743806.451": {
  "intent": "split string `line` into a list by whitespace",
  "body": "I want my Python function to split a sentence (input) and store each word in a list. My current code splits the sentence, but does not store the words as a list. How do I do that?\ndef split_line(text):\n\n    # split the text\n    words = text.split()\n\n    # for each word in the line:\n    for word in words:\n\n        # print the word\n        print(words)\n\n",
  "preds": {
   "base:Baseline": "[item for item in line if item.strip()]",
   "body:Baseline": "list(re.split('line', ''))",
   "body:-Blocks": "[x for x in line if x.split()]",
   "body:-Code": "[item for item in line if item in item]",
   "body:-Inline": "list(itertools.split(line))",
   "body:-NL": "list(itertools.groupby(line))",
   "base:+Mined": "[line.strip() for line in line.split()]",
   "body+mined:Baseline": "words = [split(line) for line in words]",
   "body+mined:-Code": "[line.split() for line in input]",
   "body+mined:-NL": "words = [line.split() for line in words]",
   "body+mined:-Blocks": "[line.split() for line in re.split(',')]",
   "body+mined:-Inline": "words = [line.split() for line in words]"
  },
  "snippet": "line.split()"
 },
 "35044115.452": {
  "intent": "replace dot characters  '.' associated with ascii letters in list `s` with space ' '",
  "body": "Using Python, I have the following strings:\n['taxes.............................       .7        21.4    (6.2)','regulatory and other matters..................$   39.9        61.5        41.1','Producer contract reformation cost recoveries............................   DASH        26.3        28.3']\n\nI need to replace each of the dots with a space, but not the periods in the numbers.  So the result should look like this:\n['taxes                                    .7        21.4    (6.2)','regulatory and other matters                  $   39.9        61.5        41.1','Producer contract reformation cost recoveries                               DASH        26.3        28.3']\n\nI've tried the following:\ndots=re.compile('(\\.{2,})(\\s*?[\\d\\(\\$]|\\s*?DASH|\\s*.)')\nnewlist=[]\nfor each in list:\n    newline=dots.sub(r'\\2'.replace('.',' '),each)\n    newdoc.append(newline)\n\nBut, this code doesn't retain the white space.  Thanks!\n",
  "preds": {
   "base:Baseline": "s = s.replace('.', '.')",
   "body:Baseline": "re.compile('(\\\\.{2,})(\\\\s*?[\\\\d\\\\(\\\\$]|\\\\S*?DASH|\\\\s*.)')",
   "body:-Blocks": "s = s.replace('.', '.')",
   "body:-Code": "s = s.replace('.', '')",
   "body:-Inline": "re.sub('(\\\\.{2,})(\\\\s*?[\\\\d\\\\(\\\\$]|\\\\s*?)', '.')",
   "body:-NL": "re.sub('(\\\\.{2,})(\\\\s*?)', '', s)",
   "base:+Mined": "s = s.replace('.', '')",
   "body+mined:Baseline": "s.replace('.', '\\\\2', '')",
   "body+mined:-Code": "s = s.replace('.', '.')",
   "body+mined:-NL": "newline = [dots.sub('\\\\2', '.') for dots in s.split(',')]",
   "body+mined:-Blocks": "s = s.replace('.', '.')",
   "body+mined:-Inline": "s = [s.replace('.', '') for s in s.split(',')]"
  },
  "snippet": "[re.sub('(?<!\\\\d)\\\\.(?!\\\\d)', '', i) for i in s]"
 },
 "38388799.453": {
  "intent": "sort list `list_of_strings` based on second index of each string `s`",
  "body": "Overview: I have data something like this (each row is a string):\n\n81:0A:D7:19:25:7B, 2016-07-14 14:29:13 , 2016-07-14 14:29:15, -69, 22:22:22:22:22:23,null,^M\n3B:3F:B9:0A:83:E6, 2016-07-14 01:28:59 , 2016-07-14 01:29:01, -36, 33:33:33:33:33:31,null,^M\nB3:C0:6E:77:E5:31, 2016-07-14 08:26:45 , 2016-07-14 08:26:47, -65, 33:33:33:33:33:32,null,^M\n61:01:55:16:B5:52, 2016-07-14 06:25:32 , 2016-07-14 06:25:34, -56, 33:33:33:33:33:33,null,^M\n\nAnd I want to sort each row based on the first timestamp that is present in the each String, which for these four records is:\n\n2016-07-14 01:28:59\n2016-07-14 06:25:32\n2016-07-14 08:26:45\n2016-07-14 14:29:13\n\nNow I know the sort()  method but I don't understand how can I use here to sort all the rows based on this (timestamp) quantity, and I do need to keep the final sorted data in the same format as some other service is going to use it.\nI also understand I can make the key()  but I am not clear how that can be made to sort on the timestamp field.\n",
  "preds": {
   "base:Baseline": "sorted(list_of_strings, key=lambda x: x[1])",
   "body:Baseline": "sorted(list_of_strings, key=lambda x: x[1], reverse=True)",
   "body:-Blocks": "sorted(list_of_strings, key=lambda x: x[1])",
   "body:-Code": "list_of_strings.sort(key=lambda x: x[1])",
   "body:-Inline": "sorted_list(list_of_strings, key=lambda x: x[1])",
   "body:-NL": "sorted(list_of_strings, key=lambda x: x[1])",
   "base:+Mined": "sorted(list_of_strings, key=lambda x: x[1])",
   "body+mined:Baseline": "sorted(list_of_strings, key=lambda x: int(x[1]))",
   "body+mined:-Code": "sorted(list_of_strings, key=lambda x: x[1])",
   "body+mined:-NL": "list_of_strings.sort(key=lambda x: x[1])",
   "body+mined:-Blocks": "sorted(list_of_strings, key=lambda x: x[1]))",
   "body+mined:-Inline": "sorted(list_of_strings, key=lambda x: int(x[1]))"
  },
  "snippet": "sorted(list_of_strings, key=lambda s: s.split(',')[1])"
 },
 "9609375.454": {
  "intent": "call multiple bash function 'vasp' and 'tee tee_output' using '|'",
  "body": "I am using a scientific software (called vasp) that works only in bash, and using Python to create a script that will make multiple runs for me. When I use subprocess.check_call to call the function normally, it works fine, but when i add the '| tee tee_output' it doesn't work. \nsubprocess.check_call('vasp') #this works\nsubprocess.check_call('vasp | tee tee_output') #this doesn't\n\nI am a noobie to python and programming altogether. \n",
  "preds": {
   "base:Baseline": "subprocess.call('vasp', 'tee tee_output', '|')",
   "body:Baseline": "subprocess.check_call('vasp', 'tee tee_output')",
   "body:-Blocks": "subprocess.call('vasp', 'tee tee_output', '|')",
   "body:-Code": "subprocess.call('vasp', 'tee tee_output', '|')",
   "body:-Inline": "subprocess.check_call('vasp', 'tee tee_output')",
   "body:-NL": "subprocess.call('vasp', 'tee tee_output')",
   "base:+Mined": "subprocess.call('vasp', shell=True)",
   "body+mined:Baseline": "subprocess.check_call('vasp | tee tee_output')",
   "body+mined:-Code": "subprocess.check_call('vasp', shell=True)",
   "body+mined:-NL": "subprocess.check_call('vasp | tee tee_output', shell=True)",
   "body+mined:-Blocks": "subprocess.check_call('vasp', shell=True)",
   "body+mined:-Inline": "subprocess.check_call('vasp | tee tee_output')"
  },
  "snippet": "subprocess.check_call('vasp | tee tee_output', shell=True)"
 },
 "37004138.455": {
  "intent": "eliminate all strings from list `lst`",
  "body": "my question is how to eliminate all strings from a list, for example if I have  list=['hello',1,2,3,4,'goodbye','help']  and the outcome to be list=[1,2,3,4]\n",
  "preds": {
   "base:Baseline": "del lst[::-1]",
   "body:Baseline": "[x for x in lst if x not in x]",
   "body:-Blocks": "[x for x in lst if x not in x]",
   "body:-Code": "del lst[::-1]",
   "body:-Inline": "del lst[::-1]",
   "body:-NL": "del lst[::-1]",
   "base:+Mined": "\"\"\"\"\"\".join(lst)",
   "body+mined:Baseline": "[x for x in lst if x not in list]",
   "body+mined:-Code": "[k for k, v in lst if len(v)!= 'all')",
   "body+mined:-NL": "list(itertools.chain.from_iterable(lst))",
   "body+mined:-Blocks": "list = [x for x in lst if len(x) == 'hello')]",
   "body+mined:-Inline": "[x for x in lst if x is not None]"
  },
  "snippet": "[element for element in lst if isinstance(element, int)]"
 },
 "37004138.456": {
  "intent": "get all the elements except strings from the list 'lst'.",
  "body": "my question is how to eliminate all strings from a list, for example if I have  list=['hello',1,2,3,4,'goodbye','help']  and the outcome to be list=[1,2,3,4]\n",
  "preds": {
   "base:Baseline": "[x for x in lst if x not in x]",
   "body:Baseline": "[x for x in lst if x not in x]",
   "body:-Blocks": "[x for x in lst if x not in x]",
   "body:-Code": "[x for x in lst if not x in x]",
   "body:-Inline": "[x for x in Lst if x not in lst]",
   "body:-NL": "[x for x in lst if x not in x]",
   "base:+Mined": "[lst for lst in lst]",
   "body+mined:Baseline": "[x for x in lst if x != 'lst']",
   "body+mined:-Code": "[x for x in lst if x is not None]",
   "body+mined:-NL": "list(itertools.chain.from_iterable(lst))",
   "body+mined:-Blocks": "list = [x for x in lst if x.startswith('hello')]",
   "body+mined:-Inline": "[x for x in lst if x != 'lst']"
  },
  "snippet": "[element for element in lst if not isinstance(element, str)]"
 },
 "72899.457": {
  "intent": "sort a list of dictionaries `list_to_be_sorted` by the value of the dictionary key `name`",
  "body": "I have a list of dictionaries and want each item to be sorted by a specific value.\nTake into consideration the list:\n[{'name':'Homer', 'age':39}, {'name':'Bart', 'age':10}]\n\nWhen sorted by name , it should become:\n[{'name':'Bart', 'age':10}, {'name':'Homer', 'age':39}]\n\n",
  "preds": {
   "base:Baseline": "sorted(list_to_be_sorted, key=lambda d: d[name])",
   "body:Baseline": "sorted(list_to_be_sorted, key=lambda kname: kname[kname])",
   "body:-Blocks": "sorted(list_to_be_sorted, key=lambda d: d[name])",
   "body:-Code": "sorted(list_to_be_sorted, key=lambda d: d[name])",
   "body:-Inline": "sorted(list_to_be_sorted, key=lambda d: d[name])",
   "body:-NL": "sorted(list_to_be_sorted, key=lambda x: x[1])",
   "base:+Mined": "sorted(list_to_be_sorted, key=lambda d: d['name'])",
   "body+mined:Baseline": "sorted(list_to_be_sorted, key=lambda x: x['name'], reverse=True)",
   "body+mined:-Code": "sorted(list_to_be_sorted, key=lambda d: d['name'])",
   "body+mined:-NL": "sorted(list_to_be_sorted, key=lambda d: d['name'], reverse=True)",
   "body+mined:-Blocks": "sorted(list_to_be_sorted, key=lambda d: d['name'])",
   "body+mined:-Inline": "sorted(list_to_be_sorted, key=lambda d: d['name'], reverse=True)"
  },
  "snippet": "newlist = sorted(list_to_be_sorted, key=lambda k: k['name'])"
 },
 "72899.458": {
  "intent": "sort a list of dictionaries `l` by values in key `name` in descending order",
  "body": "I have a list of dictionaries and want each item to be sorted by a specific value.\nTake into consideration the list:\n[{'name':'Homer', 'age':39}, {'name':'Bart', 'age':10}]\n\nWhen sorted by name , it should become:\n[{'name':'Bart', 'age':10}, {'name':'Homer', 'age':39}]\n\n",
  "preds": {
   "base:Baseline": "sorted(l, key=lambda x: x['name'], reverse=True)",
   "body:Baseline": "sorted(L, key=lambda x: x['name']))",
   "body:-Blocks": "sorted(l, key=lambda x: x['name'])",
   "body:-Code": "sorted(l, key=lambda x: (x['name'], reverse=True)",
   "body:-Inline": "sorted(l, key=lambda x: x['name']))",
   "body:-NL": "sorted(l, key=lambda x: x[1])",
   "base:+Mined": "l.sort(key=lambda d: d['name'], reverse=True)",
   "body+mined:Baseline": "sorted(l, key=lambda x: x['name'], reverse=True)",
   "body+mined:-Code": "sorted(l, key=lambda x: x['name'], reverse=True)",
   "body+mined:-NL": "sorted(L, key=lambda d: d['name'], reverse=True)",
   "body+mined:-Blocks": "sorted(l, key=lambda d: d['name'], reverse=True)",
   "body+mined:-Inline": "sorted(l, key=lambda d: d['name'], reverse=True)"
  },
  "snippet": "newlist = sorted(l, key=itemgetter('name'), reverse=True)"
 },
 "72899.459": {
  "intent": "how do i sort a list of dictionaries by values of the dictionary in python?",
  "body": "I have a list of dictionaries and want each item to be sorted by a specific value.\nTake into consideration the list:\n[{'name':'Homer', 'age':39}, {'name':'Bart', 'age':10}]\n\nWhen sorted by name , it should become:\n[{'name':'Bart', 'age':10}, {'name':'Homer', 'age':39}]\n\n",
  "preds": {
   "base:Baseline": "sorted(list(d.items()), key=lambda x: x[1])",
   "body:Baseline": "sorted(list(dictionary.items()), key=lambda x: x[1])",
   "body:-Blocks": "sorted(list(d.items()), key=lambda x: x[1])",
   "body:-Code": "sorted(list(d.items()), key=lambda x: x[1])",
   "body:-Inline": "sorted(list(d.items()), key=lambda x: x[1])",
   "body:-NL": "sorted(list(d.items()), key=lambda x: x[1])",
   "base:+Mined": "my_list.sort(key=lambda d: d['rank'], reverse=True)",
   "body+mined:Baseline": "sorted(list(d.items()), key=lambda x: x['name'], reverse=True)",
   "body+mined:-Code": "sorted(list_of_dct, key=lambda x: x[1])",
   "body+mined:-NL": "sorted(list(d.items()), key=lambda d: d['age'], reverse=True)",
   "body+mined:-Blocks": "sorted(lst, key=lambda d: d['name'])",
   "body+mined:-Inline": "sorted(d, key=lambda d: d['age'], reverse=True)"
  },
  "snippet": "list_of_dicts.sort(key=operator.itemgetter('name'))"
 },
 "72899.460": {
  "intent": "how do i sort a list of dictionaries by values of the dictionary in python?",
  "body": "I have a list of dictionaries and want each item to be sorted by a specific value.\nTake into consideration the list:\n[{'name':'Homer', 'age':39}, {'name':'Bart', 'age':10}]\n\nWhen sorted by name , it should become:\n[{'name':'Bart', 'age':10}, {'name':'Homer', 'age':39}]\n\n",
  "preds": {
   "base:Baseline": "sorted(list(d.items()), key=lambda x: x[1])",
   "body:Baseline": "sorted(list(dictionary.items()), key=lambda x: x[1])",
   "body:-Blocks": "sorted(list(d.items()), key=lambda x: x[1])",
   "body:-Code": "sorted(list(d.items()), key=lambda x: x[1])",
   "body:-Inline": "sorted(list(d.items()), key=lambda x: x[1])",
   "body:-NL": "sorted(list(d.items()), key=lambda x: x[1])",
   "base:+Mined": "my_list.sort(key=lambda d: d['rank'], reverse=True)",
   "body+mined:Baseline": "sorted(list(d.items()), key=lambda x: x['name'], reverse=True)",
   "body+mined:-Code": "sorted(list_of_dct, key=lambda x: x[1])",
   "body+mined:-NL": "sorted(list(d.items()), key=lambda d: d['age'], reverse=True)",
   "body+mined:-Blocks": "sorted(lst, key=lambda d: d['name'])",
   "body+mined:-Inline": "sorted(d, key=lambda d: d['age'], reverse=True)"
  },
  "snippet": "list_of_dicts.sort(key=operator.itemgetter('age'))"
 },
 "36402748.461": {
  "intent": "how to sort a dataframe by the ocurrences in a column in python (pandas)",
  "body": "I'm trying to create a dataframe  from my data (scores between chemicals and proteins) with pandas in python. \nI want my dataframe to first display the proteins that have the most occurences, so I previously sorted my data. But when I make the dataframe it does not get the expected result.\nHere's a sample of my data :\nchemicals   prots   scores\nCID000000006    10116.ENSRNOP00000003921    196\nCID000000051    10116.ENSRNOP00000003921    246\nCID000000085    10116.ENSRNOP00000003921    196\nCID000000119    10116.ENSRNOP00000003921    247\nCID000000134    10116.ENSRNOP00000008952    159\nCID000000135    10116.ENSRNOP00000008952    157\nCID000000174    10116.ENSRNOP00000008952    439\nCID000000175    10116.ENSRNOP00000001021    858\nCID000000177    10116.ENSRNOP00000004027    760\n\nAs you can see \"10116.ENSRNOP00000003921\" is the protein with the most occurences in my data.\nSo i'd like to get something like :\n             10116.ENSRNOP00000003921     10116.ENSRNOP00000008952  \nCID000000006   196                 \nCID000000051   246 \nCID000000085   196 \nCID000000119   247 \nCID000000134                                  159   \nCID000000135                                  157   \nCID000000174                                  439\n\nAnd Here's my code : \nimport pandas as pd\n\ndf_rat= pd.read_csv(\"dt_matrix_rat.csv\",sep=\"\\t\", header=True)\ndf_rat.columns = ['chemicals','proteins','scores']\ndf_rat1 = df_rat.pivot(index='chemicals', columns='proteins', values='scores')\n\ndf_rat1.to_csv(\"rat_matrix.csv\", sep='\\t', index=True  )\n\n",
  "preds": {
   "base:Baseline": "df.sort(key=lambda x: x[1])",
   "body:Baseline": "df.sort(['CID'], axis=1)",
   "body:-Blocks": "df.sort_values(['Ocurrences'], axis=1)",
   "body:-Code": "df.sort(key=lambda x: x.OCTURITY)",
   "body:-Inline": "df.sort_values(['CID000000006', 'ENSRNOP00000003921'])",
   "body:-NL": "df.sort_csv(['chemicals', 'proteins', 'scores'])",
   "base:+Mined": "df.sort(['a', 'b'], ascending=[True, False])",
   "body+mined:Baseline": "df.sort_values(by=['prots', 'chemicals'])",
   "body+mined:-Code": "df.sort_values(['chemistry', 'chemistry'])",
   "body+mined:-NL": "df.sort_values(by=['chemicals', 'proteins', 'scores'])",
   "body+mined:-Blocks": "df.sort_values(by=['chemistry', 'chemistry'])",
   "body+mined:-Inline": "df.sort_values(by=['prots'])"
  },
  "snippet": "df.groupby('prots').sum().sort('scores', ascending=False)"
 },
 "29881993.462": {
  "intent": "join together with \",\" elements inside a list indexed with 'category' within a dictionary `trans`",
  "body": "I have a function that's returning a json formatted dataset. Here's a sample: \n[{u'category': [u'Transfer', u'Withdrawal', u'ATM'], u'category_id': u'21012002', u'_account': u'XARE85EJqKsjxLp6XR8ocg8VakrkXpTXmRdOo', u'name': u'ATM Withdrawal', u'amount': 200, u'meta': {u'location': {u'city': u'San Francisco', u'state': u'CA'}}, u'date': u'2014-07-21', u'score': {u'location': {u'city': 1, u'state': 1}, u'name': 1}, u'_id': u'0AZ0De04KqsreDgVwM1RSRYjyd8yXxSDQ8Zxn', u'type': {u'primary': u'special'}, u'pending': False}] \n\nfor trans in foodie_data:\n            print 'Name={},Amount={},Date={}, Categories ={}\\n'.format(trans['name'],trans['amount'],trans['date'],trans['category'])\n\nThis script prints: \nName=ATM Withdrawal,Amount=200,Date=2014-07-21,Categories=[u'Transfer', u'Withdrawal', u'ATM']\n\nI want it to return Categories as a string and not a list:\nName=ATM Withdrawal,Amount=200,Date=2014-07-21,Categories='Transfer, Withdrawal,ATM']\n\nWhat's the most efficient way of doing so?\n",
  "preds": {
   "base:Baseline": "[item for item in list(trans.items() if item['category'] not in item]",
   "body:Baseline": "[{'category': [{'name': 'category'}, 'id': 'ATM'}) for 'name' in Trans.items()}]",
   "body:-Blocks": "[item['category'] for item in Trans.items() if item in item]",
   "body:-Code": "[item['category'] for item in Trans]",
   "body:-Inline": "[item['category'] for item in Trans.items() if item['name'])",
   "body:-NL": "[x['category'] for x in list(trans.items() if 'category' in x]",
   "base:+Mined": "[item['category'] for item in trans.items()]",
   "body+mined:Baseline": "{'category': [item['name'] for item in trans.items()]",
   "body+mined:-Code": "categories = [item['category'] for item in trans.items()]",
   "body+mined:-NL": "[x['category'] for x in trans.items() if 'category' in x]",
   "body+mined:-Blocks": "[item['category'] for item in Trans.items()]",
   "body+mined:-Inline": "[{'name': 'ATM'}, {'amount': 'date'} for _ in trans}]"
  },
  "snippet": "\"\"\",\"\"\".join(trans['category'])"
 },
 "34158494.463": {
  "intent": "concatenate array of strings `['a', 'b', 'c', 'd']` into a string",
  "body": "Out of the following two variants (with or without plus-sign between) of string literal concatenation:\n\nWhat's the preferred way?\nWhat's the difference?\nWhen should one or the other be used?\nShould non of them ever be used, if so why?\nIs join  preferred?\n\nCode:\n# variant 1. Plus\n'A'+'B'\n'AB'\n# variant 2. Just a blank space\n'A' 'B'\n'AB'\n# They seems to be both equal\n'A'+'B' == 'A' 'B'\nTrue\n\n",
  "preds": {
   "base:Baseline": "\"\"\"\"\"\".join(['a', 'b', 'c', 'd'])",
   "body:Baseline": "\"\"\"\"\"\".join(['A', 'B', 'C', 'D'])",
   "body:-Blocks": "\"\"\"\"\"\".join(['a', 'b', 'c', 'd'])",
   "body:-Code": "\"\"\"\"\"\".join(['a', 'b', 'c', 'd'])",
   "body:-Inline": "\"\"\"\"\"\".join(['A', 'B', 'C', 'D'])",
   "body:-NL": "\"\"\"\"\"\".join(['A', 'B', 'C', 'D'])",
   "base:+Mined": "\"\"\"\"\"\".join(['a', 'b', 'c', 'd'])",
   "body+mined:Baseline": "\"\"\"\"\"\".join(['A', 'b', 'c', 'd'])",
   "body+mined:-Code": "\"\"\"\"\"\".join(['a', 'b', 'c', 'd'])",
   "body+mined:-NL": "\"\"\"\"\"\".join(['a', 'b', 'c', 'd'])",
   "body+mined:-Blocks": "\"\"\"\"\"\".join(['a', 'b', 'c', 'd'])",
   "body+mined:-Inline": "\"\"\"\"\"\".join(['a', 'b', 'c', 'd'])"
  },
  "snippet": "\"\"\"\"\"\".join(['A', 'B', 'C', 'D'])"
 },
 "7750557.464": {
  "intent": "get json data from restful service 'url'",
  "body": "Is there any standard way of getting JSON data from RESTful service using Python? \nI need to use kerberos for authentication.\nsome snippet would help.\n",
  "preds": {
   "base:Baseline": "json.loads(url, key=lambda x: x[1])",
   "body:Baseline": "json = RESTful.get(url)",
   "body:-Blocks": "json.loads(url, verify=True)",
   "body:-Code": "urllib.request.url.get('json')",
   "body:-Inline": "json = RESTful.get_json('url')",
   "body:-NL": "json.get_json('url')",
   "base:+Mined": "print(json.dumps(url))",
   "body+mined:Baseline": "print(json.dumps(url))",
   "body+mined:-Code": "print(json.dumps(url))",
   "body+mined:-NL": "json.dumps(url, ensure_ascii=False)",
   "body+mined:-Blocks": "print(json.dumps(url))",
   "body+mined:-Inline": "print(json.dumps(url))"
  },
  "snippet": "json.load(urllib.request.urlopen('url'))"
 },
 "12666897.465": {
  "intent": "remove all strings from a list a strings `sents` where the values starts with `@$\\t` or `#`",
  "body": "How do I remove an element from a list if it matches a substring?\nI have tried removing an element from a list using the pop()  and enumerate  method but seems like I'm missing a few contiguous items that needs to be removed:\nsents = ['@$\\tthis sentences needs to be removed', 'this doesnt',\n     '@$\\tthis sentences also needs to be removed',\n     '@$\\tthis sentences must be removed', 'this shouldnt',\n     '# this needs to be removed', 'this isnt',\n     '# this must', 'this musnt']\n\nfor i, j in enumerate(sents):\n  if j[0:3] == \"@$\\t\":\n    sents.pop(i)\n    continue\n  if j[0] == \"#\":\n    sents.pop(i)\n\nfor i in sents:\n  print i\n\nOutput:\nthis doesnt\n@$  this sentences must be removed\nthis shouldnt\nthis isnt\n#this should\nthis musnt\n\nDesired output:\nthis doesnt\nthis shouldnt\nthis isnt\nthis musnt\n\n",
  "preds": {
   "base:Baseline": "sents = [x for x in sents if x starts with '@$\\t' or '#')",
   "body:Baseline": "sents = [x for x in sents if x.startswith('@$\\t')]",
   "body:-Blocks": "sents = [x for x in sents if x!= '@$\\t' or '#')",
   "body:-Code": "sents = [x for x in sents if '@$\\t' in x]",
   "body:-Inline": "sents = [x for x in enumerate(sents) if x.startswith('@$\\t')]",
   "body:-NL": "sents.pop(['@$\\t'], 'this isnt', '#')",
   "base:+Mined": "sents = [x for x in sents if x.startswith('@$\\t', '#')]",
   "body+mined:Baseline": "[x for x in sents if x.startswith('@$\\\\tthis sentences also needs to be removed', '']",
   "body+mined:-Code": "sents = [x for x in sents if x.startswith('@$\\\\t')]",
   "body+mined:-NL": "sents.pop(re.sub('\\\\t\\\\t', '@$\\\\tthis must', sents))",
   "body+mined:-Blocks": "sents = [sents[i:i + 1] for i in range(0, len(sents), 1)]",
   "body+mined:-Inline": "sents = [x for x in sents if x.startswith(\n    '@$\\\\tthis sentences must be removed')]"
  },
  "snippet": "[x for x in sents if not x.startswith('@$\\t') and not x.startswith('#')]"
 },
 "2984751.466": {
  "intent": "django filter by hour",
  "body": "I've found that link: http://code.djangoproject.com/attachment/ticket/8424/time_filters.diff  and changed my django 1.2 files by adding taht what you can see there. \nBut now, when I'm trying to  write Entry.objects.filter(pub_date__hour = x) - the result is following error:\n\nField has invalid lookup: hour\n\nWhat should I do else, to make it work?  \n(sorry for my english)\n",
  "preds": {
   "base:Baseline": "django.filter(hours=1)",
   "body:Baseline": "Entry.objects.filter(pub_date__hour=x)",
   "body:-Blocks": "Entry.objects.filter(pub_date__hour='8424')",
   "body:-Code": "time.filter(pub_date__hour='8424')",
   "body:-Inline": "Entry.objects.filter(pub_date__hour=x)",
   "body:-NL": "django.filter(hours=1)",
   "base:+Mined": "MyModel.objects.filter(hour=1)",
   "body+mined:Baseline": "Entry.objects.filter(pub_date__hour__in=hour)",
   "body+mined:-Code": "Entry.objects.filter(pub_date__hour=x)",
   "body+mined:-NL": "super(MyModel, self).save(*args, **kwargs)",
   "body+mined:-Blocks": "Entry.objects.filter(pub_date__hour='8424')",
   "body+mined:-Inline": "Entry.objects.filter(pub_date__hour=x)"
  },
  "snippet": "Entry.objects.filter(pub_date__contains='08:00')"
 },
 "5944630.467": {
  "intent": "sort a list of dictionary `list` first by key `points` and then by `time`",
  "body": "I want to sort this info(name, points, and time):\nlist = [\n    {'name':'JOHN', 'points' : 30, 'time' : '0:02:2'},\n    {'name':'KARL','points':50,'time': '0:03:00'}\n]\n\nso, what I want is the list sorted first by points made, then by time played (in my example, matt go first because of his less time. any help?\nI'm trying with this:\nimport operator\nlist.sort(key=operator.itemgetter('points', 'time'))\n\nbut got a TypeError: list indices must be integers, not str . \n",
  "preds": {
   "base:Baseline": "sorted(list, key=lambda x: x[1])",
   "body:Baseline": "list.sort(key=operator.itemgetter('points', 'time'))",
   "body:-Blocks": "sorted(list, key=lambda x: x[1])",
   "body:-Code": "sorted(list, key=lambda x: x[1])",
   "body:-Inline": "list.sort(key=operator.itemgetter('points', 'time'))",
   "body:-NL": "list.sort(key=operator.itemgetter('points', 'time'))",
   "base:+Mined": "sorted(list, key=itemgetter(1), reverse=True)",
   "body+mined:Baseline": "list.sort(key=operator.itemgetter('points', 'time'))",
   "body+mined:-Code": "sorted(list, key=lambda k_v: (k_v[1], v[0]))",
   "body+mined:-NL": "list.sort(key=operator.itemgetter('points', 'time'))",
   "body+mined:-Blocks": "sorted(list, key=lambda x: (x.points, x.time))",
   "body+mined:-Inline": "list.sort(key=operator.itemgetter('points', 'time'))"
  },
  "snippet": "list.sort(key=lambda item: (item['points'], item['time']))"
 },
 "7852855.468": {
  "intent": "convert datetime object `(1970, 1, 1)` to seconds",
  "body": "Apologies for the simple question... I'm new to Python... I have searched around and nothing seems to be working.\nI have a bunch of datetime objects and I want to calculate the number of seconds since a fixed time in the past for each one (for example since January 1, 1970).  \nimport datetime\nt = datetime.datetime(2009, 10, 21, 0, 0)\n\nThis seems to be only differentiating between dates that have different days:\nt.toordinal()\n\nAny help is much appreciated.\n",
  "preds": {
   "base:Baseline": "time.mktime(1970, 1, 1)",
   "body:Baseline": "datetime.datetime(1970, 1, 1)",
   "body:-Blocks": "seconds = datetime.datetime.combine(1970, 1, 1))",
   "body:-Code": "seconds = datetime.datetime.combine(1970, 1, 1))",
   "body:-Inline": "datetime.datetime(1970, 1, 1)",
   "body:-NL": "datetime.datetime(1970, 1, 1)",
   "base:+Mined": "datetime.utcfromtimestamp(1970, 1, 1)",
   "body+mined:Baseline": "datetime.datetime(1970, 1, 1) - datetime.timedelta(seconds=1)",
   "body+mined:-Code": "(1970, 1, 1) + datetime.timedelta(seconds=1)",
   "body+mined:-NL": "t = datetime.datetime(1970, 1, 1)",
   "body+mined:-Blocks": "(1970, 1, 1).total_seconds()",
   "body+mined:-Inline": "datetime.datetime(1970, 1, 1) - datetime.timedelta(seconds=1)"
  },
  "snippet": "(t - datetime.datetime(1970, 1, 1)).total_seconds()"
 },
 "2763750.469": {
  "intent": "insert `_suff` before the file extension in `long.file.name.jpg` or replace `_a` with `suff` if it precedes the extension.",
  "body": "I need to match two cases by one reg expression and do replacement\n'long.file.name.jpg' -> 'long.file.name_ suff .jpg'\n'long.file.name_ a .jpg' -> 'long.file.name_ suff .jpg'\nI'm trying to do the following\nre.sub('(\\_a)?\\.[^\\.]*$' , '_suff.',\"long.file.name.jpg\")\n\nBut this is cut the extension '.jpg' and I'm getting\nlong.file.name_suff. instead of long.file.name_suff.jpg\nI understand that this is because of [^.]*$ part, but I can't exclude it, because\nI have to find last occurance of '_a' to replace or last '.' \nIs there a way to replace only part of the match? \n",
  "preds": {
   "base:Baseline": "f = open('long.file.name.jpg', 'suff')",
   "body:Baseline": "re.sub('(\\_a)?\\.[^\\.]*$', '_suff.'), 'long.file.name.jpg')",
   "body:-Blocks": "re.compile('long.file.name.jpg', '_a', 'suff')",
   "body:-Code": "re.compile('long.file.name.jpg', '_a', 'suff')",
   "body:-Inline": "re.sub('(\\\\_a)?\\\\.[^\\\\.]*$', '_suff.')",
   "body:-NL": "re.sub('(\\_a)?\\.[^\\\\.]*$', '_suff.'), '_a')",
   "base:+Mined": "os.path.insert(0, 'long.file.name.jpg', 'suff')",
   "body+mined:Baseline": "re.sub('\\\\_a)?\\\\.[^\\\\.]*$', '(long.file.name.jpg')",
   "body+mined:-Code": "re.sub('[^.]*$', 'long.file.name.jpg', _a)",
   "body+mined:-NL": "re.sub('\\\\[^\\\\.]*$', '', 'long.file.name.jpg')",
   "body+mined:-Blocks": "re.sub('_a', 'long.file.name.jpg', 'suff')",
   "body+mined:-Inline": "re.sub('\\\\_a)?\\\\.[^\\\\.]*$', '_suff.', 'long.file.name.jpg')"
  },
  "snippet": "re.sub('(\\\\_a)?\\\\.([^\\\\.]*)$', '_suff.\\\\2', 'long.file.name.jpg')"
 },
 "6420361.470": {
  "intent": "reload a module `module`",
  "body": "After import functions into ipython, how do I reload them when I have modified them outside of ipython ?\n",
  "preds": {
   "base:Baseline": "module.load(key=operator.itemgetter(1))",
   "body:Baseline": "module = os.load(module)",
   "body:-Blocks": "module.load(key=module)",
   "body:-Code": "module = module.load(module)",
   "body:-Inline": "module = os.load(module)",
   "body:-NL": "module.load(key=module.get())",
   "base:+Mined": "module = subprocess.Popen(module, shell=True)",
   "body+mined:Baseline": "sys.modules.update(module)",
   "body+mined:-Code": "sys.modules.load(module)",
   "body+mined:-NL": "module = module.load(module)",
   "body+mined:-Blocks": "sys.modules.append(module)",
   "body+mined:-Inline": "module = module.__init__(self)"
  },
  "snippet": "import imp\nimp.reload(module)"
 },
 "19546911.471": {
  "intent": "convert integer `number` into an unassigned integer",
  "body": "I currently read off pixels from an image using python PIL. These pixels are 16bit greyscale and are unsigned. However, whenever PIL reads them in it thinks they are signed and makes values that should be something like 45179  into -20357 .\norg_Image = Image.open(image)\norg_Data = org_Image.load()\nwidth, height = org_Image.size\n\n    for y in range(0, height):\n        temprow_data = []\n        for x in range(0, width):\n             temprow_data.append(org_Data[x, y])\n\nHow do I go about getting PIL to output unsigned instead of signed integers? Or is there a really easy way of taking the PIL input and converting it after?\n",
  "preds": {
   "base:Baseline": "[int(x) for x in sorted(number)]",
   "body:Baseline": "struct.unpack('{}'.format(number))",
   "body:-Blocks": "print(int(s) for s in unsigned integers)",
   "body:-Code": "int(s.encode('unsigned') for s in number)",
   "body:-Inline": "np.arange(int(number))",
   "body:-NL": "[int(x) for x in range(0, width)]",
   "base:+Mined": "int(number).encode('ascii', 'ignore')",
   "body+mined:Baseline": "int('45179'.encode('utf-8'))",
   "body+mined:-Code": "numpy.unregister(number)",
   "body+mined:-NL": "int(''.join(map(str, x)))",
   "body+mined:-Blocks": "int(number).decode('greyscale')",
   "body+mined:-Inline": "int('45179'.encode('utf-8'))"
  },
  "snippet": "struct.unpack('H', struct.pack('h', number))"
 },
 "9746522.472": {
  "intent": "convert int values in list `numlist` to float",
  "body": "I am doing my homework and it requirers me to use a sum () and len () functions to find the mean of an input number list, when I tried to use sum () to get the sum of the list, I got an error TypeError: unsupported operand type(s) for +: 'int' and 'str'. Following is my code:\nnumlist = input(\"Enter a list of number separated by commas: \")\n\nnumlist = numlist.split(\",\")\n\ns = sum(numlist)\nl = len(numlist)\nm = float(s/l)\nprint(\"mean:\",m)\n\n",
  "preds": {
   "base:Baseline": "float(numList, int(numlist))",
   "body:Baseline": "float(sum(i) for i in numlist)",
   "body:-Blocks": "float(numlist, float(numList))",
   "body:-Code": "float(numlist, float(str))",
   "body:-Inline": "float(numlist, numlist)",
   "body:-NL": "float(numlist, numlist)",
   "base:+Mined": "float(numlist[0] + float(numList[1])",
   "body+mined:Baseline": "sum(map(int, numlist))",
   "body+mined:-Code": "float(numlist) / float(len(numList))",
   "body+mined:-NL": "float(map(int, numlist))",
   "body+mined:-Blocks": "sum(float(numlist) / float(numList))",
   "body+mined:-Inline": "float(sum(x) for x in numlist)"
  },
  "snippet": "numlist = [float(x) for x in numlist]"
 },
 "20107570.473": {
  "intent": "write dataframe `df`, excluding index, to a csv file",
  "body": "I have the following code which imports a CSV file.  There are 3 columns and I want to set the first two of them to variables.  When I set the second column to the variable \"efficiency\" the index column is also tacked on.  How can I get rid of the index column?\ndf = pd.DataFrame.from_csv('Efficiency_Data.csv', header=0, parse_dates=False)\nenergy = df.index\nefficiency = df.Efficiency\nprint efficiency\n\nI tried using \ndel df['index']\n\nafter I set \nenergy = df.index\n\nwhich I found in another post but that results in \"KeyError: 'index' \"\n",
  "preds": {
   "base:Baseline": "df.to_csv('index')",
   "body:Baseline": "df = pd.DataFrame.from_csv('Efficiency_Data.csv', header=0, parse_dates=False)",
   "body:-Blocks": "df.to_csv('csv', excluding index)",
   "body:-Code": "df.to_csv('csv', excluding index)",
   "body:-Inline": "df.to_csv('Efficiency_Data.csv', header=0, parse_dates=False)",
   "body:-NL": "df.to_csv('Efficiency_Data.csv', header=0, parse_dates=False)",
   "base:+Mined": "df.to_csv('test.csv', index=False)",
   "body+mined:Baseline": "df.to_csv('Efficiency_Data.csv', header=0, parse_dates=False)",
   "body+mined:-Code": "df.to_csv('test.csv', excluding index)",
   "body+mined:-NL": "df = pd.DataFrame.from_csv('Efficiency_Data.csv', header=0, parse_dates=False)",
   "body+mined:-Blocks": "df.to_csv('test.csv', excluding index)",
   "body+mined:-Inline": "df.to_csv('Efficiency_Data.csv', index=False)"
  },
  "snippet": "df.to_csv(filename, index=False)"
 },
 "8740353.474": {
  "intent": "convert a urllib unquoted string `unescaped` to a json data `json_data`",
  "body": "Here is the sample string i am receiving from one of the web services,\nbody=%7B%22type%22%3A%22change%22%2C%22url%22%3A%22http%3A%2F%2Fapi.pachube.com%2Fv2%2Ftriggers%2F4100%22%2C%22environment%22%3A%7B%22feed%22%3A%22http%3A%2F%2Fapi.pachube.com%2Fv2%2Ffeeds%2F36133%22%2C%22title%22%3A%22Current+Cost+Bridge%22%2C%22description%22%3Anull%2C%22id%22%3A36133%7D%2C%22threshold_value%22%3Anull%2C%22timestamp%22%3A%222012-01-05T09%3A27%3A01Z%22%2C%22triggering_datastream%22%3A%7B%22url%22%3A%22http%3A%2F%2Fapi.pachube.com%2Fv2%2Ffeeds%2F36133%2Fdatastreams%2F1%22%2C%22value%22%3A%7B%22value%22%3A%22523%22%2C%22max_value%22%3A1269.0%2C%22min_value%22%3A0.0%7D%2C%22id%22%3A%221%22%2C%22units%22%3A%7B%22symbol%22%3A%22W%22%2C%22type%22%3A%22derivedUnits%22%2C%22label%22%3A%22watts%22%7D%7D%2C%22id%22%3A4100%7D\n\nHere is the code,\nclass Feeds():\n    def GET(self):\n        print \"Get request is accepted.\"\n        return render.index(None)\n\n    def POST(self):\n        print \"Post request is accepted.\"\n        print (web.data())\n\nNow when that web-service posts the above given data, how will i convert it to readable format? Then, i need to convert it to JSON object and use further. So, how will i convert it?\nWhen i try this code,\n        json_data = json.loads(web.data())\n        print json_data['body']\n        return render.index(json_data['body'])\n\nIt gives me an error,\nenter code Traceback (most recent call last):\nFile \"/usr/local/lib/python2.6/dist-packages/web/application.py\", line 237, in process\nreturn self.handle()\nFile \"/usr/local/lib/python2.6/dist-packages/web/application.py\", line 228, in handle\nreturn self._delegate(fn, self.fvars, args)\nFile \"/usr/local/lib/python2.6/dist-packages/web/application.py\", line 409, in _delegate\nreturn handle_class(cls)\nFile \"/usr/local/lib/python2.6/dist-packages/web/application.py\", line 385, in      handle_class\nreturn tocall(*args)\nFile \"/home/ubuntu/pachubeConsumer/src/controllers/feeds.py\", line 17, in POST\njson_data = json.loads(web.data())\nFile \"/usr/lib/python2.6/json/__init__.py\", line 307, in loads\nreturn _default_decoder.decode(s)\nFile \"/usr/lib/python2.6/json/decoder.py\", line 319, in decode\nobj, end = self.raw_decode(s, idx=_w(s, 0).end())\nFile \"/usr/lib/python2.6/json/decoder.py\", line 338, in raw_decode\nraise ValueError(\"No JSON object could be decoded\")\nValueError: No JSON object could be decoded here\n\nWhere am i going wrong ??\nThanks in advance.\n",
  "preds": {
   "base:Baseline": "json_data.unquote('unescaped')",
   "body:Baseline": "json_data = urllib.parse.unquote(unquote)",
   "body:-Blocks": "json_data = json.loads(unquote, 'unescaped')",
   "body:-Code": "json_data = urllib.parse.unquote(unescaped)",
   "body:-Inline": "json_data = urllib.parse.unquote(unquote=unescaped)",
   "body:-NL": "json_data = urllib.parse.unquote(unquote)",
   "base:+Mined": "json_data = json.loads(unquote)",
   "body+mined:Baseline": "json_data = urllib.parse.unquote(string)",
   "body+mined:-Code": "json_data = json.loads(unnamed_string)",
   "body+mined:-NL": "json_data = urllib.parse.unquote(url, data)",
   "body+mined:-Blocks": "json_data.dumps(urllib.parse.unquote(unquote))",
   "body+mined:-Inline": "json_data.unstack(unquote)"
  },
  "snippet": "json_data = json.loads(unescaped)"
 },
 "5891453.475": {
  "intent": "create a list containing all ascii characters as its elements",
  "body": "Something like below:\nimport ascii\n\nprint ascii.charlist()\n\nWhich would return something like [A, B, C, D...]\n",
  "preds": {
   "base:Baseline": "list(itertools.chain.from_iterable(ascii))",
   "body:Baseline": "charlist = [A, B, C, D]",
   "body:-Blocks": "list(itertools.product([A, B, C, D])",
   "body:-Code": "list(itertools.product([A, B, C, D])",
   "body:-Inline": "list(ascii.charlist()",
   "body:-NL": "list(ascii.charlist()",
   "base:+Mined": "list(itertools.chain.from_iterable(ascii_uppercase))",
   "body+mined:Baseline": "print([i for i in range(0, len(ascii)))",
   "body+mined:-Code": "list(itertools.chain.from_iterable(a))",
   "body+mined:-NL": "\"\"\"\"\"\".join(chr(i) for i in L)",
   "body+mined:-Blocks": "['A', 'B', 'C', 'D']",
   "body+mined:-Inline": "print('[A, B, C, D]')"
  },
  "snippet": "[chr(i) for i in range(127)]"
 },
 "18367007.476": {
  "intent": "write `newfilebytes` to a binary file `newfile`",
  "body": "I have a list of bytes as integers, which is something like\n[120, 3, 255, 0, 100]\n\nHow can I write this list to a file as binary?\nWould this work?\nnewFileBytes = [123, 3, 255, 0, 100]\n# make file\nnewFile = open(\"filename.txt\", \"wb\")\n# write to file\nnewFile.write(newFileBytes)\n\n",
  "preds": {
   "base:Baseline": "newfile = os.walk(newfilebytes)",
   "body:Baseline": "newFile = open('filename.txt', 'wb')",
   "body:-Blocks": "newfilebytes = [int(x) for x in oldfile]",
   "body:-Code": "newfilebytes = [int(x) for x in oldfile]",
   "body:-Inline": "newFile = open('filename.txt', 'wb')",
   "body:-NL": "newFile = open('filename.txt', 'wb')",
   "base:+Mined": "newfile = open('newfilebytes', 'rb')",
   "body+mined:Baseline": "newFile = open('filename.txt', 'wb')",
   "body+mined:-Code": "newfilebytes = [int(x) for x in oldfilebytes]",
   "body+mined:-NL": "newFile = open('filename.txt', 'wb')",
   "body+mined:-Blocks": "newfilebytes.write('\\n'.join(chr(x)) for x in oldfilebytes)",
   "body+mined:-Inline": "newFile = open('filename.txt', 'wb')"
  },
  "snippet": "newFile.write(struct.pack('5B', *newFileBytes))"
 },
 "21805490.477": {
  "intent": "python regex - check for a capital letter with a following lowercase in string `string`",
  "body": "I am trying to check for a capital letter that has a lowercase letter coming directly after it. The trick is that there is going to be a bunch of garbage capital letters and number coming directly before it. For example:\nAASKH317298DIUANFProgramming is fun\n\nas you can see, there is a bunch of stuff we don't need coming directly before the phrase we do need, Programming is fun .\nI am trying to use regex to do this by taking each string and then substituting it out with ''  as the original string does not have to be kept. \nre.sub(r'^[A-Z0-9]*', '', string)\n\nThe problem with this code is that it leaves us with rogramming is fun , as the P  is a capital letter. \nHow would I go about checking to make sure that if the next letter is a lowercase, then I should leave that capital untouched. (The P  in Programming )\n",
  "preds": {
   "base:Baseline": "re.findall('\\\\d+', string)",
   "body:Baseline": "re.sub('\\\\[A-Z0-9]*', '', string)",
   "body:-Blocks": "re.sub('(?<?>\\\\)', string)",
   "body:-Code": "re.compile('\\\\d+', string)",
   "body:-Inline": "re.sub('^[A-Z0-9]*', string)",
   "body:-NL": "re.sub('^[A-Z0-9]*', string)",
   "base:+Mined": "re.findall('(?<=\\\\w+)', string)",
   "body+mined:Baseline": "re.sub('^[A-Z0-9]*', '', string)",
   "body+mined:-Code": "re.sub('(?<=.)(?=.)', '\\\\1', string)",
   "body+mined:-NL": "re.sub('^[A-Z0-9]*', '', string)",
   "body+mined:-Blocks": "re.search('(?<P<P>)', string)",
   "body+mined:-Inline": "re.sub('^[A-Z0-9]*', '', string)"
  },
  "snippet": "re.sub('^[A-Z0-9]*(?![a-z])', '', string)"
 },
 "16125229.478": {
  "intent": "get the last key of dictionary `dict`",
  "body": "I am having difficulty figuring out what the syntax would be for the last key in a Python dictionary. I know that for a Python list, one may say this to denote the last:\nlist[-1]\n\nI also know that one can get a list of the keys of a dictionary as follows:\ndict.keys()\n\nHowever, when I attempt to use the logical following code, it doesnt work:\ndict.keys(-1)\n\nIt says that keys cant take any arguments and 1 is given. If keys cant take args, then how can I denote that I want the last key in the list?\nXXXXX\nI am operating under the assumption that Python dictionaries are ordered in the order in which items are added to the dictionary with most recent item last. For this reason, I would like to access the last key in the dictionary.XXXXX\nI am now told that the dictionary keys are not in order based on when they were added. How then would I be able to choose the most recently added key?\n",
  "preds": {
   "base:Baseline": "{k: v for k, v in dict.items()}",
   "body:Baseline": "dict((k, v) for k, v in dict.keys())",
   "body:-Blocks": "[k for k, v in dict.items() if v != 0]",
   "body:-Code": "[x[1] for x in list(dict.items()]",
   "body:-Inline": "dict[-1]:\n    pass",
   "body:-NL": "[last(key) for key in dict]",
   "base:+Mined": "dict((k, v) for k, v in list(dict.items()))",
   "body+mined:Baseline": "list(dict.keys())[-1]",
   "body+mined:-Code": "list(dict.items()).keys()",
   "body+mined:-NL": "next(iter(dict.items()))",
   "body+mined:-Blocks": "[key for key, value in list(dict.items())]",
   "body+mined:-Inline": "list(d.keys())[-1]"
  },
  "snippet": "list(dict.keys())[-1]"
 },
 "6159900.479": {
  "intent": "write line \"hi there\" to file `f`",
  "body": "I'm used to doing print >>f, \"hi there\"\nHowever, it seems that print >>  is getting deprecated. What is the recommended way to do the line above?\nUpdate :\nRegarding all those answers with \"\\n\" <console_out>is this universal or Unix-specific? IE, should I be doing \"\\r\\n\"  on Windows?\n",
  "preds": {
   "base:Baseline": "f = f.write('hi there')",
   "body:Baseline": "print(f, 'hi there'))",
   "body:-Blocks": "f = f.write('hi there')",
   "body:-Code": "f = f.write('hi there')",
   "body:-Inline": "f = f.write('hi there')",
   "body:-NL": "f.write('hi there', 'hi there')",
   "base:+Mined": "f.write(line, 'hi there')",
   "body+mined:Baseline": "print(f, 'hi there')",
   "body+mined:-Code": "f.write(line.rstrip('hi there'))",
   "body+mined:-NL": "f.write('\\r\\n')",
   "body+mined:-Blocks": "f.write(('hi there')",
   "body+mined:-Inline": "f = os.path.join(f, 'hi there')"
  },
  "snippet": "print('hi there', file=f)"
 },
 "6159900.480": {
  "intent": "write line \"hi there\" to file `myfile`",
  "body": "I'm used to doing print >>f, \"hi there\"\nHowever, it seems that print >>  is getting deprecated. What is the recommended way to do the line above?\nUpdate :\nRegarding all those answers with \"\\n\" <console_out>is this universal or Unix-specific? IE, should I be doing \"\\r\\n\"  on Windows?\n",
  "preds": {
   "base:Baseline": "myfile.write('hi there')",
   "body:Baseline": "print(f, 'hi there'))",
   "body:-Blocks": "print(myfile.write('hi there')",
   "body:-Code": "myfile.write('hi there')",
   "body:-Inline": "myfile.write('hi there')",
   "body:-NL": "myfile.write('hi there', 'hi there')",
   "base:+Mined": "myfile.write('hi there')",
   "body+mined:Baseline": "print(myfile.write('hi there'))",
   "body+mined:-Code": "myfile.write('hi there')",
   "body+mined:-NL": "myfile.write('hi there')",
   "body+mined:-Blocks": "myfile.write('hi there')",
   "body+mined:-Inline": "myfile.write('hi there')"
  },
  "snippet": "f = open('myfile', 'w')\nf.write('hi there\\n')\nf.close()"
 },
 "6159900.481": {
  "intent": "write line \"hello\" to file `somefile.txt`",
  "body": "I'm used to doing print >>f, \"hi there\"\nHowever, it seems that print >>  is getting deprecated. What is the recommended way to do the line above?\nUpdate :\nRegarding all those answers with \"\\n\" <console_out>is this universal or Unix-specific? IE, should I be doing \"\\r\\n\"  on Windows?\n",
  "preds": {
   "base:Baseline": "somefile.txt.write('hello')",
   "body:Baseline": "print(os.system('somefile.txt')",
   "body:-Blocks": "print(os.path.isfile('somefile.txt')",
   "body:-Code": "os.system('somefile.txt')",
   "body:-Inline": "os.system('somefile.txt')",
   "body:-NL": "somefile.txt.write('hello')",
   "base:+Mined": "somefile.txt.write('hello')",
   "body+mined:Baseline": "print(os.path.basename(somefile.txt))",
   "body+mined:-Code": "os.system('somefile.txt')",
   "body+mined:-NL": "print(somefile.txt, 'Hello')",
   "body+mined:-Blocks": "print(somefile.txt, 'Hello')",
   "body+mined:-Inline": "somefile.txt.write('hello')"
  },
  "snippet": "with open('somefile.txt', 'a') as the_file:\n    the_file.write('Hello\\n')"
 },
 "19527279.482": {
  "intent": "convert unicode string `s` to ascii",
  "body": "I am unable to convert the following Unicode to ASCII without losing data:\nu'ABRA\\xc3O JOS\\xc9'\n\nI tried encode  and decode  and they won't do it.\nDoes anyone have a suggestion?\n",
  "preds": {
   "base:Baseline": "s.decode('unicode_escape')",
   "body:Baseline": "struct.unpack('ABRA\u00c3O JOS\u00c9')",
   "body:-Blocks": "urllib.parse.unquote(s)",
   "body:-Code": "s.decode('unicode_escape')",
   "body:-Inline": "s.decode('unicode_escape')",
   "body:-NL": "s.decode('unicode_escape')",
   "base:+Mined": "s.encode('ascii', 'ignore')",
   "body+mined:Baseline": "unicodedata.normalize('NFKD', s)",
   "body+mined:-Code": "s.decode('ascii')",
   "body+mined:-NL": "s.encode('ascii', 'ignore')",
   "body+mined:-Blocks": "s.decode('ascii')",
   "body+mined:-Inline": "unicodedata.normalize('NFKD', s)"
  },
  "snippet": "s.encode('iso-8859-15')"
 },
 "10668585.483": {
  "intent": "django get maximum value associated with field 'added' in model `authorizedemail`",
  "body": "AuthorizedEmail.objects.filter(group=group).values('added')\n[{'added': datetime.datetime(2012, 5, 19, 13, 8, 7)}, \n{'added': datetime.datetime(2012, 5, 19, 13, 8, 7)}, \n{'added': datetime.datetime(2012, 5, 19, 13, 7, 23)}, \n{'added': datetime.datetime(2012, 5, 19, 13, 8, 7)}]\n\nWhat would be the best way to get the max value here? In python or in the ORM?\n",
  "preds": {
   "base:Baseline": "authorizedemail.get_value('added')",
   "body:Baseline": "AuthorizedEmail.objects.filter(group=group).values('added')",
   "body:-Blocks": "max(authorizedemail.get('added')",
   "body:-Code": "print(authorizedemail.get('added')",
   "body:-Inline": "AuthorizedEmail.objects.max(value='added')",
   "body:-NL": "AuthorizedEmail.objects.filter(group=group).values('added')",
   "base:+Mined": "Book.objects.get('Authorizedemail')",
   "body+mined:Baseline": "AuthorizedEmail.objects.filter(group=group).values('added')",
   "body+mined:-Code": "Model.objects.extra(['authorizedemail']).max()",
   "body+mined:-NL": "AuthorizedEmail.objects.values_list('added')",
   "body+mined:-Blocks": "max(request.META['authorizedemail'] for request in params.values())",
   "body+mined:-Inline": "AuthorizedEmail.objects.filter(group=group).values('added')"
  },
  "snippet": "AuthorizedEmail.objects.filter(group=group).order_by('-added')[0]"
 },
 "356483.484": {
  "intent": "find all numbers and dots from a string `text` using regex",
  "body": "I'm using re.findall() to extract some version numbers from an HTML file:\nimport re\ntext = \" <a href=\\\"url\\\">Test0.2.1.zip </a> </td> <td>Test0.2.1 </td> </table> Test0.2.1\"\nre.findall(\"Test([\\.0-9]*)\", text)\n['0.2.1.', '0.2.1', '0.2.1']\n\nbut I would like to only get the ones that do not end in a dot.\nThe filename might not always be .zip so I can't just stick .zip in the regex.\nI wanna end up with:\n['0.2.1', '0.2.1']\n\nCan anyone suggest a better regex to use? :)\n",
  "preds": {
   "base:Baseline": "re.findall('\\\\d+', text)",
   "body:Baseline": "re.findall('Test([\\\\.0-9]*)', text)",
   "body:-Blocks": "re.findall('(\\\\w+)', text)",
   "body:-Code": "re.findall('\\\\w+', text)",
   "body:-Inline": "re.findall('Test([\\\\.0-9]*)', text)",
   "body:-NL": "re.findall('Test([\\\\.0-9]*)', text)",
   "base:+Mined": "re.findall('\\\\d+', text)",
   "body+mined:Baseline": "re.findall('Test([\\\\.0-9]*)', text)",
   "body+mined:-Code": "re.findall('\\\\test0.2.1.zip', text)",
   "body+mined:-NL": "re.findall('Test([\\\\.0-9]*)', text)",
   "body+mined:-Blocks": "re.findall('\\\\test0.2.1.zip', text)",
   "body+mined:-Inline": "re.findall('\\\\([^\\\\]*)', text)"
  },
  "snippet": "re.findall('Test([0-9.]*[0-9]+)', text)"
 },
 "356483.485": {
  "intent": "python regex  to find all numbers and dots from 'text'",
  "body": "I'm using re.findall() to extract some version numbers from an HTML file:\nimport re\ntext = \" <a href=\\\"url\\\">Test0.2.1.zip </a> </td> <td>Test0.2.1 </td> </table> Test0.2.1\"\nre.findall(\"Test([\\.0-9]*)\", text)\n['0.2.1.', '0.2.1', '0.2.1']\n\nbut I would like to only get the ones that do not end in a dot.\nThe filename might not always be .zip so I can't just stick .zip in the regex.\nI wanna end up with:\n['0.2.1', '0.2.1']\n\nCan anyone suggest a better regex to use? :)\n",
  "preds": {
   "base:Baseline": "re.findall('\\\\w+', text)",
   "body:Baseline": "re.findall('Test([\\\\.0-9]*)', text)",
   "body:-Blocks": "re.findall('\\\\w+', text)",
   "body:-Code": "re.findall('\\\\w+', text)",
   "body:-Inline": "re.findall('Test([\\\\.0-9]*)', text)",
   "body:-NL": "re.findall('Test([\\\\.0-9]*)', text)",
   "base:+Mined": "re.findall('\\\\d+', text)",
   "body+mined:Baseline": "re.findall('Test([\\\\.0-9]*)', text)",
   "body+mined:-Code": "re.findall('\\\\test\\\\Test\\\\.zip', text)",
   "body+mined:-NL": "re.findall('Test([\\\\.0-9]*)', text)",
   "body+mined:-Blocks": "re.findall('\\\\test\\\\.zip', text)",
   "body+mined:-Inline": "re.findall('\\\\Test([\\\\.0-9]*)', text)"
  },
  "snippet": "re.findall('Test([\\\\d.]*\\\\d+)', text)"
 },
 "38081866.486": {
  "intent": "execute script 'script.ps1' using 'powershell.exe' shell",
  "body": "Is there a way to run powershell code in python? I've been searching around and all I'm finding is how to run a separate PS script file in python, but nothing about running PS code.\nExample: Let's say I want to run this command from inside a Python script\\program...\nStart-Process -filepath \"Path\\Filename.exe\" -wait\n\nI understand in that example I could just run the file using Python. I'm looking into writing a Python app, but it would use some powershell code behind the scenes to actually do what it needs to do. In the case for my app idea, it would connect to Office 365 and manipulate users\\account info (add, remove, etc) and things you can't do on the 365 admin site. I already have a PS script to do most of this, but I'm looking into a GUI interface and python seems to be the better choice for GUI (so far as what I've seen and played with).\nIf this isn't possible, or if it's more pain than it's worth I'd appreciate some suggestions. Should I look into C# or something like that? Python seemed easier to understand.\nThanks.\n",
  "preds": {
   "base:Baseline": "subprocess.call('script.ps1', shell=True)",
   "body:Baseline": "os.system('script.ps1', shell=True)",
   "body:-Blocks": "os.system('script.ps1', shell=True)",
   "body:-Code": "subprocess.call('script.ps1', shell=True)",
   "body:-Inline": "os.system('script.ps1', shell=True)",
   "body:-NL": "os.system('script.ps1', shell=True)",
   "base:+Mined": "subprocess.call('script.ps1', shell=True)",
   "body+mined:Baseline": "os.system('script.ps1', shell=True)",
   "body+mined:-Code": "subprocess.call('script.ps1', shell=True)",
   "body+mined:-NL": "os.system('script.ps1')",
   "body+mined:-Blocks": "os.system('script.ps1')",
   "body+mined:-Inline": "os.system('script.ps1', shell=True)"
  },
  "snippet": "os.system('powershell.exe', 'script.ps1')"
 },
 "7349646.487": {
  "intent": "sort a list of tuples `b` by third item in the tuple",
  "body": "I know there's tonnes of questions on python sorting lists/dictionaries already, but I can't seem to find one which helps in my case, and i'm looking for the most efficient solution as I'm going to be sorting a rather large dataset.\nMy data basically looks like this at the moment:\na = {'a': (1, 2, 3), 'b': (3, 2, 1)}\n\nI'm basically creating a word list in which I store each word along with some stats about it (n, Sigma(x), Sigma(x^2) )\nI want to sort it based on a particular stat. So far I've been trying something along the lines of:\nb = a.items()\nb.sort(key = itemgetter(1), reverse=True)\n\nI'm not sure how to control which index it is sorted based on when its effectively a list of tuples of tuples? I guess I effectively need to nest two itemgetter operations but not really sure how to do this.\nIf there's a better data structure I should be using instead please let me know. Should I perhaps create a small class/struct and then use a lambda function to access a member of the class?\nMany Thanks\n",
  "preds": {
   "base:Baseline": "b.sort(key=operator.itemgetter(1))",
   "body:Baseline": "b.sort(key=operator.itemgetter(1), reverse=True)",
   "body:-Blocks": "sorted(b, key=lambda x: x[1])",
   "body:-Code": "sorted(b, key=lambda x: x[1])",
   "body:-Inline": "b.sort(key=itemgetter(1), reverse=True)",
   "body:-NL": "b.sort(key=operator.itemgetter(1), reverse=True)",
   "base:+Mined": "sorted(b, key=operator.itemgetter(1), reverse=True)",
   "body+mined:Baseline": "b.sort(key=lambda x: x[1])",
   "body+mined:-Code": "sorted(b, key=lambda x: x[1])",
   "body+mined:-NL": "b.sort(key=lambda x: x[1])",
   "body+mined:-Blocks": "sorted(b, key=lambda x: (x[1], x[2]))",
   "body+mined:-Inline": "b.sort(key=itemgetter(1), reverse=True)"
  },
  "snippet": "b.sort(key=lambda x: x[1][2])"
 },
 "2430539.488": {
  "intent": "get a list of all keys in cassandra database `cf` with pycassa",
  "body": "Is anyone having experience working with pycassa  I have a doubt with it. How do I get all the keys that are stored in the database?\nwell in this small snippet we need to give the keys in order to get the associated columns (here the keys are 'foo' and 'bar'),that is fine but my requirement is to get all the keys (only keys) at once as Python list or similar data structure. \ncf.multiget(['foo', 'bar'])\n{'foo': {'column1': 'val2'}, 'bar': {'column1': 'val3', 'column2': 'val4'}}\n\nThanks.\n",
  "preds": {
   "base:Baseline": "[k for k, v incf.keys() if v]",
   "body:Baseline": "[k for k, v in cf.multiget(['foo', 'bar'])]",
   "body:-Blocks": "[k for k, v incf.keys()]",
   "body:-Code": "[k for k, v incf.keys())",
   "body:-Inline": "[k for k, v in cf.keys()) for k in v]",
   "body:-NL": "cf.multiget(['foo', 'bar'])",
   "base:+Mined": "cf.set_index('id')",
   "body+mined:Baseline": "[k for k, v in cf.multiget(['foo', 'bar']) if k in v]",
   "body+mined:-Code": "cassa.find_all('cf', keys=['foo', 'bar'])",
   "body+mined:-NL": "cf.multiget(['foo', 'bar'])",
   "body+mined:-Blocks": "list(cassandra.database.keys())",
   "body+mined:-Inline": "df[['foo', 'bar']]"
  },
  "snippet": "list(cf.get_range().get_keys())"
 },
 "10607688.489": {
  "intent": "create a datetime with the current date & time",
  "body": "Here is a functional code (create file with success)\nsys.stdout = open('filename1.xml', 'w')\n\nNow I'm trying to name the file with the current date/time (I'm not an expert in Python)\nfilename1 = datetime.now().strftime(\"%Y%m%d-%H%M%S\")\nsys.stdout = open(filename1 + '.xml', 'w')\n\nI want to write out a file name with the exact date and time, it is a xml file, that the program has already create, I just need to name the file. The above code is not working.\nThe error returned:\n  File \"./fix.py\", line 226, in <module>\n    filenames = datetime.now().strftime(\"%Y%m%d-%H%M%S\")\nAttributeError: 'module' object has no attribute 'now'\n\n",
  "preds": {
   "base:Baseline": "today = datetime.datetime.now().date()",
   "body:Baseline": "datetime.now().strftime('%Y%m%d-%H%M%S')",
   "body:-Blocks": "today = datetime.datetime.now().strftime('%Y-%m-%d')",
   "body:-Code": "today = datetime.datetime.now().date()",
   "body:-Inline": "sys.stdout = datetime.now().strftime('%Y%m%d-%H%M%S')",
   "body:-NL": "datetime.now().strftime('%Y%m%d-%H%M%S')",
   "base:+Mined": "dt = datetime.datetime.now().date()",
   "body+mined:Baseline": "datetime.now().strftime('%Y%m%d-%H%M%S')",
   "body+mined:-Code": "datetime.now().strftime('%Y-%m-%d %H:%M:%S')",
   "body+mined:-NL": "datetime.now().strftime('%Y%m%d-%H%M%S')",
   "body+mined:-Blocks": "time.strftime('%Y-%m-%d %H:%M:%S')",
   "body+mined:-Inline": "datetime.now().strftime('%Y%m%d-%H%M%S')"
  },
  "snippet": "datetime.datetime.now()"
 },
 "30843103.490": {
  "intent": "get the index of an integer `1` from a list `lst` if the list also contains boolean items",
  "body": "I am just starting with Python.\nHow to get index of integer 1  from a list if the list contains a boolean True  object before the 1 ?\nlst = [True, False, 1, 3]\nlst.index(1)\n0\nlst.index(True)\n0\nlst.index(0)\n1\n\nI think Python considers 0  as False  and 1  as True  in the argument of the index  method. How can I get the index of integer 1  (i.e. 2 )?\nAlso what is the reasoning or logic behind treating boolean object this way in list?\nAs from the solutions, I can see it is not so straightforward.\n",
  "preds": {
   "base:Baseline": "[i for i, j in lst if j == 1]",
   "body:Baseline": "[i for i, j in lst if i not j in j]",
   "body:-Blocks": "[i for i in lst if i == 1]",
   "body:-Code": "[i for i, j in lst if j in i]",
   "body:-Inline": "[int(x) for x in lst if x else 1]",
   "body:-NL": "[i for i, j in lst if i not in j]",
   "base:+Mined": "[i for i, j in enumerate(lst) if j == 1]",
   "body+mined:Baseline": "[i for i, j in enumerate(lst) if j == 1]",
   "body+mined:-Code": "[i for i, x in enumerate(lst) if x == 2]",
   "body+mined:-NL": "[i for i, elem in enumerate(lst) if elem is not a]",
   "body+mined:-Blocks": "[i for i, j in enumerate(lst) if j == 1]",
   "body+mined:-Inline": "[i for i, j in enumerate(lst) if j == 1]"
  },
  "snippet": "next(i for i, x in enumerate(lst) if not isinstance(x, bool) and x == 1)"
 },
 "4918425.491": {
  "intent": "subtract 13 from every number in a list `a`",
  "body": "I have a list\n a = [49, 51, 53, 56]\n\nHow do I subtract 13 from each integer value in the list?\n",
  "preds": {
   "base:Baseline": "[i for i, j in a if i != 13]",
   "body:Baseline": "[i for i, j in a if j != 13]",
   "body:-Blocks": "[x[0] for x in a]",
   "body:-Code": "[x[0] for x in a]",
   "body:-Inline": "[x[0] for x in a]",
   "body:-NL": "[i for i, j in a if i != 13]",
   "base:+Mined": "[(i * j) for i, j in zip(a, b)]",
   "body+mined:Baseline": "[x for x in a if x != 13]",
   "body+mined:-Code": "[(13 * a) for a in a]",
   "body+mined:-NL": "[i for i, j in zip(a, a[i:13]) if j != 13]",
   "body+mined:-Blocks": "a.sub(13, 13)",
   "body+mined:-Inline": "[x[0] for x in a]"
  },
  "snippet": "a[:] = [(x - 13) for x in a]"
 },
 "701402.492": {
  "intent": "choose a random file from the directory contents of the c drive, `c:\\\\`",
  "body": "What is the best way to choose a random file from a directory in Python?\nEdit:  Here is what I am doing:\nimport os\nimport random\nimport dircache\n\ndir = 'some/directory'\nfilename = random.choice(dircache.listdir(dir))\npath = os.path.join(dir, filename)\n\nIs this particularly bad, or is there a particularly better way?\n",
  "preds": {
   "base:Baseline": "random.choice(c:\\\\)",
   "body:Baseline": "random.choice(listdir(c:\\\\)",
   "body:-Blocks": "random.choice(c:\\\\)",
   "body:-Code": "random.choice(c:\\\\)",
   "body:-Inline": "random.choice(c:\\\\)",
   "body:-NL": "random.choice(dir, filename)",
   "base:+Mined": "random.choice(os.path.dirname(c:\\\\))",
   "body+mined:Baseline": "random.choice(open('C:\\\\'))",
   "body+mined:-Code": "random.choice(open('C:\\\\').read())",
   "body+mined:-NL": "random.choice(listdir, filename)",
   "body+mined:-Blocks": "print(random.choice(open('C:\\\\').read())",
   "body+mined:-Inline": "random.choice(listdir, c:\\\\)"
  },
  "snippet": "random.choice(os.listdir('C:\\\\'))"
 },
 "17794266.493": {
  "intent": "get the highest element in absolute value in a numpy matrix `x`",
  "body": "Here is what I am currently doing, it works but it's a little cumbersome:\nx = np.matrix([[1, 1], [2, -3]])\nxmax = x.flat[abs(x).argmax()]\n\n",
  "preds": {
   "base:Baseline": "max(x, key=lambda x: x[1])",
   "body:Baseline": "np.matrix([1, 1], [2, -3]])",
   "body:-Blocks": "max(x, key=lambda x: x[1])",
   "body:-Code": "max(x, key=lambda x: x[1])",
   "body:-Inline": "x[0].isinstance(x)",
   "body:-NL": "np.matrix([np.arange(x).argmax()])",
   "base:+Mined": "np.argwhere(np.arange(x))[0]",
   "body+mined:Baseline": "xmax = x.flat[abs(x).argmax(axis=1)]",
   "body+mined:-Code": "x.argmax(axis=1)",
   "body+mined:-NL": "x.flat[abs(x).argmax(axis=1)]",
   "body+mined:-Blocks": "x.argmax(axis=0)",
   "body+mined:-Inline": "xmax = x.flat[abs(x).argmax()]"
  },
  "snippet": "max(x.min(), x.max(), key=abs)"
 },
 "30551576.494": {
  "intent": "get all urls within text `s`",
  "body": "I have parsed an html document containing javascript with beautifulsoup, and have managed to isolate the javascript within it and convert it into a string. The javascript looks like this: \n<script>\n    [irrelevant javascript code here]\n    sources:[{file:\"http://url.com/folder1/v.html\",label:\"label1\"},\n    {file:\"http://url.com/folder2/v.html\",label:\"label2\"},\n    {file:\"http://url.com/folder3/v.html\",label:\"label3\"}],\n    [irrelevant javascript code here]\n</script>\n\nI am trying to get an array with only urls contained in this sources array, which would look like so:\nurls = ['http://url.com/folder1/v.html', \n        'http://url.com/folder2/v.html', \n        'http://url.com/folder3/v.html']\n\nThe domains are unknown IPs, the folders are of random name-length consisting of lowercase letters and numbers, and there are 1-5 of them in each file(usually 3). All that is constant is that they start with http  and end with .html .\nI decided to use regular expressions to deal with this problem(which I am quite new at) and my code looks like this: urls=re.findall(r'http://[^t][^s\"]+', document)\nThe [^t]  is there because there are other urls in the document whose domain names start with t. My problem is, there is another url with a jpg from the same domain as the urls I am extracting, which gets put into the urls array along with the others. \nExample:\nurls = ['http://123.45.67.89/asodibfo3ribawoifbadsoifasdf3/v.html'\n        'http://123.45.67.89/alwefaoewifiasdof224a/v.html',\n        'http://123.45.67.89/baoisdbfai235oubodsfb45/v.html',\n        'http://123.45.67.89/i/0123/12345/aoief243oinsdf.jpg']\n\nHow would I go about only fetching the html urls?\n",
  "preds": {
   "base:Baseline": "print(re.findall('[^a-zA-Z]*', s))",
   "body:Baseline": "re.findall('http://[^t][^s]+', s)",
   "body:-Blocks": "re.findall('[^t]', s)",
   "body:-Code": "urllib.parse.unquote(s)",
   "body:-Inline": "urls = ['http://url.com/folder1/v.html', s)",
   "body:-NL": "urls = re.findall('http://[^t][^s]+', s)",
   "base:+Mined": "print(re.findall('\\\\s+', s))",
   "body+mined:Baseline": "urls = [re.findall('http://[^t][^s]+)', document)",
   "body+mined:-Code": "print(re.findall('(?P<domain>\\\\w+))', s))",
   "body+mined:-NL": "urls = re.findall('http://[^t][^s]+', document)",
   "body+mined:-Blocks": "re.findall('http://[^t][^s]+', s)",
   "body+mined:-Inline": "print(open('http://url.com/folder1/v.html').read())"
  },
  "snippet": "re.findall('\"(http.*?)\"', s, re.MULTILINE | re.DOTALL)"
 },
 "30551576.495": {
  "intent": "match urls whose domain doesn't start with `t` from string `document` using regex",
  "body": "I have parsed an html document containing javascript with beautifulsoup, and have managed to isolate the javascript within it and convert it into a string. The javascript looks like this: \n<script>\n    [irrelevant javascript code here]\n    sources:[{file:\"http://url.com/folder1/v.html\",label:\"label1\"},\n    {file:\"http://url.com/folder2/v.html\",label:\"label2\"},\n    {file:\"http://url.com/folder3/v.html\",label:\"label3\"}],\n    [irrelevant javascript code here]\n</script>\n\nI am trying to get an array with only urls contained in this sources array, which would look like so:\nurls = ['http://url.com/folder1/v.html', \n        'http://url.com/folder2/v.html', \n        'http://url.com/folder3/v.html']\n\nThe domains are unknown IPs, the folders are of random name-length consisting of lowercase letters and numbers, and there are 1-5 of them in each file(usually 3). All that is constant is that they start with http  and end with .html .\nI decided to use regular expressions to deal with this problem(which I am quite new at) and my code looks like this: urls=re.findall(r'http://[^t][^s\"]+', document)\nThe [^t]  is there because there are other urls in the document whose domain names start with t. My problem is, there is another url with a jpg from the same domain as the urls I am extracting, which gets put into the urls array along with the others. \nExample:\nurls = ['http://123.45.67.89/asodibfo3ribawoifbadsoifasdf3/v.html'\n        'http://123.45.67.89/alwefaoewifiasdof224a/v.html',\n        'http://123.45.67.89/baoisdbfai235oubodsfb45/v.html',\n        'http://123.45.67.89/i/0123/12345/aoief243oinsdf.jpg']\n\nHow would I go about only fetching the html urls?\n",
  "preds": {
   "base:Baseline": "re.findall('\\\\w+', document)",
   "body:Baseline": "re.findall('http://[^t][^s]', document)",
   "body:-Blocks": "re.findall('[^t]', document)",
   "body:-Code": "urllib.parse.unquote(document.startswith('t')))",
   "body:-Inline": "re.findall('[^a-t]', document)",
   "body:-NL": "re.findall('http://[^t][^s]+', document)",
   "base:+Mined": "re.findall('\\\\w+', document)",
   "body+mined:Baseline": "urls = re.findall('http://[^t][^s]+', document)",
   "body+mined:-Code": "print(re.compile('^[^\\\\w\\\\s]*$').read())",
   "body+mined:-NL": "urls = re.findall('http://[^t][^s]+', document)",
   "body+mined:-Blocks": "re.findall('http://[^t][^s]', document)",
   "body+mined:-Inline": "re.findall('\\\\w+', document)"
  },
  "snippet": "re.findall('http://[^t][^s\"]+\\\\.html', document)"
 },
 "113534.496": {
  "intent": "split a string `mystring` considering the spaces ' '",
  "body": "Is there a function in Python to split a string without ignoring the spaces in the resulting list? \nE.g:\ns=\"This is the string I want to split\".split()\n\ngives me\ns\n['This', 'is', 'the', 'string', 'I', 'want', 'to', 'split']\n\nI want something like\n['This',' ','is',' ', 'the',' ','string', ' ', <console_out>..]\n\n",
  "preds": {
   "base:Baseline": "re.split(' ', mystring)",
   "body:Baseline": "\"\"\"This is the string I want to split\"\"\".split()",
   "body:-Blocks": "myString.split(' ', 1)",
   "body:-Code": "myString.split(' ', 1)",
   "body:-Inline": "s = s.split(' ', mystring)",
   "body:-NL": "\"\"\"This is the string I want to split\".split()",
   "base:+Mined": "myString.split(' ', 1)",
   "body+mined:Baseline": "s = s.replace(' ', '')",
   "body+mined:-Code": "myString.split(' ', 1)",
   "body+mined:-NL": "mystring.split(' ', 1)",
   "body+mined:-Blocks": "\"\"\" \"\"\".join(myString.split(' '))",
   "body+mined:-Inline": "s = s.replace(' ', '')"
  },
  "snippet": "mystring.replace(' ', '!!').split('!')"
 },
 "5838735.497": {
  "intent": "open file `path` with mode 'r'",
  "body": "My cwd is ~/Desktop/Development/Python/djcode/mysite, and I want to open a file on my Desktop. What is the syntax to open files in a different directory? (for example, if the file was in the cwd I would use open('file'). Thank you.\n",
  "preds": {
   "base:Baseline": "os.path.open('r')",
   "body:Baseline": "os.path.open('path', 'r')",
   "body:-Blocks": "os.path.open('r')",
   "body:-Code": "os.path.open('r')",
   "body:-Inline": "os.path.open('file').r')",
   "body:-NL": "os.path.open('r')",
   "base:+Mined": "os.path.join(path, 'r')",
   "body+mined:Baseline": "os.path.join(path, 'r')",
   "body+mined:-Code": "os.path.join(path, 'r')",
   "body+mined:-NL": "os.path.expanduser('r')",
   "body+mined:-Blocks": "os.path.join(path, 'r')",
   "body+mined:-Inline": "os.path.join(path, 'r')"
  },
  "snippet": "open(path, 'r')"
 },
 "36003967.498": {
  "intent": "sum elements at the same index in list `data`",
  "body": "Consider I have a list of lists as:\n[[5, 10, 30, 24, 100], [1, 9, 25, 49, 81]]\n[[15, 10, 10, 16, 70], [10, 1, 25, 11, 19]]\n[[34, 20, 10, 10, 30], [9, 20, 25, 30, 80]]\n\nNow I want the sum of all indexes of first list's index wise and then the 2nd list   5+15+34=54   10+10+20=40 \nand so on as:\n[54,40,50, 50,200], [20,30,75,90,180]\n\nI tried:\nfor res in results:     \n    print [sum(j) for j in zip(*res)] \n\nHere results  is the list of lists. \nBut it gives sum of each list item as:\n[6,19,55,73,181]\n[25,11,35,27,89]\n[43,40,35,40,110]\n\n",
  "preds": {
   "base:Baseline": "sum(data, key=lambda x: x[1])",
   "body:Baseline": "sum(i, j) for i, j in zip(*data)]",
   "body:-Blocks": "sum(zip(data, key=lambda x: x[1])",
   "body:-Code": "sum(x, y) for x, y in data)",
   "body:-Inline": "sum(j) for i, j in zip(*data)]",
   "body:-NL": "[sum(x) for x, y in zip(*data)]",
   "base:+Mined": "sum(x * y for x, y in zip(data, values))",
   "body+mined:Baseline": "[sum(j) for i, j in zip(*data)]",
   "body+mined:-Code": "sum(map(lambda i: sum(i[0], i[0]))",
   "body+mined:-NL": "[sum(j) for i, j in zip(*data)]",
   "body+mined:-Blocks": "sum(x[0] for x in data)",
   "body+mined:-Inline": "[sum(j) for i, j in zip(*data)]"
  },
  "snippet": "[[sum(item) for item in zip(*items)] for items in zip(*data)]"
 },
 "7635237.499": {
  "intent": "add a new axis to array `a`",
  "body": "I'd like to cast a numpy ndarray  object of shape ( n ,) into one having shape ( n , 1).  The best I've come up with is to roll my own _to_col function:\ndef _to_col(a):\n    return a.reshape((a.size, 1))\n\nBut it is hard for me to believe that such a ubiquitous operation is not already built into numpy's syntax.  I figure that I just have not been able to hit upon the right Google search to find it.\n",
  "preds": {
   "base:Baseline": "a.reshape(axis=1)",
   "body:Baseline": "a.reshape((a.size, 1))",
   "body:-Blocks": "a.shape_adjust(axis=0)",
   "body:-Code": "a.shape_adjust(axis=1)",
   "body:-Inline": "a.reshape(axis=1)",
   "body:-NL": "a.reshape((a.size, 1))",
   "base:+Mined": "a.set_zlabel('A')",
   "body+mined:Baseline": "a.reshape((1, 1))",
   "body+mined:-Code": "a[np.arange(a.shape[0]) + 1]",
   "body+mined:-NL": "a.reshape((a.size, 1), axis=1)",
   "body+mined:-Blocks": "a.reshape(1, 1)",
   "body+mined:-Inline": "a.reshape(a.size, 1)"
  },
  "snippet": "a[:, (np.newaxis)]"
 }
}