================================================================================

QUESTION: idx=0      id=15080500
-------------------------------------INPUTS-------------------------------------

tags: linux, signals
score: 24
slot_map: {'key': ['str_0'], 'quote': ['`'], 'type': ['str'], 'value': ['signal.SIGUSR1']}
intent: send a signal `signal.sigusr1` to the current process
body(Left in tags for better readability):
<p> I have this code which listens to USR1 signals
<code_block>
 import signal
import os
import time

def receive_signal(signum, stack):
    print 'Received:', signum

signal.signal(signal.SIGUSR1, receive_signal)
signal.signal(signal.SIGUSR2, receive_signal)

print 'My PID is:', os.getpid()

while True:
    print 'Waiting...'
    time.sleep(3)

<p> This works when I send signals with <code> kill -USR1 pid
<p> But how can I send the same signal from within the above python
script so that after 10 seconds it automatically sends <code> USR1 <p>
and also receives it , without me having to open two terminals to
check it?

-------------------------------------OUTPUT-------------------------------------

                Expected= 'os.kill(os.getpid(), signal.SIGUSR1)'
           base:Baseline= sys.communicate('signal.sigusr1')
           body:Baseline= print('USR1 is:', sigusr1)
            body:-Blocks= process.call(USR1, 'signal.sigusr1')
              body:-Code= sys.system('signal.sigusr1')
            body:-Inline= signal.SIGUSR1, receive_signal)
                body:-NL= print(signal.SIGUSR1, receive_signal)
             base:+Mined= sys.stdout.write('signal.sigusr1')
     body+mined:Baseline= signal.SIGUSR1.communicate()[0]
        body+mined:-Code= signal.SIGUSR1(0, 1)
          body+mined:-NL= signal.SIGUSR1.communicate()
      body+mined:-Blocks= signal.sigusr1.communicate()[0]
      body+mined:-Inline= signal.SIGUSR1.communicate()

================================================================================

QUESTION: idx=1      id=3283984
-------------------------------------INPUTS-------------------------------------

tags: 
score: 64
slot_map: {'key': ['str_0'], 'quote': ["'"], 'type': ['str'], 'value': ['4a4b4c']}
intent: decode a hex string '4a4b4c' to utf-8.
body(Left in tags for better readability):
<p> In Python 2, converting the hexadecimal form of a string into the
corresponding unicode was straightforward:
<code_block>
 comments.decode("hex")

<p> where the variable 'comments' is a part of a line in a file (the
rest of the line does <em> not <p>  need to be converted, as it is
represented only in ASCII.
<p> Now in Python 3, however, this doesn't work (I assume because of
the bytes/string vs. string/unicode switch. I feel like there should
be a one-liner in Python 3 to do the same thing, rather than reading
the entire line as a series of bytes (which I don't want to do) and
then converting each part of the line separately. If it's possible,
I'd like to read the entire line as a unicode string (because the rest
of the line is in unicode) and only convert this one part from a
hexadecimal representation.

-------------------------------------OUTPUT-------------------------------------

                Expected= "bytes.fromhex('4a4b4c').decode('utf-8')"
           base:Baseline= print('4a4b4c'.decode('hex')
           body:Baseline= struct.unpack('4a4b4c').decode('hex')
            body:-Blocks= urllib.parse.unquote('4a4b4c')
              body:-Code= urllib.parse.unquote('4a4b4c')
            body:-Inline= comments.decode('hex').encode('4a4b4c')
                body:-NL= comments.decode('4a4b4c').encode('hex')
             base:+Mined= decoded('4a4b4c', 16)
     body+mined:Baseline= int('4a4b4c', 16)
        body+mined:-Code= """4a4b4c""".decode('hex')
          body+mined:-NL= comment.decode('4a4b4c')
      body+mined:-Blocks= """4a4b4c""".decode('hex')
      body+mined:-Inline= int('4a4b4c', 16)

================================================================================

QUESTION: idx=2      id=3844801
-------------------------------------INPUTS-------------------------------------

tags: algorithm, comparison
score: 436
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['myList']}
intent: check if all elements in list `mylist` are identical
body(Left in tags for better readability):
<p> I need a function which takes in a <code> list <p>  and outputs
<code> True <p>  if all elements in the input list evaluate as equal
to each other using the standard equality operator and <code> False
<p>  otherwise.
<p> I feel it would be best to iterate through the list comparing
adjacent elements and then <code> AND <p>  all the resulting Boolean
values. But I'm not sure what's the most Pythonic way to do that.

-------------------------------------OUTPUT-------------------------------------

                Expected= 'all(x == myList[0] for x in myList)'
           base:Baseline= all(i == j for i in mylist)
           body:Baseline= all(i == j for i, j in mylist)
            body:-Blocks= all(x == y for x in mylist)
              body:-Code= all(iter(mylist) == 0)
            body:-Inline= all(i == j for i, j in mylist)
                body:-NL= all(x in mylist for x in x)
             base:+Mined= len(set(myList)) == 1
     body+mined:Baseline= all(isinstance(x, y) for x, y in mylist)
        body+mined:-Code= all(i == j for i, j in enumerate(myList) if j == j)
          body+mined:-NL= all(x == mylist for x in mylist)
      body+mined:-Blocks= all(i == j for i, j in zip(myList, myList))
      body+mined:-Inline= all(i == j for i, j in enumerate(mylist))

================================================================================

QUESTION: idx=3      id=4302166
-------------------------------------INPUTS-------------------------------------

tags: string
score: 57
slot_map: {'key': ['var_0', 'str_0', 'str_1', 'str_2'], 'quote': ['`', '`', '`', '`'], 'type': ['var', 'str', 'str', 'str'], 'value': ['Python', ':', 'Very Good', '20']}
intent: format number of spaces between strings `python`, `:` and `very good` to be `20`
body(Left in tags for better readability):
<p> If I want to make my formatted string dynamically adjustable, I
can change the following code from
<code_block>
 print '%20s : %20s' % ("Python", "Very Good")

<p> to
<code_block>
 width = 20
print ('%' + str(width) + 's : %' + str(width) + 's') % ("Python",
"Very Good")

<p> However, it seems that string concatenation is cumbersome here.
Any other way to simplify things?

-------------------------------------OUTPUT-------------------------------------

                Expected= "print('%*s : %*s' % (20, 'Python', 20, 'Very Good'))"
           base:Baseline= """{0:.2f}""".format(python, `:','very good')
           body:Baseline= print('%20s : %s' % ('Python', ':') + 'very good')
            body:-Blocks= """{0:.2f}""".format(python, ':', 'very good')
              body:-Code= """{0:}""".format(python, `:','very good'))
            body:-Inline= print('%20s : %20s') % ('Python', 'Very Good')
                body:-NL= print('%20s : %20s' % ('Python', 'Very Good')
             base:+Mined= """{0:.2f}""".format(python, ':', 'very good')
     body+mined:Baseline= print('%20s : %20s' % ('Python', 'Very Good')
        body+mined:-Code= """{:.2f}""".format(my_string)
          body+mined:-NL= print('%20s : %20s' % ('Python', 'Very Good')
      body+mined:-Blocks= """python, :, very good""".format(('python', ':','very good')
      body+mined:-Inline= print('%20s : %20s' % ('Python', 'Very Good')

================================================================================

QUESTION: idx=4      id=7555335
-------------------------------------INPUTS-------------------------------------

tags: utf-8, cp1251
score: 26
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: how to convert a string from cp-1251 to utf-8?
body(Left in tags for better readability):
<p> I'm using mutagen to convert ID3 tags data from <a> CP-1251 <p> /
<a> CP-1252 <p>  to UTF-8. In Linux there is no problem. But on
Windows, calling <code> SetValue() <p>  on a wx.TextCtrl produces the
error:

<p> UnicodeDecodeError: 'ascii' codec can't decode byte 0xc3 in
position
  0: ordinal not in range(128)

<p> The original string (assumed to be CP-1251 encoded) that I'm
pulling from <a> mutagen <p>  is:
<code_block>
 u'\xc1\xe5\xeb\xe0\xff \xff\xe1\xeb\xfb\xed\xff \xe3\xf0\xee\xec\xf3'

<p> I've tried converting this to UTF-8:
<code_block>
 dd = d.decode('utf-8')

<p> <console_out>and even changing the default encoding from ASCII to
UTF-8:
<code_block>
 sys.setdefaultencoding('utf-8')

<p> <console_out>But I get the same error.

-------------------------------------OUTPUT-------------------------------------

                Expected= "d.decode('cp1251').encode('utf8')"
           base:Baseline= """cp-1251""".encode('utf8')
           body:Baseline= struct.setdefaultencoding('cp-1251', 'utf8')
            body:-Blocks= urllib.parse.unquote('cp-1251', 'utf-8')
              body:-Code= urllib.parse.unquote('cp-1251', 'utf-8')
            body:-Inline= sys.setdefaultencoding('cp-1251', UTF - 8)
                body:-NL= sys.setdefaultencoding('cp-1251')
             base:+Mined= s.decode('cp1251').encode('utf8')
     body+mined:Baseline= sys.setdefaultencoding('utf-8')
        body+mined:-Code= s.decode('cp-1252').encode('utf-8')
          body+mined:-NL= sys.setdefaultencoding('cp-1251', 'ignore')
      body+mined:-Blocks= s.decode('utf-8').encode('ascii', 'ignore')
      body+mined:-Inline= sys.setdefaultencoding('cp-1251').encode('utf8')

================================================================================

QUESTION: idx=5      id=2544710
-------------------------------------INPUTS-------------------------------------

tags: 
score: 44
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['kwargs']}
intent: get rid of none values in dictionary `kwargs`
body(Left in tags for better readability):
<p> Something like:
<code_block>
 for (a,b) in kwargs.iteritems():
    if not b : del kwargs[a]

<p> This code raise exception because changing of dictionary when
iterating.
<p> I discover only non pretty solution with another dictionary:
<code_block>
 res ={}
res.update((a,b) for a,b in kwargs.iteritems() if b is not None)

<p> Thanks

-------------------------------------OUTPUT-------------------------------------

                Expected= 'res = {k: v for k, v in list(kwargs.items()) if v is not None}'
           base:Baseline= dict((k, v) for k, v in list(kwargs.items()))
           body:Baseline= res.update((a, b) for a, b in kwargs.iteritems())
            body:-Blocks= dict((k, v) for k, v in list(kwargs.items())
              body:-Code= dict((k, v) for k, v in kargs.items())
            body:-Inline= res.update((a, b) for a, b in kwargs.iteritems(): if b not None)
                body:-NL= res.update((a, b) if b is not None)
             base:+Mined= {k: v for k, v in list(kwargs.items()) if v is not None}
     body+mined:Baseline= res = {k: v for k, v in list(kwargs.items()) if v is not None}
        body+mined:-Code= {k: v for k, v in list(kwargs.items()) if v is not None}
          body+mined:-NL= res.update((a, b) for a, b in kwargs.items() if b is not None)
      body+mined:-Blocks= {k: v for k, v in list(kwargs.items()) if v is not None}
      body+mined:-Inline= res = {k: v for k, v in list(kwargs.items()) if v is not None}

================================================================================

QUESTION: idx=6      id=2544710
-------------------------------------INPUTS-------------------------------------

tags: 
score: 44
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['kwargs']}
intent: get rid of none values in dictionary `kwargs`
body(Left in tags for better readability):
<p> Something like:
<code_block>
 for (a,b) in kwargs.iteritems():
    if not b : del kwargs[a]

<p> This code raise exception because changing of dictionary when
iterating.
<p> I discover only non pretty solution with another dictionary:
<code_block>
 res ={}
res.update((a,b) for a,b in kwargs.iteritems() if b is not None)

<p> Thanks

-------------------------------------OUTPUT-------------------------------------

                Expected= 'res = dict((k, v) for k, v in kwargs.items() if v is not None)'
           base:Baseline= dict((k, v) for k, v in list(kwargs.items()))
           body:Baseline= res.update((a, b) for a, b in kwargs.iteritems())
            body:-Blocks= dict((k, v) for k, v in list(kwargs.items())
              body:-Code= dict((k, v) for k, v in kargs.items())
            body:-Inline= res.update((a, b) for a, b in kwargs.iteritems(): if b not None)
                body:-NL= res.update((a, b) if b is not None)
             base:+Mined= {k: v for k, v in list(kwargs.items()) if v is not None}
     body+mined:Baseline= res = {k: v for k, v in list(kwargs.items()) if v is not None}
        body+mined:-Code= {k: v for k, v in list(kwargs.items()) if v is not None}
          body+mined:-NL= res.update((a, b) for a, b in kwargs.items() if b is not None)
      body+mined:-Blocks= {k: v for k, v in list(kwargs.items()) if v is not None}
      body+mined:-Inline= res = {k: v for k, v in list(kwargs.items()) if v is not None}

================================================================================

QUESTION: idx=7      id=14971373
-------------------------------------INPUTS-------------------------------------

tags: subprocess
score: 4
slot_map: {'key': ['str_0'], 'quote': ['`'], 'type': ['str'], 'value': ['ps -ef | grep something | wc -l']}
intent: capture final output of a chain of system commands `ps -ef | grep something | wc -l`
body(Left in tags for better readability):
<p> There are many posts here on SO, like this one: <a> Store output
of subprocess.Popen call in a string
<p> There is problem with complicated commands. For example, if I need
to get output from this

<p> ps -ef|grep something|wc -l

<p> Subprocess won't do the job, because argument for subprocess is
[name of program, arguments], so it is not possible to use more
sophisicated commands (more programs, pipes, etc.).
<p> Is there way to capture the output of a chain of multiple
commands?

-------------------------------------OUTPUT-------------------------------------

                Expected= "subprocess.check_output('ps -ef | grep something | wc -l', shell=True)"
           base:Baseline= sys.system('ps -ef | grep something | wc -l')
           body:Baseline= ps -ef | grep something | wc -l[::-1]
            body:-Blocks= subprocess.Popen('ps -ef | grep something | wc -l')
              body:-Code= subprocess.call('ps -ef | grep something | wc -l')
            body:-Inline= subprocess.communicate(ps -ef | grep something | wc -l)
                body:-NL= sys.communicate('ps -ef | grep something | wc -l')
             base:+Mined= p.communicate()[0]
     body+mined:Baseline= output = subprocess.Popen(['ps -ef', 'grep something | wc -l'])
        body+mined:-Code= process.check_output(ps -ef | grep something | wc -l)
          body+mined:-NL= ps.communicate()[0]
      body+mined:-Blocks= output = subprocess.Popen('ps -ef | grep something | wc -l')
      body+mined:-Inline= output = subprocess.Popen(['ps -ef', 'grep something | wc -l'])

================================================================================

QUESTION: idx=8      id=6726636
-------------------------------------INPUTS-------------------------------------

tags: string, split, append
score: 8
slot_map: {'key': ['str_0', '[str_0]'], 'quote': ['`', '`'], 'type': ['str', 'str'], 'value': ["['a', 'b', 'c']", "['a', 'b', 'c']"]}
intent: concatenate a list of strings `['a', 'b', 'c']`
body(Left in tags for better readability):
<p> I was wondering if python had a built in function similar to
<code_block>
 string->list

<p> and <code> list->string <p>  in scheme.
<p> So for example I would like to turn 'abc' into <code>
['a','b','c'] <p>  and vice versa using a built in function.

-------------------------------------OUTPUT-------------------------------------

                Expected= '"""""".join([\'a\', \'b\', \'c\'])'
           base:Baseline= list(['a', 'b', 'c']))
           body:Baseline= ['a', 'b', 'c']
            body:-Blocks= ['abc'] = ['a', 'b', 'c']
              body:-Code= list(['a', 'b', 'c']))
            body:-Inline= list(['a', 'b', 'c']))
                body:-NL= list(['a', 'b', 'c']))
             base:+Mined= ['a', 'b', 'c']
     body+mined:Baseline= ['a', 'b', 'c']
        body+mined:-Code= ['abc', 'b', 'c']
          body+mined:-NL= ['a', 'b', 'c']
      body+mined:-Blocks= ['a', 'b', 'c']
      body+mined:-Inline= ['a', 'b', 'c']

================================================================================

QUESTION: idx=9      id=18079563
-------------------------------------INPUTS-------------------------------------

tags: pandas, series, intersection
score: 62
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['s1', 's2']}
intent: find intersection data between series `s1` and series `s2`
body(Left in tags for better readability):
<p> I have two series <code> s1 <p>  and <code> s2 <p>  in pandas and
want to compute the intersection i.e. where all of the values of the
series are common.
<p> How would I use the <code> concat <p>  function to do this? I have
been trying to work it out but have been unable to (I don't want to
compute the intersection on the indices of <code> s1 <p>  and <code>
s2 <p> , but on the values).

-------------------------------------OUTPUT-------------------------------------

                Expected= 'pd.Series(list(set(s1).intersection(set(s2))))'
           base:Baseline= print(s1.intersection(s2.index(1))
           body:Baseline= np.arange(s1, s2)
            body:-Blocks= pd.concat([i for i, j in s1, s2])
              body:-Code= np.arange(s1, s2)
            body:-Inline= df.intersection(s1, s2)
                body:-NL= s1.intersection(s2.split())
             base:+Mined= s1.intersection(s2.cross(s1))
     body+mined:Baseline= pd.concat([s1, s2], axis=1)
        body+mined:-Code= pd.concat([s1, s2], axis=1)
          body+mined:-NL= s1.find_intersection(s2)
      body+mined:-Blocks= pd.concat([s1, s2], axis=1)
      body+mined:-Inline= pd.concat([s1, s2], axis=1)

================================================================================

QUESTION: idx=10     id=8315209
-------------------------------------INPUTS-------------------------------------

tags: html, sockets, client
score: 7
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['client']}
intent: sending http headers to `client`
body(Left in tags for better readability):
<p> I've set up a little script that should feed a client with html.
<code_block>
 import socket

sock = socket.socket()
sock.bind(('', 8080))
sock.listen(5)
client, adress = sock.accept()

print "Incoming:", adress
print client.recv(1024)
print

client.send("Content-Type: text/html\n\n")
client.send(' <html> <body> </body> </html>')

print "Answering <console_out>"
print "Finished."

import os
os.system("pause")

<p> But it is shown as plain text in the browser. Can you please tell
what I need to do ? I just can't find something in google that helps
me..
<p> Thanks.

-------------------------------------OUTPUT-------------------------------------

                Expected= "client.send('HTTP/1.0 200 OK\\r\\n')"
           base:Baseline= client.send(' headers', headers=False)
           body:Baseline= client.send('Content-Type: text/html\n\n')
            body:-Blocks= client.send('http://www.headers.com')
              body:-Code= request.headers.get('utf-8')
            body:-Inline= client.send('Content-Type: text/html\n\n')
                body:-NL= client.send('Content-Type: text/html\n')
             base:+Mined= client.send('HTTP/1.0 200 OK')
     body+mined:Baseline= client.send('Content-Type: text/html\n')
        body+mined:-Code= client.sendheaders('http://www.gmail.com')
          body+mined:-NL= client.send('Content-Type: text/html\\n\\n')
      body+mined:-Blocks= client.serve_forever()
      body+mined:-Inline= client.send('Content-Type: text/html\n\n')

================================================================================

QUESTION: idx=11     id=26153795
-------------------------------------INPUTS-------------------------------------

tags: datetime, strptime
score: 50
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['when']}
intent: format a datetime string `when` to extract date only
body(Left in tags for better readability):
<p> I have a date string and want to convert it to the date type:
<p> I have tried to use datetime.datetime.strptime with the format
that I want but it is returning the time with the conversion.
<code_block>
     when = alldates[int(daypos[0])]
    print when, type(when)

    then = datetime.datetime.strptime(when, '%Y-%m-%d')
    print then, type(then)

<p> This is what the output returns:
<code_block>
    2013-05-07 <type 'str'>
   2013-05-07 00:00:00 <type 'datetime.datetime'>

<p> I need to remove the the time: 00:00:00.

-------------------------------------OUTPUT-------------------------------------

                Expected= "then = datetime.datetime.strptime(when, '%Y-%m-%d').date()"
           base:Baseline= datetime.strptime('today', '%Y-%m-%d %H:%M')
           body:Baseline= time.datetime.strptime(when, '%Y-%m-%d')
            body:-Blocks= datetime.strptime(when, '%Y:%M:%S')
              body:-Code= datetime.strptime(when)
            body:-Inline= when = datetime.datetime.strptime(when, '%Y-%m-%d')
                body:-NL= time.strptime(when, '%Y-%m-%d')
             base:+Mined= datetime.strptime('2012-03-01T19:00:00Z', '%Y-%m-%dT%H:%M:%SZ')
     body+mined:Baseline= date = datetime.datetime.strptime(2013-05-07, '%Y-%m-%d')
        body+mined:-Code= datetime.strptime('2012-05-29T19:00:00', '%Y-%m-%dT%H:%M:%SZ')
          body+mined:-NL= dt = datetime.datetime.now().strftime('%Y-%m-%d')
      body+mined:-Blocks= datetime.strptime('2012-05-01T19:00:00', '%Y-%m-%dT%H:%M:%SZ')
      body+mined:-Inline= date.strptime(when, '%Y-%m-%d').date()

================================================================================

QUESTION: idx=12     id=172439
-------------------------------------INPUTS-------------------------------------

tags: string
score: 303
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['inputString']}
intent: split a multi-line string `inputstring` into separate strings
body(Left in tags for better readability):
<p> I have a multi-line string literal that I want to do an operation
on each line, like so:
<code_block>
 inputString = """Line 1
Line 2
Line 3"""

<p> I want to do something like the following:
<code_block>
 for line in inputString:
    doStuff()


-------------------------------------OUTPUT-------------------------------------

                Expected= "inputString.split('\\n')"
           base:Baseline= """{0:.2f}""".format(inputstring)
           body:Baseline= inputString.split(',', 1)[::-1]
            body:-Blocks= inputString = re.sub('[^a-z]', '', inputstring)
              body:-Code= inputString.split(',', 1)[0]
            body:-Inline= """Line 1"""".join(chr(inputString))
                body:-NL= re.split('', inputString)
             base:+Mined= """ """.join(map(str, inputstring))
     body+mined:Baseline= """""".join(map(str, inputString))
        body+mined:-Code= """ """.join(map(lambda x: x.split('\n'))
          body+mined:-NL= """""".join(map(str, inputString))
      body+mined:-Blocks= """""".join(map(inputstring, inputstring.split())
      body+mined:-Inline= """""".join(map(str, inputString.split(',')))

================================================================================

QUESTION: idx=13     id=172439
-------------------------------------INPUTS-------------------------------------

tags: string
score: 303
slot_map: {'key': ['str_0', 'str_1'], 'quote': ['`', '`'], 'type': ['str', 'str'], 'value': ['a \n b \r\n c', '\n']}
intent: split a multi-line string ` a \n b \r\n c ` by new line character `\n`
body(Left in tags for better readability):
<p> I have a multi-line string literal that I want to do an operation
on each line, like so:
<code_block>
 inputString = """Line 1
Line 2
Line 3"""

<p> I want to do something like the following:
<code_block>
 for line in inputString:
    doStuff()


-------------------------------------OUTPUT-------------------------------------

                Expected= "' a \\n b \\r\\n c '.split('\\n')"
           base:Baseline= re.split('\n', 'a \n b \r\n c')
           body:Baseline= a \n b \r\n c = re.findall('\n')
            body:-Blocks= 'A \n b \r\n c'.split('\n')
              body:-Code= re.split('\n', 'A \n b \r\n c')
            body:-Inline= 'A \n b \r\n c'.split('\n')
                body:-NL= re.split('\n', '\n')
             base:+Mined= re.split('\n', a \n b \r\n c)
     body+mined:Baseline= 'A \n b \r\n c'.split()
        body+mined:-Code= 'A \n b \r\n c'.split(',')
          body+mined:-NL= 'a \n b \r\n c'.split()
      body+mined:-Blocks= 'a \n b \r\n c'.split()
      body+mined:-Inline= 'A \n b \r\n c'.split()

================================================================================

QUESTION: idx=14     id=13954222
-------------------------------------INPUTS-------------------------------------

tags: 
score: 11
slot_map: {'key': ['var_0', 'str_0'], 'quote': ['`', '"'], 'type': ['var', 'str'], 'value': ['b', ':']}
intent: concatenate elements of list `b` by a colon ":"
body(Left in tags for better readability):
<p> I have a list (array) with mixed
<code_block>
 a = ["x", "2", "y"]
b = ["x", 2, "y"]
print ":".join(a)
print ":".join(b)

<p> The first join works, but the second one throws a TypeError
exception
<p> I came up with this, but is this the Python solution?
<code_block>
 print ":".join(map(str, b))

<p> BTW in the end I just would like to write this string to a file,
so if there is a specific solution for that, I'd appreciate that too.

-------------------------------------OUTPUT-------------------------------------

                Expected= '""":""".join(str(x) for x in b)'
           base:Baseline= [(x + y) for x, y in zip(b, b)]
           body:Baseline= b = map(str, b))
            body:-Blocks= b = [i.split(':"] for i in range(0, len(b))]
              body:-Code= b = [(':") for i in range(0, len(b), ':"))
            body:-Inline= print(':'.join(a, b))
                body:-NL= b = [(x + b) for x, b in zip(a, b)]
             base:+Mined= b = [int(i) for i in b]
     body+mined:Baseline= print(':'.join(map(str, b))
        body+mined:-Code= """""".join(str(i) for i in b)
          body+mined:-NL= print(':'.join(map(str, b))
      body+mined:-Blocks= """""".join(b[:, (None)])
      body+mined:-Inline= print(':'.join(map(str, b))

================================================================================

QUESTION: idx=15     id=5123839
-------------------------------------INPUTS-------------------------------------

tags: django, performance, django-models
score: 226
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['Entry']}
intent: get the first object from a queryset in django model `entry`
body(Left in tags for better readability):
<p> Often I find myself wanting to get the first object from a
queryset in Django, or return <code> None <p>  if there aren't any.
There are lots of ways to do this which all work.  But I'm wondering
which is the most performant.
<code_block>
 qs = MyModel.objects.filter(blah = blah)
if qs.count() > 0:
    return qs[0]
else:
    return None

<p> Does this result in two database calls?  That seems wasteful.  Is
this any faster?
<code_block>
 qs = MyModel.objects.filter(blah = blah)
if len(qs) > 0:
    return qs[0]
else:
    return None

<p> Another option would be:
<code_block>
 qs = MyModel.objects.filter(blah = blah)
try:
    return qs[0]
except IndexError:
    return None

<p> This generates a single database call, which is good.  But
requires creating an exception object a lot of the time, which is a
very memory-intensive thing to do when all you really need is a
trivial if-test.
<p> How can I do this with just a single database call and without
churning memory with exception objects?

-------------------------------------OUTPUT-------------------------------------

                Expected= 'Entry.objects.filter()[:1].get()'
           base:Baseline= Entry.objects.get_first()
           body:Baseline= MyModel.objects.filter(blah=blah)
            body:-Blocks= Entry.objects[0] = None
              body:-Code= entry.objects()[0].first()
            body:-Inline= entry.objects.first(0)
                body:-NL= entry.objects.filter(blah=blah)
             base:+Mined= Entry.objects.all().order_by('?')[0]
     body+mined:Baseline= MyModel.objects.filter(Q(blah=blah))
        body+mined:-Code= Entry.objects.get(0)
          body+mined:-NL= Entry.objects.filter(blah='blah')
      body+mined:-Blocks= Entry.objects.order_by('-id')[0]
      body+mined:-Inline= MyModel.objects.filter(Q(blah=blah))

================================================================================

QUESTION: idx=16     id=13567345
-------------------------------------INPUTS-------------------------------------

tags: numpy
score: 70
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: calculate sum over all rows of 2d numpy array
body(Left in tags for better readability):
<p> Let's say I have the following 2D numpy array consisting of four
rows and three columns:
<code_block>
 <console_in> a = numpy.arange(12).reshape(4,3)
<console_in> print(a)
<console_out> [[ 0  1  2]
 [ 3  4  5]
 [ 6  7  8]
 [ 9 10 11]]

<p> What would be an efficient way to generate a 1D array that
contains the sum of all columns (like <code> [18, 22, 26] <p> )? Can
this be done without having the need to loop through all columns?

-------------------------------------OUTPUT-------------------------------------

                Expected= 'a.sum(axis=1)'
           base:Baseline= sum(np.sum(2, 3))
           body:Baseline= sum(np.arange(12), axis=1)
            body:-Blocks= sum(np.sum(axis=1))
              body:-Code= np.sum(np.arange(1, 2), axis=1)
            body:-Inline= np.sum(np.arange(4, 3))
                body:-NL= sum(np.arange(12), axis=1)
             base:+Mined= np.sum(axis=1)
     body+mined:Baseline= a.sum(axis=1)
        body+mined:-Code= np.sum(axis=1)
          body+mined:-NL= a.sum(axis=1)
      body+mined:-Blocks= np.sum(sum(axis=1))
      body+mined:-Inline= a.sum(axis=1)

================================================================================

QUESTION: idx=17     id=29784889
-------------------------------------INPUTS-------------------------------------

tags: warnings
score: 15
slot_map: {'key': ['str_0'], 'quote': ["'"], 'type': ['str'], 'value': ['always']}
intent: enable warnings using action 'always'
body(Left in tags for better readability):
<p> I was setting up a ImportWarning as seemed appropriate but noticed
this warning is not reported by default;
<p> How can I set python to report ImportWarning or all warnings?
<p> Here is the import warning i wrote:
<code_block>
 try:
    from markdown import markdown

except ImportError, err:
    warnings.warn(
        'Unable to load Pypi package `markdown`, HTML output will be
unavailable. {}'.format(err),
        ImportWarning
    )


-------------------------------------OUTPUT-------------------------------------

                Expected= "warnings.simplefilter('always')"
           base:Baseline= if not always:
    pass
           body:Baseline= re.findall('Markdown', 'always')
            body:-Blocks= importWarning.set_exists('always')
              body:-Code= importWarning.set_option('always')
            body:-Inline= app.set_exists('always')
                body:-NL= warn(('always', 'ignore')
             base:+Mined= warnings.setLevel(0)
     body+mined:Baseline= warnings.warn(('always')
        body+mined:-Code= warnings.extra(('always')
          body+mined:-NL= warn('always', action='always')
      body+mined:-Blocks= warnings = warnings.get('always')
      body+mined:-Inline= warn('always', action='always')

================================================================================

QUESTION: idx=18     id=13550423
-------------------------------------INPUTS-------------------------------------

tags: 
score: 8
slot_map: {'key': ['var_0', 'str_0'], 'quote': ['`', "'"], 'type': ['var', 'str'], 'value': ['l', '']}
intent: concatenate items of list `l` with a space ' '
body(Left in tags for better readability):
<p> How can I print lists without brackets and commas?
<p> I have a list of permutations like this:
<code_block>
    [1, 2, 3]
   [1, 3, 2] etc..

<p> I want to print them like this: <code> 1 2 3

-------------------------------------OUTPUT-------------------------------------

                Expected= "print(' '.join(map(str, l)))"
           base:Baseline= [x for x in L if x.strip()]
           body:Baseline= print(' '.join(str(x) for x in l))
            body:-Blocks= print(' '.join(str(x) for x in L))
              body:-Code= print(' '.join(str(x) for x in L))
            body:-Inline= print(' '.join(str(x) for x in L))
                body:-NL= [x for x in L if x.strip()]
             base:+Mined= [item for item in L if '' in item]
     body+mined:Baseline= print(' '.join(str(x) for x in L))
        body+mined:-Code= print(' '.join(str(x) for x in L))
          body+mined:-NL= [item for item in L if '  ' in item]
      body+mined:-Blocks= print(' '.join(str(x) for x in L))
      body+mined:-Inline= print(' '.join(str(x) for x in L))

================================================================================

QUESTION: idx=19     id=25651990
-------------------------------------INPUTS-------------------------------------

tags: subprocess
score: 46
slot_map: {'key': ['str_0', 'str_1'], 'quote': ["'", "'"], 'type': ['str', 'str'], 'value': ['hello.py', 'htmlfilename.htm']}
intent: run script 'hello.py' with argument 'htmlfilename.htm' on terminal using python executable
body(Left in tags for better readability):
<p> I am trying to call a python file "hello.py" from within the
python interpreter with subprocess. But I am unable to resolve this
error. [Python 3.4.1].
<code_block>
 import subprocess
subprocess.call(['hello.py', 'htmlfilename.htm'])
Traceback (most recent call last):
  File " <pyshell#42>", line 1, in <module>
    subprocess.call(['hello.py', 'htmlfilename.htm'])
  File "C:\Python34\lib\subprocess.py", line 537, in call
    with Popen(*popenargs, **kwargs) as p:
  File "C:\Python34\lib\subprocess.py", line 858, in __init__
    restore_signals, start_new_session)
  File "C:\Python34\lib\subprocess.py", line 1111, in _execute_child
    startupinfo)
OSError: [WinError 193] %1 is not a valid Win32 application

<p> Also is there any alternate way to "call a python script with
arguments" other than using subprocess?
Thanks in advance.

-------------------------------------OUTPUT-------------------------------------

                Expected= "subprocess.call(['python.exe', 'hello.py', 'htmlfilename.htm'])"
           base:Baseline= os.system('hello.py', 'htmlfilename.htm')
           body:Baseline= subprocess.call(['hello.py', 'htmlfilename.htm'])
            body:-Blocks= subprocess.call('hello.py', 'htmlfilename.htm')
              body:-Code= subprocess.call('hello.py', 'htmlfilename.htm', shell=True)
            body:-Inline= subprocess.call('hello.py', 'htmlfilename.htm')
                body:-NL= subprocess.call(['hello.py', 'htmlfilename.htm'])
             base:+Mined= subprocess.call('hello.py', shell=True)
     body+mined:Baseline= subprocess.call(['hello.py', 'htmlfilename.htm'])
        body+mined:-Code= subprocess.call('hello.py', shell=True)
          body+mined:-NL= subprocess.call(['hello.py', 'htmlfilename.htm'])
      body+mined:-Blocks= subprocess.call('hello.py', shell=True)
      body+mined:-Inline= subprocess.call(['hello.py', 'htmlfilename.htm'])

================================================================================

QUESTION: idx=20     id=698223
-------------------------------------INPUTS-------------------------------------

tags: date, time, datetime-parsing
score: 216
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: how can i parse a time string containing milliseconds in it with python?
body(Left in tags for better readability):
<p> I am able to parse strings containing date/time with <strong>
time.strptime
<code_block>
 <console_in> import time
<console_in> time.strptime('30/03/09 16:31:32', '%d/%m/%y %H:%M:%S')
<console_out> (2009, 3, 30, 16, 31, 32, 0, 89, -1)

<p> How can I parse a time string that contains milliseconds?
<code_block>
 <console_in> time.strptime('30/03/09 16:31:32.123', '%d/%m/%y
%H:%M:%S')
<console_out> Traceback (most recent call last):
  File " <stdin>", line 1, in <module>
  File "/usr/lib/python2.5/_strptime.py", line 333, in strptime
    data_string[found.end():])
ValueError: unconverted data remains: .123


-------------------------------------OUTPUT-------------------------------------

                Expected= "time.strptime('30/03/09 16:31:32.123', '%d/%m/%y %H:%M:%S.%f')"
           base:Baseline= time.strftime('%s' % milliseconds)
           body:Baseline= time.strptime('30/03/09 16:31:32.123', '%d/%m/%y %H:%M:%S')
            body:-Blocks= time.strptime('%Y-%m-%d %H:%M')
              body:-Code= time.strptime('%s/%s' % milliseconds)
            body:-Inline= time.strptime('%d/%m/%y %H:%M:%S')
                body:-NL= time.strptime('30/03/09 16:31:32.123', '%d/%m/%y %H:%M:%S')
             base:+Mined= time.strftime('%Y-%m-%d %H:%M:%S')
     body+mined:Baseline= time.strptime('30/03/09 16:31:32.123', '%d/%m/%y %H:%M:%S')
        body+mined:-Code= print(map(int, '%Y-%m-%d').strptime('%H:%M:%S'))
          body+mined:-NL= time.strptime('30/03/09 16:31:32', '%d/%m/%y %H:%M:%S')
      body+mined:-Blocks= print(datetime.strptime('12/01/2014', '%Y-%m-%dT%H:%M:%SZ')
      body+mined:-Inline= time.strptime('30/03/09 16:31:32.123', '%d/%m/%y %H:%M:%S')

================================================================================

QUESTION: idx=21     id=6633523
-------------------------------------INPUTS-------------------------------------

tags: type-conversion
score: 102
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['my_string', 'my_float']}
intent: convert a string `my_string` with dot and comma into a float number `my_float`
body(Left in tags for better readability):
<p> How can I convert a string like <code> 123,456.908 <p>  to float
<code> 123456.908 <p>  in Python?

-------------------------------------OUTPUT-------------------------------------

                Expected= "my_float = float(my_string.replace(',', ''))"
           base:Baseline= my_string = float(my_float)
           body:Baseline= float(my_string.split())
            body:-Blocks= my_string.float('my_float')
              body:-Code= my_string.float('my_float')
            body:-Inline= my_string.float('my_float')
                body:-NL= my_string.split(',')
             base:+Mined= my_string.split(',')
     body+mined:Baseline= my_string.float('123456.908')
        body+mined:-Code= my_string.float('my_float')
          body+mined:-NL= my_string.split(',')
      body+mined:-Blocks= my_string.split('.')[0]
      body+mined:-Inline= my_string.float('my_float')

================================================================================

QUESTION: idx=22     id=6633523
-------------------------------------INPUTS-------------------------------------

tags: type-conversion
score: 102
slot_map: {'key': ['str_0'], 'quote': ['`'], 'type': ['str'], 'value': ['123,456.908']}
intent: convert a string `123,456.908` with dot and comma into a floating number
body(Left in tags for better readability):
<p> How can I convert a string like <code> 123,456.908 <p>  to float
<code> 123456.908 <p>  in Python?

-------------------------------------OUTPUT-------------------------------------

                Expected= "float('123,456.908'.replace(',', ''))"
           base:Baseline= """123,456.908""".split()
           body:Baseline= float('123,456.908', '')
            body:-Blocks= float('123,456.908')
              body:-Code= float('123,456.908')
            body:-Inline= float('123,456.908')
                body:-NL= """""".join(str(123, 456.908))
             base:+Mined= """123,456.908""".replace(',', '')
     body+mined:Baseline= float('123,456.908')
        body+mined:-Code= float('123,456.908')
          body+mined:-NL= """123,456.908""".replace(', ', '')
      body+mined:-Blocks= float('123,456.908').replace(',', '.')
      body+mined:-Inline= float('123,456.908')

================================================================================

QUESTION: idx=23     id=3108285
-------------------------------------INPUTS-------------------------------------

tags: linux, unix, environment-variables
score: 127
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: set pythonpath in python script.
body(Left in tags for better readability):
<p> I know how to set it in my /etc/profile and in my environment
variables.
<p> But what if I want to set it during a script?
Is it import os, sys? How do I do it?

-------------------------------------OUTPUT-------------------------------------

                Expected= "sys.path.append('/path/to/whatever')"
           base:Baseline= os.path.realpath(__file__)
           body:Baseline= os.path.setdefault(path)
            body:-Blocks= os.path.set_path('/etc/profile')
              body:-Code= os.path.set_path('/etc/profile')
            body:-Inline= os.path.set_path('/etc/profile')
                body:-NL= sys.path.realpath(__file__)
             base:+Mined= sys.path.append('/path/to/my/path')
     body+mined:Baseline= os.path.setp(path)
        body+mined:-Code= os.path.set_dirname('/etc/profile')
          body+mined:-NL= os.path.dirname(__file__)
      body+mined:-Blocks= os.system('/etc/profile')
      body+mined:-Inline= sys.path.append('/etc/profile')

================================================================================

QUESTION: idx=24     id=2195340
-------------------------------------INPUTS-------------------------------------

tags: regex
score: 7
slot_map: {'key': ['str_0', 'str_1', '(str_1)'], 'quote': ["'", "'", "'"], 'type': ['str', 'str', 'str'], 'value': ['Words, words, words.', '(\\W+)', '(\\W+)']}
intent: split string 'words, words, words.' using a regex '(\\w+)'
body(Left in tags for better readability):
<p> Suppose I have a string "a foobar" and I use "^a\s*" to match "a
".
<p> Is there a way to easily get "foobar" returned? (What was NOT
matched)
<p> I want to use a regex to look for a <i> command word <p>  and also
use the regex to remove the command word from the string.
<p> I know how to do this using something like:
<code_block>
 mystring[:regexobj.start()] + email[regexobj.end():]

<p> But this falls apart if I have multiple matches.
<p> Thanks!

-------------------------------------OUTPUT-------------------------------------

                Expected= "re.split('(\\\\W+)', 'Words, words, words.')"
           base:Baseline= re.split('Words, words, words.')
           body:Baseline= re.sub('\\w+)', 'Words, words, words.')
            body:-Blocks= re.split('(\\w+)', '', 'words, words, words.')
              body:-Code= re.split('\\w+)', 'Words, words, words.')
            body:-Inline= re.split('Words, words, words.')
                body:-NL= re.split('Words, words, words.')
             base:+Mined= re.split('\\w+)', 'Words, words, words.')
     body+mined:Baseline= re.split('(\\w+)', '', mystring)
        body+mined:-Code= re.split('\\w+)', 'Words, words, words.')
          body+mined:-NL= re.split('\\w+)', 'Words, words, words.')
      body+mined:-Blocks= re.split('\\w+', 'Words, words, words.')
      body+mined:-Inline= re.split('\\w+)', 'a foobar')

================================================================================

QUESTION: idx=25     id=17977584
-------------------------------------INPUTS-------------------------------------

tags: xlrd
score: 4
slot_map: {'key': ['str_0'], 'quote': ['`'], 'type': ['str'], 'value': ['Output.txt']}
intent: open a file `output.txt` in append mode
body(Left in tags for better readability):
<p> I want to write code to get data from Excel and write it to a text
file. Here is the code I have:
<code_block>
 import xlrd
import os.path
wb = xlrd.open_workbook(os.path.join('D:\TRB 2014 Data','SPS1 demo
data.xlsx'))
wb.sheet_names()
sh = wb.sheet_by_index(0)
i = 1

while sh.cell(i,11).value != 0:

   Load = sh.cell(i,11).value
   D1 = sh.cell(i,13).value
   D2 = sh.cell(i,14).value
   D3 = sh.cell(i,15).value
   D4 = sh.cell(i,16).value
   D5 = sh.cell(i,17).value
   D6 = sh.cell(i,18).value
   D7 = sh.cell(i,19).value
   DB1 = str(Load) + "  " + str(D1) + "  " + str(D2) + "  " + str(D3)+
"  " + str(D4)+ "  " + str(D5)+ "  " + str(D6)+ "  " + str(D7)

   file = open("Output.txt", "w")
   file.write(DB1 + '\n')
   file.close
   i = i + 1

<p> The problem with this code is the data written to the text file is
always displayed at the first row. Therefore, although I have 20 rows
of data in excel, the text file only shows the last data in the excel
file at the very first row in the text file. I have <code> '\n' <p>
in <code> file.write <p>  but, it doesn't seem to work.

-------------------------------------OUTPUT-------------------------------------

                Expected= "file = open('Output.txt', 'a')"
           base:Baseline= open('output.txt', shell=True)
           body:Baseline= wb = xlrd.open('Output.txt', 'w')
            body:-Blocks= open('output.txt', append=True)
              body:-Code= open('output.txt', append=True)
            body:-Inline= wb.open('Output.txt', 'w')
                body:-NL= wb.open('Output.txt', append=True)
             base:+Mined= f = open('output.txt', 'r')
     body+mined:Baseline= file = open('Output.txt', 'wb')
        body+mined:-Code= open('output.txt', 'r', append=True)
          body+mined:-NL= file.write(DB1 + '\n')
      body+mined:-Blocks= f.write('output.txt', append=True)
      body+mined:-Inline= file = open('Output.txt', 'wb')

================================================================================

QUESTION: idx=26     id=22676
-------------------------------------INPUTS-------------------------------------

tags: http, urllib
score: 930
slot_map: {'key': ['str_0', 'str_1'], 'quote': ['"', '"'], 'type': ['str', 'str'], 'value': ['http://www.example.com/songs/mp3.mp3', 'mp3.mp3']}
intent: download a file "http://www.example.com/songs/mp3.mp3" over http and save to "mp3.mp3"
body(Left in tags for better readability):
<p> I have a small utility that I use to download an MP3 file from a
website on a schedule and then builds/updates a podcast XML file which
I've added to iTunes.
<p> The text processing that creates/updates the XML file is written
in Python. However, I use wget inside a Windows <code> .bat <p>  file
to download the actual MP3 file. I would prefer to have the entire
utility written in Python.
<p> I struggled to find a way to actually download the file in Python,
thus why I resorted to using <code> wget <p> .
<p> So, how do I download the file using Python?

-------------------------------------OUTPUT-------------------------------------

                Expected= "urllib.request.urlretrieve('http://www.example.com/songs/mp3.mp3', 'mp3.mp3')"
           base:Baseline= urllib.request.urlretrieve('http://www.example.com/songs/mp3.mp3')
           body:Baseline= wget.download('http://www.example.com/songs/mp3.mp3', shell=True)
            body:-Blocks= wget.download('http://www.example.com/songs/mp3.mp3')
              body:-Code= urllib.request.urlretrieve('http://www.example.com/songs/mp3.mp3')
            body:-Inline= wget.download('http://www.example.com/songs/mp3.mp3')
                body:-NL= download('http://www.example.com/songs/mp3.mp3', shell=True)
             base:+Mined= file = open('http://www.example.com/songs/mp3.mp3', 'wb')
     body+mined:Baseline= urllib.request.urlretrieve('http://www.example.com/songs/mp3.mp3', files)
        body+mined:-Code= urllib.request.urlretrieve('http://www.example.com/songs/mp3.mp3', 'wb')
          body+mined:-NL= urllib.request.urlretrieve('http://www.example.com/songs/mp3.mp3', filename)
      body+mined:-Blocks= wget('http://www.example.com/songs/mp3.mp3')
      body+mined:-Inline= urllib.request.urlretrieve('http://www.example.com/songs/mp3.mp3', 'rb')

================================================================================

QUESTION: idx=28     id=22676
-------------------------------------INPUTS-------------------------------------

tags: http, urllib
score: 930
slot_map: {'key': ['str_0'], 'quote': ["'"], 'type': ['str'], 'value': ['http://www.example.com/']}
intent: download a file 'http://www.example.com/' over http
body(Left in tags for better readability):
<p> I have a small utility that I use to download an MP3 file from a
website on a schedule and then builds/updates a podcast XML file which
I've added to iTunes.
<p> The text processing that creates/updates the XML file is written
in Python. However, I use wget inside a Windows <code> .bat <p>  file
to download the actual MP3 file. I would prefer to have the entire
utility written in Python.
<p> I struggled to find a way to actually download the file in Python,
thus why I resorted to using <code> wget <p> .
<p> So, how do I download the file using Python?

-------------------------------------OUTPUT-------------------------------------

                Expected= "response = urllib.request.urlopen('http://www.example.com/')\nhtml = response.read()"
           base:Baseline= download('http://www.example.com/', shell=True)
           body:Baseline= wget.download('http://www.example.com/', shell=True)
            body:-Blocks= wget.download('http://www.example.com/')
              body:-Code= urllib.request.urlopen('http://www.example.com/')
            body:-Inline= download('http://www.example.com/', shell=True)
                body:-NL= download('http://www.example.com/', shell=True)
             base:+Mined= urllib.request.urlretrieve('http://www.example.com/', filename)
     body+mined:Baseline= urllib.request.urlretrieve('http://www.example.com/', file)
        body+mined:-Code= webbrowser.download('http://www.example.com/')
          body+mined:-NL= print(open('http://www.example.com/').read())
      body+mined:-Blocks= webbrowser.open('http://www.example.com/')
      body+mined:-Inline= urllib.request.urlretrieve('http://www.example.com/', files)

================================================================================

QUESTION: idx=29     id=22676
-------------------------------------INPUTS-------------------------------------

tags: http, urllib
score: 930
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['url']}
intent: download a file `url` over http
body(Left in tags for better readability):
<p> I have a small utility that I use to download an MP3 file from a
website on a schedule and then builds/updates a podcast XML file which
I've added to iTunes.
<p> The text processing that creates/updates the XML file is written
in Python. However, I use wget inside a Windows <code> .bat <p>  file
to download the actual MP3 file. I would prefer to have the entire
utility written in Python.
<p> I struggled to find a way to actually download the file in Python,
thus why I resorted to using <code> wget <p> .
<p> So, how do I download the file using Python?

-------------------------------------OUTPUT-------------------------------------

                Expected= 'r = requests.get(url)'
           base:Baseline= urllib.request.urlretrieve(url)
           body:Baseline= wget.read_open('url', shell=True)
            body:-Blocks= wget.download('url', shell=True)
              body:-Code= urllib.request.urlopen(url)
            body:-Inline= print(open('download', 'url').read())
                body:-NL= print(url.read(), 1)
             base:+Mined= urllib.request.urlopen(url)
     body+mined:Baseline= urllib.request.urlretrieve('http://www.google.com', url)
        body+mined:-Code= webbrowser.download(url)
          body+mined:-NL= urllib.request.urlretrieve('http://stackoverflow.com', 'url', filename)
      body+mined:-Blocks= webbrowser.open(url)
      body+mined:-Inline= urllib.request.urlretrieve('http://httpbin.org/download', files)

================================================================================

QUESTION: idx=31     id=15405636
-------------------------------------INPUTS-------------------------------------

tags: version, argparse
score: 44
slot_map: {'key': ['str_0', 'str_1', 'var_0'], 'quote': ["'", "'", '`'], 'type': ['str', 'str', 'var'], 'value': ['--version', '%(prog)s 2.0', 'parser']}
intent: argparse add argument with flag '--version' and version action of '%(prog)s 2.0' to parser `parser`
body(Left in tags for better readability):
<p> What's the preferred way of specifying program name and version
info within argparse?
<pre>
__version_info__ = ('2013','03','14')
__version__ = '-'.join(__version_info__)
<console_out>
parser.add_argument('-V', '--version', action='version',
version="%(prog)s ("+__version__+")")

<a>
http://argparse.googlecode.com/svn/trunk/doc/ArgumentParser.html#prog
<a> http://pymotw.com/2/argparse/
<a> http://www.python.org/dev/peps/pep-0386/
<a> http://www.python.org/dev/peps/pep-0396/
<a> http://www.python.org/dev/peps/pep-3001/


-------------------------------------OUTPUT-------------------------------------

                Expected= "parser.add_argument('--version', action='version', version='%(prog)s 2.0')"
           base:Baseline= parser.add_argument('--version', '%(prog)s 2.0')
           body:Baseline= parser.add_argument('-V', '--version', action='version', '%(prog)s 2.0')
            body:-Blocks= parser.add_argument('--version', '%(prog)s 2.0')
              body:-Code= parser.add_argument('--version', '%(prog)s 2.0')
            body:-Inline= parser.add_argument('-V', '--version', version='%(prog)s 2.0')
                body:-NL= parser.add_argument('-V', '--version', action='version', version="%(prog)s 2.0')
             base:+Mined= parser.add_argument('--version', nargs='%(prog)s 2.0')
     body+mined:Baseline= parser.add_argument('-V', '--version', action='version', version=
    '%(prog)s ("+__version__+')
        body+mined:-Code= parser.add_argument('--version', action='%(prog)s 2.0')
          body+mined:-NL= parser.add_argument('-V', '--version', action='version', version='%(prog)s ('+__version__+')
      body+mined:-Blocks= parser.add_argument('--version', help='%(prog)s 2.0')
      body+mined:-Inline= parser.add_argument('-V', '--version', version='%(prog)s ("+__version__+")')

================================================================================

QUESTION: idx=32     id=17665809
-------------------------------------INPUTS-------------------------------------

tags: methods, dictionary
score: 45
slot_map: {'key': ['str_0', 'var_0'], 'quote': ["'", '`'], 'type': ['str', 'var'], 'value': ['c', 'd']}
intent: remove key 'c' from dictionary `d`
body(Left in tags for better readability):
<p> I have a dictionary
<code_block>
 d = {'a':1, 'b':2, 'c':3}

<p> I need to remove a key, say <strong> c <p>  and return the
dictionary without that key in one function call
<code_block>
 {'a':1, 'b':2}

<p> d.pop('c') will return the key value - 3 - instead of the
dictionary.
<em> I am going to need one function solution if it exists, as this
will go into comprehensions

-------------------------------------OUTPUT-------------------------------------

                Expected= "{i: d[i] for i in d if i != 'c'}"
           base:Baseline= d = d.remove('c')
           body:Baseline= d = {'a': 1, 'b': 2, 'c': 3}
            body:-Blocks= d = d.pop('c')
              body:-Code= dict((k, c) for k, c in d.items())
            body:-Inline= dict((k, v) for k, v in list(d.items()))
                body:-NL= d = {'a': 1, 'b': 2, 'c': 3}
             base:+Mined= d = {k: v for k, v in d.items()}
     body+mined:Baseline= d = {k: v for k, v in list(d.items())}
        body+mined:-Code= d['c'] = dict((k, v) for k, v in d.items())
          body+mined:-NL= d = {k: v for k, v in list(d.items()) if v}
      body+mined:-Blocks= dict((k, v) for k, v in d.items() if v != 'c')
      body+mined:-Inline= d = {k: v for k, v in list(d.items()) if 'c' in k}

================================================================================

QUESTION: idx=33     id=41861705
-------------------------------------INPUTS-------------------------------------

tags: pandas, join, dataframe, merge
score: 3
slot_map: {'key': ['str_0', 'var_0', 'var_1', 'var_2', 'var_3', 'var_4', 'var_5'], 'quote': ['"', '`', '`', '`', '`', '`', '`'], 'type': ['str', 'var', 'var', 'var', 'var', 'var', 'var'], 'value': ['key', 'split_df', 'csv_df', 'split_df', 'csv_df', '_left', '_right']}
intent: create new dataframe object by merging columns "key" of  dataframes `split_df` and `csv_df` and rename the columns from dataframes `split_df` and `csv_df` with suffix `_left` and `_right` respectively
body(Left in tags for better readability):
<p> I've seen this question a few times, but the answers are not
working for me.  I have two dataframes, <code> split_df <p>  and
<code> csv_df <p>  that I;m trying to merge on a column that is called
<code> key <p>  in each of them.
<p> Here's the top 5 items from <code> split_df
<code_block>
         key        tags
2785  30000        ipv6
2785  30000  networking
2785  30000    wireless
2785  30000   standards
2785  30000      satcom

<p> Here's the top 5 items from the <code> csv_df
<code_block>
      key
0  30000
1  30002
2  31288
3  33630
4  31663

<p> When I run this merge statement:
<code_block>
 common_df = pd.merge(split_df,csv_df, on=['key'], suffixes=('_left',
'_right'))

<p> I get:
<code_block>
 Empty DataFrame
Columns: [key, tags]
Index: []

<p> Process finished with exit code 0
<p> I can't figure out why the merge isn't working for me.  Any
suggestions?
<p> I have indexes on both (and have run the merge with them out as
well)
<code_block>
 csv_df.set_index('key')
split_df.set_index('key')

<p> I am very new to Pyton and Pandas
<p> Thanks!

-------------------------------------OUTPUT-------------------------------------

                Expected= "pd.merge(split_df, csv_df, on=['key'], suffixes=('_left', '_right'))"
           base:Baseline= pd.merge(split_df, csv_df)
           body:Baseline= pd.merge(set_index('key', on=['key'], sep='_left', '_right'))
            body:-Blocks= dataframe.merge(['key'], 'csv_df'], inplace=True)
              body:-Code= df.merge(['key'], 'csv_df', 'key'])
            body:-Inline= common_df.set_index('key')
                body:-NL= pd.merge(split_df,csv_df), on=['key'], suffixes=['_left', '_right'])
             base:+Mined= pd.concat([split_df, csv_df], axis=1)
     body+mined:Baseline= df.set_index('key')
        body+mined:-Code= pd.merge(df1, df2, on=['key', '_right'])
          body+mined:-NL= df.set_index('key')
      body+mined:-Blocks= merged = pd.merge(df1, df2, on='key', on='value')
      body+mined:-Inline= df.set_index('key')

================================================================================

QUESTION: idx=34     id=10697757
-------------------------------------INPUTS-------------------------------------

tags: regex, string, split
score: 4
slot_map: {'key': ['var_0', 'str_0'], 'quote': ['`', '`'], 'type': ['var', 'str'], 'value': ['s', '4']}
intent: split a string `s` by space with `4` splits
body(Left in tags for better readability):
<p> I'm quite new to regular expression in python. I have the
following string and want to split them into five categories. I just
use the split() but it will just split according to white spaces.
<code_block>
 s = "1 0 A10B 1/00 Description: This is description with spaces"
sp = s.split()
<console_in> sp
<console_out> ["1", "0", "A10B", "1/00", "Description:", "This", "is",
"description", "with", "spaces"]

<p> How can I write a regular expression to make it split like this:
<code_block>
  ["1", "0", "A10B", "1/00", "Description: This is description with
spaces"]

<p> Can somebody help please? Thanks!

-------------------------------------OUTPUT-------------------------------------

                Expected= "s.split(' ', 4)"
           base:Baseline= s = s.split(4)
           body:Baseline= s = s.split(4)
            body:-Blocks= re.split('\\4', s)
              body:-Code= s.split(4, 4)
            body:-Inline= sp = s.split(4)
                body:-NL= sp = s.split(4)
             base:+Mined= re.split('\\s+', s)
     body+mined:Baseline= re.split('\\s+', s)
        body+mined:-Code= re.findall('\\s+', s)
          body+mined:-NL= re.split('\\s+', s)
      body+mined:-Blocks= s.split(',')[4]
      body+mined:-Inline= re.findall('\\[^\\]]*', s)

================================================================================

QUESTION: idx=35     id=5404068
-------------------------------------INPUTS-------------------------------------

tags: input, keyboard
score: 127
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: read keyboard-input
body(Left in tags for better readability):
<p> I would like to read data from the keyboard in python
<p> I try this:
<code_block>
 nb = input('Choose a number')
print ('Number%s \n' % (nb))

<p> But it doesn't work, neither with eclipse nor in the terminal,
it's always stop of the question. I can type a number but after
nothing happen.
<p> Do you know why?

-------------------------------------OUTPUT-------------------------------------

                Expected= "input('Enter your input:')"
           base:Baseline= input = input.read_key('input')
           body:Baseline= print('Number%s \n' % nb)
            body:-Blocks= sys.stdout.read().read()
              body:-Code= input = pd.read().input()
            body:-Inline= nb = input('Number%s \n' % nb)
                body:-NL= nb = input('Choose a number')
             base:+Mined= input('Press Enter to continue;')
     body+mined:Baseline= nb = input('Choose a number')
        body+mined:-Code= input('Enter a number: ')
          body+mined:-NL= nb = input('Choose a number')
      body+mined:-Blocks= input('Press Enter to continue;')
      body+mined:-Inline= nb = input('Choose a number')

================================================================================

QUESTION: idx=36     id=16344756
-------------------------------------INPUTS-------------------------------------

tags: apache, web, flask
score: 248
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['app']}
intent: enable debug mode on flask application `app`
body(Left in tags for better readability):
<p> I'm investigating how to develop a decent web app with Python.
Since I don't want some high-order structures to get in my way, my
choice fell on the lightweight <a> Flask framework <p> . Time will
tell if this was the right choice.
<p> So, now I've set up an Apache server with mod_wsgi, and my test
site is running fine. However, I'd like to speed up the development
routine by making the site automatically reload upon any changes in py
or template files I make. I see that any changes in site's .wsgi file
causes reloading (even without WSGIScriptReloading On in the apache
config file), but I still have to prod it manually (ie, insert extra
linebreak, save). Is there some way how to cause reload when I edit
some of the app's py files? Or, I am expected to use IDE that
refreshes the .wsgi file for me?

-------------------------------------OUTPUT-------------------------------------

                Expected= 'app.run(debug=True)'
           base:Baseline= app.debug().disable_mode()
           body:Baseline= app.config(debug=True)
            body:-Blocks= app.set_debug_mode(app)
              body:-Code= app.set_debug_mode(app.WRITE_SYSTEM)
            body:-Inline= app.disableDebug()[::-1]
                body:-NL= app.configure_mode(debug=False)
             base:+Mined= app.run(debug=True)
     body+mined:Baseline= app.run(debug=True)
        body+mined:-Code= app.run(debug=True)
          body+mined:-NL= app.run(debug=True)
      body+mined:-Blocks= app.run(debug=True)
      body+mined:-Inline= app.run(debug=True)

================================================================================

QUESTION: idx=37     id=40133826
-------------------------------------INPUTS-------------------------------------

tags: 
score: 4
slot_map: {'key': ['var_0', 'str_0'], 'quote': ['`', "'"], 'type': ['var', 'str'], 'value': ['mylist', 'save.txt']}
intent: python save list `mylist` to file object 'save.txt'
body(Left in tags for better readability):
<p> Basically I would like to save a list to python and then when the
program starts I would like to retrieve the data from the file and put
it back into the list.
<p>
So far this is the code I am using
<code_block>
 mylist = pickle.load("save.txt")
<console_out>
saveToList = (name, data)
mylist.append(saveList)
import pickle
pickle.dump(mylist, "save.txt")

<p> But it just returns the following error: TypeError: file must have
'read' and 'readline' attributes

-------------------------------------OUTPUT-------------------------------------

                Expected= "pickle.dump(mylist, open('save.txt', 'wb'))"
           base:Baseline= mylist.save('save.txt')
           body:Baseline= pickle.dump(mylist, 'save.txt')
            body:-Blocks= mylist.save(filename='save.txt')
              body:-Code= mylist = os.save('save.txt')
            body:-Inline= pickle.load('save.txt')
                body:-NL= pickle.dump(mylist, 'save.txt')
             base:+Mined= mylist.write('save.txt')
     body+mined:Baseline= pickle.dump(mylist, 'save.txt')
        body+mined:-Code= mylist = open('save.txt', 'r')
          body+mined:-NL= pickle.dump(mylist, 'save.txt')
      body+mined:-Blocks= mylist.write('save.txt')
      body+mined:-Inline= pickle.dump(mylist, 'save.txt')

================================================================================

QUESTION: idx=38     id=4490961
-------------------------------------INPUTS-------------------------------------

tags: matrix, numpy, scipy, linear-algebra
score: 13
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['P', 'T']}
intent: multiply a matrix `p` with a 3d tensor `t` in scipy
body(Left in tags for better readability):
<p> I have a matrix <code> P <p>  with shape <code> MxN <p>  and a 3d
tensor <code> T <p>  with shape <code> KxNxR <p> . I want to multiply
<code> P <p>  with every <code> NxR <p>  matrix in <code> T <p> ,
resulting in a <code> KxMxR <p>  3d tensor.
<code> P.dot(T).transpose(1,0,2) <p>  gives the desired result. Is
there a <em> nicer <p>  solution (i.e. getting rid of <code> transpose
<p> ) to this problem? This must be quite a common operation, so I
assume, others have found different approaches, e.g. using <code>
tensordot <p>  (which I tried but failed to get the desired result).
Opinions/Views would be highly appreciated!

-------------------------------------OUTPUT-------------------------------------

                Expected= 'scipy.tensordot(P, T, axes=[1, 1]).swapaxes(0, 1)'
           base:Baseline= p = p.multiply(t)
           body:Baseline= P.dot(T).transpose(1, 0, 2)
            body:-Blocks= P.dot(T).transpose(1, 0, 2)
              body:-Code= p = scipy.multiply(p, t)
            body:-Inline= p = scipy.multiply(p, t)
                body:-NL= p.dot(T).transpose(1, 0, 2)
             base:+Mined= np.einsum('ij->ij->ik->j->ik', p)
     body+mined:Baseline= P.dot(T).transpose(1, 0, 2)
        body+mined:-Code= np.einsum('ijk,ikl->ikl', p)
          body+mined:-NL= T.transpose(1, 0, 2)
      body+mined:-Blocks= P.dot(T).transpose(1, 0, 2).tolist()
      body+mined:-Inline= scipy.T.ravel()

================================================================================

QUESTION: idx=39     id=2173087
-------------------------------------INPUTS-------------------------------------

tags: list, arrays, matrix, nested-lists
score: 5
slot_map: {'key': ['str_0', '(str_0)'], 'quote': ['`', '`'], 'type': ['str', 'str'], 'value': ['(3,3,3)', '(3,3,3)']}
intent: create 3d array of zeroes of size `(3,3,3)`
body(Left in tags for better readability):
<p> I know you can create easily nested lists in python like this:
<code_block>
 [[1,2],[3,4]]

<p> But how to create a 3x3x3 matrix of zeroes?
<code_block>
 [[[0] * 3 for i in range(0, 3)] for j in range (0,3)]

<p> or
<code_block>
 [[[0]*3]*3]*3

<p> Doesn't seem right. There is no way to create it just passing a
list of dimensions to a method? Ex:
<code_block>
 CreateArray([3,3,3])


-------------------------------------OUTPUT-------------------------------------

                Expected= 'numpy.zeros((3, 3, 3))'
           base:Baseline= np.zeros((3, 3, 3))
           body:Baseline= [[(3, 3, 3)], [1, 2], [3, 4]]
            body:-Blocks= zip(*(3, 3, 3))
              body:-Code= np.array([3, 3, 3])
            body:-Inline= [(3, 3, 3)]
                body:-NL= np.array([3, 3, 3])
             base:+Mined= np.zeroes(3, 3, 3)
     body+mined:Baseline= [[[0] * 3 for i in range(0, 3)] for j in range (3, 3)]]
        body+mined:-Code= np.zeros((3, 3, 3))
          body+mined:-NL= np.array([[0] * 3) for j in range(0, 3)]
      body+mined:-Blocks= np.zeros((3, 3, 3))
      body+mined:-Inline= [[[0] * 3] for j in range(0, 3)] for i in range (0, 4)]

================================================================================

QUESTION: idx=40     id=6266727
-------------------------------------INPUTS-------------------------------------

tags: split, concatenation, word, text-segmentation
score: 53
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['content']}
intent: cut off the last word of a sentence `content`
body(Left in tags for better readability):
<p> What's the best way to slice the last word from a block of text?
<p> I can think of

<li> Split it to a list (by spaces) and removing the last item, then
reconcatenating the list.
<li> Use a regular expression to replace the last word.

<p> I'm currently taking approach #1, but I don't know how to
concatenate the list...
<code_block>
 content = content[position-1:position+249] # Content
words = string.split(content, ' ')
words = words[len[words] -1] # Cut of the last word

<p> Any code examples are much appreciated.

-------------------------------------OUTPUT-------------------------------------

                Expected= '""" """.join(content.split(\' \')[:-1])'
           base:Baseline= content = re.sub('[-1]', '', content)
           body:Baseline= content = re.sub('\\w+', '', content)
            body:-Blocks= re.sub('[^a-zA-Z]', content)
              body:-Code= [x for x in content if x.rstrip()]
            body:-Inline= content.split(content, '')
                body:-NL= content = content[position - 1:position + 249]
             base:+Mined= content.rstrip().split()[-1]
     body+mined:Baseline= content = content[position - 1:position + 249]
        body+mined:-Code= re.sub('\\s+', '', content)
          body+mined:-NL= content = content[position - 1:position + 249]
      body+mined:-Blocks= re.sub('[^\\w]', '', content)
      body+mined:-Inline= content.split(',')[-1]

================================================================================

QUESTION: idx=41     id=30385151
-------------------------------------INPUTS-------------------------------------

tags: numpy
score: 10
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['x']}
intent: convert scalar `x` to array
body(Left in tags for better readability):
<p> I am evaluating arbitrary expressions in terms of an x array, such
as 3*x**2 + 4. This normally results in an array with x's shape.
However if the expression is just a constant, it returns a scalar.
What is the best way to ensure it has x's shape without explicitly
checking the shape? Multiplying by numpy.ones(x.shape) works, but I
think that uses unnecessary computations.
<p> Edit:
To be clear, I don't just want it to be an array with size one, I want
it to be the same shape and size as X.
I'm evaluating a string using NumExpr which can contain an arbitrary
function of x:
<code_block>
 x = numpy.linspace(min, max, num)
y = numexpr.evaluate(expr, {'x': x}, {})

<p> I want to get an array of y-values that could be plotted against x
through matplotlib. Currently I am doing this, which works fine:
<code_block>
 y = numpy.ones(x.size) * y

<p> But I'm worried that this is wasteful for large sizes. Is there a
better way?

-------------------------------------OUTPUT-------------------------------------

                Expected= 'x = np.asarray(x).reshape(1, -1)[(0), :]'
           base:Baseline= np.arange(x, 2)
           body:Baseline= np.linspace(min, max, num) * np.ones(x.shape)
            body:-Blocks= np.array(x.shape)
              body:-Code= np.array([x.shape]))
            body:-Inline= np.linspace(x.shape)
                body:-NL= np.linspace(min, max, num)
             base:+Mined= np.array(x).reshape(-1, 1)
     body+mined:Baseline= numpy.linspace(min, max, num) * np.ones(x.shape)
        body+mined:-Code= x = np.zeros((3, **2))
          body+mined:-NL= numpy.linspace(min, max, num)
      body+mined:-Blocks= x = np.zeros((3, 2))
      body+mined:-Inline= numpy.linspace(min, max, num)

================================================================================

QUESTION: idx=42     id=15856127
-------------------------------------INPUTS-------------------------------------

tags: 
score: 4
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['L']}
intent: sum all elements of nested list `l`
body(Left in tags for better readability):
<code_block>
 import math
lists =  [1,[2,3],4]
total = 0
for i in range(len(lists)):
    total += sum(i)
print(total)

<p> I want it to print,
<code_block>
 <console_in>10
<console_out>
<p> But throws a error.
<p> I would like it to get it to add all numbers, including the ones
within the nested if.

-------------------------------------OUTPUT-------------------------------------

                Expected= 'sum(sum(i) if isinstance(i, list) else i for i in L)'
           base:Baseline= sum(l) for l in l)
           body:Baseline= sum(i) for i, j in zip(L, L)]
            body:-Blocks= print([x for x in L if x not in x]
              body:-Code= print([sum(x) for x in L)]
            body:-Inline= total = sum(len(list))
                body:-NL= sum(itertools.chain(*l))
             base:+Mined= sum(l[0] for l in L)
     body+mined:Baseline= total = sum(list(range(len(lists)))
        body+mined:-Code= print(sum(l) for l in L)
          body+mined:-NL= sum(list(itertools.chain.from_iterable(l)))
      body+mined:-Blocks= [(x, y) for x, y in zip(*l)]
      body+mined:-Inline= total = sum(map(lambda x: x + list(len(x)))

================================================================================

QUESTION: idx=43     id=1592158
-------------------------------------INPUTS-------------------------------------

tags: binary, floating-point, hex, decimal
score: 40
slot_map: {'key': ['str_0'], 'quote': ["'"], 'type': ['str'], 'value': ['470FC614']}
intent: convert hex string '470fc614' to a float number
body(Left in tags for better readability):
<p> How to convert the following hex string to float (single precision
32-bit) in Python?
<code_block>
 "41973333" -> 1.88999996185302734375E1

"41995C29" -> 1.91700000762939453125E1

"470FC614" -> 3.6806078125E4


-------------------------------------OUTPUT-------------------------------------

                Expected= "struct.unpack('!f', '470FC614'.decode('hex'))[0]"
           base:Baseline= float('470fc614', 16)
           body:Baseline= float('470FC614', 16)
            body:-Blocks= float('470fc614', 16)
              body:-Code= float('470fc614', 16)
            body:-Inline= float('470FC614', 16)
                body:-NL= """470FC614""".decode('hex')
             base:+Mined= int('470fc614', 16)
     body+mined:Baseline= int('470FC614', 16)
        body+mined:-Code= int('470fc614', 16)
          body+mined:-NL= int('470FC614', 16)
      body+mined:-Blocks= struct.unpack('470fc614', 16)
      body+mined:-Inline= int('470FC614', 16)

================================================================================

QUESTION: idx=44     id=5010536
-------------------------------------INPUTS-------------------------------------

tags: dictionary
score: 31
slot_map: {'key': ['str_0', 'var_0'], 'quote': ['`', '`'], 'type': ['str', 'var'], 'value': ['2', 'my_dict']}
intent: multiple each value by `2` for all keys in a dictionary `my_dict`
body(Left in tags for better readability):
<p> In python 2.6 I want to perform an operation on each dictionary
value, for example, I want to multiply by 2 for each of them. How to
code less for this task?

-------------------------------------OUTPUT-------------------------------------

                Expected= 'my_dict.update((x, y * 2) for x, y in list(my_dict.items()))'
           base:Baseline= [k for k, v in list(my_dict.items() if v > 2]
           body:Baseline= max(k, v) for k, v in my_dict.items())
            body:-Blocks= dict((k, v) for k, v in my_dict.items())
              body:-Code= max(k, v) for k, v in my_dict.items()
            body:-Inline= max(my_dict.keys())
                body:-NL= max(my_dict.values())
             base:+Mined= dict((k, v) for k, v in my_dict.items())
     body+mined:Baseline= my_dict.values.multiply(2, 2)
        body+mined:-Code= [(k, v) for k, v in my_dict.items()]
          body+mined:-NL= list(my_dict.values())
      body+mined:-Blocks= [(v * 2) for k, v in my_dict.items()]
      body+mined:-Inline= my_dict.values.multiply(2)

================================================================================

QUESTION: idx=45     id=13745648
-------------------------------------INPUTS-------------------------------------

tags: bash, call
score: 120
slot_map: {'key': ['str_0'], 'quote': ["'"], 'type': ['str'], 'value': ['sleep.sh']}
intent: running bash script 'sleep.sh'
body(Left in tags for better readability):
<p> I have a problem with the following code:
<strong> callBash.py:
<code_block>
 import subprocess
print "start"
subprocess.call("sleep.sh")
print "end"

<strong> sleep.sh:
<code_block>
 sleep 10

<p> I want the "end" to be printed after 10s. (I know that this is a
dumb example, I could simply sleep within python, but this simple
sleep.sh file was just as a test)

-------------------------------------OUTPUT-------------------------------------

                Expected= "subprocess.call('sleep.sh', shell=True)"
           base:Baseline= os.system('sleep.sh')
           body:Baseline= subprocess.call('sleep.sh')
            body:-Blocks= sys.system('sleep.sh')
              body:-Code= os.system('sleep.sh')
            body:-Inline= subprocess.call('sleep.sh')
                body:-NL= subprocess.call('sleep.sh')
             base:+Mined= subprocess.call('sleep.sh', shell=True)
     body+mined:Baseline= subprocess.call('sleep.sh', shell=True)
        body+mined:-Code= os.system('sleep.sh')
          body+mined:-NL= subprocess.call('sleep.sh', shell=True)
      body+mined:-Blocks= os.system('sleep.sh')
      body+mined:-Inline= subprocess.call('sleep.sh', shell=True)

================================================================================

QUESTION: idx=46     id=44778
-------------------------------------INPUTS-------------------------------------

tags: string, list
score: 593
slot_map: {'key': ['var_0', 'str_0'], 'quote': ['`', '`'], 'type': ['var', 'str'], 'value': ['l', ',']}
intent: join elements of list `l` with a comma `,`
body(Left in tags for better readability):
<p> What would be your preferred way to concatenate strings from a
sequence such that between every two consecutive pairs a comma is
added. That is, how do you map, for instance, <code> ['a', 'b', 'c']
<p>  to <code> 'a,b,c' <p> ? (The cases <code> ['s'] <p>  and <code>
[] <p>  should be mapped to <code> 's' <p>  and <code> '' <p> ,
respectively.)
<p> I usually end up using something like <code> ''.join(map(lambda x:
x+',',l))[:-1] <p> , but also feeling somewhat unsatisfied.

-------------------------------------OUTPUT-------------------------------------

                Expected= '""",""".join(l)'
           base:Baseline= [x for x in L if x.split(',')]
           body:Baseline= '.join(map(lambda x: x +',', l))[:-1]
            body:-Blocks= l = map(lambda x: x+',',l))
              body:-Code= [(x + y) for x, y in L.split(',')]
            body:-Inline= [(a, b) for a, b in L]
                body:-NL= '.join(map(lambda x: x +',',l))[:-1]
             base:+Mined= l = [item for item in l if item.isdigit()]
     body+mined:Baseline= """, """.join(map(lambda x: x + ',', L))[:-1]
        body+mined:-Code= """""".join(str(x) for x in L)
          body+mined:-NL= """""".join(map(lambda x: x + ',', l))[:-1]
      body+mined:-Blocks= map(lambda x: x + 'a', l))
      body+mined:-Inline= [(x + y) for x, y in L.split(',')]

================================================================================

QUESTION: idx=47     id=44778
-------------------------------------INPUTS-------------------------------------

tags: string, list
score: 593
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['myList']}
intent: make a comma-separated string from a list `mylist`
body(Left in tags for better readability):
<p> What would be your preferred way to concatenate strings from a
sequence such that between every two consecutive pairs a comma is
added. That is, how do you map, for instance, <code> ['a', 'b', 'c']
<p>  to <code> 'a,b,c' <p> ? (The cases <code> ['s'] <p>  and <code>
[] <p>  should be mapped to <code> 's' <p>  and <code> '' <p> ,
respectively.)
<p> I usually end up using something like <code> ''.join(map(lambda x:
x+',',l))[:-1] <p> , but also feeling somewhat unsatisfied.

-------------------------------------OUTPUT-------------------------------------

                Expected= "myList = ','.join(map(str, myList))"
           base:Baseline= re.sub('[^a-zA-Z]', mylist)
           body:Baseline= """""".join(map(lambda x: x + ',', l))[:-1]
            body:-Blocks= """""".join(map(lambda x: x + ',', l))[:-1]
              body:-Code= """""".join(mylist.split())
            body:-Inline= """""".join(c for c in mylist if c.split())
                body:-NL= '.join(map(lambda x: x +',', l))[:-1]
             base:+Mined= myList = [item.split() for item in myList]
     body+mined:Baseline= """""".join(map(lambda x: x + ',', L))[:-1]
        body+mined:-Code= """""".join(myList[:2])
          body+mined:-NL= """""".join(map(lambda x: x + ',', l))[:-1]
      body+mined:-Blocks= mylist.split(',')[:-1]
      body+mined:-Inline= """""".join(mylist[::2] + mylist[1::2])

================================================================================

QUESTION: idx=48     id=7286365
-------------------------------------INPUTS-------------------------------------

tags: list, range, reverse
score: 398
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: reverse the list that contains 1 to 10
body(Left in tags for better readability):
<p> How can you produce the following list with <code> range() <p>  in
Python?
<code_block>
 [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]


-------------------------------------OUTPUT-------------------------------------

                Expected= 'list(reversed(list(range(10))))'
           base:Baseline= [x for x in range(10)]
           body:Baseline= [i for i, j in range(10)]
            body:-Blocks= [x for x in range(10)]
              body:-Code= [i for i in range(10)]
            body:-Inline= [list(range(10)) for _ in range(10)]
                body:-NL= [x for x in range(10)]
             base:+Mined= [x[0] for x in range(10)]
     body+mined:Baseline= [x for x in range(10)]
        body+mined:-Code= [reverse([1, 10]) for _ in range(10)]
          body+mined:-NL= [x for x in range(10)]
      body+mined:-Blocks= [l[::-1] for l in range(10)]
      body+mined:-Inline= [x[1] for x in range(10)]

================================================================================

QUESTION: idx=49     id=18454570
-------------------------------------INPUTS-------------------------------------

tags: string, addition, subtraction
score: 24
slot_map: {'key': ['str_0', 'str_1'], 'quote': ["'", "'"], 'type': ['str', 'str'], 'value': ['bag,', 'lamp, bag, mirror']}
intent: remove substring 'bag,' from a string 'lamp, bag, mirror'
body(Left in tags for better readability):
<p> I have a long string, which is basically a list like <code>
str="lamp, bag, mirror," <p>  (and other items)
<p> I was wondering if I can add or subtract some items, in other
programming languages I can easily do: <code> str=str-"bag," <p>  and
get <code> str="lamp, mirror," <p>  this doesnt work in python (I'm
using 2.7 on a W8 pc)
<p> Is there a way to split the string across say "bag," and somehow
use that as a subtraction? Then I still need to figure out how to add.

-------------------------------------OUTPUT-------------------------------------

                Expected= "print('lamp, bag, mirror'.replace('bag,', ''))"
           base:Baseline= """""".join('lamp, bag, mirror')
           body:Baseline= """lamp, bag, mirror"""[::-1]
            body:-Blocks= """lamp, bag, mirror""".replace('bag', 'bag')
              body:-Code= """Lamp, bag, mirror""".replace('bag', '')
            body:-Inline= re.sub('lamp, bag, mirror', 'bag', 1)
                body:-NL= """lamp, bag, mirror""".replace('bag', '')
             base:+Mined= """lamp, bag, mirror""".replace('bag', '')
     body+mined:Baseline= re.sub('\\bbag\\b', '', 'lamp, bag, mirror', s)
        body+mined:-Code= """Lamp, bag, mirror""".replace('bag', '')
          body+mined:-NL= """lamp, bag, mirror.""".replace('bag', '')
      body+mined:-Blocks= re.sub('\\bbag', '', str)
      body+mined:-Inline= """Lamp, bag, mirror""".translate(None, 'bag')

================================================================================

QUESTION: idx=50     id=4357787
-------------------------------------INPUTS-------------------------------------

tags: 
score: 4
slot_map: {'key': ['str_0', 'var_0'], 'quote': ['`', '`'], 'type': ['str', 'var'], 'value': ['.', 's']}
intent: reverse the order of words, delimited by `.`, in string `s`
body(Left in tags for better readability):
<p> I have the following string:
<code_block>
 apple.orange.red.green.yellow

<p> How can i reverse it to get the following:
<code_block>
 yellow.green.red.orange.apple


-------------------------------------OUTPUT-------------------------------------

                Expected= '""".""".join(s.split(\'.\')[::-1])'
           base:Baseline= re.sub('(.)', s)
           body:Baseline= re.findall('\\b\\d+', s)
            body:-Blocks= re.findall('\\d+', s)
              body:-Code= re.sub('\\.\\.', s)
            body:-Inline= re.findall('\\.', s)
                body:-NL= s.split('.', 1)[::-1]
             base:+Mined= reversed(s, delimiter='.', reverse=True)
     body+mined:Baseline= s = s.split(',')
        body+mined:-Code= re.sub('(.+)\\.\\.', '', s)
          body+mined:-NL= re.split('\\.', s)
      body+mined:-Blocks= re.sub('(.+)', '\\1', s)
      body+mined:-Inline= re.findall('\\.\\s+', s)

================================================================================

QUESTION: idx=51     id=21787496
-------------------------------------INPUTS-------------------------------------

tags: ruby, datetime, epoch
score: 79
slot_map: {'key': ['var_0', 'str_0'], 'quote': ['`', "'"], 'type': ['var', 'str'], 'value': ['s', '%Y-%m-%d %H:%M:%S.%f']}
intent: convert epoch time represented as milliseconds `s` to string using format '%y-%m-%d %h:%m:%s.%f'
body(Left in tags for better readability):
<p> I have used a ruby script to convert iso time stamp to epoch, the
files that I am parsing has following time stamp structure:
<code_block>
 2009-03-08T00:27:31.807

<p> Since I want to keep milliseconds I used following ruby code to
convert it to epoch time:
<code_block>
 irb(main):010:0>
DateTime.parse('2009-03-08T00:27:31.807').strftime("%Q")
=> "1236472051807"

<p> But In python I tried following:
<code_block>
 import time
time.strftime('%Y-%m-%d %H:%M:%S', time.gmtime(1236472051807))

<p> But I don't get the original time date time back,
<code_block>
 <console_in> time.strftime('%Y-%m-%d %H:%M:%S',
time.gmtime(1236472051807))
<console_out> '41152-03-29 02:50:07'
<console_in>
<console_out>
<p> I wonder is it related to how I am formatting?

-------------------------------------OUTPUT-------------------------------------

                Expected= "datetime.datetime.fromtimestamp(s).strftime('%Y-%m-%d %H:%M:%S.%f')"
           base:Baseline= time.strftime('%Y-%m-%d %H:%M:%S.%f')
           body:Baseline= time.strftime('%Y-%m-%d %H:%M:%S.%f')
            body:-Blocks= time.strftime('%Y-%m-%d %H:%M:%S.%f')
              body:-Code= time.strftime('%Y-%m-%d %H:%M:%S.%f')
            body:-Inline= time.strftime('%Y-%m-%d %H:%M:%S.%f')
                body:-NL= time.strftime('%Y-%m-%d %H:%M:%S.%f')
             base:+Mined= time.mktime(s, '%Y-%m-%d %H:%M:%S.%f')
     body+mined:Baseline= time.strftime('%Y-%m-%d %H:%M:%S.%f')
        body+mined:-Code= time.strftime('%Y-%m-%d %H:%M:%S.%f')
          body+mined:-NL= time.strftime('%Y-%m-%d %H:%M:%S', time.gmtime(1236472051807))
      body+mined:-Blocks= time.strptime('%Y-%m-%d %H:%M:%S.%f')
      body+mined:-Inline= time.strftime('%Y-%m-%d %H:%M:%S.%f')

================================================================================

QUESTION: idx=52     id=21787496
-------------------------------------INPUTS-------------------------------------

tags: ruby, datetime, epoch
score: 79
slot_map: {'key': ['str_0', 'str_1'], 'quote': ["'", "'"], 'type': ['str', 'str'], 'value': ['1236472051807', '%Y-%m-%d %H:%M:%S']}
intent: parse milliseconds epoch time '1236472051807' to format '%y-%m-%d %h:%m:%s'
body(Left in tags for better readability):
<p> I have used a ruby script to convert iso time stamp to epoch, the
files that I am parsing has following time stamp structure:
<code_block>
 2009-03-08T00:27:31.807

<p> Since I want to keep milliseconds I used following ruby code to
convert it to epoch time:
<code_block>
 irb(main):010:0>
DateTime.parse('2009-03-08T00:27:31.807').strftime("%Q")
=> "1236472051807"

<p> But In python I tried following:
<code_block>
 import time
time.strftime('%Y-%m-%d %H:%M:%S', time.gmtime(1236472051807))

<p> But I don't get the original time date time back,
<code_block>
 <console_in> time.strftime('%Y-%m-%d %H:%M:%S',
time.gmtime(1236472051807))
<console_out> '41152-03-29 02:50:07'
<console_in>
<console_out>
<p> I wonder is it related to how I am formatting?

-------------------------------------OUTPUT-------------------------------------

                Expected= "time.strftime('%Y-%m-%d %H:%M:%S', time.gmtime(1236472051807 / 1000.0))"
           base:Baseline= time.strptime('1236472051807', '%Y-%m-%d %H:%M:%S')
           body:Baseline= time.strftime('%Y-%m-%d %H:%M:%S', time.gmtime(1236472051807))
            body:-Blocks= time.strftime('1236472051807', '%Y-%m-%d %H:%M:%S')
              body:-Code= time.mktime('1236472051807', '%Y-%m-%d %H:%M:%S')
            body:-Inline= time.strftime('%Y-%m-%d %H:%M:%S')
                body:-NL= DateTime.parse('2009-03-08T00:27:31.807').strftime('%Y-%m-%d %H:%M:%S')
             base:+Mined= time.strptime('1236472051807', '%Y-%m-%d %H:%M:%S')
     body+mined:Baseline= time.strftime('%Y-%m-%d %H:%M:%S')
        body+mined:-Code= time.mktime(1236472051807, '%Y-%m-%d %H:%M:%S')
          body+mined:-NL= time.strftime('%Y-%m-%d %H:%M:%S')
      body+mined:-Blocks= time.strptime('1236472051807', '%Y-%m-%d %H:%M:%S')
      body+mined:-Inline= time.strftime('%Y-%m-%d %H:%M:%S')

================================================================================

QUESTION: idx=53     id=20573459
-------------------------------------INPUTS-------------------------------------

tags: datetime
score: 49
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: get the date 7 days before the current date
body(Left in tags for better readability):
<p> I'm trying to get the date that was 7 days ago starting from
current date in python. Can anyone help me?

-------------------------------------OUTPUT-------------------------------------

                Expected= '(datetime.datetime.now() - datetime.timedelta(days=7)).date()'
           base:Baseline= today = datetime.datetime.now().date()
           body:Baseline= calendar.datetime.now().date()
            body:-Blocks= calendar.datetime.now().date()
              body:-Code= today = datetime.datetime.now().date()
            body:-Inline= calendar.datetime.now().date()
                body:-NL= calendar.datetime.now().date()
             base:+Mined= datetime.datetime(7, 7, 7)
     body+mined:Baseline= datetime.now() - datetime.timedelta(days=7, weeks=1)
        body+mined:-Code= today = datetime.datetime.now().date()
          body+mined:-NL= datetime.now() - datetime.timedelta(days=7, hours=7)
      body+mined:-Blocks= datetime.now() - datetime.timedelta(days=1)
      body+mined:-Inline= date(today - datetime.timedelta(days=7, weeks=1))

================================================================================

QUESTION: idx=54     id=15352457
-------------------------------------INPUTS-------------------------------------

tags: for-loop
score: 15
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['column', 'data']}
intent: sum elements at index `column` of each list in list `data`
body(Left in tags for better readability):
<p> I have a Python array, like so:
<code_block>
 [[1,2,3],
 [1,2,3]]

<p> I can add the row by doing <code> sum(array[i]) <p> , how can I
sum a column, using a double for loop?
<p> I.E. for the first column, I could get 2, then 4, then 6.

-------------------------------------OUTPUT-------------------------------------

                Expected= 'print(sum(row[column] for row in data))'
           base:Baseline= data[x[0] for x in data]
           body:Baseline= sum(np.sum(column))
            body:-Blocks= np.sum(iter(data), axis=1)
              body:-Code= sum(iter(data), axis=1)
            body:-Inline= [np.sum(column) for column in data]
                body:-NL= sum(iter(x) for x in data)
             base:+Mined= data = [sum(x) for x in data]
     body+mined:Baseline= sum(item[0] for item in data)
        body+mined:-Code= sum(data[0] for i in range(0, len(data), 3))
          body+mined:-NL= sum(item[0] for item in data)
      body+mined:-Blocks= sum(item[0] for item in data)
      body+mined:-Inline= sum([1, 2, 3])

================================================================================

QUESTION: idx=55     id=15352457
-------------------------------------INPUTS-------------------------------------

tags: for-loop
score: 15
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['array']}
intent: sum columns of a list `array`
body(Left in tags for better readability):
<p> I have a Python array, like so:
<code_block>
 [[1,2,3],
 [1,2,3]]

<p> I can add the row by doing <code> sum(array[i]) <p> , how can I
sum a column, using a double for loop?
<p> I.E. for the first column, I could get 2, then 4, then 6.

-------------------------------------OUTPUT-------------------------------------

                Expected= '[sum(row[i] for row in array) for i in range(len(array[0]))]'
           base:Baseline= sum([x[0] for x in array]
           body:Baseline= sum(np.sum(axis=1, 2, 3), axis=1)
            body:-Blocks= np.sum(array[i])
              body:-Code= np.sum(np.arange(array))
            body:-Inline= sum(list(array.values())
                body:-NL= sum(array[i] for i in range(1, 2, 3)]
             base:+Mined= sum(x[0] for x in array)
     body+mined:Baseline= sum([1, 2, 3])
        body+mined:-Code= sum(map(sum, my_list))
          body+mined:-NL= sum(x[1] for x in array)
      body+mined:-Blocks= sum(map(sum, my_array))
      body+mined:-Inline= sum([1, 2, 3])

================================================================================

QUESTION: idx=56     id=23164058
-------------------------------------INPUTS-------------------------------------

tags: encoding, base64
score: 50
slot_map: {'key': ['str_0'], 'quote': ["'"], 'type': ['str'], 'value': ['your string']}
intent: encode binary string 'your string' to base64 code
body(Left in tags for better readability):
<p> I am trying to encode a text string to base64.
<p> i tried doing this :
<code_block>
 name = "your name"
print('encoding %s in base64 yields =
%s\n'%(name,name.encode('base64','strict')))

<p> But this gives me the following error:
<code_block>
 LookupError: 'base64' is not a text encoding; use codecs.encode() to
handle arbitrary codecs

<p> How do I go about doing this ? ( using Python 3.4)

-------------------------------------OUTPUT-------------------------------------

                Expected= "base64.b64encode(bytes('your string', 'utf-8'))"
           base:Baseline= struct.encode('your string', 16)
           body:Baseline= codecs.encode('base64','strict'))
            body:-Blocks= codecs.encode('your string')
              body:-Code= struct.encode('your string', 16)
            body:-Inline= codecs.encode('your string')
                body:-NL= codecs.encode('your string', 'strict')
             base:+Mined= binascii.encode('base64')
     body+mined:Baseline= print('encoding %s in base64 yields = %s\n' % (name, name.encode('base64',
    'strict')))
        body+mined:-Code= base64.b64encode('your string')
          body+mined:-NL= print('encoding %s in base64 yields = %s\n'.encode('base64', 'strict'))
      body+mined:-Blocks= base64.b64encode('your string')
      body+mined:-Inline= print('encoding %s in base64 yields = %s\n'.encode('base64', 'strict'))

================================================================================

QUESTION: idx=57     id=11533274
-------------------------------------INPUTS-------------------------------------

tags: dictionary
score: 8
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['dicts']}
intent: combine list of dictionaries `dicts` with the same keys in each list to a single dictionary
body(Left in tags for better readability):
<p> I have a list of dictionaries like so:
<code_block>
 dicts = [
    {'key_a': valuex1,
     'key_b': valuex2,
     'key_c': valuex3},

    {'key_a': valuey1,
     'key_b': valuey2,
     'key_c': valuey3},

    {'key_a': valuez1,
     'key_b': valuez2,
     'key_c': valuez3}
]

<p> I would like to take these and construct a big dictionary like so:
<code_block>
 big_dict = {
    'key_a': [valuex1, valuey1, valuez1],
    'key_b': [valuex2, valuey2, valuez2],
    'key_c': [valuex3, valuey3, valuez3]
}

<p> Is there any elegant " <a> zip <p> "-like way for me to do this?
<p> All the keys are always going to be identical.

-------------------------------------OUTPUT-------------------------------------

                Expected= 'dict((k, [d[k] for d in dicts]) for k in dicts[0])'
           base:Baseline= dict((k, v) for k, v in dicts.items() if v)
           body:Baseline= dict((k, v) for k, v in dicts.items()))
            body:-Blocks= dict((k, v) for k, v in list(dicts.items()))
              body:-Code= dict((k, v) for k, v in list(dicts.items()))
            body:-Inline= dict((k, v) for k, v in dicts.items()))
                body:-NL= dict((k, v) for k, v in big_dict.items())
             base:+Mined= dict((k, v) for k, v in dicts)
     body+mined:Baseline= dict((k, v) for k, v in dicts.items() if v}
        body+mined:-Code= {k: bigdict(v) for k, v in list(dicts.items())}
          body+mined:-NL= {k: v for d in dicts for k, v in list(d.items())}
      body+mined:-Blocks= {k: bigdict(v) for k, v in list(dicts.items())}
      body+mined:-Inline= {k: v for d in dicts for k, v in list(d.items())}

================================================================================

QUESTION: idx=58     id=11533274
-------------------------------------INPUTS-------------------------------------

tags: dictionary
score: 8
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['dicts', 'k']}
intent: merge a nested dictionary `dicts` into a flat dictionary by concatenating nested values with the same key `k`
body(Left in tags for better readability):
<p> I have a list of dictionaries like so:
<code_block>
 dicts = [
    {'key_a': valuex1,
     'key_b': valuex2,
     'key_c': valuex3},

    {'key_a': valuey1,
     'key_b': valuey2,
     'key_c': valuey3},

    {'key_a': valuez1,
     'key_b': valuez2,
     'key_c': valuez3}
]

<p> I would like to take these and construct a big dictionary like so:
<code_block>
 big_dict = {
    'key_a': [valuex1, valuey1, valuez1],
    'key_b': [valuex2, valuey2, valuez2],
    'key_c': [valuex3, valuey3, valuez3]
}

<p> Is there any elegant " <a> zip <p> "-like way for me to do this?
<p> All the keys are always going to be identical.

-------------------------------------OUTPUT-------------------------------------

                Expected= '{k: [d[k] for d in dicts] for k in dicts[0]}'
           base:Baseline= dict((k, v) for k, v in dicts.items() if v != k)
           body:Baseline= dict((k, v) for k, v in dicts.items()))
            body:-Blocks= dict((k, v) for k, v in dicts.items() if v.split(k))
              body:-Code= dict((k, v) for k, v in list(dicts.items()))
            body:-Inline= {k: v for k, v in dicts.items()}
                body:-NL= {k: big_dict[k] for k in list(dicts.items())}
             base:+Mined= dict((k, v) for k, v in list(dicts.items()))
     body+mined:Baseline= dict((k, v) for k, v in list(dicts.items()))
        body+mined:-Code= {k: bigdict(v) for k, v in list(dicts.items())}
          body+mined:-NL= {k: v for k, v in list(big_dict.items()) if v}
      body+mined:-Blocks= {k: bigdict(v) for k, v in dicts.items()}
      body+mined:-Inline= {k: big_dict[k] for k in dicts}

================================================================================

QUESTION: idx=59     id=14026704
-------------------------------------INPUTS-------------------------------------

tags: html, flask
score: 21
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: how do i get the url parameter in a flask view
body(Left in tags for better readability):
<p> I am trying to get the url parameters from a flask view:
<code_block>
 www.domain.com/?f=x**2

<p> How do I get <code> x**2 <p>  from the <code> url <p>  in a Flask
view?

-------------------------------------OUTPUT-------------------------------------

                Expected= "request.args['myParam']"
           base:Baseline= self.url.get('r', 1)[0]
           body:Baseline= url = Flask.get(url)
            body:-Blocks= url = Flask.View(url)
              body:-Code= url = Flask.get('r', 1)
            body:-Inline= url = flask.get('url')
                body:-NL= urllib.request.urlretrieve(url)
             base:+Mined= app.run(debug=True)
     body+mined:Baseline= app.run(debug=True)
        body+mined:-Code= app.run(debug=True)
          body+mined:-NL= app.run(debug=True)
      body+mined:-Blocks= app.run(debug=True)
      body+mined:-Inline= app.run(debug=True)

================================================================================

QUESTION: idx=60     id=11236006
-------------------------------------INPUTS-------------------------------------

tags: arrays, list
score: 42
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['mylist']}
intent: identify duplicate values in list `mylist`
body(Left in tags for better readability):
<p> Is it possible to get which values are duplicates in a list using
python?
<p> I have a list of items:
<code_block>
     mylist = [20, 30, 25, 20]

<p> I know the best way of removing the duplicates is <code>
set(mylist) <p> , but is it possible to know what values are being
duplicated? As you can see, in this list the duplicates are the first
and last values. <code> [0, 3] <p> .
<p> Is it possible to get this result or something similar in python?
I'm trying to avoid making a ridiculously big <code> if elif <p>
conditional statement.

-------------------------------------OUTPUT-------------------------------------

                Expected= '[k for k, v in list(Counter(mylist).items()) if v > 1]'
           base:Baseline= for (key, value) in mylist):
    pass
           body:Baseline= set(set(mylist)))
            body:-Blocks= [x for x in set(mylist)]
              body:-Code= [x for x in mylist]
            body:-Inline= [x for x in mylist if x is duplicated]
                body:-NL= set(mylist, key=lambda x: x[1])
             base:+Mined= mylist = set(set(mylist))
     body+mined:Baseline= print(list(set(mylist))
        body+mined:-Code= myList = list(set(myList))
          body+mined:-NL= set([x for x in mylist if x == 3])
      body+mined:-Blocks= print(list(set(mylist))
      body+mined:-Inline= print(list(set(mylist))

================================================================================

QUESTION: idx=61     id=2354166
-------------------------------------INPUTS-------------------------------------

tags: google-app-engine, sys.path
score: 10
slot_map: {'key': ['str_0', 'var_0'], 'quote': ["'", '`'], 'type': ['str', 'var'], 'value': ['apps', '__file__']}
intent: insert directory 'apps' into directory `__file__`
body(Left in tags for better readability):
<p> I've tried adding the following line to my handler script
(main.py), but it doesn't seem to work:

<p> sys.path.append('subdir')

<code> subdir <p>  lives in the my root directory (i.e. the one
containing <code> app.yaml <p> ).
<p> This doesn't seem to work, because when I try to import modules
that live in <code> subdir <p> , my app explodes.

-------------------------------------OUTPUT-------------------------------------

                Expected= "sys.path.insert(1, os.path.join(os.path.dirname(__file__), 'apps'))"
           base:Baseline= os.path.insert(__file__)
           body:Baseline= sys.path.append('__file__')
            body:-Blocks= os.path.insert(__file__)
              body:-Code= __file__ = os.path.append('apps')
            body:-Inline= sys.path.append('__file__')
                body:-NL= os.path.insert(__file__)
             base:+Mined= __file__.append('apps')
     body+mined:Baseline= sys.path.insert(0, 'apps')
        body+mined:-Code= __file__.append('apps')
          body+mined:-NL= os.chdir(os.path.dirname(__file__))
      body+mined:-Blocks= sys.path.insert(__file__)
      body+mined:-Inline= sys.path.append('__file__')

================================================================================

QUESTION: idx=62     id=2354166
-------------------------------------INPUTS-------------------------------------

tags: google-app-engine, sys.path
score: 10
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['subdir']}
intent: modify sys.path for python module `subdir`
body(Left in tags for better readability):
<p> I've tried adding the following line to my handler script
(main.py), but it doesn't seem to work:

<p> sys.path.append('subdir')

<code> subdir <p>  lives in the my root directory (i.e. the one
containing <code> app.yaml <p> ).
<p> This doesn't seem to work, because when I try to import modules
that live in <code> subdir <p> , my app explodes.

-------------------------------------OUTPUT-------------------------------------

                Expected= "sys.path.append(os.path.join(os.path.dirname(__file__), 'subdir'))"
           base:Baseline= subdir = os.path.modify_path(subdir)
           body:Baseline= sys.path.append('subdir')
            body:-Blocks= sys.path.append('subdir')
              body:-Code= sys.path.append('subdir')
            body:-Inline= sys.path.append('subdir')
                body:-NL= subdir = sys.path.dirname(subdir)
             base:+Mined= sys.path.append(subdir)
     body+mined:Baseline= sys.path.append('subdir')
        body+mined:-Code= sys.path.append('subdir')
          body+mined:-NL= sys.path.append(subdir)
      body+mined:-Blocks= sys.path.append('subdir')
      body+mined:-Inline= sys.path.append('subdir')

================================================================================

QUESTION: idx=63     id=20211942
-------------------------------------INPUTS-------------------------------------

tags: sqlite, sql-insert
score: 18
slot_map: {'key': ['str_0'], 'quote': ["'"], 'type': ['str'], 'value': ['None']}
intent: insert a 'none' value into a sqlite3 table.
body(Left in tags for better readability):
<p> I am trying to insert a <code> None <p>  value into a row entry of
my db. The table <code> present <p>  exists
<code_block>
 db.execute("INSERT INTO present VALUES('test', ?, 9)", "This is a
test!")
db.execute("INSERT INTO present VALUES('test2', ?, 10)", None)

<p> but I get an error:
<code_block>
 ValueError: parameters are of unsupported type

<p> how do I insert a blank value for the second field in the row?

-------------------------------------OUTPUT-------------------------------------

                Expected= 'db.execute("INSERT INTO present VALUES(\'test2\',?, 10)", (None,))'
           base:Baseline= cursor.execute('INSERT INTO table VALUES (%s)', None)
           body:Baseline= db.execute('INSERT INTO present VALUES('test2',?, 10', None)
            body:-Blocks= cursor.execute('INSERT INTO table VALUES (%s, None))
              body:-Code= cursor.execute('INSERT INTO table VALUES (%s)', None)
            body:-Inline= db.execute('INSERT INTO present VALUES('test',?, 10)", None)
                body:-NL= db.execute('INSERT INTO present VALUES('test',?, 9)", None)
             base:+Mined= cursor.execute('INSERT INTO table VALUES (%s)', None)
     body+mined:Baseline= db.execute('INSERT INTO present VALUES('test2',?, 10', None)
        body+mined:-Code= cursor.execute('INSERT INTO table VALUES (%s, %s)', (None,))
          body+mined:-NL= db.execute('INSERT INTO present VALUES('test2',?, 9', None)
      body+mined:-Blocks= cursor.execute('INSERT INTO table VALUES (%s)', (None, None))
      body+mined:-Inline= db.execute('INSERT INTO table VALUES ('test',?, 9)')

================================================================================

QUESTION: idx=64     id=406121
-------------------------------------INPUTS-------------------------------------

tags: list-comprehension
score: 398
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['list_of_menuitems']}
intent: flatten list `list_of_menuitems`
body(Left in tags for better readability):
<p> Is there a simple way to flatten a list of iterables with a list
comprehension, or failing that, what would you all consider to be the
best way to flatten a shallow list like this, balancing performance
and readability?
<p> I tried to flatten such a list with a nested list comprehension,
like this:
<code_block>
 [image for image in menuitem for menuitem in list_of_menuitems]

<p> But I get in trouble of the <code> NameError <p>  variety there,
because the <code> name 'menuitem' is not defined <p> .  After
googling and looking around on Stack Overflow, I got the desired
results with a <code> reduce <p>  statement:
<code_block>
 reduce(list.__add__, map(lambda x: list(x), list_of_menuitems))

<p> But this method is fairly unreadable because I need that <code>
list(x) <p>  call there because x is a Django <code> QuerySet <p>
object.
<strong> Conclusion <p> :
<p> Thanks to everyone who contributed to this question.  Here is a
summary of what I learned.  I'm also making this a community wiki in
case others want to add to or correct these observations.
<p> My original reduce statement is redundant and is better written
this way:
<code_block>
 <console_in> reduce(list.__add__, (list(mi) for mi in
list_of_menuitems))
<console_out>
<p> This is the correct syntax for a nested list comprehension
(Brilliant summary <a> dF <p> !):
<code_block>
 <console_in> [image for mi in list_of_menuitems for image in mi]
<console_out>
<p> But neither of these methods are as efficient as using <code>
itertools.chain <p> :
<code_block>
 <console_in> from itertools import chain
<console_in> list(chain(*list_of_menuitems))
<console_out>
<p> And as @cdleary notes, it's probably better style to avoid *
operator magic by using <code> chain.from_iterable <p>  like so:
<code_block>
 <console_in> chain =
itertools.chain.from_iterable([[1,2],[3],[5,89],[],[6]])
<console_in> print(list(chain))
<console_in> [1, 2, 3, 5, 89, 6]
<console_out>

-------------------------------------OUTPUT-------------------------------------

                Expected= '[image for menuitem in list_of_menuitems for image in menuitem]'
           base:Baseline= list_of_menuitems = []
           body:Baseline= flatten(list_of_menuitems)
            body:-Blocks= list_of_menuitems.flatten()
              body:-Code= list_of_menuitems[::-1]
            body:-Inline= flatten(list_of_menuitems)
                body:-NL= [image for image in list_of_menuitems]
             base:+Mined= list_of_menuitems = []
     body+mined:Baseline= from_iterable([[1, 2], [3, 89], [6]])
        body+mined:-Code= [list_of_menuitems for _ in range(length)]
          body+mined:-NL= from itertools import list(chain(*list_of_menuitems))
      body+mined:-Blocks= [list_of_menuitems[0] for _ in range(menuitem)]
      body+mined:-Inline= from itertools.chain.from_iterable([[1, 2], [3, 89], [6]])

================================================================================

QUESTION: idx=65     id=4741537
-------------------------------------INPUTS-------------------------------------

tags: list, set
score: 14
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['b', 'a']}
intent: append elements of a set `b` to a list `a`
body(Left in tags for better readability):
<p> How do you append the elements of a set to a list in Python in the
most succinct way?
<code_block>
 <console_in> a = [1,2]
<console_in> b = set([3,4])
<console_in> a.append(list(b))
<console_in> a
<console_out> [1, 2, [3, 4]]

<p> But what I want is:
<code_block>
 [1, 2, 3, 4]


-------------------------------------OUTPUT-------------------------------------

                Expected= 'a.extend(b)'
           base:Baseline= a = [b[i] for i in a]
           body:Baseline= a.append(list(b))
            body:-Blocks= a = a[(b) for b in a]
              body:-Code= a.append(b, a)
            body:-Inline= a.append(list(b))
                body:-NL= a.append(list(b))
             base:+Mined= a = a[:] + b + a[:-1]
     body+mined:Baseline= a = [1, 2, 3, 4]
        body+mined:-Code= a = [i for i, j in zip(b, a)]
          body+mined:-NL= a = [list(b) for b in a]
      body+mined:-Blocks= a.append(b, a)
      body+mined:-Inline= a = [1, 2, 3, 4]

================================================================================

QUESTION: idx=66     id=4741537
-------------------------------------INPUTS-------------------------------------

tags: list, set
score: 14
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: append elements of a set to a list in python
body(Left in tags for better readability):
<p> How do you append the elements of a set to a list in Python in the
most succinct way?
<code_block>
 <console_in> a = [1,2]
<console_in> b = set([3,4])
<console_in> a.append(list(b))
<console_in> a
<console_out> [1, 2, [3, 4]]

<p> But what I want is:
<code_block>
 [1, 2, 3, 4]


-------------------------------------OUTPUT-------------------------------------

                Expected= 'a.extend(list(b))'
           base:Baseline= list(itertools.product([i for i in range(0, len(a)))
           body:Baseline= [x[0] for x in zip(a, b)]
            body:-Blocks= [x for x in set.items()]
              body:-Code= [set(x) for x in set(x))
            body:-Inline= [x[0] for x in a]
                body:-NL= [x[0] for x in a]
             base:+Mined= [1, 2, 3, 4, 5, 6]
     body+mined:Baseline= [1, 2, 3, 4]
        body+mined:-Code= [1, 2, 3, 4, 5, 6]
          body+mined:-NL= [1, 2, 3, 4]
      body+mined:-Blocks= ['a', 'b', 'c', 'd', 'e']
      body+mined:-Inline= [1, 2, 3, 4]

================================================================================

QUESTION: idx=67     id=31247198
-------------------------------------INPUTS-------------------------------------

tags: pandas, file-io
score: 86
slot_map: {'key': ['var_0', 'str_0'], 'quote': ['`', '`'], 'type': ['var', 'str'], 'value': ['df', 'np.txt']}
intent: write the data of dataframe `df` into text file `np.txt`
body(Left in tags for better readability):
<p> I have pandas DataFrame like this
<code_block>
         X    Y  Z    Value
0      18   55  1      70
1      18   55  2      67
2      18   57  2      75
3      18   58  1      35
4      19   54  2      70

<p> I want to write this data to a text file that looks like this:
<code_block>
 18 55 1 70
18 55 2 67
18 57 2 75
18 58 1 35
19 54 2 70

<p> I have tried something like
<code_block>
 f = open(writePath, 'a')
f.writelines(['\n', str(data['X']), ' ', str(data['Y']), ' ',
str(data['Z']), ' ', str(data['Value'])])
f.close()

<p> but it's not working. How to do this?

-------------------------------------OUTPUT-------------------------------------

                Expected= "np.savetxt('c:\\\\data\\\\np.txt', df.values, fmt='%d')"
           base:Baseline= df.write('np.txt', header=False)
           body:Baseline= df = open(writePath, 'a')
            body:-Blocks= df.to_open('np.txt')
              body:-Code= df.to_csv('np.txt')
            body:-Inline= df.write(np.txt)
                body:-NL= df.write(np.txt, '\n')
             base:+Mined= df.write(np.txt)
     body+mined:Baseline= np.txt.write(df)
        body+mined:-Code= df.to_csv('np.txt', sep='\t')
          body+mined:-NL= np.write(df, delimiter=',')
      body+mined:-Blocks= df.to_text('np.txt')
      body+mined:-Inline= df.write(np.txt)

================================================================================

QUESTION: idx=68     id=31247198
-------------------------------------INPUTS-------------------------------------

tags: pandas, file-io
score: 86
slot_map: {'key': ['var_0', 'str_0'], 'quote': ['`', "'"], 'type': ['var', 'str'], 'value': ['df', 'c:\\data\\pandas.txt']}
intent: write content of dataframe `df` into text file 'c:\\data\\pandas.txt'
body(Left in tags for better readability):
<p> I have pandas DataFrame like this
<code_block>
         X    Y  Z    Value
0      18   55  1      70
1      18   55  2      67
2      18   57  2      75
3      18   58  1      35
4      19   54  2      70

<p> I want to write this data to a text file that looks like this:
<code_block>
 18 55 1 70
18 55 2 67
18 57 2 75
18 58 1 35
19 54 2 70

<p> I have tried something like
<code_block>
 f = open(writePath, 'a')
f.writelines(['\n', str(data['X']), ' ', str(data['Y']), ' ',
str(data['Z']), ' ', str(data['Value'])])
f.close()

<p> but it's not working. How to do this?

-------------------------------------OUTPUT-------------------------------------

                Expected= "df.to_csv('c:\\\\data\\\\pandas.txt', header=None, index=None, sep=' ', mode='a')"
           base:Baseline= df.write('C:\\data\\pandas.txt')
           body:Baseline= df = open(writePath, 'C:\\data\\pandas.txt')
            body:-Blocks= df.write('C:\\data\\pandas.txt')
              body:-Code= df.write('C:\\data\\pandas.txt')
            body:-Inline= df.write('C:\\data\\pandas.txt')
                body:-NL= df.write('C:\\data\\pandas.txt')
             base:+Mined= df.write('C:\\data\\pandas.txt')
     body+mined:Baseline= f.write('C:\\data\\pandas.txt')
        body+mined:-Code= df.to_csv('c:\\data\\pandas.txt')
          body+mined:-NL= f.write('C:\\data\\pandas.txt')
      body+mined:-Blocks= df.write('C:\\data\\pandas.txt')
      body+mined:-Inline= f.write('c:\\data\\pandas.txt')

================================================================================

QUESTION: idx=69     id=15851568
-------------------------------------INPUTS-------------------------------------

tags: string, split, slice
score: 63
slot_map: {'key': ['var_0', 'str_0'], 'quote': ['`', '`'], 'type': ['var', 'str'], 'value': ['x', '-']}
intent: split a string `x` by last occurrence of character `-`
body(Left in tags for better readability):
<p> I am trying to print the last part of a string before a certain
character.
<p> I'm not quite sure whether to use the string .split() method or
string slicing or maybe something else.
<p> Here is some code that doesn't work but I think shows the logic:
<code_block>
 x = 'http://test.com/lalala-134'
print x['-':0] # beginning at the end of the string, return everything
before '-'

<p> Note that the number at the end will vary in size so I can't set
an exact count from the end of the string.

-------------------------------------OUTPUT-------------------------------------

                Expected= "print(x.rpartition('-')[0])"
           base:Baseline= x = re.split('-')
           body:Baseline= print(x['-'] + '-'))
            body:-Blocks= x.split(-1)[::-1]
              body:-Code= x.split(',', '-')
            body:-Inline= print(x['-'] + x['-'])
                body:-NL= x = 'http://test.com/lalala-134'
             base:+Mined= x.split(':')[-1]
     body+mined:Baseline= x.split('-')[-]
        body+mined:-Code= x.split('-')[-1]
          body+mined:-NL= x.split(':')[-1]
      body+mined:-Blocks= x.split('-')[-]
      body+mined:-Inline= print(x['-'] + x['-'])

================================================================================

QUESTION: idx=70     id=15851568
-------------------------------------INPUTS-------------------------------------

tags: string, split, slice
score: 63
slot_map: {'key': ['str_0'], 'quote': ["'"], 'type': ['str'], 'value': ['-']}
intent: get the last part of a string before the character '-'
body(Left in tags for better readability):
<p> I am trying to print the last part of a string before a certain
character.
<p> I'm not quite sure whether to use the string .split() method or
string slicing or maybe something else.
<p> Here is some code that doesn't work but I think shows the logic:
<code_block>
 x = 'http://test.com/lalala-134'
print x['-':0] # beginning at the end of the string, return everything
before '-'

<p> Note that the number at the end will vary in size so I can't set
an exact count from the end of the string.

-------------------------------------OUTPUT-------------------------------------

                Expected= "print(x.rsplit('-', 1)[0])"
           base:Baseline= """""".join(re.sub('-'))
           body:Baseline= """http://test.com/lalala-134""".replace('-'', '')
            body:-Blocks= print('-' + str(last.split('-'))
              body:-Code= """""".join(str('.-', '-'))
            body:-Inline= print(x['-': 0))
                body:-NL= """""".join(x['-'] for x in '-')
             base:+Mined= re.findall('-', '-', s)
     body+mined:Baseline= """-""".join(x[-:] for x in s.split())
        body+mined:-Code= last_part.split('-')
          body+mined:-NL= print(x['-'] + '-')
      body+mined:-Blocks= print('-'.rstrip('-')
      body+mined:-Inline= print(x['-'] + '-' + str(x))

================================================================================

QUESTION: idx=71     id=17438096
-------------------------------------INPUTS-------------------------------------

tags: ftp
score: 14
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: upload file using ftp
body(Left in tags for better readability):
<p> I am trying to upload file from windows server to a unix server
(basically trying to do FTP). I have used the code below
<code_block>
 #!/usr/bin/python
import ftplib
import os
filename = "MyFile.py"
ftp = ftplib.FTP("xx.xx.xx.xx")
ftp.login("UID", "PSW")
ftp.cwd("/Unix/Folder/where/I/want/to/put/file")
os.chdir(r"\\windows\folder\which\has\file")
ftp.storbinary('RETR %s' % filename, open(filename, 'w').write)

<p> I am getting the following error:
<code_block>
 Traceback (most recent call last):
  File "Windows\folder\which\has\file\MyFile.py", line 11, in <module>
    ftp.storbinary('RETR %s' % filename, open(filename, 'w').write)
  File "windows\folder\Python\lib\ftplib.py", line 466, in storbinary
    buf = fp.read(blocksize)
AttributeError: 'builtin_function_or_method' object has no attribute
'read'

<p> Also all contents of <code> MyFile.py <p>  got deleted .
<p> Can anyone advise what is going wrong.I have read that
ftp.storbinary is used for uploading files using FTP.

-------------------------------------OUTPUT-------------------------------------

                Expected= "ftp.storlines('STOR' + filename, open(filename, 'r'))"
           base:Baseline= ftp.uploadFile(filename)
           body:Baseline= ftp = ftplib.FTP('/Unix/Folder/where/I/want/to/put/file')
            body:-Blocks= ftp.storbinary('file://myFile.py')
              body:-Code= ftp.uploadFile(filename)
            body:-Inline= ftp.storbinary('RETR %s', open(filename, 'w').write)
                body:-NL= ftp.cwd('/Unix/Folder/where/I/want/to/put/file')
             base:+Mined= ftp.retrbinary('upload_file.txt', filename)
     body+mined:Baseline= ftp.storbinary('RETR %s' % filename, open(filename, 'w').write)
        body+mined:-Code= ftp.storbinary('RETR %s', filename)
          body+mined:-NL= ftp.cwd('/Unix/Folder/where/I/want/to/put/file')
      body+mined:-Blocks= ftp.storbinary('MyFile.py')
      body+mined:-Inline= ftp.storbinary('RETR %s % filename, open(filename, 'w').write)

================================================================================

QUESTION: idx=72     id=15049182
-------------------------------------INPUTS-------------------------------------

tags: selenium
score: 5
slot_map: {'key': ['str_0'], 'quote': ["'"], 'type': ['str'], 'value': ['XYZ']}
intent: add one to the hidden web element with id 'xyz' with selenium python script
body(Left in tags for better readability):
<p> I'm trying to write to a text box with my python selenium code but
get an error since a parent tag of the text box is hidden.
<code_block>
 driver.find_element_by_xpath("//input[@itemcode='XYZ']").send_keys(1)

<p> I see a Javascript executor workaround with java but need help
with something similar for python script.
<p> Thanks in advance!!

-------------------------------------OUTPUT-------------------------------------

                Expected= 'browser.execute_script("document.getElementById(\'XYZ\').value+=\'1\'")'
           base:Baseline= driver.find_element_by_id('xyz')
           body:Baseline= driver.find_element_by_xpath("//input[@itemcode='XYZ']").send_keys(1)
            body:-Blocks= driver.find_element_by_id('xyz')
              body:-Code= driver.find_element_by_id('xyz')
            body:-Inline= driver.find_element_by_xpath("//input[@itemcode='XYZ']").send_keys(1)
                body:-NL= driver.find_element_by_xpath("//input[@itemcode='XYZ']").send_keys(1)
             base:+Mined= driver.find_element_by_id('xyz').click()
     body+mined:Baseline= driver.find_element_by_xpath("//input[@itemcode='XYZ']").send_keys(1)
        body+mined:-Code= driver.find_element_by_id('xyz')
          body+mined:-NL= driver.find_element_by_xpath("//input[@itemcode='XYZ']").send_keys(1)
      body+mined:-Blocks= driver.find_element_by_id('xyz')
      body+mined:-Inline= driver.find_element_by_xpath("//input[@itemcode='XYZ']").send_keys(1)

================================================================================

QUESTION: idx=73     id=28742436
-------------------------------------INPUTS-------------------------------------

tags: arrays, numpy, max
score: 9
slot_map: {'key': ['str_0', 'str_1', '[str_0]', '[str_1]'], 'quote': ['`', '`', '`', '`'], 'type': ['str', 'str', 'str', 'str'], 'value': ['[2, 3, 4]', '[1, 5, 2]', '[2, 3, 4]', '[1, 5, 2]']}
intent: create array containing the maximum value of respective elements of array `[2, 3, 4]` and array `[1, 5, 2]`
body(Left in tags for better readability):
<p> I want to combine two numpy arrays to produce an array with the
largest values from each array.
<code_block>
 import numpy as np

a  = np.array([[ 0.,  0.,  0.5],
               [ 0.1,  0.5,  0.5],
               [ 0.1,  0.,  0.]])

b  = np.array([[ 0.,  0.,  0.0],
               [ 0.5,  0.1,  0.5],
               [ 0.5,  0.1,  0.]])

<p> I would like to produce
<code_block>
 array([[ 0.,  0.,  0.5],
       [ 0.5,  0.5,  0.5],
       [ 0.5,  0.1,  0.]])

<p> I know you can do
<code_block>
 a += b

<p> which results in
<code_block>
 array([[ 0. ,  0. ,  0.5],
       [ 0.6,  0.6,  1. ],
       [ 0.6,  0.1,  0. ]])

<p> This is clearly not what I'm after. It seems like such an easy
problem and I assume it most probably is.

-------------------------------------OUTPUT-------------------------------------

                Expected= 'np.maximum([2, 3, 4], [1, 5, 2])'
           base:Baseline= np.array([2, 3, 4], [2, 5, 2])
           body:Baseline= np.array([2, 3, 4], [1, 5, 2]])
            body:-Blocks= np.array([2, 3, 4], np.max([1, 5, 2])
              body:-Code= np.array([2, 3, 4], [2, 5, 2])
            body:-Inline= np.array([2, 3, 4], [1, 5, 2])
                body:-NL= np.max(np.array([2, 3, 4], [1, 5, 2])
             base:+Mined= np.argmax(a, [2, 3, 4], [1, 5, 2])
     body+mined:Baseline= np.maximum(a, b)
        body+mined:-Code= np.argmax(x, y)
          body+mined:-NL= np.argmax(a, np.maximum(b, [2, 3, 4]))
      body+mined:-Blocks= np.maximum_array([2, 3, 4], [1, 5, 2])
      body+mined:-Inline= np.argmax(a, b)

================================================================================

QUESTION: idx=74     id=34280147
-------------------------------------INPUTS-------------------------------------

tags: list
score: 6
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['l']}
intent: print a list `l` and move first 3 elements to the end of the list
body(Left in tags for better readability):
<p> I'm trying to figure out how to print the following list while not
starting by the first item. To be clear: If the list is <code>
[0,1,2,3,4,5,6,7,8] <p> , I want to print something like <code>
4,5,6,7,8,0,1,2,3
<p> Here's the code:
<code_block>
 you_can_move_on = False

List = [0,1,2,3,4,5,6,7,8]

next_player = 3

while not you_can_move_on:
    next_player = self.get_next_player_index(next_player)
    you_can_move_on = self.check_if_I_can_move_on
    print(next_player)

def get_next_player_index(self, i):
    if i == len(self.players):
        return 0
    else:
        return i+1

def check_if_I_can_move_on(self):
    return False


-------------------------------------OUTPUT-------------------------------------

                Expected= 'print(l[3:] + l[:3])'
           base:Baseline= print(l[0] + 3)
           body:Baseline= print([0, 1, 2, 3, 4, 5, 6, 7, 8])
            body:-Blocks= print('[0,1,2,3,4, 5, 6, 7, 8])
              body:-Code= print(l, key=lambda x: x[3])
            body:-Inline= print(l[0] + 3]
                body:-NL= print(l[0:3] + L[0, 1, 2, 3, 4, 5, 6, 7, 8])
             base:+Mined= print(l[i:i + 3] for i in range(3))
     body+mined:Baseline= print(''.join(l[i:i + 3])
        body+mined:-Code= print(' '.join(str(i) for i in L))
          body+mined:-NL= print([0, 1, 2, 3, 4, 5, 6, 7, 8])
      body+mined:-Blocks= print('[0,1,2,3,4,5,6,7,8]'.join(l))
      body+mined:-Inline= print(' '.join(L[i:i + 3])

================================================================================

QUESTION: idx=75     id=11801309
-------------------------------------INPUTS-------------------------------------

tags: file-io, absolute-path
score: 62
slot_map: {'key': ['str_0'], 'quote': ["'"], 'type': ['str'], 'value': ['.']}
intent: loop over files in directory '.'
body(Left in tags for better readability):
<p> I have a folder with ten files in it which I want to loop through.
When I print out the name of the file my code works fine:
<code_block>
 import os
indir = '/home/des/test'
for root, dirs, filenames in os.walk(indir):
    for f in filenames:
        print(f)

<p> Which prints:
<code_block>
 1
2
3
4
5
6
7
8
9
10

<p> But if I try to open the file in the loop I get an IO error:
<code_block>
 import os
indir = '/home/des/test'
for root, dirs, filenames in os.walk(indir):
    for f in filenames:
        log = open(f, 'r')

Traceback (most recent call last):
File "/home/des/my_python_progs/loop_over_dir.py", line 6, in <module>
log = open(f, 'r')
IOError: [Errno 2] No such file or directory: '1'
<console_in>
<console_out>
<p> Do I need to pass the full path of the file even inside the loop
to <code> open() <p>  them?

-------------------------------------OUTPUT-------------------------------------

                Expected= "for fn in os.listdir('.'):\n    if os.path.isfile(fn):\n        pass"
           base:Baseline= os.path.join(open('.'))
           body:Baseline= os.walk(indir, '.')
            body:-Blocks= os.path.open('.')
              body:-Code= os.path.join(open('.'))
            body:-Inline= log = open(f, '.')
                body:-NL= log = open(f, '.')
             base:+Mined= print(os.listdir('.'))
     body+mined:Baseline= os.walk(os.path.join(path, '.'))
        body+mined:-Code= for line in open('.'):
    pass
          body+mined:-NL= f = open(f, 'r')
      body+mined:-Blocks= open('.').seek(0)
      body+mined:-Inline= f = os.path.join(['.'], '.')

================================================================================

QUESTION: idx=76     id=11801309
-------------------------------------INPUTS-------------------------------------

tags: file-io, absolute-path
score: 62
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['source']}
intent: loop over files in directory `source`
body(Left in tags for better readability):
<p> I have a folder with ten files in it which I want to loop through.
When I print out the name of the file my code works fine:
<code_block>
 import os
indir = '/home/des/test'
for root, dirs, filenames in os.walk(indir):
    for f in filenames:
        print(f)

<p> Which prints:
<code_block>
 1
2
3
4
5
6
7
8
9
10

<p> But if I try to open the file in the loop I get an IO error:
<code_block>
 import os
indir = '/home/des/test'
for root, dirs, filenames in os.walk(indir):
    for f in filenames:
        log = open(f, 'r')

Traceback (most recent call last):
File "/home/des/my_python_progs/loop_over_dir.py", line 6, in <module>
log = open(f, 'r')
IOError: [Errno 2] No such file or directory: '1'
<console_in>
<console_out>
<p> Do I need to pass the full path of the file even inside the loop
to <code> open() <p>  them?

-------------------------------------OUTPUT-------------------------------------

                Expected= 'for root, dirs, filenames in os.walk(source):\n    for f in filenames:\n        pass'
           base:Baseline= print(os.path.join(source))
           body:Baseline= os.walk(open(source, 'r')
            body:-Blocks= os.path.open(source)
              body:-Code= print(os.path.join(source))
            body:-Inline= log = open(f, 'r')
                body:-NL= log = open(f, 'r')
             base:+Mined= print(os.path.join(source))
     body+mined:Baseline= os.walk(os.path.abspath(source))
        body+mined:-Code= for line in os.listdir(source):
    pass
          body+mined:-NL= f = open(f, 'r')
      body+mined:-Blocks= os.system('open(source)')
      body+mined:-Inline= f = os.path.join(source, 'rb')

================================================================================

QUESTION: idx=77     id=4172131
-------------------------------------INPUTS-------------------------------------

tags: list, random, performance
score: 71
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: create a random list of integers
body(Left in tags for better readability):
<p> I'd like to create a random list of integers for testing purposes.
The distribution of the numbers is not important. The only thing that
is counting is <strong> time <p> . I know generating random numbers is
a time-consuming task, but there must be a better way.
<p> Here's my current solution:
<code_block>
 import random
import timeit

# Random lists from [0-999] interval
print [random.randint(0, 1000) for r in xrange(10)] # v1
print [random.choice([i for i in xrange(1000)]) for r in xrange(10)] #
v2

# Measurement:
t1 = timeit.Timer('[random.randint(0, 1000) for r in xrange(10000)]',
'import random') # v1
t2 = timeit.Timer('random.sample(range(1000), 10000)', 'import
random') # v2

print t1.timeit(1000)/1000
print t2.timeit(1000)/1000

<p> v2 is faster than v1, but it is not working on such a large scale.
It gives the following error:

<strong> ValueError: sample larger than population

<p> Is there a fast, efficient solution that works at that scale?
<h3> Some results from the answer
<p> Andrew's: 0.000290962934494
<p> gnibbler's: 0.0058455221653
<p> KennyTM's: 0.00219276118279
<p> NumPy came, saw, and conquered.

-------------------------------------OUTPUT-------------------------------------

                Expected= '[int(1000 * random.random()) for i in range(10000)]'
           base:Baseline= random.sample(list(range(10)), 16)
           body:Baseline= random.sample(range(1000), 10000)
            body:-Blocks= random.sample(list(range(10)), 1)
              body:-Code= random.sample(range(0, len(random.values())))
            body:-Inline= timeit.random.sample(range(1000), 10000)
                body:-NL= timeit.Timer('random.sample(range(1000), 10000)', 'import random')
             base:+Mined= random.sample(list(range(10)), 10)
     body+mined:Baseline= random.sample(range(1000), 10000)
        body+mined:-Code= random.sample(list(range(0, 10)), 10)
          body+mined:-NL= random.sample(range(1000), 10000)
      body+mined:-Blocks= random.sample(range(0, 10))
      body+mined:-Inline= print(random.randint(0, 1000) for r in range(1000))

================================================================================

QUESTION: idx=78     id=6677332
-------------------------------------INPUTS-------------------------------------

tags: time, strftime
score: 115
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: using %f with strftime() in python to get microseconds
body(Left in tags for better readability):
<p> I'm trying to use strftime() to microsecond precision, which seems
possible using %f (as stated <a> here <p> ). However when I try the
following code:
<code_block>
 import time
import strftime from time

print strftime("%H:%M:%S.%f")

<p> <console_out>I get the hour, the minutes and the seconds, but %f
prints as %f, with no sign of the microseconds. I'm running Python
2.6.5 on Ubuntu, so it should be fine and %f should be supported (it's
supported for 2.6 and above, as far as I know.)

-------------------------------------OUTPUT-------------------------------------

                Expected= "datetime.datetime.now().strftime('%H:%M:%S.%f')"
           base:Baseline= min(os.getmtime(0, %f))
           body:Baseline= time.mktime(hours=1, minutes=10)
            body:-Blocks= microseconds = microsecond( %f, strftime()
              body:-Code= print(strftime('%f' % s))
            body:-Inline= print(strftime('%H:%M:%S.%f')
                body:-NL= print(strftime('%H:%M:%S.%f')
             base:+Mined= time.mktime(microseconds)
     body+mined:Baseline= print(strftime('%H:%M:%S.%f'))
        body+mined:-Code= print(struct.unpack('%f'))
          body+mined:-NL= print(strftime('%H:%M:%S.%f'))
      body+mined:-Blocks= time.strftime('%f %d %H:%M:%S')
      body+mined:-Inline= print(strftime('%H:%M:%S.%f'))

================================================================================

QUESTION: idx=79     id=852055
-------------------------------------INPUTS-------------------------------------

tags: google-app-engine, gql
score: 5
slot_map: {'key': ['str_0', 'str_1'], 'quote': ["'", '`'], 'type': ['str', 'str'], 'value': ['SELECT * FROM Schedule WHERE station = $1', 'foo.key()']}
intent: google app engine execute gql query 'select * from schedule where station = $1' with parameter `foo.key()`
body(Left in tags for better readability):
<p> Say I have the following model:
<code_block>
 class Schedule(db.Model):
    tripCode = db.StringProperty(required=True)
    station = db.ReferenceProperty(Station, required=True)
    arrivalTime = db.TimeProperty(required=True)
    departureTime = db.TimeProperty(required=True)

<p> And let's say I have a Station object stored in the var <code> foo
<p> .
<p> How do I assemble a GQL query that returns all Schedule objects
with a reference to the Station object referenced by <code> foo <p> ?
<p> This is my best (albeit <strong> incorrect <p> ) attempt to form
such a query:
<code_block>
 myQuery = "SELECT * FROM Schedule where station = " + str(foo.key())

<em> Once again <code> foo <em>  is a <strong> Station <em>  object

-------------------------------------OUTPUT-------------------------------------

                Expected= "db.GqlQuery('SELECT * FROM Schedule WHERE station = $1', foo.key())"
           base:Baseline= google.engine.execute('SELECT * FROM schedule WHERE station = $1', 'foo.key()')
           body:Baseline= GQL.query('SELECT * FROM Schedule WHERE station =' + str(foo.key()))
            body:-Blocks= GQL.execute('SELECT * FROM schedule WHERE station = $1', 'foo.key()')
              body:-Code= GQL.execute('SELECT * FROM schedule WHERE station = $1', 'foo.key()')
            body:-Inline= google.engine.query('SELECT * FROM Schedule WHERE station = $1', str(foo.key())
    )
                body:-NL= google.query('SELECT * FROM Schedule WHERE station = $1')
             base:+Mined= urllib.request.urlretrieve('select * from schedule WHERE station = $1',
    'foo.key()')
     body+mined:Baseline= myQuery = 'SELECT * FROM Schedule where station =' + str(foo.key())
        body+mined:-Code= GQL.GQL('SELECT * FROM schedule WHERE station = $1')
          body+mined:-NL= myQuery = 'SELECT * FROM Schedule where station =' + str(foo.key())
      body+mined:-Blocks= GQL.GQL('select * from schedule where station = $1')
      body+mined:-Inline= GQL.query('SELECT * FROM Schedule where station ='+ str(foo.key())

================================================================================

QUESTION: idx=80     id=15325182
-------------------------------------INPUTS-------------------------------------

tags: regex, pandas
score: 188
slot_map: {'key': ['str_0'], 'quote': ["'"], 'type': ['str'], 'value': ['f']}
intent: filter rows in pandas starting with alphabet 'f' using regular expression.
body(Left in tags for better readability):
<p> I would like to cleanly filter a dataframe using regex on one of
the columns.
<p> For a contrived example:
<code_block>
 <console_in> foo = pd.DataFrame({'a' : [1,2,3,4], 'b' : ['hi', 'foo',
'fat', 'cat']})
<console_in> foo
<console_out>
   a    b
0  1   hi
1  2  foo
2  3  fat
3  4  cat

<p> I want to filter the rows to those that start with <code> f <p>
using a regex. First go:
<code_block>
 <console_in> foo.b.str.match('f.*')
<console_out>
0    []
1    ()
2    ()
3    []

<p> That's not too terribly useful. However this will get me my
boolean index:
<code_block>
 <console_in> foo.b.str.match('(f.*)').str.len() > 0
<console_out>
0    False
1     True
2     True
3    False
Name: b

<p> So I could then do my restriction by:
<code_block>
 <console_in> foo[foo.b.str.match('(f.*)').str.len() > 0]
<console_out>
   a    b
1  2  foo
2  3  fat

<p> That makes me artificially put a group into the regex though, and
seems like maybe not the clean way to go. Is there a better way to do
this?

-------------------------------------OUTPUT-------------------------------------

                Expected= "df.b.str.contains('^f')"
           base:Baseline= df = pandas.filter(re.search('f')
           body:Baseline= pd.DataFrame({'a': 'f.*', 'b': 'a'})
            body:-Blocks= df.groupby('f').filter(df.index('f')
              body:-Code= df.groupby('f').filter(lambda x: x.startswith('f')
            body:-Inline= pd.concat([df.startswith('f.*')])
                body:-NL= df.filter(lambda x: x.startswith('f.*'))
             base:+Mined= df.groupby(['f'])['A'].apply(lambda x: x.startswith('F'))
     body+mined:Baseline= df[df.str.startswith('f')]
        body+mined:-Code= df[df.columns.str.startswith('f')]
          body+mined:-NL= df[df.groupby('f').apply(lambda x: x.startswith('f'))]
      body+mined:-Blocks= df[df.index.str.startswith('f')]
      body+mined:-Inline= df[df.str.startswith('f')]

================================================================================

QUESTION: idx=81     id=583557
-------------------------------------INPUTS-------------------------------------

tags: coding-style
score: 4
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['tab']}
intent: print a 2 dimensional list `tab` as a table with delimiters
body(Left in tags for better readability):
<p> I want to print a table mixed with string and float values, as tab
delimited output printout. Sure I can get the job done:
<code_block>
 <console_in> tab = [['a', 1], ['b', 2]]
<console_in> for row in tab:
<console_out>     out = ""
<console_out>     for col in row:
<console_out>             out = out + str(col) + "\t"
<console_out>     print out.rstrip()
<console_out>
a   1
b   2

<p> But I have a feeling there is a better way to do it in Python, at
least to print each row with specified delimiter, if not the whole
table. Little googling (from <a> here <p> ) and it is already shorter:
<code_block>
 <console_in> for row in tab:
<console_out>     print "\t".join([str(col) for col in row])
<console_out>
a   1
b   2

<p> Is there still a better, or more Python-ish, way to do it?

-------------------------------------OUTPUT-------------------------------------

                Expected= "print('\\n'.join('\\t'.join(str(col) for col in row) for row in tab))"
           base:Baseline= print(' '.join(item[0] for item in tab))
           body:Baseline= [['a', 1], ['b', 2]]] for 'a', 'b' in tab]
            body:-Blocks= print(' '.join(table.split()) for row in tab)
              body:-Code= print(' '.join(table) for table in tab)
            body:-Inline= print('\t'.join([str(col) for col in row])
                body:-NL= print('\t'.join([str(col) for col in tab])
             base:+Mined= print('\n'.join(map(str, t))
     body+mined:Baseline= print('\t'.join([str(col) for col in row])
        body+mined:-Code= print('\n'.join(map(str, row)))
          body+mined:-NL= print('\t'.join([str(col) for col in row])
      body+mined:-Blocks= print('\n'.join(map(str, row)) for row in tab])
      body+mined:-Inline= print('\t'.join([str(col) for col in row])

================================================================================

QUESTION: idx=82     id=38535931
-------------------------------------INPUTS-------------------------------------

tags: pandas
score: 8
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['df']}
intent: pandas: delete rows in dataframe `df` based on multiple columns values
body(Left in tags for better readability):
<p> I have a dataframe with columns <code> A,B,C <p> . I have a list
of tuples like <code> [(x1,y1), (x2,y2), <console_out>] <p> . I would
like to delete all rows that meet the following condition:
<code> (B=x1 && C=y1) | (B=x2 && C=y2) | <console_out> <p>  How can I
do that in pandas? I wanted to use the <code> isin <p>  function, but
not sure if it is possible since my list has tuples. I could do
something like this:
<code_block>
 for x,y in tuples:
    df = df.drop(df[df.B==x && df.C==y].index)

<p> Maybe there is an easier way.

-------------------------------------OUTPUT-------------------------------------

                Expected= "df.set_index(list('BC')).drop(tuples, errors='ignore').reset_index()"
           base:Baseline= df.apply(lambda x: x[1], axis=1)
           body:Baseline= df = df.drop(['A', 'B', 'C'], axis=1)
            body:-Blocks= pd.merge(df, columns=['A,B,C'], axis=1)
              body:-Code= df.apply(lambda x: x.columns, axis=1)
            body:-Inline= df = df.drop(df.columns, axis=1)
                body:-NL= df = df.drop(df.B==x && df.C==y)
             base:+Mined= df.drop(df.columns, axis=1)
     body+mined:Baseline= df.drop(df[df.B==x && df.C==y].index)
        body+mined:-Code= df.drop(df.index, axis=1, inplace=True)
          body+mined:-NL= df = df.drop(df.B==x && df.C==y).index
      body+mined:-Blocks= pd.merge(df, on='A', on='B', how='inner')
      body+mined:-Inline= df = df.drop(df[df.B==x && df.C==y].index)

================================================================================

QUESTION: idx=83     id=13945749
-------------------------------------INPUTS-------------------------------------

tags: string
score: 115
slot_map: {'key': ['str_0', 'str_1'], 'quote': ['`', '`'], 'type': ['str', 'str'], 'value': ['self.goals', 'self.penalties']}
intent: format the variables `self.goals` and `self.penalties` using string formatting
body(Left in tags for better readability):
<p> I do this in Python 2:
<code_block>
 "(%d goals, $%d)" % (self.goals, self.penalties)

<p> What is the Python 3 version of this?
<p> I tried searching for examples online but I kept getting Python 2
versions.

-------------------------------------OUTPUT-------------------------------------

                Expected= '"""({:d} goals, ${:d})""".format(self.goals, self.penalties)'
           base:Baseline= """{}""".format(self.goals, self.penalties)
           body:Baseline= """%d goals, $%d)" % (self.goals, self.penalties)
            body:-Blocks= """self.goals""".format(self.penalties))
              body:-Code= """self.goals""".format(self.penalties))
            body:-Inline= """%d goals, $%d)" % (self.goals, self.penalties)
                body:-NL= """%d goals, $%d)" % (self.goals, self.penalties)
             base:+Mined= """{} {}""".format(self.goals, self.penalties)
     body+mined:Baseline= """{} goals, {} {}""".format(self.goals, self.penalties)
        body+mined:-Code= """{} {}""".format(self.goals, self.penalties)
          body+mined:-NL= """{}_{}""".format(self.goals, self.penalties)
      body+mined:-Blocks= """{} {}""".format(self.goals, self.penalties)
      body+mined:-Inline= """{} goals {}""".format(self.goals, self.penalties)

================================================================================

QUESTION: idx=84     id=13945749
-------------------------------------INPUTS-------------------------------------

tags: string
score: 115
slot_map: {'key': ['str_0', 'var_0', 'var_1', '(str_0)'], 'quote': ['"', '`', '`', '"'], 'type': ['str', 'var', 'var', 'str'], 'value': ['({} goals, ${})', 'goals', 'penalties', '({} goals, ${})']}
intent: format string "({} goals, ${})" with variables `goals` and `penalties`
body(Left in tags for better readability):
<p> I do this in Python 2:
<code_block>
 "(%d goals, $%d)" % (self.goals, self.penalties)

<p> What is the Python 3 version of this?
<p> I tried searching for examples online but I kept getting Python 2
versions.

-------------------------------------OUTPUT-------------------------------------

                Expected= '"""({} goals, ${})""".format(self.goals, self.penalties)'
           base:Baseline= print('({} goals, ${})"
           body:Baseline= ""{} goals, ${}""".format(goals, penalties)
            body:-Blocks= """({} goals, ${})"
              body:-Code= """({} goals, ${})"
            body:-Inline= print('({} goals, ${})" % (self.goals, self.penalties))
                body:-NL= """({} goals, ${})" % (goals, penalties)
             base:+Mined= """({} goals, ${})""".format('goals', 'penalties')
     body+mined:Baseline= """{} goals, ${}""".format(goals, flags)
        body+mined:-Code= format(({} goals, ${})
          body+mined:-NL= """({} goals, ${})" % (goals, flags)
      body+mined:-Blocks= format('({} goals, ${})')
      body+mined:-Inline= """({} goals, ${})""".format(goals, flags)

================================================================================

QUESTION: idx=85     id=13945749
-------------------------------------INPUTS-------------------------------------

tags: string
score: 115
slot_map: {'key': ['str_0', '(str_0)'], 'quote': ['"', '"'], 'type': ['str', 'str'], 'value': ['({0.goals} goals, ${0.penalties})', '({0.goals} goals, ${0.penalties})']}
intent: format string "({0.goals} goals, ${0.penalties})"
body(Left in tags for better readability):
<p> I do this in Python 2:
<code_block>
 "(%d goals, $%d)" % (self.goals, self.penalties)

<p> What is the Python 3 version of this?
<p> I tried searching for examples online but I kept getting Python 2
versions.

-------------------------------------OUTPUT-------------------------------------

                Expected= '"""({0.goals} goals, ${0.penalties})""".format(self)'
           base:Baseline= print('({0.goals} goals, ${0.penalties})"
           body:Baseline= """({0.goals} goals, ${0.penalties})"
            body:-Blocks= """({0.goals} goals, ${0.penalties})"
              body:-Code= """({0.goals} goals, ${0.penalties})"
            body:-Inline= print('({0.goals} goals, ${0.penalties}')
                body:-NL= """({0.goals} goals, ${0.penalties}""".format('%d goals, $%d'))
             base:+Mined= """({0.goals} goals, ${0.penalties})"
     body+mined:Baseline= print('({0.goals} goals, ${0.penalties})'.format(self))
        body+mined:-Code= format('({0.goals} goals, ${0.penalties})')
          body+mined:-NL= """({0.goals} goals, ${0.penalties}""".format('%d goals, %d penalties'))
      body+mined:-Blocks= format('({0.goals} goals, ${0.penalties}')
      body+mined:-Inline= """({0.goals} goals, ${0.penalties}""".format(self, goal)

================================================================================

QUESTION: idx=86     id=18524642
-------------------------------------INPUTS-------------------------------------

tags: list
score: 6
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['L']}
intent: convert list of lists `l` to list of integers
body(Left in tags for better readability):
<p> I need to convert a list of lists to a list of integers.
<p> from:
<code_block>
 L1 = [[1, 2, 3, 4], [3, 7, 1, 7], [0, 5, 6, 7], [9, 4, 5, 6]]

<p> to:
<code_block>
 L2 = [1234, 3717, 0567, 9456]

<p> How can I make python recognize an integer starting with 0? Like
the case <code> L2[2]
<p> The other question is, how can I check if items in a list are
ordered?
<code_block>
 A = [1, 2, 6, 9] ---->True

<p> Other than this:
<code_block>
 A == sorted(A)

<p> You guys are FAST. Thanks!

-------------------------------------OUTPUT-------------------------------------

                Expected= "[int(''.join(str(d) for d in x)) for x in L]"
           base:Baseline= [int(x) for x in l]
           body:Baseline= [i for i, j in zip(L1, L2)]
            body:-Blocks= [int(x) for x in L]
              body:-Code= [int(x) for x in l]
            body:-Inline= [int(x) for x in L]
                body:-NL= [i for i, j in zip(L1, L2)]
             base:+Mined= [int(x) for x in L]
     body+mined:Baseline= [int(x) for x in L1]
        body+mined:-Code= l = [int(x) for x in l]
          body+mined:-NL= [int(x) for x in L2]
      body+mined:-Blocks= [int(x) for x in L]
      body+mined:-Inline= [int(x) for x in L]

================================================================================

QUESTION: idx=87     id=18524642
-------------------------------------INPUTS-------------------------------------

tags: list
score: 6
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['L']}
intent: combine elements of each list in list `l` into digits of a single integer
body(Left in tags for better readability):
<p> I need to convert a list of lists to a list of integers.
<p> from:
<code_block>
 L1 = [[1, 2, 3, 4], [3, 7, 1, 7], [0, 5, 6, 7], [9, 4, 5, 6]]

<p> to:
<code_block>
 L2 = [1234, 3717, 0567, 9456]

<p> How can I make python recognize an integer starting with 0? Like
the case <code> L2[2]
<p> The other question is, how can I check if items in a list are
ordered?
<code_block>
 A = [1, 2, 6, 9] ---->True

<p> Other than this:
<code_block>
 A == sorted(A)

<p> You guys are FAST. Thanks!

-------------------------------------OUTPUT-------------------------------------

                Expected= "[''.join(str(d) for d in x) for x in L]"
           base:Baseline= [int(x) for x in L]
           body:Baseline= [i for i, j in zip(L1, L2)]
            body:-Blocks= [int(x) for x in L]
              body:-Code= [int(x) for x in L]
            body:-Inline= [int(x) for x in L]
                body:-NL= [int(x) for x in L]
             base:+Mined= [int(x) for x in L]
     body+mined:Baseline= [int(x) for x in L1]
        body+mined:-Code= [int(x) for x in L]
          body+mined:-NL= [int(x) for x in L1 if x.isdigit()]
      body+mined:-Blocks= [int(x) for x in L]
      body+mined:-Inline= [int(x) for x in L1]

================================================================================

QUESTION: idx=88     id=18524642
-------------------------------------INPUTS-------------------------------------

tags: list
score: 6
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['L']}
intent: convert a list of lists `l` to list of integers
body(Left in tags for better readability):
<p> I need to convert a list of lists to a list of integers.
<p> from:
<code_block>
 L1 = [[1, 2, 3, 4], [3, 7, 1, 7], [0, 5, 6, 7], [9, 4, 5, 6]]

<p> to:
<code_block>
 L2 = [1234, 3717, 0567, 9456]

<p> How can I make python recognize an integer starting with 0? Like
the case <code> L2[2]
<p> The other question is, how can I check if items in a list are
ordered?
<code_block>
 A = [1, 2, 6, 9] ---->True

<p> Other than this:
<code_block>
 A == sorted(A)

<p> You guys are FAST. Thanks!

-------------------------------------OUTPUT-------------------------------------

                Expected= "L = [int(''.join([str(y) for y in x])) for x in L]"
           base:Baseline= [int(x) for x in L]
           body:Baseline= [i for i, j in zip(L1, L2)]
            body:-Blocks= [int(x) for x in L]
              body:-Code= [int(x) for x in l]
            body:-Inline= [int(x) for x in L]
                body:-NL= [int(x) for x in zip(L1, L2)]
             base:+Mined= [int(x) for x in L]
     body+mined:Baseline= [int(x) for x in L1]
        body+mined:-Code= l = [int(x) for x in l]
          body+mined:-NL= [int(x) for x in L2]
      body+mined:-Blocks= [int(x) for x in L]
      body+mined:-Inline= [int(x) for x in L]

================================================================================

QUESTION: idx=89     id=7138686
-------------------------------------INPUTS-------------------------------------

tags: 
score: 29
slot_map: {'key': ['var_0', 'str_0', 'var_1'], 'quote': ['`', "'", '`'], 'type': ['var', 'str', 'var'], 'value': ['lines', '\n', 'myfile']}
intent: write the elements of list `lines` concatenated by special character '\n' to file `myfile`
body(Left in tags for better readability):
<p> I'm trying to write an array (list?) to a text file using Python
3. Currently I have:
<code_block>
 def save_to_file(*text):

    with open('/path/to/filename.txt', mode='wt', encoding='utf-8') as
myfile:
        for lines in text:
            print(lines, file = myfile)
    myfile.close

<p> This writes what looks like the array straight to the text file,
i.e.,
<code_block>
 ['element1', 'element2', 'element3']
username@machine:/path$

<p> What I'm looking to do is create the file with
<code_block>
 element1
element2
element3
username@machine:/path$

<p> I've tried different ways to loop through and append a "\n" but it
seems that the write is dumping the array in one operation. The
question is similar to <a> How to write list of strings to file,
adding newlines? <p>  but the syntax looked like it was for Python 2?
When I tried a modified version of it:
<code_block>
 def save_to_file(*text):

    myfile = open('/path/to/filename.txt', mode='wt',
encoding='utf-8')
    for lines in text:
        myfile.write(lines)
    myfile.close

<p> <console_out>the Python shell gives "TypeError: must be str, not
list" which I think is because of changes between Python2 and Python
3. What am I missing to get each element on a newline?
<p> EDIT: Thank you to @agf and @arafangion; combining what both of
you wrote, I came up with:
<code_block>
 def save_to_file(text):

    with open('/path/to/filename.txt', mode='wt', encoding='utf-8') as
myfile:
        myfile.write('\n'.join(text))
        myfile.write('\n')

<p> It looks like I had part of the issue with "*text" (I had read
that expands arguments but it didn't click until you wrote that
[element] was becoming [[element]] that I was getting a str-not-list
type error; I kept thinking I needed to tell the definition that it
was getting a list/array passed to it and that just stating "test"
would be a string.) It worked once I changed it to just text and used
myfile.write with join, and the additional \n puts in the final
newline at the end of the file.

-------------------------------------OUTPUT-------------------------------------

                Expected= "myfile.write('\\n'.join(lines))"
           base:Baseline= myfile.write('\n')
           body:Baseline= myfile.write('\n'.join(text))
            body:-Blocks= myfile.write('\n')
              body:-Code= myfile.write('\n')
            body:-Inline= myfile.write('\n'.join(lines))
                body:-NL= myfile.write('\n'.join(text))
             base:+Mined= myfile.write('\n'.join(lines))
     body+mined:Baseline= myfile.write('\n')
        body+mined:-Code= f.write('\n'.join(myfile))
          body+mined:-NL= myfile.write('\n'.join(lines))
      body+mined:-Blocks= myfile.write('\n'.join(lines))
      body+mined:-Inline= myfile.write('\n'.join(lines))

================================================================================

QUESTION: idx=90     id=1866343
-------------------------------------INPUTS-------------------------------------

tags: string
score: 6
slot_map: {'key': ['str_0', 'str_1'], 'quote': ["'", "'"], 'type': ['str', 'str'], 'value': ['X', 'N']}
intent: removing an element from a list based on a predicate 'x' or 'n'
body(Left in tags for better readability):
<p> I want to remove an element from list, such that the element
contains <code> 'X' <p>  or <code> 'N' <p> . I have to apply for a
large genome. Here is an example:
<p> input:
<code_block>
 codon=['AAT','XAC','ANT','TTA']

<p> expected output:
<code_block>
 codon=['AAT','TTA']


-------------------------------------OUTPUT-------------------------------------

                Expected= "[x for x in ['AAT', 'XAC', 'ANT', 'TTA'] if 'X' not in x and 'N' not in x]"
           base:Baseline= [x[0] for x in n]
           body:Baseline= [i for i, j in enumerate(x, n)]
            body:-Blocks= [x for x in enumerate(x, n)]
              body:-Code= [x[i] for i in range(10)]
            body:-Inline= [x[0] for x in 'n']
                body:-NL= [x[i] for i in range(n)]
             base:+Mined= [x for x in a if x != 'n']
     body+mined:Baseline= [x for x in lst if x['X'] == 'N']
        body+mined:-Code= [x for x in l if 'x' in x]
          body+mined:-NL= [x for x in lst if 'X' in x]
      body+mined:-Blocks= [x for x in DNA if 'x' in x]
      body+mined:-Inline= [x for x in ['AAT', 'XAC', 'ANT', 'TTA'] if x != 'N']

================================================================================

QUESTION: idx=91     id=17238587
-------------------------------------INPUTS-------------------------------------

tags: regex
score: 6
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['text']}
intent: remove duplicate words from a string `text` using regex
body(Left in tags for better readability):
<p> I am very new a Python
<p> I want to change sentence if there are repeated words.
<strong> Correct

<li> Ex. "this just so so so nice" --> "this is just so nice"
<li> Ex. "this is just is is" --> "this is just is"

<p> Right now am I using this reg. but it do all so change on letters.
Ex. "My friend and i is happy" --> "My friend and is happy" (it remove
the "i" and space) ERROR
<code_block>
 text = re.sub(r'(\w+)\1', r'\1', text) #remove duplicated words in
row

<p> How can I do the same change but instead of letters it have to
check on words?

-------------------------------------OUTPUT-------------------------------------

                Expected= "text = re.sub('\\\\b(\\\\w+)( \\\\1\\\\b)+', '\\\\1', text)"
           base:Baseline= re.sub('\\w+', text)
           body:Baseline= re.sub('\\w+\\1', text)
            body:-Blocks= re.sub('[^a-zA-Z]', text)
              body:-Code= re.sub('\\[\\]', text)
            body:-Inline= re.sub('\\w+\\1', text)
                body:-NL= re.sub('\\w+\\1', text)
             base:+Mined= re.sub('(\\w+)', '\\1', text)
     body+mined:Baseline= re.sub('(\\w+)', '\\1', text)
        body+mined:-Code= re.sub('[^a-zA-Z]', '', text)
          body+mined:-NL= re.sub('\\w+', '\\1', text)
      body+mined:-Blocks= re.sub('[^a-zA-Z]', '', text)
      body+mined:-Inline= re.sub('(\\w+)', '\\1', text)

================================================================================

QUESTION: idx=92     id=26053849
-------------------------------------INPUTS-------------------------------------

tags: pandas, dataframe
score: 67
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: count non zero values in each column in pandas data frame
body(Left in tags for better readability):
<p> I have a python-pandas-dataframe in which first column is user_id
and rest of the columns are tags(tag_0 to tag_122).
I have the data in the following format:
<code_block>
 UserId  Tag_0   Tag_1
7867688 0   5
7867688 0   3
7867688 3   0
7867688 3.5 3.5
7867688 4   4
7867688 3.5 0

<p> My aim is to achieve <code> Sum(Tag)/Count(NonZero(Tags)) <p>  for
each user_id
<code> df.groupby('user_id').sum() <p> , gives me <code> sum(tag) <p>
, however I am clueless about counting non zero values
<p> Is it possible to achieve <code> Sum(Tag)/Count(NonZero(Tags)) <p>
in one command?
<p> In MySQL I could achieve this as follows:-
<code_block>
 select user_id, sum(tag)/count(nullif(tag,0)) from table group by 1

<p> Any help shall be appreciated.

-------------------------------------OUTPUT-------------------------------------

                Expected= 'df.astype(bool).sum(axis=1)'
           base:Baseline= df['nonzero'] = df['zero'].sum()
           body:Baseline= df.groupby('user_id').sum()
            body:-Blocks= df.groupby('user_id').sum()
              body:-Code= df['User_ID'] = df['Tag_0']
            body:-Inline= df.groupby('UserId').apply(lambda x: x.count(tag, 0))
                body:-NL= df.groupby('user_id').sum()
             base:+Mined= df.count_nonzero(axis=1)
     body+mined:Baseline= df.groupby('user_id').sum()
        body+mined:-Code= df.groupby('user_id').agg(lambda x: x.tag_0).count()
          body+mined:-NL= df.groupby('user_id').sum()
      body+mined:-Blocks= df.groupby('user_id').sum()
      body+mined:-Inline= df.groupby('UserId').sum()

================================================================================

QUESTION: idx=93     id=15534223
-------------------------------------INPUTS-------------------------------------

tags: regex, match
score: 5
slot_map: {'key': ['str_0', 'str_1'], 'quote': ["'", "'"], 'type': ['str', 'str'], 'value': ['(?<!Distillr)\\\\AcroTray\\.exe', 'C:\\SomeDir\\AcroTray.exe']}
intent: search for string that matches regular expression pattern '(?<!distillr)\\\\acrotray\\.exe' in string 'c:\\somedir\\acrotray.exe'
body(Left in tags for better readability):
<p> I want to search for a file called "AcroTray.exe" on my disk. The
program should print a warning <strong> if the file is located in a
directory other than "Distillr" <p> .
I used the following Syntax to perform the negative match
<code_block>
 (?!Distillr)

<p> The problem is that although I use the "!" it always produces a
MATCH. I tried to figure out the problem using IPython but failed.
This is what I tried:
<code_block>
 import re

filePath = "C:\Distillr\AcroTray.exe"

if re.search(r'(?!Distillr)\\AcroTray\.exe', filePath):
    print "MATCH"

<p> It prints a MATCH.
What is wrong with my regex?
<p> I would like to get a match on:
<code_block>
 C:\SomeDir\AcroTray.exe

<p> But not on:
<code_block>
 C:\Distillr\AcroTray.exe


-------------------------------------OUTPUT-------------------------------------

                Expected= "re.search('(?<!Distillr)\\\\\\\\AcroTray\\\\.exe', 'C:\\\\SomeDir\\\\AcroTray.exe')"
           base:Baseline= re.findall('(?<!distillr)\\\\acrotray\\.exe', 'C:\\Somedir\\acroTRAY.exe')
           body:Baseline= re.search('(?<!distillr)\\\\acrotray\\.exe', 'C:\\Somedir\\AcroTray.exe')
            body:-Blocks= re.findall('(?<!distillr)\\\\acrotray\\.exe', 'C:\\Somedir\\acroTray.exe')
              body:-Code= re.findall('(?<!distillr)\\\\acrotray\\.exe', 'C:\\somedir\\acroTray.exe')
            body:-Inline= re.search('(?<!distillr)\\\\acrotray\\.exe', 'C:\\Somedir\\acroTray.exe')
                body:-NL= re.search('(?<!distillr)\\AcroTray\\.exe', 'C:\\somedir\\acrotray.exe')
             base:+Mined= re.findall('(?<!distillr)\\\\acrotray\\.exe', 'c:\\somedir\\acroTRAY.exe')
     body+mined:Baseline= re.search('(?<!distillr)\\\\acrotray\\.exe', c)
        body+mined:-Code= match = re.compile('(?<!distillr)\\\\acrotray\\.exe')
          body+mined:-NL= re.search('(?<!distillr)\\\\acrotray\\.exe', s)
      body+mined:-Blocks= match = re.compile('(?<!distillr)\\\\acrotray\\.exe')
      body+mined:-Inline= re.search('(?<!distillr)\\\\acrotray\\.exe', 'c:\\Somedir\\AcroTray.exe')

================================================================================

QUESTION: idx=94     id=5453026
-------------------------------------INPUTS-------------------------------------

tags: string, list
score: 32
slot_map: {'key': ['str_0'], 'quote': ["'"], 'type': ['str'], 'value': ['QH QD JC KD JS']}
intent: split string 'qh qd jc kd js' into a list on white spaces
body(Left in tags for better readability):
<p> I'm trying to split a string:
<code_block>
 'QH QD JC KD JS'

<p> into a list like:
<code_block>
 ['QH', 'QD', 'JC', 'KD', 'JS']

<p> How would I go about doing this?

-------------------------------------OUTPUT-------------------------------------

                Expected= '"""QH QD JC KD JS""".split()'
           base:Baseline= list('qh qd jc kd js')
           body:Baseline= list('QH QD JC KD JS')
            body:-Blocks= list('qh qd jc kd js')
              body:-Code= list('qh qd jc kd js')
            body:-Inline= ['QH QD JC kd js'].split()
                body:-NL= list('QH QD JC KD JS')
             base:+Mined= """QH QD JC kD js""".replace(' ', '')
     body+mined:Baseline= ['QH', 'Qd', 'JC', 'KD', 'JS']
        body+mined:-Code= ['qh qd jc kd js', 'QH QD jC kD js']
          body+mined:-NL= ['QH', 'Qd', 'JC', 'KD', 'JS']
      body+mined:-Blocks= ['qh qd jc kd js'.split()]
      body+mined:-Inline= ['QH', 'Qd', 'JC', 'KD', 'JS']

================================================================================

QUESTION: idx=95     id=18168684
-------------------------------------INPUTS-------------------------------------

tags: xml, regex
score: 16
slot_map: {'key': ['str_0', 'var_0'], 'quote': ["'", '`'], 'type': ['str', 'var'], 'value': ['>.*<', 'line']}
intent: search for occurrences of regex pattern '>.*<' in xml string `line`
body(Left in tags for better readability):
<p> I'm trying to use regex to parse an <code> XML <p>  file (in my
case this seems the simplest way).
<p> For example a line might be:
<code_block>
 line=' <City_State>PLAINSBORO, NJ 08536-1906 </City_State>'

<p> To access the text for the tag City_State, I'm using:
<code_block>
 attr = re.match('>.* <', line)

<p> but nothing is being returned.
<p> Can someone point out what I'm doing wrong?

-------------------------------------OUTPUT-------------------------------------

                Expected= "print(re.search('>.*<', line).group(0))"
           base:Baseline= print(re.search('>.*<', line))
           body:Baseline= re.match('>.*<', line)
            body:-Blocks= print(re.search('>.*<')
              body:-Code= re.search('>.*<', line)
            body:-Inline= re.search('>.*<', line)
                body:-NL= re.match('>.*<', line)
             base:+Mined= print(re.findall('>.*<', line))
     body+mined:Baseline= re.findall('>.*<', line)
        body+mined:-Code= print(re.search('>.*<', line))
          body+mined:-NL= re.findall('>.*<', line)
      body+mined:-Blocks= print(re.search('>.*<', line))
      body+mined:-Inline= re.search('>.*<', line)

================================================================================

QUESTION: idx=96     id=4914277
-------------------------------------INPUTS-------------------------------------

tags: 
score: 73
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['filename']}
intent: erase all the contents of a file `filename`
body(Left in tags for better readability):
<p> In the Unix shell I can do this to empty a file:
<code_block>
 cd /the/file/directory/
:> thefile.ext

<p> How would I go about doing this in Python?
<p> Is <code> os.system <p>  the way here, I wouldn't know how since I
would have to send 2 actions after each other i.e. the <code> cd <p>
and then the <code> :> <p> .

-------------------------------------OUTPUT-------------------------------------

                Expected= "open(filename, 'w').close()"
           base:Baseline= open('filename', 'rb', filename)
           body:Baseline= os.system.exit(filename)
            body:-Blocks= os.system.exit(filename)
              body:-Code= os.system('\n'.join(open(filename))
            body:-Inline= os.system('/the/file/directory/', filename)
                body:-NL= os.system.from_file('filename')
             base:+Mined= os.chdir('filename')[0]
     body+mined:Baseline= os.system('/the/file/directory/')
        body+mined:-Code= f = open('filename', 'r')
          body+mined:-NL= os.environ['filename'].close()
      body+mined:-Blocks= os.system('open(filename)')
      body+mined:-Inline= os.system('thefile.ext')

================================================================================

QUESTION: idx=97     id=19068269
-------------------------------------INPUTS-------------------------------------

tags: datetime
score: 99
slot_map: {'key': ['str_0'], 'quote': ["'"], 'type': ['str'], 'value': ['%Y-%m-%d %H:%M:%S.%f']}
intent: convert a string into datetime using the format '%y-%m-%d %h:%m:%s.%f'
body(Left in tags for better readability):
<p> How do I convert a a string of datetime into datetime format in
python so that it can be compared with another date?
<code_block>
 string_date = "2013-09-28 20:30:55.78200"
abc = datetime.datetime.now()

if abc  > string_date :
    print True


-------------------------------------OUTPUT-------------------------------------

                Expected= "datetime.datetime.strptime(string_date, '%Y-%m-%d %H:%M:%S.%f')"
           base:Baseline= datetime.strptime('%Y-%m-%d %H:%M:%S.%f')
           body:Baseline= date = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.%f')
            body:-Blocks= datetime.strptime('%Y-%m-%d %H:%M:%S.%f')
              body:-Code= datetime.strptime('%Y-%m-%d %H:%M:%S.%f')
            body:-Inline= datetime.strptime('2013-09-28 20:30:55.78200', '%Y-%m-%d %H:%M:%S.%f')
                body:-NL= abc.datetime.now().strftime('%Y-%m-%d %H:%M:%S.%f')
             base:+Mined= datetime.strptime('%Y-%m-%d %H:%M:%S.%f')
     body+mined:Baseline= dt = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.%f')
        body+mined:-Code= date.strftime('%Y-%m-%d %H:%M:%S.%f')
          body+mined:-NL= date = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.%f')
      body+mined:-Blocks= d.strftime('%Y-%m-%d %H:%M:%S.%f')
      body+mined:-Inline= date = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.%f')

================================================================================

QUESTION: idx=98     id=20683167
-------------------------------------INPUTS-------------------------------------

tags: list
score: 11
slot_map: {'key': ['str_0', 'var_0'], 'quote': ["'", '`'], 'type': ['str', 'var'], 'value': ['332', 'thelist']}
intent: find the index of a list with the first element equal to '332' within the list of lists `thelist`
body(Left in tags for better readability):
<p> The list is similar to this:
<code_block>
 [["12", "stuA", "stuB"], ["51", "stuC", "stuD"], <console_out>,
["3234", "moreStuff", "andMore"]]

<p> Now I need to locate an item (get index) only by its first value
(e.g. <code> "332" <p> ). Is there any better way to do this, apart
from iterating from the first one to compare with each value?
<p> Code:
<code_block>
 index = 0
for item in thelist:
    if item[0] == "332":
         print index

    index = index + 1


-------------------------------------OUTPUT-------------------------------------

                Expected= "[index for index, item in enumerate(thelist) if item[0] == '332']"
           base:Baseline= [x[0] for x in thelist if x[1] == 332]
           body:Baseline= [i for i, j in thelist if j == '332']
            body:-Blocks= [x[0] for x in thelist if x[1] == '332']
              body:-Code= [i[0] for i in thelist if i == '332']
            body:-Inline= [x for x in thelist if x == '332']
                body:-NL= [x for x in thelist if x[0] == '332']
             base:+Mined= [i for i, j in enumerate(thelist) if j == '332']
     body+mined:Baseline= [x for x in thelist if x[0] == '332']
        body+mined:-Code= [i for i, v in enumerate(thelist) if v[0] == 332]
          body+mined:-NL= [x for x in thelist if x[0] == '332']
      body+mined:-Blocks= [x for x in thelist if x[0] == '332']
      body+mined:-Inline= [x for x in thelist if x[0] == '332']

================================================================================

QUESTION: idx=99     id=30693804
-------------------------------------INPUTS-------------------------------------

tags: 
score: 4
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['text']}
intent: lower a string `text` and remove non-alphanumeric characters aside from space
body(Left in tags for better readability):
<p> I'm trying to remove all non-alphanumeric characters except the
space from a string, but can't seem to figure out how I exclude space.
I'm currently doing it this way:
<code_block>
 re.sub('[\W_]+', '', text).lower().strip()

<p> But running my function yields the following results:
<code_block>
 print removePunctuation('Hi, you!')
print removePunctuation(' No under_score!')
hiyou
nounderscore

<p> Where I want it to be:
<code_block>
 hi you
no underscore

<p> So how do I exclude space from being replaced?
<p> My current optimum is this:
<code_block>
 re.sub('[^\s\w]+', '', text).lower().strip().replace('_','')


-------------------------------------OUTPUT-------------------------------------

                Expected= "re.sub('[^\\\\sa-zA-Z0-9]', '', text).lower().strip()"
           base:Baseline= re.sub('[^a-zA-Z]', '', text)
           body:Baseline= re.sub('[^\\s\\w]+', '', text).lower().replace('_', '')
            body:-Blocks= re.sub('[^a-zA-Z]', text)
              body:-Code= re.sub('\\d+', text)
            body:-Inline= re.sub('[^\\s\\w]+', '', text).lower().strip().replace('_', '')
                body:-NL= re.sub('[^\\s\\w]+', '', text).lower().strip().replace('_', '')
             base:+Mined= re.sub('[^a-zA-Z]', '', text)
     body+mined:Baseline= re.sub('[^\\s\\w]+', '', text).lower().strip().replace('_', '')
        body+mined:-Code= re.sub('[^a-zA-Z0-9-]+', '', text)
          body+mined:-NL= re.sub('[^\\s\\w]+', '', text).lower().strip().replace('_', '')
      body+mined:-Blocks= re.sub('\\w', '', text)
      body+mined:-Inline= re.sub('[^\\s\\w]+', '', text).lower().strip().replace('_', '')

================================================================================

QUESTION: idx=100    id=30693804
-------------------------------------INPUTS-------------------------------------

tags: 
score: 4
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['text']}
intent: remove all non-alphanumeric characters except space from a string `text` and lower it
body(Left in tags for better readability):
<p> I'm trying to remove all non-alphanumeric characters except the
space from a string, but can't seem to figure out how I exclude space.
I'm currently doing it this way:
<code_block>
 re.sub('[\W_]+', '', text).lower().strip()

<p> But running my function yields the following results:
<code_block>
 print removePunctuation('Hi, you!')
print removePunctuation(' No under_score!')
hiyou
nounderscore

<p> Where I want it to be:
<code_block>
 hi you
no underscore

<p> So how do I exclude space from being replaced?
<p> My current optimum is this:
<code_block>
 re.sub('[^\s\w]+', '', text).lower().strip().replace('_','')


-------------------------------------OUTPUT-------------------------------------

                Expected= "re.sub('(?!\\\\s)[\\\\W_]', '', text).lower().strip()"
           base:Baseline= re.sub('[^a-zA-Z]', '', text)
           body:Baseline= re.sub('[^\\w_]+', '', text).lower().strip()
            body:-Blocks= re.sub('[^a-zA-Z]', '', text)
              body:-Code= re.sub('\\s+', text)
            body:-Inline= re.sub('[^\\s\\w]+', '', text).lower().strip().replace('_', '')
                body:-NL= re.sub('[^\\s\\w]+', '', text).lower().strip().replace('_', '')
             base:+Mined= re.sub('[^a-zA-Z]', '', text)
     body+mined:Baseline= re.sub('[^\\s\\w]+', '', text).lower().replace('_', '')
        body+mined:-Code= re.sub('[^a-zA-Z0-9-]+', '', text)
          body+mined:-NL= re.sub('[^\\s\\w]+', '', text).lower().strip().replace('_', '')
      body+mined:-Blocks= re.sub('[^a-zA-Z]', '', text)
      body+mined:-Inline= re.sub('[^\\s\\w]+', '', text).lower().strip().replace('_', '')

================================================================================

QUESTION: idx=101    id=17138464
-------------------------------------INPUTS-------------------------------------

tags: matplotlib, label, output, subscript
score: 4
slot_map: {'key': ['str_0', 'str_1', 'str_2', 'str_3'], 'quote': ["'", "'", "'", "'"], 'type': ['str', 'str', 'str', 'str'], 'value': ['H20', '2', 'x', 'y']}
intent: subscript text 'h20' with '2' as subscripted in matplotlib labels for arrays 'x' and 'y'.
body(Left in tags for better readability):
<p> this is my first question and I am a noob at python. So probably
more to follow...
<p> I would like to create a figure with matplotlib. In the labels, I
would like to include a chemical formula, which involves subscripts (I
think the same would work for superscripts...).
<p> Anyway, I have no idea, how the label would have to look like.
<code_block>
 import numpy as nu
import pylab as plt

x = nu.array([1,2,3,4])
y = nu.array([1,2,3,4])

plt.plot(x,y, label='H2O')
plt.legend(loc=1)
plt.show()

<p> Ok, this gives me a plot with the label "H2O". How can I subscript
the "2" in the label, as is common for chemical formulae?
<p> I searched the web, but I didn't find anything useful yet.
<p> I figured that I could use
<code_block>
 from matplotlib import rc
rc['text', usetex=True]

<p> but I don't want to use it (I know how to use LaTeX, but I don't
want here).
<p> Another option is:
<code_block>
 label='H$_2$O'

<p> but this changes the font (math).
<p> There MUST be a way, how does subscripting in matplotlib-legends
work?
<p> Thanks a lot!

-------------------------------------OUTPUT-------------------------------------

                Expected= "plt.plot(x, y, label='H₂O')"
           base:Baseline= plt.subscript('h20', '2')
           body:Baseline= plt.legend(loc=1, font='H$_2$O')
            body:-Blocks= legend.legend('H2O', 'X', 'Y')
              body:-Code= legend.legend('H20', '2')
            body:-Inline= plt.subscript('H$_2$O')
                body:-NL= plt.subscript('H20', '2')
             base:+Mined= plt.subplots_adjust(label='H20', label='Y')
     body+mined:Baseline= plt.plot(x, y, label='H2O')
        body+mined:-Code= ax.set_title('H20')
          body+mined:-NL= rc['text', usetex=True, label='H$_2$O')
      body+mined:-Blocks= ax.set_xticklabels(['x', 'y'])
      body+mined:-Inline= rc['text', usetex=True)

================================================================================

QUESTION: idx=102    id=17138464
-------------------------------------INPUTS-------------------------------------

tags: matplotlib, label, output, subscript
score: 4
slot_map: {'key': ['str_0', 'str_1', 'str_2', 'str_3'], 'quote': ["'", "'", "'", "'"], 'type': ['str', 'str', 'str', 'str'], 'value': ['H20', '2', 'x', 'y']}
intent: subscript text 'h20' with '2' as subscripted in matplotlib labels for arrays 'x' and 'y'.
body(Left in tags for better readability):
<p> this is my first question and I am a noob at python. So probably
more to follow...
<p> I would like to create a figure with matplotlib. In the labels, I
would like to include a chemical formula, which involves subscripts (I
think the same would work for superscripts...).
<p> Anyway, I have no idea, how the label would have to look like.
<code_block>
 import numpy as nu
import pylab as plt

x = nu.array([1,2,3,4])
y = nu.array([1,2,3,4])

plt.plot(x,y, label='H2O')
plt.legend(loc=1)
plt.show()

<p> Ok, this gives me a plot with the label "H2O". How can I subscript
the "2" in the label, as is common for chemical formulae?
<p> I searched the web, but I didn't find anything useful yet.
<p> I figured that I could use
<code_block>
 from matplotlib import rc
rc['text', usetex=True]

<p> but I don't want to use it (I know how to use LaTeX, but I don't
want here).
<p> Another option is:
<code_block>
 label='H$_2$O'

<p> but this changes the font (math).
<p> There MUST be a way, how does subscripting in matplotlib-legends
work?
<p> Thanks a lot!

-------------------------------------OUTPUT-------------------------------------

                Expected= "plt.plot(x, y, label='$H_2O$')"
           base:Baseline= plt.subscript('h20', '2')
           body:Baseline= plt.legend(loc=1, font='H$_2$O')
            body:-Blocks= legend.legend('H2O', 'X', 'Y')
              body:-Code= legend.legend('H20', '2')
            body:-Inline= plt.subscript('H$_2$O')
                body:-NL= plt.subscript('H20', '2')
             base:+Mined= plt.subplots_adjust(label='H20', label='Y')
     body+mined:Baseline= plt.plot(x, y, label='H2O')
        body+mined:-Code= ax.set_title('H20')
          body+mined:-NL= rc['text', usetex=True, label='H$_2$O')
      body+mined:-Blocks= ax.set_xticklabels(['x', 'y'])
      body+mined:-Inline= rc['text', usetex=True)

================================================================================

QUESTION: idx=103    id=9138112
-------------------------------------INPUTS-------------------------------------

tags: list
score: 186
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['mylist']}
intent: loop over a list `mylist` if sublists length equals 3
body(Left in tags for better readability):
<p> I have a list with sublists in it. I want to print all the
sublists with length equal to 3.
<p> I am doing the following in python:
<code_block>
 for x in values[:]:
    if len(x) == 3:
        print(x)

<code> values <p>  is the original list. Does the above code print
every sublist with length equal to 3 for each value of <code> x <p> ?
I want to display the sublists where <code> length == 3 <p>  only
once.
<p> The problem is solved. The problem is with the Eclipse editor. I
don't understand the reason, but it is displaying only half of my list
when I run my loop.
<p> Are there any settings I have to change in Eclipse?

-------------------------------------OUTPUT-------------------------------------

                Expected= '[x for x in mylist if len(x) == 3]'
           base:Baseline= myList.loop(lambda x: len(x[1]))
           body:Baseline= print(len(x) == 3)
            body:-Blocks= print(set(mylist, sublist) if sublist length == 3)
              body:-Code= print(list(mylist.items() == 3))
            body:-Inline= print(list(mylist.items() if len(x) == 3))
                body:-NL= for i in mylist:
    pass
             base:+Mined= myList[len(myList)) == 3
     body+mined:Baseline= [sublist for sublist in mylist if len(x) == 3]
        body+mined:-Code= print(list(range(len(mylist), 3))
          body+mined:-NL= [len(x) for x in mylist if len(y) == 3]
      body+mined:-Blocks= [list(x) for x in mylist if len(x))]
      body+mined:-Inline= print(list(itertools.chain.from_iterable(mylist)))

================================================================================

QUESTION: idx=104    id=1807026
-------------------------------------INPUTS-------------------------------------

tags: arrays, list, initialization
score: 18
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['lst']}
intent: initialize a list `lst` of 100 objects object()
body(Left in tags for better readability):
<p> I'm a  looking to initialize an array/list of objects that are not
empty -- the class constructor generates data. In C++ and Java I would
do something like this:
<code_block>
 Object lst = new Object[100];

<p> I've dug around, but is there a Pythonic way to get this done?
<p> This doesn't work like I thought it would (I get 100 references to
the same object):
<code_block>
 lst = [Object()]*100

<p> But this seems to work in the way I want:
<code_block>
 lst = [Object() for i in range(100)]

<p> List comprehension seems (intellectually) like "a lot" of work for
something that's so simple in Java.

-------------------------------------OUTPUT-------------------------------------

                Expected= 'lst = [Object() for _ in range(100)]'
           base:Baseline= lst = [i for i in range(100)]
           body:Baseline= lst = [Object() for i in range(100)]
            body:-Blocks= lst = [i for i in range(100)]
              body:-Code= lst = [i for i in range(100)]
            body:-Inline= lst = [Object() for i in range(100)]
                body:-NL= lst = [Object() for i in range(100)]
             base:+Mined= lst = [x for x in lst]
     body+mined:Baseline= lst = [Object() for i in range(100)]
        body+mined:-Code= lst = [i for i in range(100)]
          body+mined:-NL= lst = [Object() for i in range(100)]
      body+mined:-Blocks= lst = [i for i in range(100)]
      body+mined:-Inline= lst = [Object() for i in range(100)]

================================================================================

QUESTION: idx=105    id=1807026
-------------------------------------INPUTS-------------------------------------

tags: arrays, list, initialization
score: 18
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['lst', 'Object']}
intent: create list `lst` containing 100 instances of object `object`
body(Left in tags for better readability):
<p> I'm a  looking to initialize an array/list of objects that are not
empty -- the class constructor generates data. In C++ and Java I would
do something like this:
<code_block>
 Object lst = new Object[100];

<p> I've dug around, but is there a Pythonic way to get this done?
<p> This doesn't work like I thought it would (I get 100 references to
the same object):
<code_block>
 lst = [Object()]*100

<p> But this seems to work in the way I want:
<code_block>
 lst = [Object() for i in range(100)]

<p> List comprehension seems (intellectually) like "a lot" of work for
something that's so simple in Java.

-------------------------------------OUTPUT-------------------------------------

                Expected= 'lst = [Object() for i in range(100)]'
           base:Baseline= lst = [x for x in object]
           body:Baseline= lst = [Object() for i in range(100)]
            body:-Blocks= lst = [i for i in range(100)]
              body:-Code= lst = [i for i in range(100)]
            body:-Inline= lst = [Object() for i in range(100)]
                body:-NL= lst = [x for x in range(100)]
             base:+Mined= lst = [x for x in object]
     body+mined:Baseline= lst = [Object() for i in range(100)]
        body+mined:-Code= lst = [i for i in range(100)]
          body+mined:-NL= lst = [x for x in range(100)]
      body+mined:-Blocks= lst = [i for i in range(100)]
      body+mined:-Inline= lst = [Object() for i in range(100)]

================================================================================

QUESTION: idx=106    id=19664253
-------------------------------------INPUTS-------------------------------------

tags: html, css, xpath, selenium
score: 25
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['href', 'someclass']}
intent: get the content of child tag with`href` attribute whose parent has css `someclass`
body(Left in tags for better readability):
<p> I am trying to retrieve the data from the webpage has the html in
below
<code_block>
        <div class="someclass">
       <p class="name"> <a href="#/word/1/">helloworld </a> </p>
       </div>

<p> My goal is to parse "#/word/1/"
What I did is
<code_block>
         target = self.driver.find_element_by_class_name('someclass')
        print target
        print target.text
        print target.get_attribute("css=a@href")
        print target.tag_name

<p> but the output are
<code_block>
  <selenium.webdriver.remote.webelement.WebElement object at
0x10bf16210>
 helloworld
 None
 div

<p> I tried so many ways , it seems there is no way i can get the
content of 'a href' within the targeted class.
<p> I really dont want to do is get the source code of the page, and
then do a string searching, that seems dumb....
<p> anyway to get that?

-------------------------------------OUTPUT-------------------------------------

                Expected= "self.driver.find_element_by_css_selector('.someclass a').get_attribute('href')"
           base:Baseline= Child.find_element_by_css_name('someclass')
           body:Baseline= self.driver.find_element_by_class_name('someclass')
            body:-Blocks= Child.find_element_by_id('someClass')
              body:-Code= Child.find_element_by_css_selector('someclass')
            body:-Inline= self.driver.find_element_by_class_name('someclass')
                body:-NL= self.driver.find_element_by_class_name('someclass')
             base:+Mined= soup.find_element_by_css_selector('someclass')
     body+mined:Baseline= print(target.get_attribute('css=a@href')
        body+mined:-Code= print(element['a href']).get('a href'))
          body+mined:-NL= target.get_attribute('css=a@href')
      body+mined:-Blocks= child.tag.get_href()
      body+mined:-Inline= get_attribute('css=a@href')

================================================================================

QUESTION: idx=107    id=13793321
-------------------------------------INPUTS-------------------------------------

tags: pandas
score: 9
slot_map: {'key': ['var_0', 'var_1', 'str_0'], 'quote': ['`', '`', "'"], 'type': ['var', 'var', 'str'], 'value': ['df1', 'df2', 'Date_Time']}
intent: joining data from dataframe `df1` with data from dataframe `df2` based on matching values of column 'date_time' in both dataframes
body(Left in tags for better readability):
<p> I have two DataFrames:
<code_block>
 df1 = ['Date_Time',
    'Temp_1',
    'Latitude',
    'N_S',
    'Longitude',
    'E_W']

df2 = ['Date_Time',
    'Year',
    'Month',
    'Day',
    'Hour',
    'Minute',
    'Seconds']

<p> As You can see both DataFrames have <code> Date_Time <p>  as a
common column. I want to Join these two DataFrames by matching <code>
Date_Time <p> .
<p> My current code is: <code> df.join(df2, on='Date_Time') <p> , but
this is giving an error.

-------------------------------------OUTPUT-------------------------------------

                Expected= "df1.merge(df2, on='Date_Time')"
           base:Baseline= pd.merge(df1, df2, inplace=True)
           body:Baseline= df1.join(df2, on='Date_Time')
            body:-Blocks= df1.join(df2, on='Date_Time')
              body:-Code= df1.merge(df2.values())
            body:-Inline= df1.merge(df2.values())
                body:-NL= df1.join(df2, on='Date_Time')
             base:+Mined= df1.merge(df2, on='Date_Time')
     body+mined:Baseline= pd.merge(df1, df2, on='Date_Time')
        body+mined:-Code= df1.merge(df2, how='left', on='date_time')
          body+mined:-NL= pd.concat([df1, df2], axis=1)
      body+mined:-Blocks= df1.merge(df2, on='Date_Time')
      body+mined:-Inline= pd.concat([df1, df2], axis=1)

================================================================================

QUESTION: idx=108    id=3367288
-------------------------------------INPUTS-------------------------------------

tags: 
score: 14
slot_map: {'key': ['str_0', 'var_0'], 'quote': ['`', '`'], 'type': ['str', 'var'], 'value': ['%s', 'str1']}
intent: use `%s` operator to print variable values `str1` inside a string
body(Left in tags for better readability):
<p> I want to introduce a variable <code> [i] <p>  into a string in
Python.
<p> For example look at the following script. I just want to be able
to give a name to the image, for example <code> geo[0].tif <p>
<console_out> to <code> geo[i].tif <p> , or if you use an accountant
as I can replace a portion of the value chain to generate a counter.
<code_block>
 data = self.cmd("r.out.gdal in=rdata out=geo.tif")
self.dataOutTIF.setValue("geo.tif")


-------------------------------------OUTPUT-------------------------------------

                Expected= "'first string is: %s, second one is: %s' % (str1, 'geo.tif')"
           base:Baseline= str1 = str1.split('%s')
           body:Baseline= self.dataOutTIF.setValue(str1))
            body:-Blocks= str1 = str1.split('%s')
              body:-Code= print('%s', str1)
            body:-Inline= print('%s'.join(str1))
                body:-NL= self.dataOutTIF.setValue('str1')
             base:+Mined= print(''.join(str1))
     body+mined:Baseline= """""".join(str1)
        body+mined:-Code= """""".join(str1)
          body+mined:-NL= print('\n'.join(str1))
      body+mined:-Blocks= str1 = str1.split('.')[0]
      body+mined:-Inline= """""".join(str1)

================================================================================

QUESTION: idx=109    id=3475251
-------------------------------------INPUTS-------------------------------------

tags: string, list, split
score: 209
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: split a string by a delimiter in python
body(Left in tags for better readability):
<p> How to split this string where <code> __ <p>  is the delimiter
<code_block>
 MATCHES__STRING

<p> To get an output of <code> ['MATCHES', 'STRING'] <p> ?

-------------------------------------OUTPUT-------------------------------------

                Expected= "[x.strip() for x in '2.MATCHES $$TEXT$$ STRING'.split('$$TEXT$$')]"
           base:Baseline= """{0:.2f}""".format(',', '')
           body:Baseline= 'MATCHES', 'STRING']
            body:-Blocks= """MATCHES', 'STRING'".split('__')
              body:-Code= re.split('\n', '', str)
            body:-Inline= """""".join(str(s) for s in MATCHES__STRING()))
                body:-NL= """MATCHES__STRING""".split()
             base:+Mined= re.split('\\s+', s)
     body+mined:Baseline= """MATCHES__STRING""".split(',')
        body+mined:-Code= mystring.split('\n')
          body+mined:-NL= """MATCHES__STRING""".split()
      body+mined:-Blocks= re.split('(?<=__)', 'MATCHES', 'STRING')
      body+mined:-Inline= mATCHES__STRING.split(',')

================================================================================

QUESTION: idx=110    id=273192
-------------------------------------INPUTS-------------------------------------

tags: exception, path, directory, operating-system
score: 4616
slot_map: {'key': ['str_0'], 'quote': ['`'], 'type': ['str'], 'value': ['directory']}
intent: check if directory `directory ` exists and create it if necessary
body(Left in tags for better readability):
<p> What is the most elegant way to check if the directory a file is
going to be written to exists, and if not, create the directory using
Python? Here is what I tried:
<code_block>
 import os

file_path = "/my/directory/filename.txt"
directory = os.path.dirname(file_path)

try:
    os.stat(directory)
except:
    os.mkdir(directory)

f = file(filename)

<p> Somehow, I missed <code> os.path.exists <p>  (thanks kanja, Blair,
and Douglas). This is what I have now:
<code_block>
 def ensure_dir(file_path):
    directory = os.path.dirname(file_path)
    if not os.path.exists(directory):
        os.makedirs(directory)

<p> Is there a flag for "open", that makes this happen automatically?

-------------------------------------OUTPUT-------------------------------------

                Expected= 'if not os.path.exists(directory):\n    os.makedirs(directory)'
           base:Baseline= os.path.isfile(directory)
           body:Baseline= os.path.exists(directory)
            body:-Blocks= os.path.exists(directory)
              body:-Code= os.path.exists(directory)
            body:-Inline= os.path.exists(directory)
                body:-NL= os.path.exists(directory)
             base:+Mined= os.path.exists(directory)
     body+mined:Baseline= os.path.exists(directory)
        body+mined:-Code= os.path.exists(directory)
          body+mined:-NL= os.path.exists(directory)
      body+mined:-Blocks= print(os.path.exists(directory))
      body+mined:-Inline= os.path.exists(directory)

================================================================================

QUESTION: idx=111    id=273192
-------------------------------------INPUTS-------------------------------------

tags: exception, path, directory, operating-system
score: 4616
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['path']}
intent: check if a directory `path` exists and create it if necessary
body(Left in tags for better readability):
<p> What is the most elegant way to check if the directory a file is
going to be written to exists, and if not, create the directory using
Python? Here is what I tried:
<code_block>
 import os

file_path = "/my/directory/filename.txt"
directory = os.path.dirname(file_path)

try:
    os.stat(directory)
except:
    os.mkdir(directory)

f = file(filename)

<p> Somehow, I missed <code> os.path.exists <p>  (thanks kanja, Blair,
and Douglas). This is what I have now:
<code_block>
 def ensure_dir(file_path):
    directory = os.path.dirname(file_path)
    if not os.path.exists(directory):
        os.makedirs(directory)

<p> Is there a flag for "open", that makes this happen automatically?

-------------------------------------OUTPUT-------------------------------------

                Expected= 'try:\n    os.makedirs(path)\nexcept OSError:\n    if not os.path.isdir(path):\n        raise'
           base:Baseline= os.path.exists(path)
           body:Baseline= os.path.exists(path)
            body:-Blocks= os.path.exists(path)
              body:-Code= print(os.path.exists())
            body:-Inline= os.path.exists(directory)
                body:-NL= os.path.exists(path)
             base:+Mined= os.path.exists(path)
     body+mined:Baseline= os.path.exists(path)
        body+mined:-Code= os.path.exists(path)
          body+mined:-NL= os.path.exists(path)
      body+mined:-Blocks= print(os.path.exists(path))
      body+mined:-Inline= os.path.exists(path)

================================================================================

QUESTION: idx=112    id=273192
-------------------------------------INPUTS-------------------------------------

tags: exception, path, directory, operating-system
score: 4616
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['path']}
intent: check if a directory `path` exists and create it if necessary
body(Left in tags for better readability):
<p> What is the most elegant way to check if the directory a file is
going to be written to exists, and if not, create the directory using
Python? Here is what I tried:
<code_block>
 import os

file_path = "/my/directory/filename.txt"
directory = os.path.dirname(file_path)

try:
    os.stat(directory)
except:
    os.mkdir(directory)

f = file(filename)

<p> Somehow, I missed <code> os.path.exists <p>  (thanks kanja, Blair,
and Douglas). This is what I have now:
<code_block>
 def ensure_dir(file_path):
    directory = os.path.dirname(file_path)
    if not os.path.exists(directory):
        os.makedirs(directory)

<p> Is there a flag for "open", that makes this happen automatically?

-------------------------------------OUTPUT-------------------------------------

                Expected= 'distutils.dir_util.mkpath(path)'
           base:Baseline= os.path.exists(path)
           body:Baseline= os.path.exists(path)
            body:-Blocks= os.path.exists(path)
              body:-Code= print(os.path.exists())
            body:-Inline= os.path.exists(directory)
                body:-NL= os.path.exists(path)
             base:+Mined= os.path.exists(path)
     body+mined:Baseline= os.path.exists(path)
        body+mined:-Code= os.path.exists(path)
          body+mined:-NL= os.path.exists(path)
      body+mined:-Blocks= print(os.path.exists(path))
      body+mined:-Inline= os.path.exists(path)

================================================================================

QUESTION: idx=113    id=273192
-------------------------------------INPUTS-------------------------------------

tags: exception, path, directory, operating-system
score: 4616
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['path']}
intent: check if a directory `path` exists and create it if necessary
body(Left in tags for better readability):
<p> What is the most elegant way to check if the directory a file is
going to be written to exists, and if not, create the directory using
Python? Here is what I tried:
<code_block>
 import os

file_path = "/my/directory/filename.txt"
directory = os.path.dirname(file_path)

try:
    os.stat(directory)
except:
    os.mkdir(directory)

f = file(filename)

<p> Somehow, I missed <code> os.path.exists <p>  (thanks kanja, Blair,
and Douglas). This is what I have now:
<code_block>
 def ensure_dir(file_path):
    directory = os.path.dirname(file_path)
    if not os.path.exists(directory):
        os.makedirs(directory)

<p> Is there a flag for "open", that makes this happen automatically?

-------------------------------------OUTPUT-------------------------------------

                Expected= 'try:\n    os.makedirs(path)\nexcept OSError as exception:\n    if exception.errno != errno.EEXIST:\n        raise'
           base:Baseline= os.path.exists(path)
           body:Baseline= os.path.exists(path)
            body:-Blocks= os.path.exists(path)
              body:-Code= print(os.path.exists())
            body:-Inline= os.path.exists(directory)
                body:-NL= os.path.exists(path)
             base:+Mined= os.path.exists(path)
     body+mined:Baseline= os.path.exists(path)
        body+mined:-Code= os.path.exists(path)
          body+mined:-NL= os.path.exists(path)
      body+mined:-Blocks= print(os.path.exists(path))
      body+mined:-Inline= os.path.exists(path)

================================================================================

QUESTION: idx=114    id=18785032
-------------------------------------INPUTS-------------------------------------

tags: string, replace
score: 4
slot_map: {'key': ['str_0', 'str_1', 'str_2'], 'quote': ["'", "'", "'"], 'type': ['str', 'str', 'str'], 'value': ['H3', 'H1', 'text']}
intent: replace a separate word 'h3' by 'h1' in a string 'text'
body(Left in tags for better readability):
<p> I am trying to replace a string i.e. "H3" in a file with "H1" but
I want only "H3" to get replaced and not "mmmoleculeH3" to become
"mmmoleculeH1". I tried re but my limited knowledge in python didn't
get me anywhere. If there is any other method than that would be
great.script that i am using now is:
<code_block>
 #!/usr/bin/python

import fileinput
import sys
def replaceAll(file,searchExp,replaceExp):
    for line in fileinput.input(file, inplace=1):
        if searchExp in line:
            line = line.replace(searchExp,replaceExp)
        sys.stdout.write(line)

replaceAll("boxFile.cof","H3","H1")

<p> If there is any way i can do it with this itself without using re
then that would be great.Thanks in advance.

-------------------------------------OUTPUT-------------------------------------

                Expected= "re.sub('\\\\bH3\\\\b', 'H1', text)"
           base:Baseline= re.sub('\\d+', 'h3', text)
           body:Baseline= re.sub('(?=?=)', 'H3', text)
            body:-Blocks= re.sub('(?)', 'H3', text)
              body:-Code= re.sub('(?)', 'H3', text)
            body:-Inline= re.sub('(?=H3)', 'H1')
                body:-NL= re.sub('[h3]', 'H1', text)
             base:+Mined= text = re.sub('(\\w+)', '\\1', 'h3', text)
     body+mined:Baseline= re.sub('((\\w+)', '\\1', text)
        body+mined:-Code= text.replace('h3', 'h1')
          body+mined:-NL= line = line.replace('h3', '')
      body+mined:-Blocks= text.replace('h3', 'h1')
      body+mined:-Inline= text.replace('H3', 'H1')

================================================================================

QUESTION: idx=115    id=1450897
-------------------------------------INPUTS-------------------------------------

tags: string
score: 148
slot_map: {'key': ['str_0', 'str_1'], 'quote': ["'", "'"], 'type': ['str', 'str'], 'value': ['aas30dsa20', '']}
intent: substitute ascii letters in string 'aas30dsa20' with empty string ''
body(Left in tags for better readability):
<p> How can I remove all characters except numbers from string?

-------------------------------------OUTPUT-------------------------------------

                Expected= "re.sub('\\\\D', '', 'aas30dsa20')"
           base:Baseline= """aas30dsA20""".replace('', '')
           body:Baseline= """""".join(re.sub('Aas30dsA20', ''))
            body:-Blocks= """aas30dsa20""".replace('', '')
              body:-Code= """Aas30dsA20""".replace('', '')
            body:-Inline= """aas30dsa20""".replace('', '')
                body:-NL= """Aas30dsA20""".replace('', '')
             base:+Mined= """aas30dsA20""".replace(' ', '')
     body+mined:Baseline= """aas30dsa20""".replace(' ', '')
        body+mined:-Code= """aas30dsa20""".replace(',', '')
          body+mined:-NL= """aas30dsa20""".encode('ascii')
      body+mined:-Blocks= re.sub('(\\d+)', '\\1', 'Aas30DA20')
      body+mined:-Inline= """aas30dsa20""".replace('', '')

================================================================================

QUESTION: idx=116    id=1450897
-------------------------------------INPUTS-------------------------------------

tags: string
score: 148
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['aas30dsa20']}
intent: get digits only from a string `aas30dsa20` using lambda function
body(Left in tags for better readability):
<p> How can I remove all characters except numbers from string?

-------------------------------------OUTPUT-------------------------------------

                Expected= '"""""".join([x for x in \'aas30dsa20\' if x.isdigit()])'
           base:Baseline= """{0:.2f}""".format(aas30dsa20)
           body:Baseline= re.sub('(aas30dsa20))', '', aas30DFa20)
            body:-Blocks= re.sub('\\d+', 'aas30dsa20')
              body:-Code= re.sub('\\d+', 'aas30dsa20')
            body:-Inline= """""".join(str(aas30dsa20))
                body:-NL= """""".join(str(aas30dsa20))
             base:+Mined= """""".join(str(aas30dsA20))
     body+mined:Baseline= """""".join(str(aas30dsa20))
        body+mined:-Code= """aas30dsa20""".isdigit()
          body+mined:-NL= """""".join(str(aas30dsa20))
      body+mined:-Blocks= """aas30dsa20""".replace(',', '')
      body+mined:-Inline= """aas30dsa20""".replace(',', '')

================================================================================

QUESTION: idx=117    id=14435268
-------------------------------------INPUTS-------------------------------------

tags: xml, beautifulsoup
score: 16
slot_map: {'key': ['str_0', 'var_0'], 'quote': ['"', '`'], 'type': ['str', 'var'], 'value': ['name', 'soup']}
intent: access a tag called "name" in beautifulsoup `soup`
body(Left in tags for better readability):
<p> I want to access a tag called as <code> "name" <p>  such as:
<code_block>
 <contact> <name>Yesugey </name> <lastName>Yesil </lastName>
<phone>+90 333 9695395 </phone> </contact>

<p> Since <code> "name" <p>  is a property of a BeautifulSoup tag
object, I cannot access the child tag <code> name <p> :
<code_block>
 <console_in> c1
<contact> <name>Yesugey </name> <lastname>Yesil </lastname> <phone>+90
333 9695395 </p
hone> </contact>
<console_in> c1.name
<console_out> 'contact'
<console_in> c1.lastname
<lastname>Yesil </lastname>


-------------------------------------OUTPUT-------------------------------------

                Expected= "print(soup.find('name').string)"
           base:Baseline= soup.find_elements_by_xpath("name')
           body:Baseline= soup.findall('name')
            body:-Blocks= soup.findChild('name')
              body:-Code= soup.findChild('name')
            body:-Inline= soup.find_element_by_name('name')
                body:-NL= soup.find_tag('name')
             base:+Mined= soup.findAll(text=True)
     body+mined:Baseline= soup.findAll('name')
        body+mined:-Code= soup.findAll('name')
          body+mined:-NL= soup.find_all('contact', {'lastname': 'Yesil'})
      body+mined:-Blocks= soup.findAll('name')
      body+mined:-Inline= soup.find('contact', {'lastname': 'Yesil'})

================================================================================

QUESTION: idx=118    id=4928274
-------------------------------------INPUTS-------------------------------------

tags: mongodb, pymongo
score: 13
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['records', 'cursor']}
intent: get a dictionary `records` of key-value pairs in pymongo cursor `cursor`
body(Left in tags for better readability):
<p> Is it possible to iterate over a pymongo <code> Cursor <p>  as a
key-value pair like a <code> dict <p> ? I'm using python 2.6 and
pymongo 1.9.
<p> I've tried this:
<code_block>
 import pymongo
mongo = pymongo.Connection('localhost')
mongo_db = mongo['my_database']
mongo_coll = mongo_db['my_collection']
cursor = mongo_coll.find()
records = dict([(record_id, record) for record_id, record in
mongo_cursor])

<p> But I get the error:
<code_block>
 ValueError: too many values to unpack


-------------------------------------OUTPUT-------------------------------------

                Expected= "records = dict((record['_id'], record) for record in cursor)"
           base:Baseline= cursor.dict((k, v) for k, v in list(records.items()))
           body:Baseline= dict((k, v) for k, v in cursor.items()))
            body:-Blocks= records = pymongo.dict((k, v) for k, v in cursor.items())
              body:-Code= {k: v for k, v in list(cursor.keys())}
            body:-Inline= records = pymongo.keys()
                body:-NL= records = dict((k, v) for k, v in cursor.items()))
             base:+Mined= cursor.dict((k, v) for k, v in cursor.items())
     body+mined:Baseline= records = dict([(record_id, record) for record_id in mongo_cursor])
        body+mined:-Code= records = {k: v for k, v in list(cursor.items())}
          body+mined:-NL= cursor = mongo_coll.find_all(list(d.keys()))
      body+mined:-Blocks= dict((k, v) for k, v in list(Cursor.items()))
      body+mined:-Inline= {k: v for k, v in list(mongo_coll.items())}

================================================================================

QUESTION: idx=119    id=20180210
-------------------------------------INPUTS-------------------------------------

tags: numpy, matrix
score: 28
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: create new matrix object  by concatenating data from matrix a and matrix b
body(Left in tags for better readability):
<p> new to Python, struggling in numpy, hope someone can help me,
thank you!
<code_block>
 from numpy  import *
A = matrix('1.0 2.0; 3.0 4.0')
B = matrix('5.0 6.0')
C = matrix('1.0 2.0; 3.0 4.0; 5.0 6.0')
print "A=",A
print "B=",B
print "C=",C

<p> results:
<code_block>
 A= [[ 1.  2.]
   [ 3.  4.]]
B= [[ 5.  6.]]
C= [[ 1.  2.]
   [ 3.  4.]
   [ 5.  6.]]

<p> Question: how to use A and B to generate C, like in matlab <code>
C=[A;B] <p> ?

-------------------------------------OUTPUT-------------------------------------

                Expected= 'np.concatenate((A, B))'
           base:Baseline= np.matrix(a, b)
           body:Baseline= np.matlab(A, B, C)
            body:-Blocks= np.concat([A; B], axis=0)
              body:-Code= np.concat([A, B], axis=1)
            body:-Inline= np.concat([A, B], axis=1)
                body:-NL= np.concat([A, B], axis=1)
             base:+Mined= numpy.concatenate((a, b))
     body+mined:Baseline= C = np.concatenate(A, B)
        body+mined:-Code= C = np.concatenate((A, B))
          body+mined:-NL= np.concatenate((A, B))
      body+mined:-Blocks= C = np.concatenate((A, B))
      body+mined:-Inline= np.concatenate((A, B), axis=1)

================================================================================

QUESTION: idx=120    id=20180210
-------------------------------------INPUTS-------------------------------------

tags: numpy, matrix
score: 28
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['A', 'B']}
intent: concat two matrices `a` and `b` in numpy
body(Left in tags for better readability):
<p> new to Python, struggling in numpy, hope someone can help me,
thank you!
<code_block>
 from numpy  import *
A = matrix('1.0 2.0; 3.0 4.0')
B = matrix('5.0 6.0')
C = matrix('1.0 2.0; 3.0 4.0; 5.0 6.0')
print "A=",A
print "B=",B
print "C=",C

<p> results:
<code_block>
 A= [[ 1.  2.]
   [ 3.  4.]]
B= [[ 5.  6.]]
C= [[ 1.  2.]
   [ 3.  4.]
   [ 5.  6.]]

<p> Question: how to use A and B to generate C, like in matlab <code>
C=[A;B] <p> ?

-------------------------------------OUTPUT-------------------------------------

                Expected= 'np.vstack((A, B))'
           base:Baseline= numpy.concat([a, b])
           body:Baseline= np.concat([A, B], axis=1)
            body:-Blocks= numpy.concat([A; B])
              body:-Code= np.concat([a, b])
            body:-Inline= numpy.concat([A, B])
                body:-NL= numpy.concat([A, B])
             base:+Mined= np.concatenate((a, b), axis=1)
     body+mined:Baseline= np.concatenate(A, B)
        body+mined:-Code= np.concatenate((A, B), axis=1)
          body+mined:-NL= np.concatenate((A, B), axis=1)
      body+mined:-Blocks= np.concatenate(a, b)
      body+mined:-Inline= np.concatenate((A, B), axis=1)

================================================================================

QUESTION: idx=121    id=2011048
-------------------------------------INPUTS-------------------------------------

tags: size, character
score: 6
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['filepath']}
intent: get the characters count in a file `filepath`
body(Left in tags for better readability):
<p> I have a python code which reads many files.
but some files are extremely large due to which i have errors coming
in other codes.
i want a way in which i can check for the character count of the files
so that i avoid reading those extremely large files.
Thanks.

-------------------------------------OUTPUT-------------------------------------

                Expected= 'os.stat(filepath).st_size'
           base:Baseline= print(os.path.getcount(filepath))
           body:Baseline= print(os.path.count(len(filepath))))
            body:-Blocks= print(os.path.count(filepath))
              body:-Code= print(os.path.count(filepath))
            body:-Inline= print(os.path.getccount(filepath))
                body:-NL= print(os.path.realpath(filepath))
             base:+Mined= len(filePath) - len(filepath)
     body+mined:Baseline= len(open('filepath').read())
        body+mined:-Code= print(re.findall('(?<=\\w+)\\s+', filePath))
          body+mined:-NL= print(len(os.path.join(filepath, filepath)))
      body+mined:-Blocks= len(open('filepath').read())
      body+mined:-Inline= print(len(open('filepath').read())

================================================================================

QUESTION: idx=122    id=2600191
-------------------------------------INPUTS-------------------------------------

tags: list, count
score: 1706
slot_map: {'key': ['str_0', 'var_0'], 'quote': ['"', '`'], 'type': ['str', 'var'], 'value': ['a', 'l']}
intent: count the occurrences of item "a" in list `l`
body(Left in tags for better readability):
<p> Given an item, how can I count its occurrences in a list in
Python?

-------------------------------------OUTPUT-------------------------------------

                Expected= "l.count('a')"
           base:Baseline= sum(len(x) for x in L)
           body:Baseline= sum(x for x in l if x not in x)
            body:-Blocks= len(x) for x in L)
              body:-Code= sum(x for x in l if x.isdigit() == 'a')
            body:-Inline= count(x for x in L)
                body:-NL= [x for x in L if x == a]
             base:+Mined= sum(len(s) for s in L)
     body+mined:Baseline= Counter({'a': a, 'b': a})
        body+mined:-Code= Counter({'a': 1, 'b': 1})
          body+mined:-NL= len(L) - len(L))
      body+mined:-Blocks= sum(1 for item in L if item == 'a')
      body+mined:-Inline= Counter({'a': 1, 'b': 1})

================================================================================

QUESTION: idx=123    id=2600191
-------------------------------------INPUTS-------------------------------------

tags: list, count
score: 1706
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['l']}
intent: count the occurrences of items in list `l`
body(Left in tags for better readability):
<p> Given an item, how can I count its occurrences in a list in
Python?

-------------------------------------OUTPUT-------------------------------------

                Expected= 'Counter(l)'
           base:Baseline= sum(len(x) for x in L)
           body:Baseline= sum(x) for x in L)
            body:-Blocks= len(x) for x in L)
              body:-Code= sum(x for x in l)
            body:-Inline= count(x for x in L)
                body:-NL= count(x for x in L)
             base:+Mined= sum(len(x) for x in L)
     body+mined:Baseline= Counter({x for x in l if x % 2 == 0}
        body+mined:-Code= Counter({'c': 1, 'd': 2, 'e': 1})
          body+mined:-NL= Counter(L, key=lambda x: x[1])
      body+mined:-Blocks= sum(1 for i in L if i % 2 == 0)
      body+mined:-Inline= sum(1 for i in L if i == 0)

================================================================================

QUESTION: idx=124    id=2600191
-------------------------------------INPUTS-------------------------------------

tags: list, count
score: 1706
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['l']}
intent: count the occurrences of items in list `l`
body(Left in tags for better readability):
<p> Given an item, how can I count its occurrences in a list in
Python?

-------------------------------------OUTPUT-------------------------------------

                Expected= '[[x, l.count(x)] for x in set(l)]'
           base:Baseline= sum(len(x) for x in L)
           body:Baseline= sum(x) for x in L)
            body:-Blocks= len(x) for x in L)
              body:-Code= sum(x for x in l)
            body:-Inline= count(x for x in L)
                body:-NL= count(x for x in L)
             base:+Mined= sum(len(x) for x in L)
     body+mined:Baseline= Counter({x for x in l if x % 2 == 0}
        body+mined:-Code= Counter({'c': 1, 'd': 2, 'e': 1})
          body+mined:-NL= Counter(L, key=lambda x: x[1])
      body+mined:-Blocks= sum(1 for i in L if i % 2 == 0)
      body+mined:-Inline= sum(1 for i in L if i == 0)

================================================================================

QUESTION: idx=125    id=2600191
-------------------------------------INPUTS-------------------------------------

tags: list, count
score: 1706
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['l']}
intent: count the occurrences of items in list `l`
body(Left in tags for better readability):
<p> Given an item, how can I count its occurrences in a list in
Python?

-------------------------------------OUTPUT-------------------------------------

                Expected= 'dict((x, l.count(x)) for x in set(l))'
           base:Baseline= sum(len(x) for x in L)
           body:Baseline= sum(x) for x in L)
            body:-Blocks= len(x) for x in L)
              body:-Code= sum(x for x in l)
            body:-Inline= count(x for x in L)
                body:-NL= count(x for x in L)
             base:+Mined= sum(len(x) for x in L)
     body+mined:Baseline= Counter({x for x in l if x % 2 == 0}
        body+mined:-Code= Counter({'c': 1, 'd': 2, 'e': 1})
          body+mined:-NL= Counter(L, key=lambda x: x[1])
      body+mined:-Blocks= sum(1 for i in L if i % 2 == 0)
      body+mined:-Inline= sum(1 for i in L if i == 0)

================================================================================

QUESTION: idx=126    id=2600191
-------------------------------------INPUTS-------------------------------------

tags: list, count
score: 1706
slot_map: {'key': ['str_0', 'var_0'], 'quote': ['"', '`'], 'type': ['str', 'var'], 'value': ['b', 'l']}
intent: count the occurrences of item "b" in list `l`
body(Left in tags for better readability):
<p> Given an item, how can I count its occurrences in a list in
Python?

-------------------------------------OUTPUT-------------------------------------

                Expected= "l.count('b')"
           base:Baseline= [x for x in L if 'b' in x]
           body:Baseline= sum(item for item in L if item == 'b' in item)
            body:-Blocks= len(l) == 'b')
              body:-Code= sum(len(b)) for b in L)
            body:-Inline= count(x for x in L)
                body:-NL= [x for x in L if x == 'b']
             base:+Mined= sum(len(s) for s in L)
     body+mined:Baseline= sum(1 for item in L if item == 'b')
        body+mined:-Code= Counter({'b': 1, 'c': 2, 'd': 3})
          body+mined:-NL= len(L) - len(L))
      body+mined:-Blocks= sum(1 for item in L if item == 'b')
      body+mined:-Inline= sum(1 for item in L if 'b' in item)

================================================================================

QUESTION: idx=127    id=12842997
-------------------------------------INPUTS-------------------------------------

tags: file, directory, copy
score: 55
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['srcfile', 'dstdir']}
intent: copy file `srcfile` to directory `dstdir`
body(Left in tags for better readability):
<p> First thing I have to mention here, I'm new to python.
<p> Now I have a file located in:
<code_block>
 a/long/long/path/to/file.py

<p> I want to copy to my home directory with a new folder created:
<code_block>
 /home/myhome/new_folder

<p> My expected result is:
<code_block>
 /home/myhome/new_folder/a/long/long/path/to/file.py

<p> Is there any existing library to do that? If no, how can I achieve
that?

-------------------------------------OUTPUT-------------------------------------

                Expected= 'shutil.copy(srcfile, dstdir)'
           base:Baseline= os.copydir(srcfile, dstdir)
           body:Baseline= os.path.dirname(srcfile, dstdir)
            body:-Blocks= os.copydir(srcfile, dstdir)
              body:-Code= os.copy(srcfile, dstdir)
            body:-Inline= os.path.copydir(srcfile, dstdir)
                body:-NL= os.copydir(srcfile, dstdir)
             base:+Mined= os.chdir(srcfile, dstdir)
     body+mined:Baseline= os.path.dirname(srcfile)
        body+mined:-Code= os.path.join(srcfile, dstdir)
          body+mined:-NL= os.path.dirname(srcfile)
      body+mined:-Blocks= dstdir = os.path.join(srcfile, dstdir)
      body+mined:-Inline= os.chdir(srcfile)

================================================================================

QUESTION: idx=128    id=1555968
-------------------------------------INPUTS-------------------------------------

tags: dictionary
score: 7
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['x']}
intent: find the key associated with the largest value in dictionary `x` whilst key is non-zero value
body(Left in tags for better readability):
<p> I'm new Python and trying to implement code in a more Pythonic and
efficient fashion.
Given a dictionary with numeric keys and values, what is the best way
to find the largest key with a non-zero value?
<p> Thanks

-------------------------------------OUTPUT-------------------------------------

                Expected= 'max(k for k, v in x.items() if v != 0)'
           base:Baseline= max(x, key=lambda x: x[0])
           body:Baseline= max(key, value) == 0
            body:-Blocks= max(x, key=lambda x: x[0])
              body:-Code= max(x, key=operator.itemgetter(x))
            body:-Inline= max(x, key=lambda x: x.isnull()
                body:-NL= [k for k, v in x.items() if v is nonzero]
             base:+Mined= max(x, key=lambda x: x[1])
     body+mined:Baseline= max(x, key=lambda x: x[1])
        body+mined:-Code= max(x, key=lambda x: x[1])
          body+mined:-NL= max(x, key=lambda x: x[1])
      body+mined:-Blocks= max(x, key=lambda x: x.isnull(x))
      body+mined:-Inline= max(x, key=lambda x: x[1])

================================================================================

QUESTION: idx=129    id=1555968
-------------------------------------INPUTS-------------------------------------

tags: dictionary
score: 7
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['x']}
intent: get the largest key whose not associated with value of 0 in dictionary `x`
body(Left in tags for better readability):
<p> I'm new Python and trying to implement code in a more Pythonic and
efficient fashion.
Given a dictionary with numeric keys and values, what is the best way
to find the largest key with a non-zero value?
<p> Thanks

-------------------------------------OUTPUT-------------------------------------

                Expected= '(k for k, v in x.items() if v != 0)'
           base:Baseline= max(x, key=lambda x: x[0])
           body:Baseline= max(k, v) for k, v in x.items()
            body:-Blocks= max(x, key=lambda x: x[0])
              body:-Code= max(x, key=lambda x: x[0])
            body:-Inline= max(x, key=lambda x: x[0])
                body:-NL= max(x, key=lambda x: x[0])
             base:+Mined= max(x, key=lambda x: x[0])
     body+mined:Baseline= max(x, key=lambda x: x[0])
        body+mined:-Code= max(x, key=lambda x: x[0])
          body+mined:-NL= max(x, key=lambda x: x[0])
      body+mined:-Blocks= max(x, key=lambda x: x[0])
      body+mined:-Inline= max(x, key=lambda x: x != 0)

================================================================================

QUESTION: idx=130    id=1555968
-------------------------------------INPUTS-------------------------------------

tags: dictionary
score: 7
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['x']}
intent: get the largest key in a dictionary `x` with non-zero value
body(Left in tags for better readability):
<p> I'm new Python and trying to implement code in a more Pythonic and
efficient fashion.
Given a dictionary with numeric keys and values, what is the best way
to find the largest key with a non-zero value?
<p> Thanks

-------------------------------------OUTPUT-------------------------------------

                Expected= 'max(k for k, v in x.items() if v != 0)'
           base:Baseline= max(x, key=lambda x: nonzero)
           body:Baseline= max(x, key=operator.itemgetter(0)))
            body:-Blocks= max(x, key=lambda x: x[0])
              body:-Code= max(x, key=operator.itemgetter(0))
            body:-Inline= max(x, key=lambda x: nonzero)
                body:-NL= max(x, key=lambda x: nonzero)
             base:+Mined= max(x, key=lambda x: x[1])
     body+mined:Baseline= max(x, key=lambda x: x[1])
        body+mined:-Code= max(x, key=lambda x: x[1])
          body+mined:-NL= max(x, key=lambda x: x[0])
      body+mined:-Blocks= max(x, key=operator.itemgetter(0))
      body+mined:-Inline= max(x, key=lambda x: x != 0)

================================================================================

QUESTION: idx=131    id=17021863
-------------------------------------INPUTS-------------------------------------

tags: file, testing
score: 19
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: put the curser at beginning of the file
body(Left in tags for better readability):
<p> I have a script that reads a file and then completes tests based
on that file however I am running into a problem because the file
reloads after one hour and I cannot get the script to re-read the file
after or at that point in time.
<p> So:

<li> GETS NEW FILE TO READ
<li> Reads file
<li> performs tests on file
<li> GET NEW FILE TO READ (with same name - but that can change if it
is part of a solution)
<li> Reads new file
<li> perform same tests on new file

<p> Can anyone suggest a way to get Python to re-read the file?

-------------------------------------OUTPUT-------------------------------------

                Expected= 'file.seek(0)'
           base:Baseline= curser.start_new_file()
           body:Baseline= print(os.path.getmtime(0, 1))
            body:-Blocks= curser.read().reset_file()
              body:-Code= os.chmod(curser)
            body:-Inline= curser.read().reset_file()
                body:-NL= print(os.path.realpath(__file__))
             base:+Mined= curser.add_argument('foo', 'bar')
     body+mined:Baseline= print(os.path.join(dirname, file))
        body+mined:-Code= print(os.path.join(file, curser))
          body+mined:-NL= os.startswith(file_name)
      body+mined:-Blocks= curser.seek(open('myfile.txt').read())
      body+mined:-Inline= return os.path.join(file, curser)

================================================================================

QUESTION: idx=132    id=38152389
-------------------------------------INPUTS-------------------------------------

tags: pandas, numpy, dataframe
score: 62
slot_map: {'key': ['str_0', 'str_1', 'var_0', 'str_2', 'var_1'], 'quote': ["'", "'", '`', "'", '`'], 'type': ['str', 'str', 'var', 'str', 'var'], 'value': ['b', 'a', 'df', 'c', 'df']}
intent: combine values from column 'b' and column 'a' of dataframe `df`  into column 'c' of datafram `df`
body(Left in tags for better readability):
<p> I'm looking for a method that behaves similarly to coalesce in
T-SQL. I have 2 columns (column A and B) that are sparsely populated
in a pandas dataframe. I'd like to create a new column using the
following rules:

<li> If the value in column A <em> is not null <li> , use that value
for the new column C
<li> If the value in column A <em> is null <li> , use the value in
column B for the new column C

<p> Like I mentioned, this can be accomplished in MS SQL Server via
the coalesce function. I haven't found a good pythonic method for
this; does one exist?

-------------------------------------OUTPUT-------------------------------------

                Expected= "df['c'] = np.where(df['a'].isnull, df['b'], df['a'])"
           base:Baseline= df['b'] = df['A'] + df['C']
           body:Baseline= df['B', 'A'] = df['C']
            body:-Blocks= df['C'] = df['A'].merge(['B', 'A'], axis=1)
              body:-Code= df['C'] = df['A'].concat([df['B'], df['C'], axis=1)
            body:-Inline= df['A'] = df['C']
                body:-NL= df['b', 'a'] = df['c']
             base:+Mined= df['b'].combine(df['a'], df['c'])
     body+mined:Baseline= df['C'] = df['A'].combine(df['B'], df['C'])
        body+mined:-Code= df['c'] = df['b'].coalesce(df['A'], df['B'])
          body+mined:-NL= df['c'] = df['b'].combine(df['a'], df['c'])
      body+mined:-Blocks= df.concat([df.B], axis=1)
      body+mined:-Inline= df.concat([df['b'], df['a'], axis=1)

================================================================================

QUESTION: idx=133    id=4175686
-------------------------------------INPUTS-------------------------------------

tags: 
score: 4
slot_map: {'key': ['str_0', 'var_0'], 'quote': ["'", '`'], 'type': ['str', 'var'], 'value': ['ele', 'd']}
intent: remove key 'ele' from dictionary `d`
body(Left in tags for better readability):
<p> I use this way to remove an emelment from a dict:
<code_block>
     d["ele"] = data
<console_out>
    d["ele"] = None

<p> I think by this I can remove the reference on the original element
so that the removed data can be freed, no memory leak.
<p> Is it the right way to do this?

-------------------------------------OUTPUT-------------------------------------

                Expected= "del d['ele']"
           base:Baseline= d = {'ele': 'ele'}
           body:Baseline= d = dict((k, v) for k, v in d.items()) if v in k]
            body:-Blocks= d = dict((k, v) for k, v in d.items() if 'ele' in k)
              body:-Code= d = dict.remove('ele')
            body:-Inline= dict((k, 'ele') for k, v in list(d.items()))
                body:-NL= d = list(d.items()))
             base:+Mined= d = {k: v for k, v in list(d.items())}
     body+mined:Baseline= d = dict((k, e) for k, e in d.items())
        body+mined:-Code= d = dict((i for i, e in list(d.items()) if e!= 'ele')
          body+mined:-NL= d['ele'] = 'None'
      body+mined:-Blocks= d.update({'ele': 1, 'x': 2, 'y': 1})
      body+mined:-Inline= d = dict(data['ele'] for data in data)

================================================================================

QUESTION: idx=134    id=5871168
-------------------------------------INPUTS-------------------------------------

tags: django, datetime, django-database
score: 48
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['MyModel', 'timestamp']}
intent: update datetime field in `mymodel` to be the existing `timestamp` plus 100 years
body(Left in tags for better readability):
<p> How can I subtract or add 100 years to a <code> datetime <p>
field in the database in Django?
<p> The date is in database, I just want to directly update the field
without retrieving it out to calculate and then insert.

-------------------------------------OUTPUT-------------------------------------

                Expected= "MyModel.objects.update(timestamp=F('timestamp') + timedelta(days=36524.25))"
           base:Baseline= myModel.update(timestamp=100, datetime=100)
           body:Baseline= timestamp = datetime.datetime.now().date()
            body:-Blocks= myModel.update(timestamp, 100)
              body:-Code= myModel.update({'timestamp': 100, 'year': 100})
            body:-Inline= myModel.update(timestamp, 100 years)
                body:-NL= myModel.update({timestamp: 100, datetime: 100})
             base:+Mined= myModel.update({'date': datetime.datetime.combine(date.today, date.today))})
     body+mined:Baseline= myModel.update(date=today + datetime.timedelta(100) + 100)
        body+mined:-Code= MyModel.set_index(['timestamp', '100Y'])
          body+mined:-NL= myModel.dt.to_timestamp()
      body+mined:-Blocks= MyModel.date.set_index(['timestamp', '100Y'])
      body+mined:-Inline= myModel.update({'date': datetime.timestamp + 100 years})

================================================================================

QUESTION: idx=135    id=11574195
-------------------------------------INPUTS-------------------------------------

tags: list, join, merge
score: 153
slot_map: {'key': ['str_0', 'str_1', 'str_2', '[str_0]', '[str_1]', '[str_2]'], 'quote': ['`', '`', '`', '`', '`', '`'], 'type': ['str', 'str', 'str', 'str', 'str', 'str'], 'value': ["['it']", "['was']", "['annoying']", "['it']", "['was']", "['annoying']"]}
intent: merge list `['it']` and list `['was']` and list `['annoying']` into one list
body(Left in tags for better readability):

<strong> Possible Duplicate:
<a> Making a flat list out of list of lists in Python
<a> Join a list of lists together into one list in Python

<p> I have many lists which looks like
<code_block>
 ['it']
['was']
['annoying']

<p> I want the above to look like
<code_block>
 ['it', 'was', 'annoying']

<p> How do I achieve that?

-------------------------------------OUTPUT-------------------------------------

                Expected= "['it'] + ['was'] + ['annoying']"
           base:Baseline= [list(['it', 'was'], ['annoying'] for _ in range(1)]
           body:Baseline= list(['it']', 'was', 'annoying']))
            body:-Blocks= [(x, y) for x, y in zip(['it', 'was']], 'annoying']]
              body:-Code= [(x, y) for x, y in zip(['it', 'was']], 'annoying']]
            body:-Inline= [list(['it'] and list(['was']], ['annoying']]]
                body:-NL= [list(['it'] and list(['was']], ['annoying']]
             base:+Mined= ['it', 'annoying']
     body+mined:Baseline= [['it', 'was', 'annoying'] for _ in range(10)]
        body+mined:-Code= [['it', 'was', 'annoying']]
          body+mined:-NL= [['it', 'was', 'annoying'] for _ in range(0, len(s)], s)]
      body+mined:-Blocks= [['it', 'was'], ['annoying']]
      body+mined:-Inline= ['it', 'was', 'annoying']

================================================================================

QUESTION: idx=136    id=587647
-------------------------------------INPUTS-------------------------------------

tags: 
score: 11
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['x']}
intent: increment a value with leading zeroes in a number `x`
body(Left in tags for better readability):
<p> What would be the best way to increment a value that contains
leading zeroes?  For example, I'd like to increment "00000001".
However, it should be noted that the number of leading zeroes will not
exceed 30.  So there may be cases like "0000012", "00000000000000099",
or "000000000000045".
<p> I can think of a couple ways, but I want to see if someone comes
up with something slick.

-------------------------------------OUTPUT-------------------------------------

                Expected= 'str(int(x) + 1).zfill(len(x))'
           base:Baseline= max(x, zeroes=0)
           body:Baseline= len(x, key=lambda x: x[0]))
            body:-Blocks= x[0] = x[1]
              body:-Code= x[0].strftime('0')
            body:-Inline= x['0'] = ''.join(x)
                body:-NL= x = zeroes.randint(x)
             base:+Mined= [(1, 2), (2, 3), (3, 4), (5, 6)]
     body+mined:Baseline=  increment((x[1:]) for x in range(30))
        body+mined:-Code= x = increment(0, 1)
          body+mined:-NL= x = zeroes.multivariate_normal(x, axis=1)
      body+mined:-Blocks= x.groupby(1).agg(1)
      body+mined:-Inline= x.loc[:, (0)]

================================================================================

QUESTION: idx=137    id=17315881
-------------------------------------INPUTS-------------------------------------

tags: pandas
score: 35
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['df']}
intent: check if a pandas dataframe `df`'s index is sorted
body(Left in tags for better readability):
<p> I have a vanilla pandas dataframe with an index. I need to check
if the index is sorted. Preferably without sorting it again.
<p> e.g. I can test an index to see if it is unique by
index.is_unique() is there a similar way for testing sorted?

-------------------------------------OUTPUT-------------------------------------

                Expected= 'all(df.index[:-1] <= df.index[1:])'
           base:Baseline= df.index.sort(key=lambda x: x[1])
           body:Baseline= df.index.is_unique()
            body:-Blocks= df.index.sort(key=lambda x: x.is_unique()
              body:-Code= if df.is_unique():
    pass
            body:-Inline= df.index.is_unique()
                body:-NL= df.index.sort(key=lambda x: x[1])
             base:+Mined= df.sort(index=False, inplace=True)
     body+mined:Baseline= df.index.sort(key=lambda x: x.is_unique())
        body+mined:-Code= df.index.is_unique()
          body+mined:-NL= df.index.sort(key=lambda x: x[1])
      body+mined:-Blocks= df.index.sort(key=lambda index: index.is_unique(index))
      body+mined:-Inline= df.index.isin(['unique', 'unique'])

================================================================================

QUESTION: idx=138    id=16296643
-------------------------------------INPUTS-------------------------------------

tags: list, tuples
score: 231
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['t']}
intent: convert tuple `t` to list
body(Left in tags for better readability):
<p> I'm currently working on a map editor for a game in pygame, using
tile maps.
The level is built up out of blocks in the following structure (though
much larger):
<code_block>
 level1 = (
         (1,1,1,1,1,1)
         (1,0,0,0,0,1)
         (1,0,0,0,0,1)
         (1,0,0,0,0,1)
         (1,0,0,0,0,1)
         (1,1,1,1,1,1))

<p> where "1" is a block that's a wall and "0" is a block that's empty
air.
<p> The following code is basically the one handling the change of
block type:
<code_block>
 clicked = pygame.mouse.get_pressed()
if clicked[0] == 1:
    currLevel[((mousey+cameraY)/60)][((mousex+cameraX)/60)] = 1

<p> But since the level is stored in a tuple, I'm unable to change the
values of the different blocks. How do I go about changing the
different values in the level in an easy manner?

-------------------------------------OUTPUT-------------------------------------

                Expected= 'list(t)'
           base:Baseline= t = t[::-1]
           body:Baseline= t = pygame.tile_map(map(t, map(t)), reverse=True)
            body:-Blocks= t = map.setLevel(t)
              body:-Code= t = map(t.split())
            body:-Inline= t = map(list(t.items()))
                body:-NL= currLevel[(t) for t in zip(*t)]
             base:+Mined= t = [t[i] for i in t]
     body+mined:Baseline= t = map(t, level1)
        body+mined:-Code= list(level(t) for t in tuple(t.items())
          body+mined:-NL= currLevel[(x + y) for x in t]
      body+mined:-Blocks= t = map(t, t)
      body+mined:-Inline= t = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]

================================================================================

QUESTION: idx=139    id=16296643
-------------------------------------INPUTS-------------------------------------

tags: list, tuples
score: 231
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['t']}
intent: convert list `t` to tuple
body(Left in tags for better readability):
<p> I'm currently working on a map editor for a game in pygame, using
tile maps.
The level is built up out of blocks in the following structure (though
much larger):
<code_block>
 level1 = (
         (1,1,1,1,1,1)
         (1,0,0,0,0,1)
         (1,0,0,0,0,1)
         (1,0,0,0,0,1)
         (1,0,0,0,0,1)
         (1,1,1,1,1,1))

<p> where "1" is a block that's a wall and "0" is a block that's empty
air.
<p> The following code is basically the one handling the change of
block type:
<code_block>
 clicked = pygame.mouse.get_pressed()
if clicked[0] == 1:
    currLevel[((mousey+cameraY)/60)][((mousex+cameraX)/60)] = 1

<p> But since the level is stored in a tuple, I'm unable to change the
values of the different blocks. How do I go about changing the
different values in the level in an easy manner?

-------------------------------------OUTPUT-------------------------------------

                Expected= 'tuple(l)'
           base:Baseline= t = tuple([i for i in t])
           body:Baseline= t = pygame.tile_map(t, t))
            body:-Blocks= t = map.setLevel(t)
              body:-Code= t = map(list(t.items())
            body:-Inline= t = tuple(map(list(t.items()), key=lambda t: t[0])
                body:-NL= tuple(t, key=lambda t: t[0])
             base:+Mined= tuple(map(t, l))
     body+mined:Baseline= tuple(map(tuple, level1))
        body+mined:-Code= tuple(map(tuple, iter(t))
          body+mined:-NL= tuple(x[0] for x in t)
      body+mined:-Blocks= tuple(map(t, t))
      body+mined:-Inline= tuple(map(tuple, level1))

================================================================================

QUESTION: idx=140    id=16296643
-------------------------------------INPUTS-------------------------------------

tags: list, tuples
score: 231
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['level1']}
intent: convert tuple `level1` to list
body(Left in tags for better readability):
<p> I'm currently working on a map editor for a game in pygame, using
tile maps.
The level is built up out of blocks in the following structure (though
much larger):
<code_block>
 level1 = (
         (1,1,1,1,1,1)
         (1,0,0,0,0,1)
         (1,0,0,0,0,1)
         (1,0,0,0,0,1)
         (1,0,0,0,0,1)
         (1,1,1,1,1,1))

<p> where "1" is a block that's a wall and "0" is a block that's empty
air.
<p> The following code is basically the one handling the change of
block type:
<code_block>
 clicked = pygame.mouse.get_pressed()
if clicked[0] == 1:
    currLevel[((mousey+cameraY)/60)][((mousex+cameraX)/60)] = 1

<p> But since the level is stored in a tuple, I'm unable to change the
values of the different blocks. How do I go about changing the
different values in the level in an easy manner?

-------------------------------------OUTPUT-------------------------------------

                Expected= 'level1 = map(list, level1)'
           base:Baseline= list(level1, key=lambda tup: tup[1])
           body:Baseline= pygame.tile_map(level1, key=lambda t: t[0], reverse=True)
            body:-Blocks= level1 = map(level1, level2)
              body:-Code= list(level1, key=lambda tup: tup[0])
            body:-Inline= list(level1, key=lambda t: t[0])
                body:-NL= [(level1, key=lambda t: t[0]) for t in level1]
             base:+Mined= map(lambda x: x[1])
     body+mined:Baseline= pygame.tile(level1, 0)
        body+mined:-Code= list(level1.flatten())
          body+mined:-NL= currLevel[(x + y) for x, y in zip(level1, levelX)]
      body+mined:-Blocks= Level1 = [tuple(level1) for tuple in tuple]
      body+mined:-Inline= currLevel[(1, 0), (1, 1), (0, 0)]

================================================================================

QUESTION: idx=141    id=3880399
-------------------------------------INPUTS-------------------------------------

tags: logging
score: 58
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['dataobject', 'logFile']}
intent: send the output of pprint object `dataobject` to file `logfile`
body(Left in tags for better readability):
<p> I have the following code:
<code_block>
 logFile=open('c:\\temp\\mylogfile'+'.txt', 'w')
pprint.pprint(dataobject)

<p> how can i send the contents of dataobject to the log file on the
pretty print format ?

-------------------------------------OUTPUT-------------------------------------

                Expected= 'pprint.pprint(dataobject, logFile)'
           base:Baseline= logfile.send('//logfile')
           body:Baseline= pprint.pprint(dataobject, logFile)
            body:-Blocks= logfile = pd.open('dataobject', 'logfile')
              body:-Code= logfile = pd.open('dataobject', 'logfile')
            body:-Inline= pprint.pprint(dataobject)
                body:-NL= pprint.pprint(dataobject)
             base:+Mined= dataobject.send('logfile')
     body+mined:Baseline= pprint.pprint(dataobject)
        body+mined:-Code= logfile.write(dataobject)
          body+mined:-NL= pprint.pprint(dataobject)
      body+mined:-Blocks= logfile.write('\n'.join(dataobject))
      body+mined:-Inline= pprint.pprint(dataobject, pretty_print=True)

================================================================================

QUESTION: idx=142    id=21800169
-------------------------------------INPUTS-------------------------------------

tags: indexing, pandas
score: 336
slot_map: {'key': ['str_0'], 'quote': ["'"], 'type': ['str'], 'value': ['BoolCol']}
intent: get index of rows in column 'boolcol'
body(Left in tags for better readability):
<p> Given a DataFrame with a column "BoolCol", we want to find the
indexes of the DataFrame in which the values for "BoolCol" == True
<p> I currently have the iterating way to do it, which works
perfectly:
<code_block>
 for i in range(100,3000):
    if df.iloc[i]['BoolCol']== True:
         print i,df.iloc[i]['BoolCol']

<p> But this is not the correct panda's way to do it.
After some research, I am currently using this code:
<code_block>
 df[df['BoolCol'] == True].index.tolist()

<p> This one gives me a list of indexes, but they dont match, when I
check them by doing:
<code_block>
 df.iloc[i]['BoolCol']

<p> The result is actually False!!
<p> Which would be the correct Pandas way to do this?

-------------------------------------OUTPUT-------------------------------------

                Expected= "df.loc[df['BoolCol']]"
           base:Baseline= df['boolcol'].index('index')
           body:Baseline= df[df['BoolCol'] == True].index.tolist()
            body:-Blocks= df['boolCol'] = df['BoolCol']
              body:-Code= df['boolCol'] = df['BoolCol']
            body:-Inline= df.iloc[i]['BoolCol'] == True
                body:-NL= df['boolCol'] == True].index.tolist()
             base:+Mined= df.index.get_level_values('boolcol')
     body+mined:Baseline= df[df['BoolCol'] == True]
        body+mined:-Code= df.index.get_level_values('BoolCol') == True
          body+mined:-NL= df[df['BoolCol'] == True].index.tolist()
      body+mined:-Blocks= df.index.get_level_values('BoolCol')
      body+mined:-Inline= df[df['BoolCol'] == True].index.tolist()

================================================================================

QUESTION: idx=143    id=21800169
-------------------------------------INPUTS-------------------------------------

tags: indexing, pandas
score: 336
slot_map: {'key': ['str_0', 'var_0'], 'quote': ["'", '`'], 'type': ['str', 'var'], 'value': ['BoolCol', 'df']}
intent: create a list containing the indexes of rows where the value of column 'boolcol' in dataframe `df` are equal to true
body(Left in tags for better readability):
<p> Given a DataFrame with a column "BoolCol", we want to find the
indexes of the DataFrame in which the values for "BoolCol" == True
<p> I currently have the iterating way to do it, which works
perfectly:
<code_block>
 for i in range(100,3000):
    if df.iloc[i]['BoolCol']== True:
         print i,df.iloc[i]['BoolCol']

<p> But this is not the correct panda's way to do it.
After some research, I am currently using this code:
<code_block>
 df[df['BoolCol'] == True].index.tolist()

<p> This one gives me a list of indexes, but they dont match, when I
check them by doing:
<code_block>
 df.iloc[i]['BoolCol']

<p> The result is actually False!!
<p> Which would be the correct Pandas way to do this?

-------------------------------------OUTPUT-------------------------------------

                Expected= "df.iloc[np.flatnonzero(df['BoolCol'])]"
           base:Baseline= df[index(df['boolcol'] == True]
           body:Baseline= df[i]['BoolCol'] == True].index.tolist()
            body:-Blocks= [i for i, j in df.values() if j == True]
              body:-Code= [i for i, j in df if j == 'boolCol']
            body:-Inline= [df[i]['BoolCol'] == True]
                body:-NL= df[df['BoolCol'] == True].index.tolist()
             base:+Mined= df[df['boolCol'] == True]
     body+mined:Baseline= df[df['BoolCol'] == True].index.tolist()
        body+mined:-Code= [i for i, v in df.index.get('BoolCol') if v == True]
          body+mined:-NL= df[df['BoolCol'] == True].index.tolist()
      body+mined:-Blocks= [(df == 'BoolCol').any(axis=1)]
      body+mined:-Inline= df[df['BoolCol'] == True].index.tolist()

================================================================================

QUESTION: idx=144    id=21800169
-------------------------------------INPUTS-------------------------------------

tags: indexing, pandas
score: 336
slot_map: {'key': ['str_0'], 'quote': ["'"], 'type': ['str'], 'value': ['BoolCol']}
intent: get list of indexes of rows where column 'boolcol' values match true
body(Left in tags for better readability):
<p> Given a DataFrame with a column "BoolCol", we want to find the
indexes of the DataFrame in which the values for "BoolCol" == True
<p> I currently have the iterating way to do it, which works
perfectly:
<code_block>
 for i in range(100,3000):
    if df.iloc[i]['BoolCol']== True:
         print i,df.iloc[i]['BoolCol']

<p> But this is not the correct panda's way to do it.
After some research, I am currently using this code:
<code_block>
 df[df['BoolCol'] == True].index.tolist()

<p> This one gives me a list of indexes, but they dont match, when I
check them by doing:
<code_block>
 df.iloc[i]['BoolCol']

<p> The result is actually False!!
<p> Which would be the correct Pandas way to do this?

-------------------------------------OUTPUT-------------------------------------

                Expected= "df[df['BoolCol'] == True].index.tolist()"
           base:Baseline= [i for i, v in enumerate(boolcol.values()) if v == True]
           body:Baseline= df[df['BoolCol'] == True].index.tolist()
            body:-Blocks= [i for i, j in enumerate(df['boolCol'] if j == True]
              body:-Code= [x['boolCol'] == True]
            body:-Inline= df[df['BoolCol'] == True].index.tolist()
                body:-NL= df[df['boolCol'] == True].index.tolist()
             base:+Mined= [index for index, row in enumerate(boolcol) if row == True]
     body+mined:Baseline= df[df['BoolCol'] == True]
        body+mined:-Code= [i for i, v in enumerate(df.BoolCol) if v == True]
          body+mined:-NL= df[df['BoolCol'] == True].index.tolist()
      body+mined:-Blocks= [index for index, row in df.index if row['BoolCol'] == True]
      body+mined:-Inline= df[df['BoolCol'] == True].index.tolist()

================================================================================

QUESTION: idx=145    id=21800169
-------------------------------------INPUTS-------------------------------------

tags: indexing, pandas
score: 336
slot_map: {'key': ['var_0', 'str_0'], 'quote': ['`', "'"], 'type': ['var', 'str'], 'value': ['df', 'BoolCol']}
intent: get index of rows in dataframe `df` which column 'boolcol' matches value true
body(Left in tags for better readability):
<p> Given a DataFrame with a column "BoolCol", we want to find the
indexes of the DataFrame in which the values for "BoolCol" == True
<p> I currently have the iterating way to do it, which works
perfectly:
<code_block>
 for i in range(100,3000):
    if df.iloc[i]['BoolCol']== True:
         print i,df.iloc[i]['BoolCol']

<p> But this is not the correct panda's way to do it.
After some research, I am currently using this code:
<code_block>
 df[df['BoolCol'] == True].index.tolist()

<p> This one gives me a list of indexes, but they dont match, when I
check them by doing:
<code_block>
 df.iloc[i]['BoolCol']

<p> The result is actually False!!
<p> Which would be the correct Pandas way to do this?

-------------------------------------OUTPUT-------------------------------------

                Expected= "df[df['BoolCol']].index.tolist()"
           base:Baseline= df.loc[df['boolcol'] == True]
           body:Baseline= df[df['BoolCol'] == True].index.tolist()
            body:-Blocks= df.index(['boolCol'] == True)
              body:-Code= df.index['boolCol'] == True
            body:-Inline= df[df['BoolCol'] == True]
                body:-NL= df[df['boolCol'] == True].index.tolist()
             base:+Mined= df[df['boolCol'] == True]
     body+mined:Baseline= df[df['BoolCol'] == True].index.tolist()
        body+mined:-Code= df[df['BoolCol'] == True]
          body+mined:-NL= df[df['BoolCol'] == True].index.tolist()
      body+mined:-Blocks= df[df['BoolCol'] == True]
      body+mined:-Inline= df[df['BoolCol'] == True].index.tolist()

================================================================================

QUESTION: idx=146    id=299446
-------------------------------------INPUTS-------------------------------------

tags: 
score: 29
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['owd']}
intent: change working directory to the directory `owd`
body(Left in tags for better readability):
<p> I have a function that resembles the one below. I'm not sure how
to use the os module to get back to my original working directory at
the conclusion of the jar's execution.
<code_block>
 def run():
    owd = os.getcwd()
    #first change dir to build_dir path
    os.chdir(testDir)
    #run jar from test directory
    os.system(cmd)
    #change dir back to original working directory (owd)

<p> note: I think my code formatting is off - not sure why. My
apologies in advance

-------------------------------------OUTPUT-------------------------------------

                Expected= 'os.chdir(owd)'
           base:Baseline= os.chdir('owd')
           body:Baseline= os.chdir(testDir)
            body:-Blocks= os.chdir(owd)
              body:-Code= os.chdir('owd')
            body:-Inline= os.chdir(owd)
                body:-NL= os.chdir(owd)
             base:+Mined= os.chdir('owd')
     body+mined:Baseline= os.chdir(testDir)
        body+mined:-Code= os.chdir('/tmp/owd')
          body+mined:-NL= os.chdir(os.path.dirname(__file__))
      body+mined:-Blocks= os.chdir(os.path.dirname(owd))
      body+mined:-Inline= os.chdir(__file__)

================================================================================

QUESTION: idx=147    id=14695134
-------------------------------------INPUTS-------------------------------------

tags: mysql, sql, database, sqlite
score: 9
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['testfield', 'c']}
intent: insert data from a string `testfield` to sqlite db `c`
body(Left in tags for better readability):
<p> I'm trying to insert strings read from a file into an <code>
sqlite <p>  database in Python. The strings have whitespace (newline,
tab characters, and spaces) and also have appearances of single or
double quotes.  Here's how I try to do it:
<code_block>
 import sqlite3
conn = sqlite3.connect('example.db')
c = conn.cursor()

# Create table
c.execute('''CREATE TABLE test
             (a text, b text)''')

f = open("foo", "w")
f.write("hello\n\'world\'\n")
f.close()

testfield = open("foo").read()

# Insert a row of data
c.execute("INSERT INTO test VALUES ('%s', 'bar')" %(testfield))

# Save (commit) the changes
conn.commit()

<p> I find that this fails with the error:
<code_block>
     c.execute("INSERT INTO test VALUES ('%s', 'bar')" %(testfield))
sqlite3.OperationalError: near "world": syntax error

<p> How can I achieve this? Do the strings need to be escaped before
insertion in the db, and if so how? thanks.

-------------------------------------OUTPUT-------------------------------------

                Expected= 'c.execute("INSERT INTO test VALUES (?, \'bar\')", (testfield,))'
           base:Baseline= c.execute('INSERT INTO testfield')
           body:Baseline= c = sqlite3.connect('example.db')
            body:-Blocks= c = db.read_csv('testfield')
              body:-Code= c = db.insert(testfield)
            body:-Inline= c.execute('INSERT INTO test VALUES ('%s', 'bar') % (testfield))
                body:-NL= c.execute('INSERT INTO test VALUES ('%s', 'bar') % (testfield))
             base:+Mined= cursor.execute('INSERT INTO testfield VALUES (%s, %s)', (testfield,))
     body+mined:Baseline= c.execute('INSERT INTO test VALUES ('%s', 'bar')' % (testfield))
        body+mined:-Code= cursor.execute('INSERT INTO testfield (text) VALUES (%s)', (testfield,))
          body+mined:-NL= c.execute('INSERT INTO test VALUES ('%s', 'bar')' % (testfield))
      body+mined:-Blocks= cursor.execute('INSERT INTO testfield data (newline) VALUES (%s)', testfield)
      body+mined:-Inline= c.execute('SELECT * FROM testfield WHERE bar = {}')

================================================================================

QUESTION: idx=148    id=24242433
-------------------------------------INPUTS-------------------------------------

tags: string, rawstring
score: 22
slot_map: {'key': ['str_0'], 'quote': ['"'], 'type': ['str'], 'value': ['\\x89\\n']}
intent: decode string "\\x89\\n" into a normal string
body(Left in tags for better readability):
<p> In Python, I have a string like this:
<code_block>
 '\\x89\\n'

<p> How can I decode it into a normal string like:
<code_block>
 '\x89\n'


-------------------------------------OUTPUT-------------------------------------

                Expected= '"""\\\\x89\\\\n""".decode(\'string_escape\')'
           base:Baseline= """\\x89\\n""".decode('normal')
           body:Baseline= """\\x89\\n""".decode('normal')
            body:-Blocks= """\\x89\\n""".decode('normal')
              body:-Code= """\\x89\\n""".decode('normal')
            body:-Inline= """\\x89\\n""".decode('normal')
                body:-NL= """\\x89\\n""".decode('normal')
             base:+Mined= """\\x89\\n""".decode('normal')
     body+mined:Baseline= """""".decode('\\x89\\n')
        body+mined:-Code= """\\x89\\n""".decode('normal')
          body+mined:-NL= """\\x89\\n""".decode('unicode-escape')
      body+mined:-Blocks= ""\\x89\\n""".decode('utf-8')
      body+mined:-Inline= normalize('NFKD', 'x89\\n')

================================================================================

QUESTION: idx=149    id=24242433
-------------------------------------INPUTS-------------------------------------

tags: string, rawstring
score: 22
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['raw_string']}
intent: convert a raw string `raw_string` into a normal string
body(Left in tags for better readability):
<p> In Python, I have a string like this:
<code_block>
 '\\x89\\n'

<p> How can I decode it into a normal string like:
<code_block>
 '\x89\n'


-------------------------------------OUTPUT-------------------------------------

                Expected= "raw_string.decode('string_escape')"
           base:Baseline= """""".join(raw_string.split())
           body:Baseline= raw_string.decode('normal')
            body:-Blocks= raw_string.decode('normal')
              body:-Code= raw_string.decode('normal')
            body:-Inline= raw_string.decode('normal')
                body:-NL= raw_string.split('\x89\\n')
             base:+Mined= """""".join(raw_string)
     body+mined:Baseline= """""".join(raw_string)
        body+mined:-Code= raw_string.decode('normal')
          body+mined:-NL= raw_string.split('\x89\\n')
      body+mined:-Blocks= raw_string.decode('utf-8')
      body+mined:-Inline= """""".join(raw_string)

================================================================================

QUESTION: idx=150    id=24242433
-------------------------------------INPUTS-------------------------------------

tags: string, rawstring
score: 22
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['raw_byte_string']}
intent: convert a raw string `raw_byte_string` into a normal string
body(Left in tags for better readability):
<p> In Python, I have a string like this:
<code_block>
 '\\x89\\n'

<p> How can I decode it into a normal string like:
<code_block>
 '\x89\n'


-------------------------------------OUTPUT-------------------------------------

                Expected= "raw_byte_string.decode('unicode_escape')"
           base:Baseline= """raw_byte_string""".split()
           body:Baseline= raw_byte_string.decode('normal')
            body:-Blocks= raw_byte_string.decode('normal')
              body:-Code= raw_byte_string.decode('normal')
            body:-Inline= raw_byte_string.decode('normal')
                body:-NL= raw_byte_string.split('\x89\\n')
             base:+Mined= """""".join(raw_byte_string)
     body+mined:Baseline= """""".join(raw_byte_string)
        body+mined:-Code= raw_byte_string.decode('unicode_escape')
          body+mined:-NL= """""".join(raw_byte_string.split(','))
      body+mined:-Blocks= """""".join(chr(raw_byte_string))
      body+mined:-Inline= """""".join(raw_byte_string)

================================================================================

QUESTION: idx=151    id=22882922
-------------------------------------INPUTS-------------------------------------

tags: regex, string
score: 20
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['s']}
intent: split a string `s` with into all strings of repeated characters
body(Left in tags for better readability):
<p> I am not well experienced with Regex but I have been reading a lot
about it. Assume there's a string <code> s = '111234' <p>  I want a
list with the string split into <code> L = ['111', '2', '3', '4'] <p>
. My approach was to make a group checking if it's a digit or not and
then check for a repetition of the group. Something like this
<code_block>
 L = re.findall('\d[\1+]', s)

<p> I think that <code> \d[\1+] <p>  will basically check for either
"digit" or "digit +" the same repetitions. I think this might do what
I want.

-------------------------------------OUTPUT-------------------------------------

                Expected= "[m.group(0) for m in re.finditer('(\\\\d)\\\\1*', s)]"
           base:Baseline= re.split('\\d+', s)
           body:Baseline= re.findall('\\d[\\1+]', s)
            body:-Blocks= re.split('\\d+', s)
              body:-Code= re.findall('\\d+', s)
            body:-Inline= re.findall('\\d[\\1+]', s)
                body:-NL= re.findall('\\d[\\1+]', s)
             base:+Mined= re.findall('\\s+', s)
     body+mined:Baseline= L = re.findall('\\d[\\1+]', s)
        body+mined:-Code= re.findall('\\d+', s)
          body+mined:-NL= re.findall('\\d[\\1+]', s)
      body+mined:-Blocks= re.findall('\\d+(?<=\\d+)', s)
      body+mined:-Inline= re.findall('\\d[\\1+]', s)

================================================================================

QUESTION: idx=152    id=4143502
-------------------------------------INPUTS-------------------------------------

tags: matplotlib, geometry, scatter-plot, scatter
score: 192
slot_map: {'key': ['str_0'], 'quote': ['`'], 'type': ['str'], 'value': ['np.random.randn(100)']}
intent: scatter a plot with x, y position of `np.random.randn(100)` and face color equal to none
body(Left in tags for better readability):
<p> In Python, with Matplotlib, how can a scatter plot with <em> empty
<p>  circles be plotted?  The goal is to draw empty circles around
<em> some <p>  of the colored disks already plotted by <code>
scatter() <p> , so as to highlight them, ideally without having to
redraw the colored circles.
<p> I tried <code> facecolors=None <p> , to no avail.

-------------------------------------OUTPUT-------------------------------------

                Expected= "plt.scatter(np.random.randn(100), np.random.randn(100), facecolors='none')"
           base:Baseline= np.random.randn(100)
           body:Baseline= np.random.randn(100)
            body:-Blocks= plt.scatter(np.random.randn(100))
              body:-Code= plt.scatter(np.random.randn(100))
            body:-Inline= np.random.randn(100)
                body:-NL= np.random.randn(100)
             base:+Mined= plt.savefig('np.random.randn(100)')
     body+mined:Baseline= plt.plot(x, y, na.random.randn(100))
        body+mined:-Code= plt.scatter(x, y, marker=np.random.randn(100))
          body+mined:-NL= plt.plot(x, y, np.random.randn(100))
      body+mined:-Blocks= plt.scatter(x, y, z, marker=np.random.randn(100))
      body+mined:-Inline= plt.plot(x, y, 'np.random.randn(100))

================================================================================

QUESTION: idx=153    id=4143502
-------------------------------------INPUTS-------------------------------------

tags: matplotlib, geometry, scatter-plot, scatter
score: 192
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: do a scatter plot with empty circles
body(Left in tags for better readability):
<p> In Python, with Matplotlib, how can a scatter plot with <em> empty
<p>  circles be plotted?  The goal is to draw empty circles around
<em> some <p>  of the colored disks already plotted by <code>
scatter() <p> , so as to highlight them, ideally without having to
redraw the colored circles.
<p> I tried <code> facecolors=None <p> , to no avail.

-------------------------------------OUTPUT-------------------------------------

                Expected= "plt.plot(np.random.randn(100), np.random.randn(100), 'o', mfc='none')"
           base:Baseline= plt.scatter(background=False)
           body:Baseline= re.findall('\n')[::-1]
            body:-Blocks= plt.scatter(inner=None)
              body:-Code= plt.scatter('\n')
            body:-Inline= plt. scatterplot(empty circles)
                body:-NL= sorted(list(range(10)), key=lambda x: x[1])
             base:+Mined= plt.plot(x, y)
     body+mined:Baseline= ax.spines['left'].set_visible(False)
        body+mined:-Code= plt.scatter(ax.get_yticklabels(), marker='r')
          body+mined:-NL= plt.plot(x, y, 'bo')
      body+mined:-Blocks= ax.scatter(x, y, color='r', label='black')
      body+mined:-Inline= plt.plot(x, y, 'r')

================================================================================

QUESTION: idx=154    id=32063985
-------------------------------------INPUTS-------------------------------------

tags: beautifulsoup
score: 37
slot_map: {'key': ['str_0'], 'quote': ['`'], 'type': ['str'], 'value': ['main-content']}
intent: remove a div with a id `main-content` using beautifulsoup
body(Left in tags for better readability):
<p> I want to delete the specific <code> div <p>  from <code> soup <p>
object.
<p> I am using <code> python 2.7 <p>  and <code> bs4 <p> .
<p> According to documentation we can use <code> div.decompose() <p> .
<p> But that would delete all the <code> div <p> . How can I delete a
<code> div <p>  with specific class?

-------------------------------------OUTPUT-------------------------------------

                Expected= "soup.find('div', id='main-content').decompose()"
           base:Baseline= soup.findAll(id=main - content)
           body:Baseline= soup.delete(div, id=main - content)
            body:-Blocks= soup.remove(id=main - content)
              body:-Code= beautifulsoup.remove(id=main - content)
            body:-Inline= soup.delete(div, id=main - content)
                body:-NL= soup.remove(div, id=main - content)
             base:+Mined= soup.findAll(id=maincontent)
     body+mined:Baseline= soup.pop('main-content', None)
        body+mined:-Code= soup.findAll('div', id=main - content)
          body+mined:-NL= soup.pop('div', None)
      body+mined:-Blocks= soup.remove(div, id=main - content)
      body+mined:-Inline= soup.body.filter(div__name__in=['main-content'])

================================================================================

QUESTION: idx=155    id=27975069
-------------------------------------INPUTS-------------------------------------

tags: pandas, dataframe
score: 189
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['ball', 'ids']}
intent: filter rows containing key word `ball` in column `ids`
body(Left in tags for better readability):
<p> Assume we have a data frame in Python Pandas that looks like this:
<code_block>
 df = pd.DataFrame({'vals': [1, 2, 3, 4], 'ids': [u'aball', u'bball',
u'cnut', u'fball']})

<p> Or, in table form:
<code_block>
 ids    vals
aball   1
bball   2
cnut    3
fball   4

<p> How do I filter rows which contain the key word "ball?" For
example, the output should be:
<code_block>
 ids    vals
aball   1
bball   2
fball   4


-------------------------------------OUTPUT-------------------------------------

                Expected= "df[df['ids'].str.contains('ball')]"
           base:Baseline= ids.filter(key=lambda x: x[1])
           body:Baseline= df = pd.DataFrame({'vals': [1, 2, 3, 4], 'ids': ['aball', 'bball', 'cnut',
    'fball']})
            body:-Blocks= ids.filter(key=lambda x: x['ball'])
              body:-Code= ids.filter(key=lambda x: x['ball']))
            body:-Inline= df.filter(ids, key=lambda x: x['ball']))
                body:-NL= df.filter(ids, key=lambda x: x['bball']))
             base:+Mined= ids.filter(id__in=['ball', 'id'])
     body+mined:Baseline= df['ids'] = df['ball'].apply(lambda x: x.groupby('ball'))
        body+mined:-Code= df[df.columns.contains('ball')]
          body+mined:-NL= df.loc[df['ids'] == 'bball']
      body+mined:-Blocks= df['ids'] = df['ball'].str.contains('ball')
      body+mined:-Inline= df[df['ids']].str.contains('ball')

================================================================================

QUESTION: idx=156    id=20461165
-------------------------------------INPUTS-------------------------------------

tags: pandas, dataframe, indexing, series
score: 557
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['df']}
intent: convert index at level 0 into a column in dataframe `df`
body(Left in tags for better readability):
<p> This seems rather obvious, but I can't seem to figure out how to
convert an index of data frame to a column?
<p> For example:
<code_block>
 df=
        gi       ptt_loc
 0  384444683      593
 1  384444684      594
 2  384444686      596

<p> To,
<code_block>
 df=
    index1    gi       ptt_loc
 0  0     384444683      593
 1  1     384444684      594
 2  2     384444686      596


-------------------------------------OUTPUT-------------------------------------

                Expected= 'df.reset_index(level=0, inplace=True)'
           base:Baseline= df.columns[0:]]
           body:Baseline= df.index1 = df.columns[0]
            body:-Blocks= df['index'] = df['index'].columns
              body:-Code= df['index'] = df['column']
            body:-Inline= df.columns[:, (level 0)]
                body:-NL= df.columns.reset_index(level=0)
             base:+Mined= df.set_index(level=0)
     body+mined:Baseline= df.columns = ['index1', 'gi', 'ptt_loc']
        body+mined:-Code= df['column'] = df['column'].astype(float)
          body+mined:-NL= df.columns = ['index1', 'index2']
      body+mined:-Blocks= df['column'] = df['column'].astype(float)
      body+mined:-Inline= df.columns = ['index1', 'ptt_loc']

================================================================================

QUESTION: idx=157    id=20461165
-------------------------------------INPUTS-------------------------------------

tags: pandas, dataframe, indexing, series
score: 557
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['df', 'index1']}
intent: add indexes in a data frame `df` to a column `index1`
body(Left in tags for better readability):
<p> This seems rather obvious, but I can't seem to figure out how to
convert an index of data frame to a column?
<p> For example:
<code_block>
 df=
        gi       ptt_loc
 0  384444683      593
 1  384444684      594
 2  384444686      596

<p> To,
<code_block>
 df=
    index1    gi       ptt_loc
 0  0     384444683      593
 1  1     384444684      594
 2  2     384444686      596


-------------------------------------OUTPUT-------------------------------------

                Expected= "df['index1'] = df.index"
           base:Baseline= df.index1[index1:]
           body:Baseline= df[index1].index1]
            body:-Blocks= df.index1 = df.columns
              body:-Code= df['index1'] = index1
            body:-Inline= df[index1].index1.columns
                body:-NL= df[index1:] = df.index1
             base:+Mined= df.set_index('index1')
     body+mined:Baseline= df['index1'] = df['ptt_loc']
        body+mined:-Code= df['index1'] = index1
          body+mined:-NL= df['index1'] = df.index.get_level_values(0)
      body+mined:-Blocks= df.set_index('index1')
      body+mined:-Inline= df.columns = ['index1', 'index2']

================================================================================

QUESTION: idx=158    id=20461165
-------------------------------------INPUTS-------------------------------------

tags: pandas, dataframe, indexing, series
score: 557
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: convert pandas index in a dataframe to columns
body(Left in tags for better readability):
<p> This seems rather obvious, but I can't seem to figure out how to
convert an index of data frame to a column?
<p> For example:
<code_block>
 df=
        gi       ptt_loc
 0  384444683      593
 1  384444684      594
 2  384444686      596

<p> To,
<code_block>
 df=
    index1    gi       ptt_loc
 0  0     384444683      593
 1  1     384444684      594
 2  2     384444686      596


-------------------------------------OUTPUT-------------------------------------

                Expected= "df.reset_index(level=['tick', 'obs'])"
           base:Baseline= df['index'] = df['index'].columns
           body:Baseline= df.to_columns().tolist()
            body:-Blocks= pd.concat([df.index, df.columns])
              body:-Code= df['index'] = df['columns']
            body:-Inline= df.to_columns().index()
                body:-NL= df.columns.reset_index()
             base:+Mined= pd.concat([df1, df2], axis=1)
     body+mined:Baseline= df.columns = ['index1', 'gi', 'ptt_loc']
        body+mined:-Code= df['column'] = df['column'].astype(float)
          body+mined:-NL= df.columns = ['index1', 'index2']
      body+mined:-Blocks= df['col'] = df['col'].astype(float)
      body+mined:-Inline= df.columns = ['gi', 'ptt_loc']

================================================================================

QUESTION: idx=159    id=4685571
-------------------------------------INPUTS-------------------------------------

tags: sequences
score: 4
slot_map: {'key': ['str_0'], 'quote': ["'"], 'type': ['str'], 'value': ['b']}
intent: get reverse of list items from list 'b' using extended slicing
body(Left in tags for better readability):
<code_block>
 <console_in> b=[('spam',0), ('eggs',1)]
<console_in> [reversed(x) for x in b]
<console_out> [ <reversed object at 0x7fbf07de7090>, <reversed object
at 0x7fbf07de70d0>]

<p> Bummer. I expected to get a list of reversed tuples!
<p> Sure I can do:
<code_block>
 <console_in> [tuple(reversed(x)) for x in b]
<console_out> [(0, 'spam'), (1, 'eggs')]

<p> But I hoped for something generic? Smth that when being handed
over a list of tuples, returns a list of reversed tuples, and when
handed over a list of lists, returns a list of reversed lists.
<p> Sure, an ugly hack with isinstance() is always available but I
kind of hoped avoiding going that route.

-------------------------------------OUTPUT-------------------------------------

                Expected= '[x[::-1] for x in b]'
           base:Baseline= [x[0] for x in b]
           body:Baseline= [tuple(x) for x in b]
            body:-Blocks= [(x, y) for x, y in zip(b, b)]
              body:-Code= [item[0] for item in b]
            body:-Inline= [tuple(reversed(x) for x in b]
                body:-NL= [tuple(x) for x in b]
             base:+Mined= [x[0] for x in a]
     body+mined:Baseline= [tuple(x) for x in b for y in reversed(x)]
        body+mined:-Code= [x[::-1] for x in b]
          body+mined:-NL= [tuple(x) for x in b]
      body+mined:-Blocks= [x[::-1] for x in a]
      body+mined:-Inline= [tuple(x) for x in b for y in b]

================================================================================

QUESTION: idx=160    id=17960441
-------------------------------------INPUTS-------------------------------------

tags: arrays, numpy, zip
score: 34
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['a', 'b']}
intent: join each element in array `a` with element at the same index in array `b` as a tuple
body(Left in tags for better readability):
<p> For example I have 2 arrays
<code_block>
 a = array([[0, 1, 2, 3],
           [4, 5, 6, 7]])
b = array([[0, 1, 2, 3],
           [4, 5, 6, 7]])

<p> How can I <code> zip
<code> a <p>  and <code> b <p>  so I get
<code_block>
 c = array([[(0,0), (1,1), (2,2), (3,3)],
           [(4,4), (5,5), (6,6), (7,7)]])

<p> ?

-------------------------------------OUTPUT-------------------------------------

                Expected= 'np.array([zip(x, y) for x, y in zip(a, b)])'
           base:Baseline= [x[0] for x in zip(a, b)]
           body:Baseline= [(x, y) for x, y in a, b)]
            body:-Blocks= zip(a, b, c)
              body:-Code= [(x, y) for x, y in zip(a, b)]
            body:-Inline= [(x, y) for x, y in zip(a, b)]
                body:-NL= [(x, y) for x, y in zip(a, b)]
             base:+Mined= a, b = zip(a[i], b[i])
     body+mined:Baseline= c = zip(*a, b)
        body+mined:-Code= tuple(zip(a, b))
          body+mined:-NL= a[np.arange(b)] = zip(*a)
      body+mined:-Blocks= zip(a, b, c)
      body+mined:-Inline= [[(0, 0), (1, 1), (2, 2), (3, 3), (4, 5, 6, 7]])

================================================================================

QUESTION: idx=161    id=17960441
-------------------------------------INPUTS-------------------------------------

tags: arrays, numpy, zip
score: 34
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['a', 'b']}
intent: zip two 2-d arrays `a` and `b`
body(Left in tags for better readability):
<p> For example I have 2 arrays
<code_block>
 a = array([[0, 1, 2, 3],
           [4, 5, 6, 7]])
b = array([[0, 1, 2, 3],
           [4, 5, 6, 7]])

<p> How can I <code> zip
<code> a <p>  and <code> b <p>  so I get
<code_block>
 c = array([[(0,0), (1,1), (2,2), (3,3)],
           [(4,4), (5,5), (6,6), (7,7)]])

<p> ?

-------------------------------------OUTPUT-------------------------------------

                Expected= "np.array(zip(a.ravel(), b.ravel()), dtype='i4,i4').reshape(a.shape)"
           base:Baseline= zip(a, b, c)
           body:Baseline= zip(a, b, c)
            body:-Blocks= zip([a, b]) for a, b in zip(A, B)]
              body:-Code= zip([a, b]) for a, b in zip(A, B)]
            body:-Inline= zip(a, b, c)
                body:-NL= zip(a, b, c)
             base:+Mined= zip(a, b, c)
     body+mined:Baseline= zip(zip(a, b), reverse=True)
        body+mined:-Code= zip(a, b, axis=1)
          body+mined:-NL= zip([0, 0), (1, 1), (2, 2), (3, 3)],
      body+mined:-Blocks= zip(a, b, c)
      body+mined:-Inline= zip(a, b, c)

================================================================================

QUESTION: idx=162    id=438684
-------------------------------------INPUTS-------------------------------------

tags: 
score: 28
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['list_of_ints']}
intent: convert list `list_of_ints` into a comma separated string
body(Left in tags for better readability):
<p> I'm new to python, and have a list of longs which I want to join
together into a comma separated string.
<p> In PHP I'd do something like this:
<code_block>
 $output = implode(",", $array)

<p> In Python, I'm not sure how to do this. I've tried using join, but
this doesn't work since the elements are the wrong type (i.e., not
strings). Do I need to create a copy of the list and convert each
element in the copy from a long into a string? Or is there a simpler
way to do it?

-------------------------------------OUTPUT-------------------------------------

                Expected= '""",""".join([str(i) for i in list_of_ints])'
           base:Baseline= """""".join(map(list_of_ints))
           body:Baseline= """""".join(list_of_ints)
            body:-Blocks= """.join(list_of_ints)
              body:-Code= """""".join(list_of_ints)
            body:-Inline= """""".join(list_of_ints)
                body:-NL= print(list_of_ints.split())
             base:+Mined= """ """.join(map(str, list_of_ints))
     body+mined:Baseline= """""".join(list_of_ints)
        body+mined:-Code= """""".join(list_of_ints)
          body+mined:-NL= """ """.join(map(str, list_of_ints))
      body+mined:-Blocks= """""".join(map(str, list_of_ints))
      body+mined:-Inline= """""".join(map(str, list_of_ints))

================================================================================

QUESTION: idx=163    id=8519922
-------------------------------------INPUTS-------------------------------------

tags: post, curl, urllib2, pycurl
score: 9
slot_map: {'key': ['var_0', 'var_1', 'var_2'], 'quote': ['`', '`', '`'], 'type': ['var', 'var', 'var'], 'value': ['DATA', 'username', 'password']}
intent: send a post request with raw data `data` and basic authentication with `username` and `password`
body(Left in tags for better readability):
<p> I'm playing around with the Google Checkout API and I want to pull
it into a Django app. I need to post data to Google using basic http
authentication. I've been testing this with <code> curl <p>  like
this:
<code_block>
 curl -d "$(cat mytest.xml)" -u username:password https://url

<p> And that posts the content of my test XML file to Google. And it
works fine!
<p> But I'm having problems porting that simple line to Python. I've
managed several different ways (httplib2, urllib2, pycurl) of
connecting with a password and posting something but the respose is
always 400 BAD REQUEST.
<p> Is there a python equivalent for posting block of text to a HTTP
Basic auth server? I'm running out of walls to bang my head against.

<p> Apologies for not adding any code. Here are some of my greatest
hits. In each, <code> DATA <p>  is an XML string. <code> URL <p> ,
<code> USERNAME <p>  and <code> PASSWORD <p>  are constant.
<code_block>
 req = urllib2.Request(URL)
req.add_header("Authorization", "Basic %s" %
base64.encodestring('%s:%s'%(USERNAME, PASSWORD)))
u = urllib2.urlopen(req, DATA)

<p> Gives me a lovely <code> HTTP Error 400: Bad Request

<code_block>
 passman = urllib2.HTTPPasswordMgrWithDefaultRealm()
passman.add_password(None, URL, USERNAME, PASSWORD)
authhandler = urllib2.HTTPBasicAuthHandler(passman)
opener = urllib2.build_opener(authhandler)
urllib2.install_opener(opener)
pagehandle = urllib2.urlopen(URL, DATA)

<p> Gives <code> HTTP Error 401: Unauthorized

<code_block>
 pycurl.global_init(pycurl.GLOBAL_DEFAULT)
c = pycurl.Curl()
c.setopt(pycurl.URL, URL)
c.setopt(pycurl.USERPWD, "%s:%s" % (USERNAME,PASSWORD))
c.setopt(pycurl.POST, 1)
c.setopt(pycurl.HTTPHEADER, ["Content-type: text/xml"])
c.setopt(pycurl.POSTFIELDS, DATA)
b = StringIO.StringIO()
c.setopt(pycurl.WRITEFUNCTION, b.write)
c.perform()

<p> Seems to struggle with passing the <code> DATA <p>  string as a
POSTFIELD. I've tried <code> urllib.urlencode() <p> ing DATA in
several different ways but

<code_block>
 h = httplib2.Http()
h.add_credentials(USERNAME, PASSWORD)
print = h.request(URL, "POST", body=base64.encodestring(DATA))

<p> The credentials don't seem to do anything - I get an unauthorised
message back from Google.
<p> There are more but they're all based on these.

-------------------------------------OUTPUT-------------------------------------

                Expected= 'requests.post(url, data=DATA, headers=HEADERS_DICT, auth=(username, password))'
           base:Baseline= r = requests.post(data, verify=False)
           body:Baseline= urllib2.request.urlopen(URL, DATA)
            body:-Blocks= r = requests.post(data, auth={'username': 'password'})
              body:-Code= requests.get('data', headers={'username': 'password'})
            body:-Inline= urllib2.request.urlopen(URL, DATA)
                body:-NL= urllib2.request(URL, 'POST', body=base64.encodestring(DATA))
             base:+Mined= r = requests.post(url, data=data, password=password)
     body+mined:Baseline= r = requests.post(url, data=data)
        body+mined:-Code= r = requests.post(url, headers={'username': 'password'})
          body+mined:-NL= r = requests.post(url, data=data)
      body+mined:-Blocks= urllib.request.urlencode('HTTP/1.0 200 OK')
      body+mined:-Inline= requests.get('http://google.com', auth=('username', 'password'))

================================================================================

QUESTION: idx=164    id=26443308
-------------------------------------INPUTS-------------------------------------

tags: 
score: 34
slot_map: {'key': ['str_0', 'str_1'], 'quote': ["'", '"'], 'type': ['str', 'str'], 'value': ['}', 'abcd}def}']}
intent: find last occurrence of character '}' in string "abcd}def}"
body(Left in tags for better readability):
<p> How would I find the last occurrence of a character in a string?
<code_block>
 string = "abcd}def}"
string = string.find('}',last) # Want something like this


-------------------------------------OUTPUT-------------------------------------

                Expected= '"""abcd}def}""".rfind(\'}\')'
           base:Baseline= re.findall('{}', 'abcd}def}"
           body:Baseline= string = string.find('}', last)
            body:-Blocks= """abcd}def""".last()
              body:-Code= '}'.last(abcd}def}"
            body:-Inline= string = string.find('}', last)
                body:-NL= string = string.find('}', last)
             base:+Mined= """abcd}def""".rstrip('}')
     body+mined:Baseline= string = string.find('{}', 1)
        body+mined:-Code= """abcd}def""".index('}')
          body+mined:-NL= string = string.find('}', last)
      body+mined:-Blocks= len('{}'.format('abcd}def}"))
      body+mined:-Inline= '}' + 'abcd}def'

================================================================================

QUESTION: idx=165    id=22365172
-------------------------------------INPUTS-------------------------------------

tags: for-loop, syntax
score: 4
slot_map: {'key': ['str_0', '[str_0]'], 'quote': ['`', '`'], 'type': ['str', 'str'], 'value': ['[1, 2, 3]', '[1, 2, 3]']}
intent: iterate ove list `[1, 2, 3]` using list comprehension
body(Left in tags for better readability):
<p> I am experiencing a bit of confusion with how to place a for loop
at the end of a line in python, for instance
<code_block>
 for i in x:
    print i

<p> produces the expected result but if I run
<code_block>
 print i for i in x

<p> I get a syntax error. Could someone explain a little more about
how one goes about putting your for loops at the end of a line like
this.

-------------------------------------OUTPUT-------------------------------------

                Expected= 'print([item for item in [1, 2, 3]])'
           base:Baseline= for i in [1, 2, 3])
           body:Baseline= for i in [1, 2, 3]
            body:-Blocks= for i in [1, 2, 3])
              body:-Code= for line in [1, 2, 3])
            body:-Inline= for i in [1, 2, 3])
                body:-NL= for i in [1, 2, 3])
             base:+Mined= [i for i in range(0, len(i), [1, 2, 3])]
     body+mined:Baseline= for i in [1, 2, 3]]
        body+mined:-Code= for (i in range(1, 2, 3) if i % 2 == 0)
          body+mined:-NL= for i in x:
    pass
      body+mined:-Blocks= [i for i in [1, 2, 3]]
      body+mined:-Inline= print(list(range(1, 2, 3))

================================================================================

QUESTION: idx=166    id=12300912
-------------------------------------INPUTS-------------------------------------

tags: optimization, dictionary
score: 7
slot_map: {'key': ['str_0', 'str_1', 'var_0'], 'quote': ["'", "'", '`'], 'type': ['str', 'str', 'var'], 'value': ['x', 'y', 'd']}
intent: extract all the values with keys 'x' and 'y' from a list of dictionaries `d` to list of tuples
body(Left in tags for better readability):
<p> I have a list of dictionaries like this:
<code_block>
  data = [{'x': 1, 'y': 10},
         {'x': 3, 'y': 15},
         {'x': 2, 'y': 1},
          <console_out> ]

<p> I have a function (for example <code> matplotlib.axis.plot <p> )
which needs lists of <code> x <p>  and <code> y <p>  values. So I have
to "transpose" the dictionary".
<p> First question: what do you call this operation? Is "transpose"
the correct term?
<p> I've tried this, but I'm searching for an efficient way (maybe
there are some special <code> numpy <p>  function):
<code_block>
 x = range(100)
y = reversed(range(100))
d = [dict((('x',xx), ('y', yy))) for (xx, yy) in zip(x,y)]
# d is [{'y': 99, 'x': 0}, {'y': 98, 'x': 1}, <console_out> ]

timeit.Timer("[dd['x'] for dd in d]", "from __main__ import
d").timeit()
# 6.803985118865967

from operator import itemgetter
timeit.Timer("map(itemgetter('x'), d)", "from __main__ import d,
itemgetter").timeit()
# 7.322326898574829

timeit.Timer("map(f, d)", "from __main__ import d, itemgetter;
f=itemgetter('x')").timeit()
# 7.098556041717529

# quite dangerous
timeit.Timer("[dd.values()[1] for dd in d]", "from __main__ import
d").timeit()
# 19.358459949493408

<p> Is there a better solution? My doubt is: in these cases the hash
of the string <code> 'x' <p> is recomputed every time?

-------------------------------------OUTPUT-------------------------------------

                Expected= "[(x['x'], x['y']) for x in d]"
           base:Baseline= [(k, v) for k, v in d.items() if 'x' in k]
           body:Baseline= timeit.Timer("[d.values()[1] for dd in d]', 'from __main__ import d").timeit()
            body:-Blocks= [d['x'] for d in d.items()]
              body:-Code= [d['x'] for d in zip(d.items()], d['y'])]
            body:-Inline= [d['x'] for d in zip(x, y)]
                body:-NL= [d['x'], d['y'] for d in zip(x, y])
             base:+Mined= [(d['x'], d['y'] for d in d]
     body+mined:Baseline= [dict((x, y) for x, y in zip(zip(x, Y))) for y in data]
        body+mined:-Code= [(v, k) for k, v in d.items()]
          body+mined:-NL= [d['x'] for d in zip(x, y)]
      body+mined:-Blocks= [{k: v for k, v in d.items() if v.isdigit()} for d in d]
      body+mined:-Inline= [(x, y) for x, y in zip(d, data)]

================================================================================

QUESTION: idx=167    id=678236
-------------------------------------INPUTS-------------------------------------

tags: string, path
score: 1172
slot_map: {'key': ['str_0'], 'quote': ["'"], 'type': ['str'], 'value': ['hemanth.txt']}
intent: get the filename without the extension from file 'hemanth.txt'
body(Left in tags for better readability):
<p> How to get the filename without the extension from a path in
Python?
<p> For instance, if I had <code> "/path/to/some/file.txt" <p> , I
would want <code> "file" <p> .

-------------------------------------OUTPUT-------------------------------------

                Expected= "print(os.path.splitext(os.path.basename('hemanth.txt'))[0])"
           base:Baseline= open('hemanth.txt', filename)
           body:Baseline= open('hemanth.txt', filename)
            body:-Blocks= os.path.isfile('hemanth.txt')
              body:-Code= os.path.isfile('hemanth.txt')
            body:-Inline= os.path.splitext('hemanth.txt')
                body:-NL= open('hemanth.txt', filename)
             base:+Mined= os.path.splitext('hemanth.txt')
     body+mined:Baseline= os.path.splitext('hemanth.txt')
        body+mined:-Code= os.path.splitext('hemanth.txt')
          body+mined:-NL= os.path.expanduser('hemanth.txt')
      body+mined:-Blocks= os.path.splitext('hemanth.txt')
      body+mined:-Inline= os.path.splitext('hemanth.txt', filename)

================================================================================

QUESTION: idx=168    id=2597166
-------------------------------------INPUTS-------------------------------------

tags: list, dictionary
score: 28
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['x']}
intent: create a dictionary by adding each two adjacent elements in tuple `x` as key/value pair to it
body(Left in tags for better readability):
<p> I need to transform a list into dictionary as follows.
The odd elements has the key, and even number elements has the value.
<code> x = (1,'a',2,'b',3,'c') <p>  -> <code> {1: 'a', 2: 'b', 3: 'c'}
<code_block>
 def set(self, val_):
    i = 0
    for val in val_:
        if i == 0:
            i = 1
            key = val
        else:
            i = 0
            self.dict[key] = val

<p> A better way to get the same results?
<h2> ADDED
<code_block>
 i = iter(k)
print dict(zip(i,i))

<p> seems to be working

-------------------------------------OUTPUT-------------------------------------

                Expected= 'dict(x[i:i + 2] for i in range(0, len(x), 2))'
           base:Baseline= dict((k, v) for k, v in x.items())
           body:Baseline= dict(zip(i, i))
            body:-Blocks= dict(zip(x, y))
              body:-Code= dict((k, v) for k, v in x.items())
            body:-Inline= dict(zip(x, key)
                body:-NL= dict((k, v) for k, v in x.items() if v == 0)
             base:+Mined= dict(x + y for x, y in zip(x, y))
     body+mined:Baseline= dict(zip(i, j) for i, j in zip(x, j))
        body+mined:-Code= dict(zip(x, y))
          body+mined:-NL= dict((k, v) for k, v in x.items() if v == 0)
      body+mined:-Blocks= dict(zip(x, y))
      body+mined:-Inline= dict(zip(i, j) for i, j in zip(x, i))

================================================================================

QUESTION: idx=169    id=7895449
-------------------------------------INPUTS-------------------------------------

tags: list, merge, list-comprehension, itertools
score: 6
slot_map: {'key': ['str_0', '[str_0]'], 'quote': ['`', '`'], 'type': ['str', 'str'], 'value': ["[['A', 'B', 'C'], ['D', 'E', 'F'], ['G', 'H', 'I']]", "[['A', 'B', 'C'], ['D', 'E', 'F'], ['G', 'H', 'I']]"]}
intent: create a list containing flattened list `[['a', 'b', 'c'], ['d', 'e', 'f'], ['g', 'h', 'i']]`
body(Left in tags for better readability):
<p> How do I merge a list of lists?
<code_block>
 [['A', 'B', 'C'], ['D', 'E', 'F'], ['G', 'H', 'I']]

<p> into
<code_block>
 ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I']

<p> Even better if I can add a value on the beginning and end of each
item before merging the lists, like html tags.
<p> i.e., the end result would be:
<code_block>
 [' <tr>A </tr>', ' <tr>B </tr>', ' <tr>C </tr>', ' <tr>D </tr>', '
<tr>E </tr>', ' <tr>F </tr>', ' <tr>G </tr>', ' <tr>H </tr>', ' <tr>I
</tr>']


-------------------------------------OUTPUT-------------------------------------

                Expected= "values = sum([['A', 'B', 'C'], ['D', 'E', 'F'], ['G', 'H', 'I']], [])"
           base:Baseline= [['a', 'b', 'c', ['d', 'e', 'f'], ['g', 'h', 'i']]]
           body:Baseline= [['A', 'B', 'C', 'D', 'E', 'F'], ['G', 'H', 'I']]]
            body:-Blocks= [['a', 'b', 'c', ['d', 'e', 'f'], ['g', 'h', 'i']]]
              body:-Code= [['a', 'b', 'c', ['d', 'e', 'f'], ['g', 'h', 'i']]]
            body:-Inline= [['A', 'B', 'C'], ['D', 'E', 'F'], ('G', 'H', 'I']]
                body:-NL= [['A', 'B', 'C', 'D', 'E', 'F'], ['G', 'H', 'I']]
             base:+Mined= [['a', 'b', 'c', ['d', 'e', 'f'], ['g', 'h', 'i']]
     body+mined:Baseline= [['A', 'B', 'C'], ['D', 'E', 'F', 'G', 'H', 'I']]
        body+mined:-Code= [['a', 'b', 'c', 'd', 'e', 'f'], ['g', 'h', 'i']]
          body+mined:-NL= [['A', 'B', 'C'], ['D', 'E', 'F'], 'G', 'H', 'I']]
      body+mined:-Blocks= [['a', 'b', 'c', 'd', 'e', 'f'], ['g', 'h', 'i']]
      body+mined:-Inline= [['A', 'B', 'C'], ['D', 'E', 'F', 'G', 'H', 'I']]

================================================================================

QUESTION: idx=170    id=31617845
-------------------------------------INPUTS-------------------------------------

tags: pandas
score: 109
slot_map: {'key': ['var_0', 'str_0'], 'quote': ['`', "'"], 'type': ['var', 'str'], 'value': ['df', 'closing_price']}
intent: select rows in a dataframe `df` column 'closing_price' between two values 99 and 101
body(Left in tags for better readability):
<p> I am trying to modify a DataFrame <code> df <p>  to only contain
rows for which the values in the column <code> closing_price <p>  are
between 99 and 101 and trying to do this with the code below.
<p> However, I get the error

<p> ValueError: The truth value of a Series is ambiguous. Use a.empty,
a.bool(), a.item(), a.any() or a.all()

<p> and I am wondering if there is a way to do this without using
loops.
<code_block>
 df = df[(99 <= df['closing_price'] <= 101)]


-------------------------------------OUTPUT-------------------------------------

                Expected= "df = df[(df['closing_price'] >= 99) & (df['closing_price'] <= 101)]"
           base:Baseline= df.loc[df['closing_price'] == 100]
           body:Baseline= df[99 <= df['closing_price'] <= 101]
            body:-Blocks= df.loc[df['closing_price'] == 99]
              body:-Code= df.loc[df['closing_price'] == 99]
            body:-Inline= df.loc[df['closing_price'] <= 99]
                body:-NL= df.loc[df['closing_price'] <= 99]
             base:+Mined= df.loc[df['closing_price'] > 99]
     body+mined:Baseline= df[df['closing_price'] > 99]
        body+mined:-Code= df.loc[df['closing_price'] > 99 and 101]
          body+mined:-NL= df[df['closing_price'] > 99]
      body+mined:-Blocks= df.loc[df['closing_price'] > 99]
      body+mined:-Inline= df[(99 <= df['closing_price'] <= 101)

================================================================================

QUESTION: idx=171    id=25698710
-------------------------------------INPUTS-------------------------------------

tags: replace, pandas, dataframe
score: 51
slot_map: {'key': ['str_0', 'str_1', 'var_0'], 'quote': ['`', '`', '`'], 'type': ['str', 'str', 'var'], 'value': ['\n', '<br>', 'df']}
intent: replace all occurences of newlines `\n` with `<br>` in dataframe `df`
body(Left in tags for better readability):
<p> I have a pandas dataframe with about 20 columns.
<p> It is possible to replace all occurrences of a string (here a
newline) by manually writing all column names:
<code_block>
 df['columnname1'] = df['columnname1'].str.replace("\n"," <br>")
df['columnname2'] = df['columnname2'].str.replace("\n"," <br>")
df['columnname3'] = df['columnname3'].str.replace("\n"," <br>")
<console_out>
df['columnname20'] = df['columnname20'].str.replace("\n"," <br>")

<p> This unfortunately does not work:
<code_block>
 df = df.replace("\n"," <br>")

<p> Is there any other, more elegant solution?

-------------------------------------OUTPUT-------------------------------------

                Expected= "df.replace({'\\n': '<br>'}, regex=True)"
           base:Baseline= df.replace('\n', '<br>')
           body:Baseline= df['columnname1'].replace('\n', '<br>')
            body:-Blocks= df.replace('\n', '<br>')
              body:-Code= df.replace('\n', '<br>')
            body:-Inline= df.replace('\n', '<br>')
                body:-NL= df.replace('\n', '<br>')
             base:+Mined= df.replace('\n', '<br>')
     body+mined:Baseline= df['columnname1'].str.replace('\\n', '<br>')
        body+mined:-Code= df.replace('\n', '<br>')
          body+mined:-NL= df['columnname1'].str.replace('\n', '<br>')
      body+mined:-Blocks= df.replace('\n', '<br>')
      body+mined:-Inline= df['columnname1'].str.replace('\n', '<br>')

================================================================================

QUESTION: idx=172    id=25698710
-------------------------------------INPUTS-------------------------------------

tags: replace, pandas, dataframe
score: 51
slot_map: {'key': ['str_0', 'str_1', 'var_0'], 'quote': ['`', '`', '`'], 'type': ['str', 'str', 'var'], 'value': ['\n', '<br>', 'df']}
intent: replace all occurrences of a string `\n` by string `<br>` in a pandas data frame `df`
body(Left in tags for better readability):
<p> I have a pandas dataframe with about 20 columns.
<p> It is possible to replace all occurrences of a string (here a
newline) by manually writing all column names:
<code_block>
 df['columnname1'] = df['columnname1'].str.replace("\n"," <br>")
df['columnname2'] = df['columnname2'].str.replace("\n"," <br>")
df['columnname3'] = df['columnname3'].str.replace("\n"," <br>")
<console_out>
df['columnname20'] = df['columnname20'].str.replace("\n"," <br>")

<p> This unfortunately does not work:
<code_block>
 df = df.replace("\n"," <br>")

<p> Is there any other, more elegant solution?

-------------------------------------OUTPUT-------------------------------------

                Expected= "df.replace({'\\n': '<br>'}, regex=True)"
           base:Baseline= df.replace('\n', '<br>')
           body:Baseline= df['columnname1'].str.replace('\n', '<br>')
            body:-Blocks= df.replace('\n', '<br>')
              body:-Code= df.replace('\n', '<br>')
            body:-Inline= df['columnname1'].str.replace('\n', '<br>')
                body:-NL= df.replace('\n', '<br>')
             base:+Mined= df.replace('\n', '<br>', '\n')
     body+mined:Baseline= df['columnname1'].str.replace('\\n', '<br>')
        body+mined:-Code= df.replace('\n', '<br>')
          body+mined:-NL= df['columnname1'].str.replace('\\n', '<br>')
      body+mined:-Blocks= df['col'] = df['col'].replace('\n', '<br>')
      body+mined:-Inline= df['columnname1'].str.replace('\\n', '<br>')

================================================================================

QUESTION: idx=173    id=41923858
-------------------------------------INPUTS-------------------------------------

tags: map-function
score: 3
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['word']}
intent: create a list containing each two adjacent letters in string `word` as its elements
body(Left in tags for better readability):
<p> I have a for loop that iterates through a string and returns pairs
of each character and the next following one:
<code_block>
 <console_in> word = 'abcdef'
<console_in> for i in range(len(word)-1):
<console_out>     print word[i:i+2]
<console_out>
ab
bc
cd
de
ef

<p> Is it possible to write this using a map/filter combination
instead? I'm having a problem figuring out how to get the next
character instead of using <code> i+2 <p> .
<p> I've tried to pass the word twice to map them together like this:
<code_block>
 <console_in> word = 'abcdef'
<console_in> map(lambda x, y: x+y, word, word[1:])
<console_out>
<p> But I'm unsure how to avoid the concatenation error with a str and
None:
<code_block>
 <console_in> map(lambda x, y: x+y, word, word[1:])
<console_out> Traceback (most recent call last):
  File " <stdin>", line 1, in <module>
  File " <stdin>", line 1, in <lambda>
TypeError: cannot concatenate 'str' and 'NoneType' objects


-------------------------------------OUTPUT-------------------------------------

                Expected= '[(x + y) for x, y in zip(word, word[1:])]'
           base:Baseline= [word[i:i + 2] for i in range(2)]
           body:Baseline= map(lambda x, y: x + y, word, word[1:])
            body:-Blocks= list(word.replace(',', ''))
              body:-Code= list(word.split(',')
            body:-Inline= word[i:i + 2]
                body:-NL= [(x + y) for x, y in word]
             base:+Mined= [i.split(' ', 1)[0] for i in word.split()]
     body+mined:Baseline= map(lambda x, y: x + y, word, word[1:])
        body+mined:-Code= [word[i:i + 1] for i in range(len(word), 1)]
          body+mined:-NL= map(lambda x, y: x + y, word, word[1:])
      body+mined:-Blocks= [word[i:i + 2] for i in range(0, len(word), 2)]
      body+mined:-Inline= [(x + y) for x, y in zip(word, word[1:])]

================================================================================

QUESTION: idx=174    id=41923858
-------------------------------------INPUTS-------------------------------------

tags: map-function
score: 3
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['word']}
intent: get a list of pairs from a string `word` using lambda function
body(Left in tags for better readability):
<p> I have a for loop that iterates through a string and returns pairs
of each character and the next following one:
<code_block>
 <console_in> word = 'abcdef'
<console_in> for i in range(len(word)-1):
<console_out>     print word[i:i+2]
<console_out>
ab
bc
cd
de
ef

<p> Is it possible to write this using a map/filter combination
instead? I'm having a problem figuring out how to get the next
character instead of using <code> i+2 <p> .
<p> I've tried to pass the word twice to map them together like this:
<code_block>
 <console_in> word = 'abcdef'
<console_in> map(lambda x, y: x+y, word, word[1:])
<console_out>
<p> But I'm unsure how to avoid the concatenation error with a str and
None:
<code_block>
 <console_in> map(lambda x, y: x+y, word, word[1:])
<console_out> Traceback (most recent call last):
  File " <stdin>", line 1, in <module>
  File " <stdin>", line 1, in <lambda>
TypeError: cannot concatenate 'str' and 'NoneType' objects


-------------------------------------OUTPUT-------------------------------------

                Expected= 'list(map(lambda x, y: x + y, word[:-1], word[1:]))'
           base:Baseline= [k for k, v in word.items()]
           body:Baseline= map(lambda x, y: x + y, word, word[1:])
            body:-Blocks= [k for k, v in word.split(',')]
              body:-Code= [k for k, v in word.split()]
            body:-Inline= print(word[i:i + 2])
                body:-NL= print(list(word.items()), key=lambda x: x[1])
             base:+Mined= [(k, v) for k, v in word.items()]
     body+mined:Baseline= map(lambda x, y: x + y, word, word[1:])
        body+mined:-Code= [(x, y) for x, y in word.split(',')]
          body+mined:-NL= map(lambda x, y: x + y, word, word[1:])
      body+mined:-Blocks= [(k, v) for k, v in word.split(',')]
      body+mined:-Inline= [(x + y) for x, y in zip(word, word[1:])]

================================================================================

QUESTION: idx=175    id=9760588
-------------------------------------INPUTS-------------------------------------

tags: string, url, extract
score: 13
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['myString']}
intent: extract a url from a string `mystring`
body(Left in tags for better readability):
<p> For example:
<code_block>
 string = "This is a link http://www.google.com"

<p> How could I extract 'http://www.google.com' ?
<p> (Each link will be of the same format i.e 'http://')

-------------------------------------OUTPUT-------------------------------------

                Expected= "print(re.findall('(https?://[^\\\\s]+)', myString))"
           base:Baseline= urllib.parse.quote(myString)
           body:Baseline= re.findall('http://www.google.com', mystring)
            body:-Blocks= myString.rfind('http://www.google.com')
              body:-Code= myString.rfind('http://www.google.com')
            body:-Inline= myString.rfindall('http://www.google.com')
                body:-NL= """This is a link http://www.google.com"".join(mystring)
             base:+Mined= urllib.parse.urlencode('utf-8')
     body+mined:Baseline= urllib.parse.urlretrieve('http://www.google.com', myString)
        body+mined:-Code= urllib.request.urlretrieve('http://www.google.com')
          body+mined:-NL= urllib.request.urlretrieve('http://www.google.com', myString)
      body+mined:-Blocks= urllib.parse.quote('http://www.google.com')
      body+mined:-Inline= urllib.request.urlretrieve('http://www.google.com', myString)

================================================================================

QUESTION: idx=176    id=9760588
-------------------------------------INPUTS-------------------------------------

tags: string, url, extract
score: 13
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['myString']}
intent: extract a url from a string `mystring`
body(Left in tags for better readability):
<p> For example:
<code_block>
 string = "This is a link http://www.google.com"

<p> How could I extract 'http://www.google.com' ?
<p> (Each link will be of the same format i.e 'http://')

-------------------------------------OUTPUT-------------------------------------

                Expected= "print(re.search('(?P<url>https?://[^\\\\s]+)', myString).group('url'))"
           base:Baseline= urllib.parse.quote(myString)
           body:Baseline= re.findall('http://www.google.com', mystring)
            body:-Blocks= myString.rfind('http://www.google.com')
              body:-Code= myString.rfind('http://www.google.com')
            body:-Inline= myString.rfindall('http://www.google.com')
                body:-NL= """This is a link http://www.google.com"".join(mystring)
             base:+Mined= urllib.parse.urlencode('utf-8')
     body+mined:Baseline= urllib.parse.urlretrieve('http://www.google.com', myString)
        body+mined:-Code= urllib.request.urlretrieve('http://www.google.com')
          body+mined:-NL= urllib.request.urlretrieve('http://www.google.com', myString)
      body+mined:-Blocks= urllib.parse.quote('http://www.google.com')
      body+mined:-Inline= urllib.request.urlretrieve('http://www.google.com', myString)

================================================================================

QUESTION: idx=177    id=5843518
-------------------------------------INPUTS-------------------------------------

tags: regex, string
score: 280
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['mystring']}
intent: remove all special characters, punctuation and spaces from a string `mystring` using regex
body(Left in tags for better readability):
<p> I need to remove all special characters, punctuation and spaces
from a string so that I only have letters and numbers.

-------------------------------------OUTPUT-------------------------------------

                Expected= "re.sub('[^A-Za-z0-9]+', '', mystring)"
           base:Baseline= re.sub('[^a-zA-Z]', myString)
           body:Baseline= re.sub('\\w+|\\W+||\\w+)', mystring)
            body:-Blocks= re.sub('\\w+', mystring)
              body:-Code= re.sub('\\w+', myString)
            body:-Inline= re.sub('[^a-z]', mystring)
                body:-NL= re.sub('\\s+', mystring)
             base:+Mined= re.sub('[^a-zA-Z]', '', mystring)
     body+mined:Baseline= re.sub('\\s+', '', mystring)
        body+mined:-Code= re.sub('[a-zA-Z]', '', mystring)
          body+mined:-NL= re.sub('[^a-zA-Z]', '', mystring)
      body+mined:-Blocks= re.sub('[^a-zA-Z]', '', mystring)
      body+mined:-Inline= re.sub('(\\w+)', '', myString)

================================================================================

QUESTION: idx=178    id=36674519
-------------------------------------INPUTS-------------------------------------

tags: datetime, pandas, indexing
score: 4
slot_map: {'key': ['str_0'], 'quote': ["'"], 'type': ['str'], 'value': ['2016-01-01']}
intent: create a datetimeindex containing 13 periods of the second friday of each month starting from date '2016-01-01'
body(Left in tags for better readability):
<p> I need to get the 2nd Friday of each month in Python.
<p> I have written the function below that demonstrates what I need.
However, I am wondering if there is a more elegant way to do it using
Pandas' <code> date_range <p>  function and appropriate offsets.
<code_block>
 def second_friday_of_month_date_range( start, end ):
    dr = pd.date_range( start, end, freq='MS' )

    first_weekday_of_month_to_2nd_friday_of_month = np.array( [ 12,
11, 10, 9, 8, 14, 13 ], dtype=int )
    wd                                            =
first_weekday_of_month_to_2nd_friday_of_month[ dr.weekday ]
    offsets                                       = [
datetime.timedelta( days=int(x)-1 ) for x in wd ]
    dts                                           = [d+o for d, o in
zip( dr, offsets)]
    return pd.DatetimeIndex( dts )

import pandas as pd
import datetime
d0 = datetime.datetime(2016,1,1)
d1 = datetime.datetime(2017,1,1)
dr = second_friday_of_month_date_range( d0, d1 )
print( dr )

>> DatetimeIndex(['2016-01-08', '2016-02-12', '2016-03-11',
'2016-04-08',
               '2016-05-13', '2016-06-10', '2016-07-08', '2016-08-12',
               '2016-09-09', '2016-10-14', '2016-11-11', '2016-12-09',
               '2017-01-13'],
              dtype='datetime64[ns]', freq=None, tz=None)


-------------------------------------OUTPUT-------------------------------------

                Expected= "pd.date_range('2016-01-01', freq='WOM-2FRI', periods=13)"
           base:Baseline= datetimeindex.date_range('2016-01-01', 13)
           body:Baseline= datetime.datetime_index(['2016-01-01', '%B-%Y-%M-%H'])
            body:-Blocks= pd.datetimeindex(datetime.date_range='2016-01-01', datetime.timedelta=13)
              body:-Code= pd.datetimeindex(datetime.strptime('2016-01-01', '%Y-%m-%d'))
            body:-Inline= pd.date_index(['2016-01-01', '%Y-%m-%d'])
                body:-NL= pd.datetimeindex(['2016-01-01', '%B-%d-%Y').date_range(13))
             base:+Mined= datetimeindex.date_range(12, '%Y-%m-%d')
     body+mined:Baseline= pd.to_datetime(pd.Timedelta(1970, 1, 1))
        body+mined:-Code= pd.to_datetime(pd.Timestamp('2016-01-01', '%Y-%m-%d').date()
          body+mined:-NL= pd.to_datetime(pd.Timedelta(days=int(x) for x in wd, dts)
      body+mined:-Blocks= df.date_range('2016-01-01', '%Y-%m-%d').date()
      body+mined:-Inline= datetime.datetime(2016, 1, 1) + datetime.timedelta(days=int(x) - 1)

================================================================================

QUESTION: idx=179    id=508657
-------------------------------------INPUTS-------------------------------------

tags: java, arrays
score: 8
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['matrix']}
intent: create multidimensional array `matrix` with 3 rows and 2 columns in python
body(Left in tags for better readability):
<p> I have a little Java problem I want to translate to Python.
Therefor I need a multidimensional array. In Java it looks like:
<code_block>
 double dArray[][][] = new
double[x.length()+1][y.length()+1][x.length()+y.length()+3];
dArray[0][0][0] = 0;
dArray[0][0][1] = POSITIVE_INFINITY;

<p> Further values will be created bei loops and written into the
array.
<p> How do I instantiate the array?
<p> PS: There is no matrix multiplication involved...

-------------------------------------OUTPUT-------------------------------------

                Expected= 'matrix = [[a, b], [c, d], [e, f]]'
           base:Baseline= matrix.shape(3, 2)
           body:Baseline= matrix[i:i + j[i] for i in range(3)]
            body:-Blocks= matrix.reshape(3, 2)
              body:-Code= matrix = np.array([3, 2], axis=1)
            body:-Inline= matrix[0][0][1] = np.Matrix(3, columns)
                body:-NL= matrix[3][2] = np.array([x.length() + 2], axis=0)
             base:+Mined= matrix = [[1, 2], [3, 4], [5, 6], [7, 8]]
     body+mined:Baseline= matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
        body+mined:-Code= matrix = [[(1, 2), (3, 4), (5, 6), (7, 8), (9, 10)]
          body+mined:-NL= matrix = [[1, 2, 3], [4, 5, 6]]
      body+mined:-Blocks= matrix = [[1, 2], [3, 4], [5, 6]]
      body+mined:-Inline= matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]

================================================================================

QUESTION: idx=180    id=1007481
-------------------------------------INPUTS-------------------------------------

tags: regex, django
score: 244
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: replace spaces with underscore
body(Left in tags for better readability):
<p> I want to replace whitespace with underscore in a string to create
nice URLs. So that for example:
<code_block>
 "This should be connected" becomes "This_should_be_connected"

<p> I am using Python with Django. Can this be solved using regular
expressions?

-------------------------------------OUTPUT-------------------------------------

                Expected= "mystring.replace(' ', '_')"
           base:Baseline= re.sub('[^a-zA-Z]', '\\1', '', re.sub')
           body:Baseline= re.sub('(?=\\w+)\\W+)', 'This_should_be_connected')
            body:-Blocks= re.sub('[^a-zA-Z]', '', ''.strip())
              body:-Code= re.sub('\\w+', '', '')
            body:-Inline= re.sub('[^a-z]', '', 'This_should_be_connected')
                body:-NL= re.sub('(This_should_be_connected)', 'This_ SHOULD_BE_connected')
             base:+Mined= re.sub('(?<=.)(?=.)', '\\1', s)
     body+mined:Baseline= """This_should_be_connected""".replace(' ', '')
        body+mined:-Code= re.sub('(?<=.)(?=.)', '', 'hello world!')
          body+mined:-NL= re.sub('(\\w+)', '\\1', 'This_should_be_connected')
      body+mined:-Blocks= re.sub('[^a-zA-Z]*', '', s)
      body+mined:-Inline= """This_should_be_connected""".replace(',', '')

================================================================================

QUESTION: idx=181    id=51520
-------------------------------------INPUTS-------------------------------------

tags: path, relative-path, absolute-path
score: 823
slot_map: {'key': ['str_0'], 'quote': ["'"], 'type': ['str'], 'value': ['mydir/myfile.txt']}
intent: get an absolute file path of file 'mydir/myfile.txt'
body(Left in tags for better readability):
<p> Given a path such as <code> "mydir/myfile.txt" <p> , how do I find
the file's absolute path relative to the current working directory in
Python? E.g. on Windows, I might end up with:
<code_block>
 "C:/example/cwd/mydir/myfile.txt"


-------------------------------------OUTPUT-------------------------------------

                Expected= "os.path.abspath('mydir/myfile.txt')"
           base:Baseline= os.path.abspath('mydir/myfile.txt')
           body:Baseline= os.path.abspath('C:/example/cwd/mydir/myfile.txt')
            body:-Blocks= os.path.absolute_path('mydir/myfile.txt')
              body:-Code= os.path.abspath('mydir/myfile.txt')
            body:-Inline= os.path.realpath('C:/example/cwd/mydir/myfile.txt')
                body:-NL= os.path.realpath('mydir/myfile.txt')
             base:+Mined= os.path.abspath('mydir/myfile.txt')
     body+mined:Baseline= os.path.abspath('mydir/myfile.txt')
        body+mined:-Code= os.path.abspath('mydir/myfile.txt')
          body+mined:-NL= os.path.abspath('mydir/myfile.txt')
      body+mined:-Blocks= os.path.abspath('mydir/myfile.txt')
      body+mined:-Inline= os.path.abspath('mydir/myfile.txt')

================================================================================

QUESTION: idx=182    id=1249786
-------------------------------------INPUTS-------------------------------------

tags: string, line-breaks
score: 4
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['my_string']}
intent: split string `my_string` on white spaces
body(Left in tags for better readability):
<p> Is there a cross-platform library function that would collapse a
multiline string into a single-line string with no repeating spaces?
<p> I've come up with some snip below, but I wonder if there is a
standard function which I could just import which is perhaps even
optimized in C?
<code_block>
 def collapse(input):
    import re
    rn = re.compile(r'(\r\n)+')
    r = re.compile(r'\r+')
    n = re.compile(r'\n+')
    s = re.compile(r'\ +')
    return s.sub(' ',n.sub(' ',r.sub(' ',rn.sub(' ',input))))

<p> P.S. Thanks for good observations. <code> ' '.join(input.split())
<p>  seems to be the winner as it actually runs faster about twice in
my case compared to search-replace with a precompiled <code> r'\s+'
<p>  regex.

-------------------------------------OUTPUT-------------------------------------

                Expected= '""" """.join(my_string.split())'
           base:Baseline= my_string.split('\n')
           body:Baseline= re.compile('\\n+', my_string)
            body:-Blocks= re.compile(' '.join(input.split())
              body:-Code= re.sub('\\w+', my_string)
            body:-Inline= re.compile('', my_string)
                body:-NL= re.compile('\\n+', my_string)
             base:+Mined= my_string.split('\n')
     body+mined:Baseline= re.compile('\\s+', my_string)
        body+mined:-Code= my_string.split(' ', 1)
          body+mined:-NL= re.sub('\\s+', my_string)
      body+mined:-Blocks= re.sub('\\s+', '', my_string)
      body+mined:-Inline= re.sub('\\s+', '', my_string)

================================================================================

QUESTION: idx=183    id=4444923
-------------------------------------INPUTS-------------------------------------

tags: regex
score: 91
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['filename']}
intent: get filename without extension from file `filename`
body(Left in tags for better readability):
<p> If I have a filename like one of these:
<code_block>
 1.1.1.1.1.jpg

1.1.jpg

1.jpg

<p> How could I get only the filename, without the extension? Would a
regex be appropriate?

-------------------------------------OUTPUT-------------------------------------

                Expected= 'os.path.splitext(filename)[0]'
           base:Baseline= os.path.isfile(filename)
           body:Baseline= print(re.sub('(?=\\w+)', filename))
            body:-Blocks= filename.rsplit(filename)
              body:-Code= print(os.path.isfile(filename))
            body:-Inline= filename.split()[:-1]
                body:-NL= os.path.splitext(filename)
             base:+Mined= print(os.path.join(filename))
     body+mined:Baseline= print(re.compile('\\.join(filename) for filename in filename))
        body+mined:-Code= filename = re.compile('(.*?\\w+)')
          body+mined:-NL= os.path.expanduser('filename', filename)
      body+mined:-Blocks= print(re.sub('[filename]', '', filename))
      body+mined:-Inline= print(os.path.splitext(filename))

================================================================================

QUESTION: idx=184    id=13728486
-------------------------------------INPUTS-------------------------------------

tags: functional-programming
score: 5
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['i', 'l']}
intent: get a list containing the sum of each element `i` in list `l` plus the previous elements
body(Left in tags for better readability):
<p> I am trying to write a function which maps elements of a list to
get sum of the element and the previous elements in the list in a
functional style using python e.g. :
<code_block>
 func([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) = [0, 1, 3, 6, 10, 15, 21, 28,
36, 45]

<p> I have tried using recursion, but get <code> RuntimeError: maximum
recursion depth exceeded <p>  with a long list.:
<code_block>
 def recursion_way(inlist, accu, summ):
    if len(inlist) == 0:
         return accu
    else:
        return recursion_way(inlist[1:], accu + [summ + inlist[0]],
summ + inlist[0])


-------------------------------------OUTPUT-------------------------------------

                Expected= '[sum(l[:i]) for i, _ in enumerate(l)]'
           base:Baseline= [sum(i) for i in L]
           body:Baseline= sum(i, j) / j for i, j in l)
            body:-Blocks= [sum(i) for i in L]
              body:-Code= [sum(i) for i in L]
            body:-Inline= [sum(i) for i, j in L]
                body:-NL= [sum(i) for i, j in zip(L, L)]
             base:+Mined= [sum(i) for i in L]
     body+mined:Baseline= [sum(x) for x in L if x[0] == 0]
        body+mined:-Code= [sum(i) for i in l]
          body+mined:-NL= [sum(i) for i in zip(*L)]
      body+mined:-Blocks= sum(i * j for i, j in zip(*l))
      body+mined:-Inline= sum([x for x in L if len(x) == 0])

================================================================================

QUESTION: idx=185    id=9743134
-------------------------------------INPUTS-------------------------------------

tags: regex
score: 7
slot_map: {'key': ['str_0', 'str_1', 'str_2'], 'quote': ['`', '`', '`'], 'type': ['str', 'str', 'str'], 'value': ['Docs/src/Scripts/temp', '/', '/']}
intent: split a string `docs/src/scripts/temp` by `/` keeping `/` in the result
body(Left in tags for better readability):
<p> Easiest way to explain this is an example:
I have this string: 'Docs/src/Scripts/temp'
Which I know how to split two different ways:
<code_block>
 re.split('/', 'Docs/src/Scripts/temp') -> ['Docs', 'src', 'Scripts',
'temp']

re.split('(/)', 'Docs/src/Scripts/temp') -> ['Docs', '/', 'src', '/',
'Scripts', '/', 'temp']

<p> Is there a way to split by the forward slash, but keep the slash
part of the words?
For example, I want the above string to look like this:
<code_block>
 ['Docs/', '/src/', '/Scripts/', '/temp']

<p> Any help would be appreciated!

-------------------------------------OUTPUT-------------------------------------

                Expected= '"""Docs/src/Scripts/temp""".replace(\'/\', \'/\\x00/\').split(\'\\x00\')'
           base:Baseline= results = re.split('/', 'docs/src/scripts/temp')
           body:Baseline= re.findall('/', 'Docs/src/Scripts/temp')
            body:-Blocks= """Docs/src/Scripts/Temp""".split('/')
              body:-Code= """Docs/src/scripts/temp""".split(',/')
            body:-Inline= re.split('/', 'Docs/src/Scripts/temp')
                body:-NL= re.split('/', 'Docs/src/Scripts/temp')
             base:+Mined= result = split(docs/src/scripts/temp.split(',/))
     body+mined:Baseline= re.split('/', 'Docs/src/Scripts/temp')
        body+mined:-Code= re.split('Docs/src/scripts/temp', '/')
          body+mined:-NL= re.split('/', 'Docs/src/scripts/temp')
      body+mined:-Blocks= """Docs/src/scripts/temp""".rsplit('/')
      body+mined:-Inline= re.split('/', 'Docs/src/Scripts/temp')

================================================================================

QUESTION: idx=186    id=20546419
-------------------------------------INPUTS-------------------------------------

tags: arrays, numpy
score: 21
slot_map: {'key': ['str_0'], 'quote': ["'"], 'type': ['str'], 'value': ['r']}
intent: shuffle columns of an numpy array 'r'
body(Left in tags for better readability):
<p> Let's say I have an array <code> r <p>  of dimension <code> (n, m)
<p> . I would like to shuffle the columns of that array.
<p> If I use <code> numpy.random.shuffle(r) <p>  it shuffles the
lines. How can I only shuffle the columns? So that the first column
become the second one and the third the first, etc, randomly.
<strong> Example:
<p> input:
<code_block>
 array([[  1,  20, 100],
       [  2,  31, 401],
       [  8,  11, 108]])

<p> output:
<code_block>
 array([[  20, 1, 100],
       [  31, 2, 401],
       [  11,  8, 108]])


-------------------------------------OUTPUT-------------------------------------

                Expected= 'np.random.shuffle(np.transpose(r))'
           base:Baseline= np.shuffle(r, axis=0)
           body:Baseline= np.random.shuffle(np.reshuff(r, n, m))
            body:-Blocks= np.shuffle(r, axis=0)
              body:-Code= np.shuffle(np.shape[0], axis=1)
            body:-Inline= np.shuffle(r, axis=1, reverse=True)
                body:-NL= np.shuffle(r, numpy.random.reshuffle(n, m))
             base:+Mined= np.shuffle(x, y)
     body+mined:Baseline= np.random.shuffle(r, axis=1)
        body+mined:-Code= np.random.shuffle(r, 2)
          body+mined:-NL= np.random.shuffle(r, axis=1)
      body+mined:-Blocks= np.random.shuffle(r, 1, 1)
      body+mined:-Inline= np.random.shuffle(r, 1)

================================================================================

QUESTION: idx=187    id=32675861
-------------------------------------INPUTS-------------------------------------

tags: pandas
score: 59
slot_map: {'key': ['str_0', 'str_1', 'str_2'], 'quote': ["'", "'", "'"], 'type': ['str', 'str', 'str'], 'value': ['B', 'D', 'df']}
intent: copy all values in a column 'b' to a new column 'd' in a pandas data frame 'df'
body(Left in tags for better readability):
<p> This is a very basic question, I just can not seem to find an
answer.
<p> I have a dataframe like this, called df:
<code_block>
   A     B     C
 a.1   b.1   c.1
 a.2   b.2   c.2
 a.3   b.3   c.3

<p> Then I extract all the rows from df, where column 'B' has a value
of 'b.2'.  I assign these results to df_2.
<code_block>
 df_2 = df[df['B'] == 'b.2']

<p> df_2 becomes:
<code_block>
   A     B     C
 a.2   b.2   c.2

<p> Then, I copy all the values in column 'B' to a new column named
'D'. Causing df_2 to become:
<code_block>
   A     B     C     D
 a.2   b.2   c.2   b.2

<p> When I preform an assignment like this:
<code_block>
 df_2['D'] = df_2['B']

<p> I get the following warning:

<p> A value is trying to be set on a copy of a slice from a DataFrame.
Try
  using .loc[row_indexer,col_indexer] = value instead
<p> See the the caveats in the documentation:
  <a> http://pandas.pydata.org/pandas-
docs/stable/indexing.html#indexing-view-versus-copy

<p> I have also tried using .loc when creating df_2 like this:
<code_block>
 df_2 = df.loc[df['B'] == 'b.2']

<p> However, I still get the warning.
<p> Any help is greatly appreciated.

-------------------------------------OUTPUT-------------------------------------

                Expected= "df['D'] = df['B']"
           base:Baseline= df['b'] = df['d']
           body:Baseline= df.loc[df['B'] == 'B.2']
            body:-Blocks= df['B'] = df['D'].copy()
              body:-Code= df.copy(df['B'], df['D'], axis=1)
            body:-Inline= df.loc[df['B'] == 'b.2']
                body:-NL= df['B'] = df['C']
             base:+Mined= df['b'] = df['d']
     body+mined:Baseline= df.loc[df['B'] == 'b.2']
        body+mined:-Code= df['B'] = df['D'].loc[row_indexer == 'B'].astype(int)
          body+mined:-NL= df.loc[df['B'] == 'b.2']
      body+mined:-Blocks= df['B'] = df['D'].loc[row['B'].isin(col_index)]
      body+mined:-Inline= df.loc[df['B'].isin(['B', 'C'])]

================================================================================

QUESTION: idx=188    id=14227561
-------------------------------------INPUTS-------------------------------------

tags: dictionary, nested
score: 13
slot_map: {'key': ['str_0', 'str_1'], 'quote': ["'", "'"], 'type': ['str', 'str'], 'value': ['data', 'B']}
intent: find a value within nested json 'data' where the key inside another key 'b' is unknown.
body(Left in tags for better readability):
<p> From the following json, in python, I'd like to extract the value
"TEXT". All the keys are constant except for unknown. Unknown could be
any string like "a6784t66" or "hobvp*nfe". <strong> The value of
unknown is not known <p> , only that it will be in that position in
each json response.
<code_block>
 {
  "A": {
    "B": {
      "unknown": {
        "1": "F",
        "maindata": [
          {
            "Info": "TEXT"
          }
        ]
      }
    }
  }
}

<p> one line json
<code_block>
 '{"A":{"B":{"unknown":{"1":"F","maindata":[{"Info":"TEXT"}]}}}}'

<p> How would you get the value of "Text"? (I know how to load the
json with json.loads)..but I'm not sure how to get the value of
"Text". Thanks.
<p> (I'm not sure what the best title is.)

-------------------------------------OUTPUT-------------------------------------

                Expected= "list(data['A']['B'].values())[0]['maindata'][0]['Info']"
           base:Baseline= print([k for k, v in data.items() if 'b' not in k])
           body:Baseline= json.loads(['A': 'B'], 'B': 'TEXT'))
            body:-Blocks= json.loads('data', key=lambda x: x['b'] == 'TEXT')
              body:-Code= json.loads('data', key=lambda x: x['b'])
            body:-Inline= [k for k, v in data.items() if 'B' is unknown]
                body:-NL= {{k for k, v in data.items() if 'B' is unknown}
             base:+Mined= data['b'] = json.loads(data['a'])
     body+mined:Baseline= {k: v for k, v in data.items() if k != 'TEXT'}
        body+mined:-Code= print(data['a6784t66']['hobvp*nfe'])
          body+mined:-NL= {k: v for k, v in data.items() if 'A' in k}
      body+mined:-Blocks= print(data['b']['c'])
      body+mined:-Inline= {k: v for k, v in list(data.items()) if 'ab' in k}

================================================================================

QUESTION: idx=189    id=14858916
-------------------------------------INPUTS-------------------------------------

tags: 
score: 5
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['string', 'predicate']}
intent: check characters of string `string` are true predication of function `predicate`
body(Left in tags for better readability):
<p> In Python 3, what's the shortest way to check whether a predicate
is true for all characters of a string?

-------------------------------------OUTPUT-------------------------------------

                Expected= 'all(predicate(x) for x in string)'
           base:Baseline= print('predicate'.join(string))
           body:Baseline= print(dict((k, v) for k, v in predicate.items()))
            body:-Blocks= print(string.encode('predicate')))
              body:-Code= print(predicate.__dict__ for _ in string)
            body:-Inline= print(predicate.__dict__).isnull()
                body:-NL= print(string.__predicate__).issubset(string)
             base:+Mined= """""".join(str(predicate))
     body+mined:Baseline= print(predicate(s) for s in string.values())
        body+mined:-Code= predicate(string).isalpha()
          body+mined:-NL= print(re.sub('(?<predicate)', '', string))
      body+mined:-Blocks= print(predicate(string, None)
      body+mined:-Inline= predicate(s, key=lambda x: x[1])

================================================================================

QUESTION: idx=190    id=574236
-------------------------------------INPUTS-------------------------------------

tags: macos, filesystems, hard-drive
score: 5
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: determine number of files on a drive with python
body(Left in tags for better readability):
<p> I have been trying to figure out how to retrieve (quickly) the
number of files on a given HFS+ drive with python.
<p> I have been playing with os.statvfs and such, but can't quite get
anything (that seems helpful to me).
<p> Any ideas?
<strong> Edit: <p>  Let me be a bit more specific. =]
<p> I am writing a timemachine-like wrapper around rsync for various
reasons, and would like a very fast estimate (does not have to be
perfect) of the number of files on the drive rsync is going to scan.
This way I can watch the progress from rsync (if you call it like
<code> rsync -ax --progress <p> , or with the <code> -P <p>  option)
as it builds its initial file list, and report a percentage and/or ETA
back to the user.
<p> This is completely separate from the actual backup, which is no
problem tracking progress. But with the drives I am working on with
several million files, it means the user is watching a counter of the
number of files go up with no upper bound for a few minutes.
<p> I have tried playing with os.statvfs with exactly the method
described in one of the answers so far, but the results do not make
sense to me.
<code_block>
 <console_in> import os
<console_in> os.statvfs('/').f_files - os.statvfs('/').f_ffree
<console_out> 64171205L

<p> The more portable way gives me around 1.1 million on this machine,
which is the same as every other indicator I have seen on this
machine, including rsync running its preparations:
<code_block>
 <console_in> sum(len(filenames) for path, dirnames, filenames in
os.walk("/"))
<console_out> 1084224

<p> Note that the first method is instantaneous, while the second one
made me come back 15 minutes later to update because it took just that
long to run.
<p> Does anyone know of a similar way to get this number, or what is
wrong with how I am treating/interpreting the os.statvfs numbers?

-------------------------------------OUTPUT-------------------------------------

                Expected= "os.statvfs('/').f_files - os.statvfs('/').f_ffree"
           base:Baseline= print(os.path.getmtime(filename))
           body:Baseline= sum(len(f_files) for f in os.statvfs('/').read()))
            body:-Blocks= print(os.statvfs.count('file'))
              body:-Code= sys.statvfs.count()
            body:-Inline= sum(len(os.statvfs('/').f_files) for os in os.walk('/'))
                body:-NL= os.statvfs('/').f_files()
             base:+Mined= sum(os.path.abspath(file))
     body+mined:Baseline= sum(f_files - os.statvfs('/').f_ffree)
        body+mined:-Code= return sum(os.statvfs(file_list))
          body+mined:-NL= os.statvfs('/').f_files
      body+mined:-Blocks= return sum(os.statvfs(open('/tmp/test.hstack', 'rb'))
      body+mined:-Inline= sum(len(filenames) for path, dirnames, filenames in os.walk('/'))

================================================================================

QUESTION: idx=191    id=7011291
-------------------------------------INPUTS-------------------------------------

tags: sql, sqlite
score: 34
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: how to get a single result from a sqlite query in python?
body(Left in tags for better readability):
<p> Is there an elegant way of getting a single result from an SQLite
SELECT query when using python 2.7?
<p> for example:
<code_block>
 conn = sqlite3.connect('db_path.db')
cursor=conn.cursor()
cursor.execute("SELECT MAX(value) FROM table")

for row in cursor:
    for elem in row:
        maxVal = elem

<p> is there a way to avoid those nested <code> for <p> s and get the
value directly? I've tried
<code_block>
 maxVal = cursor[0][0]

<p> without any success.

-------------------------------------OUTPUT-------------------------------------

                Expected= 'cursor.fetchone()[0]'
           base:Baseline= result = sqlite.query(lambda x: x[1])
           body:Baseline= cursor.execute('SELECT MAX(value) FROM table')
            body:-Blocks= results = sqlite.query(lambda x: x[1])
              body:-Code= result = sqlite.query(lambda x: x[1])
            body:-Inline= cursor.execute('SELECT MAX(value) FROM table')
                body:-NL= cursor.execute('SELECT MAX(value) FROM table')
             base:+Mined= cursor.execute('INSERT INTO table VALUES (%s, %s)', (1, 2, 3))
     body+mined:Baseline= cursor.execute('SELECT MAX(value) FROM table')
        body+mined:-Code= cursor.execute('SELECT * FROM records WHERE email LIKE ')
          body+mined:-NL= cursor.execute('SELECT MAX(value) FROM table')
      body+mined:-Blocks= cursor.execute('SELECT * FROM table WHERE index=False')
      body+mined:-Inline= cursor.execute('SELECT MAX(value) FROM table')

================================================================================

QUESTION: idx=192    id=6378889
-------------------------------------INPUTS-------------------------------------

tags: string, list, int
score: 10
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['user_input', 'user_list']}
intent: convert string `user_input` into a list of integers `user_list`
body(Left in tags for better readability):
<p> In my python Script I have:
<code_block>
 user = nuke.getInput("Frames Turned On")
userLst = [user]
print userLst

<p> Result:
<code_block>
 ['12,33,223']

<p> I was wondering How I would remove the <code> ' <p>  in the list,
or somehow convert it into int?

-------------------------------------OUTPUT-------------------------------------

                Expected= "user_list = [int(number) for number in user_input.split(',')]"
           base:Baseline= user_input = [int(x) for x in user_list]
           body:Baseline= user_list = nuke.getInput('Frames Turned On')
            body:-Blocks= user_list = [int(x) for x in user_input]
              body:-Code= user_input = [int(x) for x in user_list]
            body:-Inline= user_list = nuke.input('Frames Turned On')
                body:-NL= user_list = nuke.getInput('Frames Turned On')
             base:+Mined= user_list = [int(i) for i in user_input]
     body+mined:Baseline= nuke.getInput('Frames Turned On')
        body+mined:-Code= user_list = [int(i) for i in user_input]
          body+mined:-NL= nuke.getInput('Frames Turned On')
      body+mined:-Blocks= user_list = [int(x) for x in input]
      body+mined:-Inline= user_list = [int(x) for x in user_input]

================================================================================

QUESTION: idx=193    id=6378889
-------------------------------------INPUTS-------------------------------------

tags: string, list, int
score: 10
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['user']}
intent: get a list of integers by splitting  a string `user` with comma
body(Left in tags for better readability):
<p> In my python Script I have:
<code_block>
 user = nuke.getInput("Frames Turned On")
userLst = [user]
print userLst

<p> Result:
<code_block>
 ['12,33,223']

<p> I was wondering How I would remove the <code> ' <p>  in the list,
or somehow convert it into int?

-------------------------------------OUTPUT-------------------------------------

                Expected= "[int(s) for s in user.split(',')]"
           base:Baseline= [int(x) for x in user.split(',')]
           body:Baseline= userLst = [int(x) for x in user]
            body:-Blocks= [int(x) for x in user.split()]
              body:-Code= [int(x) for x in user]
            body:-Inline= user = nuke.split(',')
                body:-NL= user = nuke.split(',')
             base:+Mined= [int(x) for x in User.split(',')]
     body+mined:Baseline= nuke.getInput('Frames Turned On')
        body+mined:-Code= [int(x) for x in user.split(',')]
          body+mined:-NL= [int(x) for x in user.split()]
      body+mined:-Blocks= [int(x) for x in user.split()]
      body+mined:-Inline= [int(x) for x in userLst]

================================================================================

QUESTION: idx=194    id=5212870
-------------------------------------INPUTS-------------------------------------

tags: sorting
score: 195
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: sorting a python list by two criteria
body(Left in tags for better readability):
<p> I have the following list created from a sorted csv
<code_block>
 list1 = sorted(csv1, key=operator.itemgetter(1))

<p> I would actually like to sort the list by two criteria: first by
the value in field 1 and then by the value in field 2. How do I do
this?

-------------------------------------OUTPUT-------------------------------------

                Expected= 'sorted(list, key=lambda x: (x[0], -x[1]))'
           base:Baseline= sorted(list(itertools.chain.from_iterable(1)))
           body:Baseline= sorted(list1, key=operator.itemgetter(1))
            body:-Blocks= sorted(list(csv.items()), key=lambda x: x[1])
              body:-Code= sorted(list(range(1)), key=lambda x: x[1])
            body:-Inline= sorted(list1, key=operator.itemgetter(1))
                body:-NL= sorted(list1, key=operator.itemgetter(1))
             base:+Mined= sorted(lst, key=lambda x: x[1])
     body+mined:Baseline= sorted(csv1, key=operator.itemgetter(1))
        body+mined:-Code= sorted(lst, key=lambda x: x[1])
          body+mined:-NL= sorted(csv1, key=operator.itemgetter(1))
      body+mined:-Blocks= sorted(L, key=lambda x: (x['value'] == x['value'])
      body+mined:-Inline= sorted(list1, key=operator.itemgetter(1))

================================================================================

QUESTION: idx=195    id=403421
-------------------------------------INPUTS-------------------------------------

tags: list, sorting, oop, count
score: 909
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['ut', 'cmpfun']}
intent: sort a list of objects `ut`, based on a function `cmpfun` in descending order
body(Left in tags for better readability):
<p> I've got a list of Python objects that I'd like to sort by an
attribute of the objects themselves.  The list looks like:
<code_block>
 <console_in> ut
<console_out> [ <Tag: 128>, <Tag: 2008>, <Tag: <>, <Tag:
actionscript>, <Tag: addresses>,
 <Tag: aes>, <Tag: ajax> <console_out>]

<p> Each object has a count:
<code_block>
 <console_in> ut[1].count
<console_out> 1L

<p> I need to sort the list by number of counts descending.
<p> I've seen several methods for this, but I'm looking for best
practice in Python.

-------------------------------------OUTPUT-------------------------------------

                Expected= 'ut.sort(key=cmpfun, reverse=True)'
           base:Baseline= ut.sort(key=lambda x: x[1])
           body:Baseline= ut.sort(key=operator.itemgetter(1))
            body:-Blocks= ut.sort(key=lambda x: x['cmpfun'], reverse=True)
              body:-Code= ut.sort(key=lambda x: x[1])
            body:-Inline= sorted(ut, key=operator.itemgetter(1))
                body:-NL= ut.sort(key=operator.itemgetter('cmpfun', reverse=True)
             base:+Mined= sorted(ut, key=cmpfun)
     body+mined:Baseline= sorted(ut, key=lambda x: int(x['count']))
        body+mined:-Code= sorted(ut, key=cmpfun.get)
          body+mined:-NL= ut.sort(key=lambda x: int(x[1].count()), reverse=True)
      body+mined:-Blocks= sorted(ut, key=cmpfun.index)
      body+mined:-Inline= sorted(ut, key=lambda x: int(x['c']))

================================================================================

QUESTION: idx=196    id=403421
-------------------------------------INPUTS-------------------------------------

tags: list, sorting, oop, count
score: 909
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['ut', 'count']}
intent: reverse list `ut` based on the `count` attribute of each object
body(Left in tags for better readability):
<p> I've got a list of Python objects that I'd like to sort by an
attribute of the objects themselves.  The list looks like:
<code_block>
 <console_in> ut
<console_out> [ <Tag: 128>, <Tag: 2008>, <Tag: <>, <Tag:
actionscript>, <Tag: addresses>,
 <Tag: aes>, <Tag: ajax> <console_out>]

<p> Each object has a count:
<code_block>
 <console_in> ut[1].count
<console_out> 1L

<p> I need to sort the list by number of counts descending.
<p> I've seen several methods for this, but I'm looking for best
practice in Python.

-------------------------------------OUTPUT-------------------------------------

                Expected= 'ut.sort(key=lambda x: x.count, reverse=True)'
           base:Baseline= ut = [x for x in enumerate(ut.count()])
           body:Baseline= sorted(ut, reverse=True)
            body:-Blocks= ut.sort(key=lambda x: x[1])
              body:-Code= ut.sort(key=lambda x: x[1])
            body:-Inline= sorted(ut, key=ut.count)
                body:-NL= ut[1].apply(lambda x: x[1])
             base:+Mined= ut.reverse(reverse=True)
     body+mined:Baseline= sorted(ut, key=lambda x: int(x.count()))
        body+mined:-Code= sorted(ut, key=lambda x: x.count)
          body+mined:-NL= ut.reverse(1, 1)
      body+mined:-Blocks= sorted(ut, reverse=True)
      body+mined:-Inline= sorted(ut, key=lambda x: int(x['count']))

================================================================================

QUESTION: idx=197    id=403421
-------------------------------------INPUTS-------------------------------------

tags: list, sorting, oop, count
score: 909
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['ut', 'count']}
intent: sort a list of objects `ut` in reverse order by their `count` property
body(Left in tags for better readability):
<p> I've got a list of Python objects that I'd like to sort by an
attribute of the objects themselves.  The list looks like:
<code_block>
 <console_in> ut
<console_out> [ <Tag: 128>, <Tag: 2008>, <Tag: <>, <Tag:
actionscript>, <Tag: addresses>,
 <Tag: aes>, <Tag: ajax> <console_out>]

<p> Each object has a count:
<code_block>
 <console_in> ut[1].count
<console_out> 1L

<p> I need to sort the list by number of counts descending.
<p> I've seen several methods for this, but I'm looking for best
practice in Python.

-------------------------------------OUTPUT-------------------------------------

                Expected= 'ut.sort(key=lambda x: x.count, reverse=True)'
           base:Baseline= sorted(ut, key=lambda x: x[1])
           body:Baseline= sorted(ut, key=lambda k: k.count)
            body:-Blocks= ut.sort(key=lambda x: x[1])
              body:-Code= sorted(ut, key=lambda x: x[1])
            body:-Inline= sorted(ut, key=ut.count)
                body:-NL= ut.sort(key=lambda x: x[1])
             base:+Mined= sorted(ut, key=lambda x: order.index(x['count']))
     body+mined:Baseline= sorted(ut, reverse=True)
        body+mined:-Code= sorted(ut, key=lambda x: x.count)
          body+mined:-NL= sorted(ut, reverse=True)
      body+mined:-Blocks= sorted(ut, key=lambda tup: tup[1])
      body+mined:-Inline= sorted(ut, key=lambda x: int(x['count']))

================================================================================

QUESTION: idx=198    id=19601086
-------------------------------------INPUTS-------------------------------------

tags: selenium, button, click, href
score: 19
slot_map: {'key': ['str_0'], 'quote': ["'"], 'type': ['str'], 'value': ['Send']}
intent: click a href button 'send' with selenium
body(Left in tags for better readability):
<p> I have one button from one LinkedIn page with this code:
<code_block>
 <div class="primary-action-button"> <a class="primary-action label" h
ref="/requestList?displayProposal=&amp;destID=39959446&amp;creationTyp
e=DC&amp;authToken=Yr4_&amp;authType=OUT_OF_NETWORK&amp;trk=vsrp_peopl
e_res_pri_act&amp;trkInfo=VSRPsearchId%3A2998448551382744275729%2CVSRP
targetId%3A39959446%2CVSRPcmpt%3Aprimary">Send InMail </a> </div>

<p> Is there any way to click on an element just by its href link?
Thanks

-------------------------------------OUTPUT-------------------------------------

                Expected= "driver.find_element_by_partial_link_text('Send').click()"
           base:Baseline= driver.find_element_by_css_selector('send')
           body:Baseline= click('send', selenium)
            body:-Blocks= driver.find_element_by_name('send')
              body:-Code= driver.find_element_by_css_selector('send')
            body:-Inline= click('send', selenium)
                body:-NL= s = selenium.click('send', class='primary-action-button')
             base:+Mined= driver.find_element_by_css_selector("//div[@ href='send']").click()
     body+mined:Baseline= button.click('send', 1)
        body+mined:-Code= driver.find_element_by_href('send')
          body+mined:-NL= driver.find_element_by_class_name('send')
      body+mined:-Blocks= driver.find_element_by_href('send')
      body+mined:-Inline= driver.get('http://stackoverflow.com')

================================================================================

QUESTION: idx=199    id=19601086
-------------------------------------INPUTS-------------------------------------

tags: selenium, button, click, href
score: 19
slot_map: {'key': ['str_0'], 'quote': ['`'], 'type': ['str'], 'value': ['Send InMail']}
intent: click a href button having text `send inmail` with selenium
body(Left in tags for better readability):
<p> I have one button from one LinkedIn page with this code:
<code_block>
 <div class="primary-action-button"> <a class="primary-action label" h
ref="/requestList?displayProposal=&amp;destID=39959446&amp;creationTyp
e=DC&amp;authToken=Yr4_&amp;authType=OUT_OF_NETWORK&amp;trk=vsrp_peopl
e_res_pri_act&amp;trkInfo=VSRPsearchId%3A2998448551382744275729%2CVSRP
targetId%3A39959446%2CVSRPcmpt%3Aprimary">Send InMail </a> </div>

<p> Is there any way to click on an element just by its href link?
Thanks

-------------------------------------OUTPUT-------------------------------------

                Expected= "driver.findElement(By.linkText('Send InMail')).click()"
           base:Baseline= driver.find_element_by_css_selector('send inmail')
           body:Baseline= click('send InMail', selenium)
            body:-Blocks= driver.find_element_by_id('send inmail')
              body:-Code= driver.find_element_by_css_selector('send inmail')
            body:-Inline= click('send InMail', selenium)
                body:-NL= click a href button having text `send inmail')
             base:+Mined= driver.find_element_by_css_selector('.send inmail').click()
     body+mined:Baseline= link = selenium.Link('Send InMail')
        body+mined:-Code= driver.find_element_by_href('send inmail').click()
          body+mined:-NL= driver.find_element_by_class_name('send inmail')
      body+mined:-Blocks= driver.find_element_by_href('send_inmail')
      body+mined:-Inline= driver.get('http://stackoverflow.com')

================================================================================

QUESTION: idx=200    id=19601086
-------------------------------------INPUTS-------------------------------------

tags: selenium, button, click, href
score: 19
slot_map: {'key': ['str_0'], 'quote': ["'"], 'type': ['str'], 'value': ['Send InMail']}
intent: click a href button with text 'send inmail' with selenium
body(Left in tags for better readability):
<p> I have one button from one LinkedIn page with this code:
<code_block>
 <div class="primary-action-button"> <a class="primary-action label" h
ref="/requestList?displayProposal=&amp;destID=39959446&amp;creationTyp
e=DC&amp;authToken=Yr4_&amp;authType=OUT_OF_NETWORK&amp;trk=vsrp_peopl
e_res_pri_act&amp;trkInfo=VSRPsearchId%3A2998448551382744275729%2CVSRP
targetId%3A39959446%2CVSRPcmpt%3Aprimary">Send InMail </a> </div>

<p> Is there any way to click on an element just by its href link?
Thanks

-------------------------------------OUTPUT-------------------------------------

                Expected= "driver.find_element_by_link_text('Send InMail').click()"
           base:Baseline= driver.find_element_by_css_selector('send inmail').click()
           body:Baseline= click('send InMail', selenium)
            body:-Blocks= driver.find_element_by_css_name('send inmail')
              body:-Code= driver.find_element_by_css_selector('send inmail')
            body:-Inline= click_button('send inmail', selenium)
                body:-NL= a = selenium.click('send inmail')
             base:+Mined= driver.find_element_by_css_selector('send inmail').click()
     body+mined:Baseline= link = selenium.Link('Send InMail')
        body+mined:-Code= driver.find_element_by_href('send inmail').click()
          body+mined:-NL= driver.find_element_by_class_name('send inmail')
      body+mined:-Blocks= driver.find_element_by_href('send_inmail').click()
      body+mined:-Inline= driver.get('http://stackoverflow.com')

================================================================================

QUESTION: idx=201    id=3944876
-------------------------------------INPUTS-------------------------------------

tags: string, integer, concatenation
score: 53
slot_map: {'key': ['var_0', 'str_0'], 'quote': ['`', "'"], 'type': ['var', 'str'], 'value': ['i', 'ME']}
intent: cast an int `i` to a string and concat to string 'me'
body(Left in tags for better readability):
<p> I want to be able to generate a number of text files with the
names fileX.txt where X is some integer:
<code_block>
 for i in range(key):
    filename = "ME" + i + ".txt" //Error here! Can't concat a string
and int
    filenum = filename
    filenum = open(filename , 'w')

<p> Does anyone else know how to do the filename = "ME" + i  part so I
get a list of files with the names: "ME0.txt" , "ME1.txt" , "ME2.txt"
, and etc

-------------------------------------OUTPUT-------------------------------------

                Expected= "'ME' + str(i)"
           base:Baseline= """""".join(str(i)) for i in'me'
           body:Baseline= f = open(filename, 'ME'))
            body:-Blocks= """ME""".join(str(i))
              body:-Code= """.join(open('ME0.txt', 'ME2.txt'))
            body:-Inline= """ME""".join(str(i))
                body:-NL= """ME""".join(str(i)) for i in range(key))
             base:+Mined= """, """.join(i)
     body+mined:Baseline= filename = 'ME' + i + '.txt'
        body+mined:-Code= print(open('ME0.txt', 'ME1.txt'))
          body+mined:-NL= filenum = open(filename, 'w').read()
      body+mined:-Blocks= """ME0.txt""".join('ME1.txt')
      body+mined:-Inline= """, """.join(i)

================================================================================

QUESTION: idx=202    id=40903174
-------------------------------------INPUTS-------------------------------------

tags: pandas
score: 4
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: sorting data in dataframe pandas
body(Left in tags for better readability):
<p> I obtained the following DataFrame:
<code_block>
     Dis        System_num  Energy
0   0.9           1       -2.3108
1   0.7           1       11.8735
2   1.2           1       -2.3408
3   2.0           1       -0.3485
4   2.0           2       -0.9379
5   0.7           2       7.4776
6   1.5           2       -2.2877
7   0.9           2       -4.1789
8   2.0           3       -3.6596
9   1.0           3       -18.4582
10  0.9           3       -16.2202
11  0.7           3       16.6290

<p> I want to sort values (ascending) in the Dis column for each
number in System_num, I mean:
<code_block>
 0   0.7           1       11.8735
1   0.9           1       -2.3108
2   1.2           1       -2.3408
3   2.0           1       -0.3485
4   0.7           2       7.4776
5   0.9           2       -4.1789
6   1.5           2       -2.2877
7   2.0           2       -0.9379
8   0.7           3       16.6290
8   0.9           3       -16.2202
10  1.0           3       -18.4582
11  2.0           3       -3.6596


-------------------------------------OUTPUT-------------------------------------

                Expected= "df.sort_values(['System_num', 'Dis'])"
           base:Baseline= pd.concat([df.groupby(df.index)], axis=1)
           body:Baseline= df.sort(['Dis'], axis=1)
            body:-Blocks= df.sorted(dataFrame, key=lambda x: x[1])
              body:-Code= df.sort_values('ascending')
            body:-Inline= df.sorted(DataFrame, columns=['Dis'], key=lambda x: x[1])
                body:-NL= df.sorted(df.index.values()), axis=0)
             base:+Mined= df.sort(key=lambda x: x[1])
     body+mined:Baseline= df.sort(key=lambda x: x.astype(int) for x in System_num)
        body+mined:-Code= df.sort_values(inplace=True)
          body+mined:-NL= df.sort(key=lambda x: x[1])
      body+mined:-Blocks= df.sort_values(['Dis'], ascending=[True, False])
      body+mined:-Inline= df.sort(['Dis', 'Energy'], ascending=False)

================================================================================

QUESTION: idx=203    id=4454298
-------------------------------------INPUTS-------------------------------------

tags: prepend
score: 73
slot_map: {'key': ['str_0', 'str_1', 'str_2'], 'quote': ["'", "'", "'"], 'type': ['str', 'str', 'str'], 'value': ['#test firstline\n', 'infile', 'outfile']}
intent: prepend the line '#test firstline\n' to the contents of file 'infile' and save as the file 'outfile'
body(Left in tags for better readability):
<p> I need to add a single line to the first line of a text file and
it looks like the only options available to me are more lines of code
than I would expect from python. Something like this:
<code_block>
 f = open('filename','r')
temp = f.read()
f.close()

f = open('filename', 'w')
f.write("#testfirstline")

f.write(temp)
f.close()

<p> Is there no easier way? Additionally, I see this two-handle
example more often than opening a single handle for reading and
writing ('r+') - why is that?

-------------------------------------OUTPUT-------------------------------------

                Expected= "open('outfile', 'w').write('#test firstline\\n' + open('infile').read())"
           base:Baseline= os.system('#test firstline\n')
           body:Baseline= f = open('#testfirstline\n', 'outfile')
            body:-Blocks= os.chmod('#test firstline\n')
              body:-Code= os.chmod('#test firstline\n')
            body:-Inline= f.write('#test firstline\n')
                body:-NL= f.write('#test firstline\n')
             base:+Mined= os.system('#test firstline\n')
     body+mined:Baseline= f.write('#test firstline\n')
        body+mined:-Code= outfile.write('#Test firstline\n')
          body+mined:-NL= f.write('#test firstline\n')
      body+mined:-Blocks= outfile.write('#test firstline\n')
      body+mined:-Inline= f.write('#test firstline\n')

================================================================================

QUESTION: idx=204    id=19729928
-------------------------------------INPUTS-------------------------------------

tags: sorting, tuples
score: 11
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['l']}
intent: sort a list `l` by length of value in tuple
body(Left in tags for better readability):
<p> I am having difficulty sorting a list of tuples. I would like to
sort by the length of a string in the list.
<p> For example:
<code_block>
 l = [(99,'bbc', 121),(33,'abcd', 231),(44,'zb', 148),
(23,'abcde',221)]

<p> if I sort by element 1:
<code_block>
 l.sort(key=itemgetter(1), reverse=True)

<p> This will sort on the alphabetical ranking of the strings, not the
length. I would prefer to sort in-place and reverse sort, with longest
string first.
<p> I can use a lambda and cmp,
<code_block>
 l.sort(lambda x,y: cmp(len(x[1]), len(y[1])), reverse=True)

<p> but is there a more elegant, or pythonic way using key and/or
itemgetter?

-------------------------------------OUTPUT-------------------------------------

                Expected= 'l.sort(key=lambda t: len(t[1]), reverse=True)'
           base:Baseline= sorted(l, key=lambda x: x[1])
           body:Baseline= l.sort(key=itemgetter(1), reverse=True)
            body:-Blocks= sorted(l, key=lambda x: x[1])
              body:-Code= sorted(l, key=lambda x: x[1])
            body:-Inline= l.sort(key=itemgetter(1), reverse=True)
                body:-NL= l.sort(key=itemgetter(1), reverse=True)
             base:+Mined= sorted(l, key=lambda x: len(x[1])
     body+mined:Baseline= l.sort(key=itemgetter(1), reverse=True)
        body+mined:-Code= sorted(L, key=lambda item: itemgetter(len(item), item))
          body+mined:-NL= l.sort(key=lambda x, y: cmp(len(x[1]), len(y[1]))
      body+mined:-Blocks= sorted(L, key=lambda t: t[len(t[1]))
      body+mined:-Inline= l.sort(key=itemgetter(1))

================================================================================

QUESTION: idx=205    id=31371879
-------------------------------------INPUTS-------------------------------------

tags: regex, split
score: 5
slot_map: {'key': ['var_0', 'str_0'], 'quote': ['`', "'"], 'type': ['var', 'str'], 'value': ['s', 'd']}
intent: split string `s` by words that ends with 'd'
body(Left in tags for better readability):
<p> I want to split strings only by suffixes. For example, I would
like to be able to split <code> dord word <p>  to <code> [dor,wor] <p>
.
<p> I though that <code> \wd <p>  would search for words that end with
<code> d <p> . However this does not produce the expected results
<code_block>
 import re
re.split(r'\wd',"dord word")
['do', ' wo', '']

<p> How can I split by suffixes?

-------------------------------------OUTPUT-------------------------------------

                Expected= "re.findall('\\\\b(\\\\w+)d\\\\b', s)"
           base:Baseline= s = s.split('d')
           body:Baseline= re.findall('\\d', s)
            body:-Blocks= s.split(',', 'd')
              body:-Code= s.split(',', 'd')
            body:-Inline= re.split('\\wd', 'dord word')
                body:-NL= re.findall('\\d', s)
             base:+Mined= re.split('\\d+', s)
     body+mined:Baseline= re.findall('\\w', s)
        body+mined:-Code= s = re.findall('\\d+', s)
          body+mined:-NL= re.findall('\\d', s)
      body+mined:-Blocks= re.split('[d]', s)
      body+mined:-Inline= re.findall('\\d+', s)

================================================================================

QUESTION: idx=206    id=9012008
-------------------------------------INPUTS-------------------------------------

tags: regex
score: 114
slot_map: {'key': ['var_0', 'var_1', 'str_0'], 'quote': ['`', '`', '`'], 'type': ['var', 'var', 'str'], 'value': ['True', 'foobarrrr', 'ba[rzd]']}
intent: return `true` if string `foobarrrr` contains regex `ba[rzd]`
body(Left in tags for better readability):
<p> I have a regular expression like this:
<code_block>
 regexp = u'ba[r|z|d]'

<p> Function must return True if word contains <strong> bar <p> ,
<strong> baz <p>  or <strong> bad <p> .
In short, I need regexp analog for Python's
<code_block>
 'any-string' in 'text'

<p> How can I realize it? Thanks!

-------------------------------------OUTPUT-------------------------------------

                Expected= "bool(re.search('ba[rzd]', 'foobarrrr'))"
           base:Baseline= return False if (foobarrrr.is not regex(ba[rzd]):
    pass
           body:Baseline= re.findall('\\b\\b', 'foobarrrr', 'ba[rzd]')
            body:-Blocks= """foobarrrr""".join(re.sub('[^a-zA-Z]', 'ba[rzd]')
              body:-Code= return False if re.sub('(?\\b\\d]', 'foobarrrr', 'ba[rzd]')
            body:-Inline= return True if (foobarrrr.is_any-string) in re.findall('\\b', 'ba[rzd]')
                body:-NL= """foobarrrr""".replace('ba[rzd]', 'any-string')
             base:+Mined= """foobarrrr""".encode('ascii', 'ba[rzd]')
     body+mined:Baseline= re.search('\\bba[r|z|d]', 'foobarrrr')
        body+mined:-Code= """foobarrrr""".endswith(ba[rzd])
          body+mined:-NL= """ba[r|z|d]""".encode('utf8')
      body+mined:-Blocks= """foobarrrr""".endswith('bar[rzd]')
      body+mined:-Inline= re.findall('\\bba[r|z|d]', 'foobarrrr')

================================================================================

QUESTION: idx=207    id=7961363
-------------------------------------INPUTS-------------------------------------

tags: algorithm, list, duplicates, intersection
score: 1128
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['t']}
intent: removing duplicates in list `t`
body(Left in tags for better readability):
<p> Pretty much I need to write a program that checks if a list has
any duplicates and if it does it removes them and returns a new list
with the items that weren't duplicated/removed. This is what I have
tried but honestly I don't know what to do.
<code_block>
 def remove_duplicates():
    t = ['a', 'b', 'c', 'd']
    t2 = ['a', 'c', 'd']
    for t in t2:
        t.append(t.remove())
    return t


-------------------------------------OUTPUT-------------------------------------

                Expected= 'list(set(t))'
           base:Baseline= [x for x in list(t)]
           body:Baseline= t = ['a', 'b', 'c', 'd']
            body:-Blocks= del t[i] for i in list(t)]
              body:-Code= [x for x in t if not duplicates]
            body:-Inline= t = [x for x in t]
                body:-NL= t = [duplicates for duplicates in t]
             base:+Mined= [x for x in list(t.items()) if x != 1]
     body+mined:Baseline= t2 = [x for x in t if x not in list(t)]
        body+mined:-Code= t.sort(key=lambda x: x.duplicates())
          body+mined:-NL= t2 = [t for t in t2 if t.duplicated()]
      body+mined:-Blocks= t = list(set(t))
      body+mined:-Inline= t = list(set(t))

================================================================================

QUESTION: idx=208    id=7961363
-------------------------------------INPUTS-------------------------------------

tags: algorithm, list, duplicates, intersection
score: 1128
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['source_list']}
intent: removing duplicates in list `source_list`
body(Left in tags for better readability):
<p> Pretty much I need to write a program that checks if a list has
any duplicates and if it does it removes them and returns a new list
with the items that weren't duplicated/removed. This is what I have
tried but honestly I don't know what to do.
<code_block>
 def remove_duplicates():
    t = ['a', 'b', 'c', 'd']
    t2 = ['a', 'c', 'd']
    for t in t2:
        t.append(t.remove())
    return t


-------------------------------------OUTPUT-------------------------------------

                Expected= 'list(set(source_list))'
           base:Baseline= [x for x in source_list if x is not duplicates]
           body:Baseline= [x for x in source_list if x not in x]
            body:-Blocks= source_list.remove(key=operator.itemgetter(1))
              body:-Code= [x for x in source_list if not duplicates]
            body:-Inline= [duplicates for duplicates insource_list]
                body:-NL= source_list = [x for x in source_list]
             base:+Mined= [list(source_list) for _ in range(10)]
     body+mined:Baseline= source_list.sort(key=lambda x: abs(x))
        body+mined:-Code= source_list.sort(key=lambda x: x.duplicates())
          body+mined:-NL= t = list(source_list)
      body+mined:-Blocks= source_list.sort(key=lambda x: x.index(x))
      body+mined:-Inline= source_list.sort(key=lambda x: list(x.duplicates())

================================================================================

QUESTION: idx=209    id=7961363
-------------------------------------INPUTS-------------------------------------

tags: algorithm, list, duplicates, intersection
score: 1128
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['abracadabra']}
intent: removing duplicates in list `abracadabra`
body(Left in tags for better readability):
<p> Pretty much I need to write a program that checks if a list has
any duplicates and if it does it removes them and returns a new list
with the items that weren't duplicated/removed. This is what I have
tried but honestly I don't know what to do.
<code_block>
 def remove_duplicates():
    t = ['a', 'b', 'c', 'd']
    t2 = ['a', 'c', 'd']
    for t in t2:
        t.append(t.remove())
    return t


-------------------------------------OUTPUT-------------------------------------

                Expected= "list(OrderedDict.fromkeys('abracadabra'))"
           base:Baseline= del my_list(abracadabra)
           body:Baseline= [x for x in abracadabra if x not in x]
            body:-Blocks= del mynew list(abracadabra)
              body:-Code= delicate(abracadabra)
            body:-Inline= for (duplicates in abracadabra):
    pass
                body:-NL= [duplicates for duplicates in abracadabra]
             base:+Mined= list(set(abracadabra.items()))
     body+mined:Baseline= list(abracadabra.items())
        body+mined:-Code= new_list = list(set(abracadabra.items()))
          body+mined:-NL= t = list(abracadabra.values())
      body+mined:-Blocks= return list(set(abracadabra.items()))
      body+mined:-Inline= list(set(abracadabra.values())

================================================================================

QUESTION: idx=210    id=5183533
-------------------------------------INPUTS-------------------------------------

tags: list, matrix, numpy
score: 40
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['a']}
intent: convert array `a` into a list
body(Left in tags for better readability):
<p> I using the dot() function from numpy to multiply a matrix of 3x3
with a numpy.array of 1x3. The output is for example this:
<p> [[ 0.16666667  0.66666667  0.16666667]]
<p> which is of type:
<code_block>
 <class 'numpy.matrixlib.defmatrix.matrix'>

<p> how can I convert this to a list. Because I know the result will
always be a matrix of 1x3 so it should be coverted to a list because I
need to be able to loop through it later for calculation the pearson
distance of two of those lists.
<strong> So to summarize: how can I make a list from this matrix?

-------------------------------------OUTPUT-------------------------------------

                Expected= 'numpy.array(a).reshape(-1).tolist()'
           base:Baseline= list(itertools.chain.from_iterable(a))
           body:Baseline= list(a, numpy.matrixlib.array(1))
            body:-Blocks= list(a, key=lambda x: x[1])
              body:-Code= list(a).dot(1)
            body:-Inline= list(numpy.matrixlib.defmatrix(a))
                body:-NL= list(a.items()).decode('matrixlib.defmatrix.matrix')
             base:+Mined= list(itertools.chain(*a))
     body+mined:Baseline= list(map(int, a.split())
        body+mined:-Code= list(np.dot(a, [0.166666666667, 0.16666667]]))
          body+mined:-NL= numpy.matrixlib.concatenate((a, a))
      body+mined:-Blocks= list(numpy.dot(a, 1))
      body+mined:-Inline= list(itertools.product([0.16666667, 0.66666667])

================================================================================

QUESTION: idx=211    id=5183533
-------------------------------------INPUTS-------------------------------------

tags: list, matrix, numpy
score: 40
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['a']}
intent: convert the first row of numpy matrix `a` to a list
body(Left in tags for better readability):
<p> I using the dot() function from numpy to multiply a matrix of 3x3
with a numpy.array of 1x3. The output is for example this:
<p> [[ 0.16666667  0.66666667  0.16666667]]
<p> which is of type:
<code_block>
 <class 'numpy.matrixlib.defmatrix.matrix'>

<p> how can I convert this to a list. Because I know the result will
always be a matrix of 1x3 so it should be coverted to a list because I
need to be able to loop through it later for calculation the pearson
distance of two of those lists.
<strong> So to summarize: how can I make a list from this matrix?

-------------------------------------OUTPUT-------------------------------------

                Expected= 'numpy.array(a)[0].tolist()'
           base:Baseline= [a[0] for a in zip(*a)]
           body:Baseline= list(a, numpy.matrixlib.array(1))
            body:-Blocks= list(a.shape[0])
              body:-Code= list(a.shape[0]
            body:-Inline= list(a.shape[0]
                body:-NL= numpy.matrixlib.defmatrix(a)
             base:+Mined= a = a[:, (0)]
     body+mined:Baseline= numpy.dot(a, 1)
        body+mined:-Code= list(np.dot(a, [0.166666666667, 0.16666667]]))
          body+mined:-NL= numpy.matrixlib.concatenate((a, a))
      body+mined:-Blocks= numpy.dot(a, axis=1)
      body+mined:-Inline= list(itertools.product([0.16666667, 0.66666667])

================================================================================

QUESTION: idx=212    id=5999747
-------------------------------------INPUTS-------------------------------------

tags: beautifulsoup
score: 47
slot_map: {'key': ['var_0', 'var_1', 'str_0'], 'quote': ['`', '`', '`'], 'type': ['var', 'var', 'str'], 'value': ['soup', 'td', 'Address:']}
intent: in `soup`, get the content of the sibling of the `td`  tag with text content `address:`
body(Left in tags for better readability):
<p> I'm trying to get the content "My home address" using the
following but got the AttributeError:
<code_block>
 address = soup.find(text="Address:")
print address.nextSibling

<p> This is my HTML:
<code_block>
 <td> <b>Address: </b> </td>
<td>My home address </td>

<p> What is a good way to navigate down <code> td <p>  tag and pull
the content?

-------------------------------------OUTPUT-------------------------------------

                Expected= "print(soup.find(text='Address:').findNext('td').contents[0])"
           base:Baseline= soup.find_element_by_xpath('//a[address:])')
           body:Baseline= soup.find(text='Address:')
            body:-Blocks= soup.find_element_by_css_name('My Home Address')
              body:-Code= soup.findAll(text={'address':})
            body:-Inline= soup.find(text='Address:')
                body:-NL= soup.find(text='Address:')
             base:+Mined= soup.findAll(text=True)
     body+mined:Baseline= address = soup.find(text='Address:')
        body+mined:-Code= soup.find_element_by_id('address:')
          body+mined:-NL= soup.find(text='Address:')
      body+mined:-Blocks= soup.find_all('td', {'address': 'My home address'})
      body+mined:-Inline= soup.find(text='Address:')

================================================================================

QUESTION: idx=213    id=4284648
-------------------------------------INPUTS-------------------------------------

tags: string, list, tuples
score: 14
slot_map: {'key': ['var_0', 'str_0'], 'quote': ['`', '`'], 'type': ['var', 'str'], 'value': ['l', '@']}
intent: convert elements of each tuple in list `l` into a string  separated by character `@`
body(Left in tags for better readability):
<p> I've written a function in python that returns a list, for example
<code_block>
 [(1,1),(2,2),(3,3)]

<p> But i want the output as a string so i can replace the comma with
another char so the output would be
<code_block>
 '1@1' '2@2' '3@3'

<p> Any easy way around this?:)
Thanks for any tips in advance

-------------------------------------OUTPUT-------------------------------------

                Expected= '""" """.join([(\'%d@%d\' % t) for t in l])'
           base:Baseline= """""".join(map(int, x) for x in L)
           body:Baseline= """""".join(str(x) for x in L))
            body:-Blocks= """""".join(str(x) for x in L)
              body:-Code= """""".join(str(x) for x in L)
            body:-Inline= """""".join(str(x) for x in L))
                body:-NL= [x[0] for x in L]
             base:+Mined= """""".join(map(str, L))
     body+mined:Baseline= """""".join(map(str, L))
        body+mined:-Code= """""".join(str(x) for x in L)
          body+mined:-NL= """""".join(map(lambda x: x.split('@'), L))
      body+mined:-Blocks= """""".join(map(str, L))
      body+mined:-Inline= """""".join(map(str, L))

================================================================================

QUESTION: idx=214    id=4284648
-------------------------------------INPUTS-------------------------------------

tags: string, list, tuples
score: 14
slot_map: {'key': ['var_0', 'str_0'], 'quote': ['`', "'"], 'type': ['var', 'str'], 'value': ['l', '@']}
intent: convert each tuple in list `l` to a string with '@' separating the tuples' elements
body(Left in tags for better readability):
<p> I've written a function in python that returns a list, for example
<code_block>
 [(1,1),(2,2),(3,3)]

<p> But i want the output as a string so i can replace the comma with
another char so the output would be
<code_block>
 '1@1' '2@2' '3@3'

<p> Any easy way around this?:)
Thanks for any tips in advance

-------------------------------------OUTPUT-------------------------------------

                Expected= '""" """.join([(\'%d@%d\' % (t[0], t[1])) for t in l])'
           base:Baseline= """""".join(l, '@')
           body:Baseline= """""".join(map(lambda x: x.split('@')))
            body:-Blocks= """""".join(str(x) for x in L))
              body:-Code= """""".join(str(x) for x in L)
            body:-Inline= """""".join(str(x) for x in L))
                body:-NL= """""".join(map(lambda x: x[1], x[2]))
             base:+Mined= """""".join(map(str, zip(*l))
     body+mined:Baseline= """""".join(map(str, L))
        body+mined:-Code= """""".join(str(x) for x in L)
          body+mined:-NL= """""".join(map(lambda x: x.split('@'), l))
      body+mined:-Blocks= """""".join(map(str, L))
      body+mined:-Inline= """""".join(map(str, L))

================================================================================

QUESTION: idx=215    id=26809954
-------------------------------------INPUTS-------------------------------------

tags: html, selenium, web-crawler, splinter
score: 7
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: get the html from the current web page of a selenium driver
body(Left in tags for better readability):
<p> I'm trying to crawl the website " <a> http://everydayhealth.com
<p> ". However, I found that the page will dynamically rendered. So,
when I click the button "More", some new news will be shown. However,
using splinter to click the button doesn't let "browser.html"
automatically changes to the current html content. Is there a way to
let it get newest html source, using either splinter or selenium? My
code in splinter is as follows:
<code_block>
 import requests
from bs4 import BeautifulSoup
from splinter import Browser

browser = Browser()
browser.visit('http://everydayhealth.com')
browser.click_link_by_text("More")

print(browser.html)

<p> Based on @Louis's answer, I rewrote the program as follows:
<code_block>
 from selenium import webdriver
from selenium.webdriver.support.ui import WebDriverWait

driver = webdriver.Firefox()
driver.get("http://www.everydayhealth.com")
more_xpath = '//a[@class="btn-more"]'
more_btn = WebDriverWait(driver, 10).until(lambda driver:
driver.find_element_by_xpath(more_xpath))
more_btn.click()
more_news_xpath = '(//a[@href="http://www.everydayhealth.com/recipe-
rehab/5-herbs-and-spices-to-intensify-flavor.aspx"])[2]'
WebDriverWait(driver, 5).until(lambda driver:
driver.find_element_by_xpath(more_news_xpath))

print(driver.execute_script("return
document.documentElement.outerHTML;"))
driver.quit()

<p> However, in the output text, I still couldn't find the text in the
updated page. For example, when I search "Is Milk Your Friend or
Foe?", it still returns nothing. What's the problem?

-------------------------------------OUTPUT-------------------------------------

                Expected= "driver.execute_script('return document.documentElement.outerHTML;')"
           base:Baseline= driver.find_element_by_css_id('html')
           body:Baseline= driver.find_element_by_xpath(http://www.everydayhealth.com')
            body:-Blocks= driver.find_element_by_css_selector('browser.html')
              body:-Code= driver.find_element_by_css_selector('browser.html')
            body:-Inline= driver.set_index('//a[@class="btn-more"]')
                body:-NL= driver.execute_script("return document.documentElement.outerHTML;"))
             base:+Mined= driver.get('http://stackoverflow.com')
     body+mined:Baseline= driver.execute_script("return document.documentElement.outerHTML;')
        body+mined:-Code= driver.get('http://everydayhealth.com')
          body+mined:-NL= driver.execute_script('return document.documentElement.outerHTML;')
      body+mined:-Blocks= driver.find_element_by_css_selector("http://everydayhealth.com').click()
      body+mined:-Inline= driver.click_link_by_text('More')

================================================================================

QUESTION: idx=216    id=29696641
-------------------------------------INPUTS-------------------------------------

tags: regex, string, list
score: 4
slot_map: {'key': ['str_0', 'var_0'], 'quote': ['`', '`'], 'type': ['str', 'var'], 'value': ['\\d+[xX]', 'teststr']}
intent: get all matches with regex pattern `\\d+[xx]` in list of string `teststr`
body(Left in tags for better readability):
<p> So I have this list of strings:
<code_block>
 teststr = ['1 FirstString', '2x Sec String', '3rd String', 'x
forString', '5X fifth']

<p> What I need to do, is to get all the elements from this list that
contain:
<code_block>
 number + "x"

<p> or
<code_block>
 number + "X"

<p> For example if I have the function
<code_block>
 def SomeFunc(string):
    #do something

<p> I would like to get an output like this:
<code_block>
 2x Sec String
5X fifth

<p> I found somewhere here in StackOverflow this function:
<code_block>
 def CheckIfContainsNumber(inputString):
    return any(char.isdigit() for char in inputString)

<p> But this returns each string that has a number.
<p> How can I expand the functions to get the desired output?

-------------------------------------OUTPUT-------------------------------------

                Expected= "[i for i in teststr if re.search('\\\\d+[xX]', i)]"
           base:Baseline= re.findall('\\d+[xx]', teststr)
           body:Baseline= re.match('\\d+[xx]', teststr)
            body:-Blocks= print(re.findall('\\d+[xx]')
              body:-Code= re.findall('\\d+[xx]', teststr)
            body:-Inline= re.match('\\d+[xx]', teststr)
                body:-NL= re.match('\\d+[xx]', teststr)
             base:+Mined= re.findall('\\d+[xx]', teststr)
     body+mined:Baseline= [match for match in re.findall('\\d+[xx]', teststr)]
        body+mined:-Code= [match for match in re.findall('\\d+[xx]', teststr)]
          body+mined:-NL= re.findall('\\d+[xx]', teststr)
      body+mined:-Blocks= re.findall('\\d+[xx]', teststr)
      body+mined:-Inline= re.findall('\\d+[xx]', teststr)

================================================================================

QUESTION: idx=217    id=15315452
-------------------------------------INPUTS-------------------------------------

tags: pandas
score: 261
slot_map: {'key': ['str_0', 'str_1', 'str_2', 'var_0'], 'quote': ["'", "'", "'", '`'], 'type': ['str', 'str', 'str', 'var'], 'value': ['A', 'B', 'C', 'df']}
intent: select values from column 'a' for which corresponding values in column 'b' will be greater than 50, and in column 'c' - equal 900 in dataframe `df`
body(Left in tags for better readability):
<p> For example I have simple DF:
<code_block>
 import pandas as pd
from random import randint

df = pd.DataFrame({'A': [randint(1, 9) for x in xrange(10)],
                   'B': [randint(1, 9)*10 for x in xrange(10)],
                   'C': [randint(1, 9)*100 for x in xrange(10)]})

<p> Can I select values from 'A' for which corresponding values for
'B' will be greater than 50, and for 'C' - not equal 900, using
methods and idioms of Pandas?

-------------------------------------OUTPUT-------------------------------------

                Expected= "df['A'][(df['B'] > 50) & (df['C'] == 900)]"
           base:Baseline= df.loc[df['A'] == 50, df['C'] != 900]
           body:Baseline= df = pd.DataFrame({'A': [i > 50, 'B': i < 50], 'C': i > 900})
            body:-Blocks= df['A'] = df['C']
              body:-Code= df['A'] = df['C']
            body:-Inline= df.loc[df['A'] != 900]
                body:-NL= df = pd.DataFrame(['A', 'B', 'C'], axis=1)
             base:+Mined= df.loc[df['A'] > 50, 'B'] > 900]
     body+mined:Baseline= df.loc[df['A'].isin(['B', 'C'])]
        body+mined:-Code= df.loc[df['A'] > 50, ['B'] > 900]
          body+mined:-NL= df.loc[df['A'].isin(['B', 'C'])]
      body+mined:-Blocks= df.loc[df['B'] > 50, 'C'] > 900]
      body+mined:-Inline= df[['A', 'B', 'C']].loc[df['C'] > 900]

================================================================================

QUESTION: idx=218    id=4642501
-------------------------------------INPUTS-------------------------------------

tags: sorting, dictionary
score: 21
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['o']}
intent: sort dictionary `o` in ascending order based on its keys and items
body(Left in tags for better readability):
<p> Can anyone tell me how I can sort this:
<code_block>
 {'a': [1, 2, 3], 'c': ['one', 'two'], 'b': ['blah', 'bhasdf',
'asdf'], 'd': ['asdf', 'wer', 'asdf', 'zxcv']}

<p> into
<code_block>
 {'a': [1, 2, 3], 'b': ['blah', 'bhasdf', 'asdf'], 'c': ['one',
'two'],'d': ['asdf', 'wer', 'asdf', 'zxcv']}

<p> ?
Thanks!
<p> UPDATE 1, code sample:
<p> So I am doing linguistics. One article is broken down to words
that are stored in a database and have all kinds of properties
including para ID and sentence ID. The task: trying to rebuild the
original text.
<p> Get 500 consecutive words from DB
<code_block>
 words = Words.objects.all()[wordId:wordId+500]
# I first create paragraphs, through which I can loop later in my
django template,
# and in each para will be a list of words (also dictionaries).
# So i am trying to get a dictionary with values that are lists of
dictionaries.
# 'pp' i make just for shorthanding a long-named variable.
paras={}
para_high = para_low =  words[0].belongs_to_paragraph
for w in words:
    last_word = w
    pp = w.belongs_to_paragraph
    if pp >para_high:
        para_high = pp
    if pp < para_low:
        para_low = pp
    if pp in paras:
        paras[pp].append(w)
    else:
        list = [w]
        paras[pp] = list
# Since there are blank lines between paragraphs, in rebuilding the
text as it
    #  looked originally, I need to insert blank lines.
    # Since i have the ID's of the paragraphs and they go somewhat
like that: 1,3,4,8,9
    #(the gaps between 1 & 3 and 4 & 8 i have to fill in with
something else,
    # which is why i had para_low and para_high to loop the range.
isbr = True
for i in range(para_low, para_high+1):
    if i in paras:
        isbr = True
    else:
        if isbr:
            paras[i]=['break']
            isbr = False
        else:
            paras[i]=[]

<p> At this point, however, if I try to loop the dict and rebuild the
text, some later id'd paragraphs come before previous ones, and that
just doesn't do it.
<p> UPDATE 2, loop code:
<code_block>
         {% for k,v in wording.iteritems()  %}
        {% if v[0] == 'break' %}
        <br/>
        {% else %}
        </div> <div class="p">{% for word in v %}{% if
word.special==0%} {% endif %} <span class="word {% if word.special ==
0%}clickable{% endif%}" wid="{{word.id}}" special="{{word.special}}"
somethingElse={{word.somethingElse}}>{{ word.word }} </span>{% endfor
%}
        {% endif %}
    {% endfor %}


-------------------------------------OUTPUT-------------------------------------

                Expected= 'sorted(o.items())'
           base:Baseline= sorted(list(o.items()), key=lambda x: x[1])
           body:Baseline= sorted(list(o.items()), key=lambda x: x[1], reverse=True)
            body:-Blocks= sorted(o, key=lambda x: x[1])
              body:-Code= sorted(list(o.items()), key=lambda x: x[1])
            body:-Inline= sorted(o, key=lambda x: x[1])
                body:-NL= sorted(o, key=lambda x: x[1])
             base:+Mined= sorted(list(o.items()), key=lambda x: x[1])
     body+mined:Baseline= sorted(o, key=itemgetter(1), reverse=True)
        body+mined:-Code= sorted(list(o.items()), key=lambda x: x[1])
          body+mined:-NL= sorted(list(o.items()), key=lambda x: x[1])
      body+mined:-Blocks= sorted(list(o.items()), key=lambda x: x[1])
      body+mined:-Inline= sorted(list(o.items()), key=lambda x: x[1])

================================================================================

QUESTION: idx=219    id=4642501
-------------------------------------INPUTS-------------------------------------

tags: sorting, dictionary
score: 21
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['d']}
intent: get sorted list of keys of dict `d`
body(Left in tags for better readability):
<p> Can anyone tell me how I can sort this:
<code_block>
 {'a': [1, 2, 3], 'c': ['one', 'two'], 'b': ['blah', 'bhasdf',
'asdf'], 'd': ['asdf', 'wer', 'asdf', 'zxcv']}

<p> into
<code_block>
 {'a': [1, 2, 3], 'b': ['blah', 'bhasdf', 'asdf'], 'c': ['one',
'two'],'d': ['asdf', 'wer', 'asdf', 'zxcv']}

<p> ?
Thanks!
<p> UPDATE 1, code sample:
<p> So I am doing linguistics. One article is broken down to words
that are stored in a database and have all kinds of properties
including para ID and sentence ID. The task: trying to rebuild the
original text.
<p> Get 500 consecutive words from DB
<code_block>
 words = Words.objects.all()[wordId:wordId+500]
# I first create paragraphs, through which I can loop later in my
django template,
# and in each para will be a list of words (also dictionaries).
# So i am trying to get a dictionary with values that are lists of
dictionaries.
# 'pp' i make just for shorthanding a long-named variable.
paras={}
para_high = para_low =  words[0].belongs_to_paragraph
for w in words:
    last_word = w
    pp = w.belongs_to_paragraph
    if pp >para_high:
        para_high = pp
    if pp < para_low:
        para_low = pp
    if pp in paras:
        paras[pp].append(w)
    else:
        list = [w]
        paras[pp] = list
# Since there are blank lines between paragraphs, in rebuilding the
text as it
    #  looked originally, I need to insert blank lines.
    # Since i have the ID's of the paragraphs and they go somewhat
like that: 1,3,4,8,9
    #(the gaps between 1 & 3 and 4 & 8 i have to fill in with
something else,
    # which is why i had para_low and para_high to loop the range.
isbr = True
for i in range(para_low, para_high+1):
    if i in paras:
        isbr = True
    else:
        if isbr:
            paras[i]=['break']
            isbr = False
        else:
            paras[i]=[]

<p> At this point, however, if I try to loop the dict and rebuild the
text, some later id'd paragraphs come before previous ones, and that
just doesn't do it.
<p> UPDATE 2, loop code:
<code_block>
         {% for k,v in wording.iteritems()  %}
        {% if v[0] == 'break' %}
        <br/>
        {% else %}
        </div> <div class="p">{% for word in v %}{% if
word.special==0%} {% endif %} <span class="word {% if word.special ==
0%}clickable{% endif%}" wid="{{word.id}}" special="{{word.special}}"
somethingElse={{word.somethingElse}}>{{ word.word }} </span>{% endfor
%}
        {% endif %}
    {% endfor %}


-------------------------------------OUTPUT-------------------------------------

                Expected= 'sorted(d)'
           base:Baseline= sorted(list(d.keys())
           body:Baseline= sorted(list(d.keys()), key=lambda x: x[1], reverse=True)
            body:-Blocks= sorted(d, key=lambda x: x[1])
              body:-Code= sorted(list(d.items()), key=lambda x: x[1])
            body:-Inline= sorted(list(d.keys()), key=lambda x: x[1])
                body:-NL= sorted(list(d.keys()), key=lambda x: x[1])
             base:+Mined= sorted(d, key=d.get)
     body+mined:Baseline= sorted(list(d.items()), key=lambda x: x[1])
        body+mined:-Code= sorted(list(d.items()), key=lambda x: x[1])
          body+mined:-NL= sorted(list(d.items()), key=lambda x: x[1])
      body+mined:-Blocks= sorted(list(d.items()), key=lambda x: x[1])
      body+mined:-Inline= sorted(d, key=lambda x: x[1])

================================================================================

QUESTION: idx=220    id=4642501
-------------------------------------INPUTS-------------------------------------

tags: sorting, dictionary
score: 21
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: how to sort dictionaries by keys in python
body(Left in tags for better readability):
<p> Can anyone tell me how I can sort this:
<code_block>
 {'a': [1, 2, 3], 'c': ['one', 'two'], 'b': ['blah', 'bhasdf',
'asdf'], 'd': ['asdf', 'wer', 'asdf', 'zxcv']}

<p> into
<code_block>
 {'a': [1, 2, 3], 'b': ['blah', 'bhasdf', 'asdf'], 'c': ['one',
'two'],'d': ['asdf', 'wer', 'asdf', 'zxcv']}

<p> ?
Thanks!
<p> UPDATE 1, code sample:
<p> So I am doing linguistics. One article is broken down to words
that are stored in a database and have all kinds of properties
including para ID and sentence ID. The task: trying to rebuild the
original text.
<p> Get 500 consecutive words from DB
<code_block>
 words = Words.objects.all()[wordId:wordId+500]
# I first create paragraphs, through which I can loop later in my
django template,
# and in each para will be a list of words (also dictionaries).
# So i am trying to get a dictionary with values that are lists of
dictionaries.
# 'pp' i make just for shorthanding a long-named variable.
paras={}
para_high = para_low =  words[0].belongs_to_paragraph
for w in words:
    last_word = w
    pp = w.belongs_to_paragraph
    if pp >para_high:
        para_high = pp
    if pp < para_low:
        para_low = pp
    if pp in paras:
        paras[pp].append(w)
    else:
        list = [w]
        paras[pp] = list
# Since there are blank lines between paragraphs, in rebuilding the
text as it
    #  looked originally, I need to insert blank lines.
    # Since i have the ID's of the paragraphs and they go somewhat
like that: 1,3,4,8,9
    #(the gaps between 1 & 3 and 4 & 8 i have to fill in with
something else,
    # which is why i had para_low and para_high to loop the range.
isbr = True
for i in range(para_low, para_high+1):
    if i in paras:
        isbr = True
    else:
        if isbr:
            paras[i]=['break']
            isbr = False
        else:
            paras[i]=[]

<p> At this point, however, if I try to loop the dict and rebuild the
text, some later id'd paragraphs come before previous ones, and that
just doesn't do it.
<p> UPDATE 2, loop code:
<code_block>
         {% for k,v in wording.iteritems()  %}
        {% if v[0] == 'break' %}
        <br/>
        {% else %}
        </div> <div class="p">{% for word in v %}{% if
word.special==0%} {% endif %} <span class="word {% if word.special ==
0%}clickable{% endif%}" wid="{{word.id}}" special="{{word.special}}"
somethingElse={{word.somethingElse}}>{{ word.word }} </span>{% endfor
%}
        {% endif %}
    {% endfor %}


-------------------------------------OUTPUT-------------------------------------

                Expected= 'sorted(d.items())'
           base:Baseline= sorted(list(d.items()), key=lambda x: x[1])
           body:Baseline= sorted(list(d.items()), key=lambda x: x[1], reverse=True)
            body:-Blocks= sorted(list(d.items()), key=lambda x: x[1])
              body:-Code= sorted(list(d.items()), key=lambda x: x[1])
            body:-Inline= sorted(list(d.items()), key=lambda x: x[1])
                body:-NL= sorted(list(d.items()), key=lambda x: x[1])
             base:+Mined= sorted(list(d.items()), key=lambda x: x[1])
     body+mined:Baseline= sorted(list(d.items()), key=lambda x: x[1])
        body+mined:-Code= sorted(list(d.items()), key=lambda x: x[1])
          body+mined:-NL= ['a', 'b', 'c', 'd', 'asdf', 'zxcv']
      body+mined:-Blocks= sorted(list(d.items()), key=lambda x: x[1])
      body+mined:-Inline= sorted(words, key=lambda x: x[1])

================================================================================

QUESTION: idx=221    id=642154
-------------------------------------INPUTS-------------------------------------

tags: string, integer
score: 444
slot_map: {'key': ['str_0'], 'quote': ['"'], 'type': ['str'], 'value': ['1']}
intent: convert string "1" into integer
body(Left in tags for better readability):
<p> I have a tuple of tuples from a MySQL query like this:
<code_block>
 T1 = (('13', '17', '18', '21', '32'),
      ('07', '11', '13', '14', '28'),
      ('01', '05', '06', '08', '15', '16'))

<p> I'd like to convert all the string elements into integers and put
them back into a list of lists:
<code_block>
 T2 = [[13, 17, 18, 21, 32], [7, 11, 13, 14, 28], [1, 5, 6, 8, 15,
16]]

<p> I tried to achieve it with <code> eval <p>  but didn't get any
decent result yet.

-------------------------------------OUTPUT-------------------------------------

                Expected= "int('1')"
           base:Baseline= int('1', 1))
map(int, re.findall('\n')
           body:Baseline= map(int, map(map(lambda x: x[1], reverse=True))
            body:-Blocks= map(int, x.split('1')))
              body:-Code= [int(x) for x in enumerate(1, 2)]
            body:-Inline= int(map(int, x, 16))
                body:-NL= int('1').decode('int')
             base:+Mined= int('1' + str(i))
     body+mined:Baseline= [int(x) for x in T2]
        body+mined:-Code= map(int, ['1', '2', '3'])
          body+mined:-NL= ast.literal_eval("1"")
      body+mined:-Blocks= [int(x) for x in '1']
      body+mined:-Inline= [int(x) for x in T2]

================================================================================

QUESTION: idx=222    id=642154
-------------------------------------INPUTS-------------------------------------

tags: string, integer
score: 444
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: function to convert strings into integers
body(Left in tags for better readability):
<p> I have a tuple of tuples from a MySQL query like this:
<code_block>
 T1 = (('13', '17', '18', '21', '32'),
      ('07', '11', '13', '14', '28'),
      ('01', '05', '06', '08', '15', '16'))

<p> I'd like to convert all the string elements into integers and put
them back into a list of lists:
<code_block>
 T2 = [[13, 17, 18, 21, 32], [7, 11, 13, 14, 28], [1, 5, 6, 8, 15,
16]]

<p> I tried to achieve it with <code> eval <p>  but didn't get any
decent result yet.

-------------------------------------OUTPUT-------------------------------------

                Expected= 'int()'
           base:Baseline= int(s) for s in re.findall('\\d+', 16)
           body:Baseline= [i for i, j in enumerate(zip(tuple, tuple), tuple)) for tuple in list(T1, T2)]
            body:-Blocks= map(int, x.split())
              body:-Code= map(int, sublist, zip(*map(lambda x: x.split())))
            body:-Inline= map(int, x.split())
                body:-NL= [int(x) for x in zip(T1, T2)]
             base:+Mined= map(int, inputstring.split(','))
     body+mined:Baseline= map(int, T2.split())
        body+mined:-Code= [map(int, x) for x in rows]
          body+mined:-NL= map(int, ['13', '17', '18', '21', '32'])
      body+mined:-Blocks= map(int, [''.join(str(i) for i in rows])
      body+mined:-Inline= [int(x) for x in T2]

================================================================================

QUESTION: idx=223    id=642154
-------------------------------------INPUTS-------------------------------------

tags: string, integer
score: 444
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['T1']}
intent: convert items in `t1` to integers
body(Left in tags for better readability):
<p> I have a tuple of tuples from a MySQL query like this:
<code_block>
 T1 = (('13', '17', '18', '21', '32'),
      ('07', '11', '13', '14', '28'),
      ('01', '05', '06', '08', '15', '16'))

<p> I'd like to convert all the string elements into integers and put
them back into a list of lists:
<code_block>
 T2 = [[13, 17, 18, 21, 32], [7, 11, 13, 14, 28], [1, 5, 6, 8, 15,
16]]

<p> I tried to achieve it with <code> eval <p>  but didn't get any
decent result yet.

-------------------------------------OUTPUT-------------------------------------

                Expected= 'T2 = [map(int, x) for x in T1]'
           base:Baseline= int(map(int(t1))
           body:Baseline= [i for i, j in zip(t1, t2)]
            body:-Blocks= [int(x) for x in t1]
              body:-Code= map(int, tuple(t1))
            body:-Inline= map(int, x.split())
                body:-NL= [int(x) for x in zip(t1, t2)]
             base:+Mined= int(str(i) for i in t1)
     body+mined:Baseline= [int(x) for x in T1]
        body+mined:-Code= t1 = [int(i) for i in t1]
          body+mined:-NL= ast.literal_eval(t1)
      body+mined:-Blocks= [int(x) for x in t1]
      body+mined:-Inline= map(int, zip(*t1))

================================================================================

QUESTION: idx=224    id=3777301
-------------------------------------INPUTS-------------------------------------

tags: shell
score: 237
slot_map: {'key': ['str_0'], 'quote': ['`'], 'type': ['str'], 'value': ['./test.sh']}
intent: call a shell script `./test.sh` using subprocess
body(Left in tags for better readability):
<p> How to call a shell script from python code?

-------------------------------------OUTPUT-------------------------------------

                Expected= "subprocess.call(['./test.sh'])"
           base:Baseline= subprocess.call('./test.sh', shell=True)
           body:Baseline= subprocess.call('./test.sh', shell=True)
            body:-Blocks= subprocess.call('./test.sh', shell=True)
              body:-Code= subprocess.call('./test.sh', shell=True)
            body:-Inline= subprocess.call('./test.sh', shell=True)
                body:-NL= subprocess.call('./test.sh')
             base:+Mined= subprocess.call('./test.sh', shell=True)
     body+mined:Baseline= subprocess.call('./test.sh', shell=True)
        body+mined:-Code= subprocess.call('./test.sh', shell=True)
          body+mined:-NL= subprocess.call(['./test.sh', shell=True)
      body+mined:-Blocks= subprocess.call('/test.sh', shell=True)
      body+mined:-Inline= subprocess.call('./test.sh', shell=True)

================================================================================

QUESTION: idx=225    id=3777301
-------------------------------------INPUTS-------------------------------------

tags: shell
score: 237
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['notepad']}
intent: call a shell script `notepad` using subprocess
body(Left in tags for better readability):
<p> How to call a shell script from python code?

-------------------------------------OUTPUT-------------------------------------

                Expected= "subprocess.call(['notepad'])"
           base:Baseline= subprocess.call('notepad', shell=True)
           body:Baseline= subprocess.call('notepad', shell=True)
            body:-Blocks= subprocess.call('notepad', shell=True)
              body:-Code= subprocess.call('notepad', shell=True)
            body:-Inline= subprocess.call('notepad', shell=True)
                body:-NL= subprocess.call('notepad', shell=True)
             base:+Mined= subprocess.call('notepad', shell=True)
     body+mined:Baseline= subprocess.call(['notepad', 'notepad'])
        body+mined:-Code= subprocess.call('notepad', shell=True)
          body+mined:-NL= subprocess.call(['notepad', 'notepad'])
      body+mined:-Blocks= subprocess.call(['notepad', '/r'])
      body+mined:-Inline= subprocess.call(['notepad', 'notepad'])

================================================================================

QUESTION: idx=226    id=7946798
-------------------------------------INPUTS-------------------------------------

tags: list
score: 90
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['l1', 'l2']}
intent: combine lists `l1` and `l2`  by alternating their elements
body(Left in tags for better readability):
<p> In Python, is there a good way to interleave two lists of the same
length?
<p> Say I'm given <code> [1,2,3] <p>  and <code> [10,20,30] <p> . I'd
like to transform those into <code> [1,10,2,20,3,30] <p> .

-------------------------------------OUTPUT-------------------------------------

                Expected= '[val for pair in zip(l1, l2) for val in pair]'
           base:Baseline= [i for i, j in zip(l1, l2)]
           body:Baseline= [i for i, j in zip(l1, l2)]
            body:-Blocks= [i for i, j in zip(l1, l2)]
              body:-Code= [i for i, j in zip(l1, l2)]
            body:-Inline= zip(l1, l2)
                body:-NL= [i for i, j in zip(l1, l2)]
             base:+Mined= [(x + y) for x, y in zip(l1, l2)]
     body+mined:Baseline= [(x + y) for x, y in zip(l1, l2)]
        body+mined:-Code= [(x + y) for x, y in zip(l1, l2)]
          body+mined:-NL= from functools import reduce
reduce(lambda x, y: x + y, l1, l2)
      body+mined:-Blocks= [(x + y) for x, y in zip(l1, l2)]
      body+mined:-Inline= [(x + y) for x, y in zip(l1, l2)]

================================================================================

QUESTION: idx=227    id=8908287
-------------------------------------INPUTS-------------------------------------

tags: base64
score: 279
slot_map: {'key': ['str_0'], 'quote': ["'"], 'type': ['str'], 'value': ['data to be encoded']}
intent: encode string 'data to be encoded'
body(Left in tags for better readability):
<p> Following this <a> python example <p> , I encode a string as
Base64 with:
<code_block>
 <console_in> import base64
<console_in> encoded = base64.b64encode(b'data to be encoded')
<console_in> encoded
<console_out> b'ZGF0YSB0byBiZSBlbmNvZGVk'

<p> But, if I leave out the leading <code> b <p> :
<code_block>
 <console_in> encoded = base64.b64encode('data to be encoded')
<console_out>
<p> I get the following error:
<code_block>
 Traceback (most recent call last):
  File " <stdin>", line 1, in <module>
  File "C:\Python32\lib\base64.py", line 56, in b64encode
   raise TypeError("expected bytes, not %s" % s.__class__.__name__)
   TypeError: expected bytes, not str

<p> Why is this?

-------------------------------------OUTPUT-------------------------------------

                Expected= "encoded = base64.b64encode('data to be encoded')"
           base:Baseline= """data to be encoded""".encode('utf-8')
           body:Baseline= struct.encode('data to be encoded')
            body:-Blocks= """data to be encoded""".encode('utf-8')
              body:-Code= struct.encode('data to be encoded')
            body:-Inline= struct.encode('data to be encoded')
                body:-NL= struct.encode('data to be encoded')
             base:+Mined= data.encode('utf-8')
     body+mined:Baseline= encoded = base64.b64encode('data to be encoded')
        body+mined:-Code= """data to be encoded""".encode('base64')
          body+mined:-NL= base64.b64encode('data to be encoded')
      body+mined:-Blocks= """data to be encoded""".encode('base64')
      body+mined:-Inline= encoded = base64.b64encode('data to be encoded')

================================================================================

QUESTION: idx=228    id=8908287
-------------------------------------INPUTS-------------------------------------

tags: base64
score: 279
slot_map: {'key': ['str_0', 'var_0'], 'quote': ['`', '`'], 'type': ['str', 'var'], 'value': ['data to be encoded', 'ascii']}
intent: encode a string `data to be encoded` to `ascii` encoding
body(Left in tags for better readability):
<p> Following this <a> python example <p> , I encode a string as
Base64 with:
<code_block>
 <console_in> import base64
<console_in> encoded = base64.b64encode(b'data to be encoded')
<console_in> encoded
<console_out> b'ZGF0YSB0byBiZSBlbmNvZGVk'

<p> But, if I leave out the leading <code> b <p> :
<code_block>
 <console_in> encoded = base64.b64encode('data to be encoded')
<console_out>
<p> I get the following error:
<code_block>
 Traceback (most recent call last):
  File " <stdin>", line 1, in <module>
  File "C:\Python32\lib\base64.py", line 56, in b64encode
   raise TypeError("expected bytes, not %s" % s.__class__.__name__)
   TypeError: expected bytes, not str

<p> Why is this?

-------------------------------------OUTPUT-------------------------------------

                Expected= "encoded = 'data to be encoded'.encode('ascii')"
           base:Baseline= ascii.encode('data to be encoded')
           body:Baseline= struct.encode('data to be encoded')
            body:-Blocks= ascii.encode('data to be encoded')
              body:-Code= ascii.encode('data to be encoded')
            body:-Inline= struct.encode('data to be encoded')
                body:-NL= struct.encode('data to be encoded')
             base:+Mined= encodedata.encode('ascii', 'ignore')
     body+mined:Baseline= encoded = base64.b64encode('data to be encoded')
        body+mined:-Code= ascii.encode('base64')
          body+mined:-NL= base64.b64encode('data to be encoded')
      body+mined:-Blocks= ascii.encode('base64')
      body+mined:-Inline= encoded = base64.b64encode('data to be encoded')

================================================================================

QUESTION: idx=229    id=7856296
-------------------------------------INPUTS-------------------------------------

tags: parsing, csv, dictionary
score: 32
slot_map: {'key': ['str_0'], 'quote': ["'"], 'type': ['str'], 'value': ['text.txt']}
intent: parse tab-delimited csv file 'text.txt' into a list
body(Left in tags for better readability):
<p> I currently have a CSV file which, when opened in Excel, has a
total of 5 columns. Only columns A and C are of any significance to me
and the data in the remaining columns is irrelevant.
<p> Starting on line 8 and then working in multiples of 7 (ie. lines
8, 15, 22, 29, 36 etc...), I am looking to create a dictionary with
Python 2.7 with the information from these fields. The data in column
A will be the key (a 6-digit integer) and the data in column C being
the respective value for the key. I've tried to highlight this below
but the formatting isn't the best:-
<code_block>
     A        B      C          D
1                           CDCDCDCD
2                           VDDBDDB
3
4
5
6
7  DDEFEEF                   FEFEFEFE
8  123456         JONES
9
10
11
12
13
14
15 293849         SMITH

<p> As per the above, I am looking to extract the value from A7
(DDEFEEF) as a key in my dictionary and "FEFEFEFE" being the
respective data and then add another entry to my dictionary, jumping
to line 15 with "2938495" being my key and "Smith" being the
respective value.
<p> Any suggestions? The source file is a .txt file with entries being
tab-delimited.
Thanks
<p> Clarification:
<p> Just to clarify, so far, I have tried the below:-
<code_block>
 import csv

mydict = {:}
f = open("myfile", 'rt')
reader = csv.reader(f)
    for row in reader:
        print row

<p> The above simply prints out all content though a row at a time. I
did try "for row(7) in reader" but this returned an error. I then
researched it and had a go at the below but it didn't work neither:
<code_block>
 import csv
from itertools import islice

entries = csv.reader(open("myfile", 'rb'))
mydict = {'key' : 'value'}

for i in xrange(6):
    mydict['i(0)] = 'I(2)    # integers representing columns
    range = islice(entries,6)
    for entry in range:
        mydict[entries(0) = entries(2)] # integers representing
columns


-------------------------------------OUTPUT-------------------------------------

                Expected= "lol = list(csv.reader(open('text.txt', 'rb'), delimiter='\\t'))"
           base:Baseline= list('text.txt', delimiter=',')
           body:Baseline= df = open('text.txt', 'rt')
            body:-Blocks= [open('text.txt', 'rb').read()]
              body:-Code= list('text.txt', delimiter=',')
            body:-Inline= df = open('text.txt', 'rt')
                body:-NL= list('text.txt', delimiter=',')
             base:+Mined= [item for sublist in open('text.txt', 'rb').read()]
     body+mined:Baseline= [row[0] for row in reader]
        body+mined:-Code= [row[0] for row in reader]
          body+mined:-NL= list(open('myfile', 'rb'))
      body+mined:-Blocks= list(open('text.txt', 'rb').read().split()))
      body+mined:-Inline= f = csv.reader(f)

================================================================================

QUESTION: idx=230    id=9035479
-------------------------------------INPUTS-------------------------------------

tags: object, dictionary
score: 10
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['my_str', 'my_object']}
intent: get attribute `my_str` of object `my_object`
body(Left in tags for better readability):
<code_block>
 <console_in> my_object.name = 'stuff'
<console_in> my_str = 'name'
<console_in> my_object[my_str] # won't work because it's not a
dictionary :)
<console_out>
<p> How can I access to the fields of <code> my_object <p>  defined on
<code> my_str <p>  ?

-------------------------------------OUTPUT-------------------------------------

                Expected= 'getattr(my_object, my_str)'
           base:Baseline= my_object.getattr(my_str)
           body:Baseline= my_object[my_str]
            body:-Blocks= my_object.getattr(my_str)
              body:-Code= my_object.getattr(my_str)
            body:-Inline= my_object[my_str]
                body:-NL= my_object[__name__]
             base:+Mined= my_str = my_object.getattr(my_object)
     body+mined:Baseline= getattr(my_object, my_str)
        body+mined:-Code= getattr(my_object, my_str)
          body+mined:-NL= my_object.getattr(my_str)
      body+mined:-Blocks= getattr(my_object, my_object)
      body+mined:-Inline= getattr(my_object, 'name', None)

================================================================================

QUESTION: idx=231    id=5558418
-------------------------------------INPUTS-------------------------------------

tags: list, dictionary
score: 81
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['LD']}
intent: group a list of dicts `ld` into one dict by key
body(Left in tags for better readability):
<p> I am looking to change back and forth between a dictionary of
lists (all of the same length):
<code_block>
 DL = {'a': [0, 1], 'b': [2, 3]}

<p> and a list of dictionaries:
<code_block>
 LD = [{'a': 0, 'b': 2}, {'a': 1, 'b': 3}]

<p> I am looking for the cleanest way to switch between the two forms.

-------------------------------------OUTPUT-------------------------------------

                Expected= 'print(dict(zip(LD[0], zip(*[list(d.values()) for d in LD]))))'
           base:Baseline= dict((k, v) for k, v in list(ld.items()))
           body:Baseline= dict((k, v) for k, v in zip(DL, LD)]
            body:-Blocks= dict((k, v) for k, v in list(d.items()))
              body:-Code= dict((k, v) for k, v in list(ld.items()))
            body:-Inline= [d['a'] for d in DL]
                body:-NL= [d['a'] for d in LD]
             base:+Mined= dict((k, v) for k, v in list(ld.items()))
     body+mined:Baseline= [dict(zip(DL, LD)) for x in LD]
        body+mined:-Code= dict((k, v) for k, v in list(d.items()) for d in l)
          body+mined:-NL= [dict(zip(DL, LD)) for x in LD]
      body+mined:-Blocks= dict((k, v) for k, v in list(ld.items()) for v in d.items()))
      body+mined:-Inline= [dict(zip(DL, LD)) for x in list(LD.items())]

================================================================================

QUESTION: idx=232    id=638048
-------------------------------------INPUTS-------------------------------------

tags: list, tuples
score: 31
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: how do i sum the first value in each tuple in a list of tuples in python?
body(Left in tags for better readability):
<p> I have a list of tuples (always pairs) like this:
<code_block>
 [(0, 1), (2, 3), (5, 7), (2, 1)]

<p> I'd like to find the sum of the first items in each pair, i.e.:
<code_block>
 0 + 2 + 5 + 2

<p> How can I do this in Python? At the moment I'm iterating through
the list:
<code_block>
 sum = 0
for pair in list_of_pairs:
   sum += pair[0]

<p> I have a feeling there must be a more Pythonic way.

-------------------------------------OUTPUT-------------------------------------

                Expected= 'sum([pair[0] for pair in list_of_pairs])'
           base:Baseline= sum(x[0] for x in zip(*my_list, my_list))
           body:Baseline= sum(x * y) for x, y in zip(zip(list_of_pairs), reverse=True)
            body:-Blocks= sum(x[0] for x in zip(*tuple(zip(x), x[0]), reverse=True)
              body:-Code= sum(x[0] for x in zip(*my_list))
            body:-Inline= sum(x[0] for x in zip(*my_list)
                body:-NL= sum(x[0] for x in zip(*list_of_pairs)]
             base:+Mined= sum(x[0] for x in l)
     body+mined:Baseline= sum(x[0] for x in list_of_pairs)
        body+mined:-Code= print(sum(x[0] for x in l))
          body+mined:-NL= sum(x[0] for x in list_of_pairs)
      body+mined:-Blocks= sum(x[0] for x in l)
      body+mined:-Inline= sum(x[0] for x in list_of_pairs)

================================================================================

QUESTION: idx=233    id=14950260
-------------------------------------INPUTS-------------------------------------

tags: unicode, dictionary
score: 52
slot_map: {'key': ['str_0', '{str_0}'], 'quote': ['"', '"'], 'type': ['str', 'str'], 'value': ["{'code1':1,'code2':1}", "{'code1':1,'code2':1}"]}
intent: convert unicode string u"{'code1':1,'code2':1}" into dictionary
body(Left in tags for better readability):
<p> I have unicode <code> u"{'code1':1,'code2':1}" <p>  and I want it
in dictionary format.
<p> I want it in <code> {'code1':1,'code2':1} <p>  format.
<p> I tried <code> unicodedata.normalize('NFKD',
my_data).encode('ascii','ignore') <p>  but it returns string not
dictionary.
<p> Can anyone help me?

-------------------------------------OUTPUT-------------------------------------

                Expected= 'd = ast.literal_eval("{\'code1\':1,\'code2\':1}")'
           base:Baseline= dict((k, v) for k, v in u.split('{'code1': 1,'code2': 1})
           body:Baseline= dict((k, v) for k, v in unicodedata.normalize('NFKD', {'code1': 1, 'code2': 1})
    )
            body:-Blocks= dict((k, v) for k, v in unicodedata.normalize('NFKD', my_data).encode('ascii','ignore')
              body:-Code= dict((k, v) for k, v in {'code1': 1, 'code2': 1})
            body:-Inline= dict('{'code1': 1,' 'code2': 1}'.decode('unicode_escape')
                body:-NL= dict((k, v) for k, v in u.items() if v != 1)
             base:+Mined= {'code1': 1, 'code2': 1}
     body+mined:Baseline= {'code1': 1, 'code2': 1}
        body+mined:-Code= dict(k.encode('utf-8') for k in u.decode('unicode-escape'))
          body+mined:-NL= '{'code1': 1,'code2': 1}'.encode('ascii', 'ignore')
      body+mined:-Blocks= unicodedata.normalize('NFKD', my_data).encode('ascii', 'ignore')
      body+mined:-Inline= """""".join(c for c in "{'code1': 1,'code2': 1}")

================================================================================

QUESTION: idx=234    id=11416772
-------------------------------------INPUTS-------------------------------------

tags: regex, dollar-sign
score: 12
slot_map: {'key': ['var_0', 'str_0'], 'quote': ['`', '`'], 'type': ['var', 'str'], 'value': ['mystring', '$']}
intent: find all words in a string `mystring` that start with the `$` sign
body(Left in tags for better readability):
<p> How can I extract all words in a string that start with the $
sign? For example in the string
<code_block>
 This $string is an $example

<p> I want to extract the words <code> $string <p>  and <code>
$example <p> .
<p> I tried with this regex <code> \b[$]\S* <p>  but it works fine
only if I use a normal character rather than dollar.

-------------------------------------OUTPUT-------------------------------------

                Expected= "[word for word in mystring.split() if word.startswith('$')]"
           base:Baseline= re.findall('\\d+$', myString)
           body:Baseline= re.findall('\\b[$]\\S*', mystring)
            body:-Blocks= re.findall('\\b[$]\\S*', mystring)
              body:-Code= re.findall('\\w+)', myString)
            body:-Inline= re.findall('\\w+)', mystring)
                body:-NL= re.findall('\\b[$]', mystring)
             base:+Mined= re.findall('\\w+', mystring)
     body+mined:Baseline= re.findall('\\b[$]\\S*', mystring)
        body+mined:-Code= re.findall('\\b$,', mystring)
          body+mined:-NL= re.findall('\\b[$]', mystring)
      body+mined:-Blocks= re.findall('\\b[$]\\S*', mystring)
      body+mined:-Inline= re.findall('\\w(\\w+)', mystring)

================================================================================

QUESTION: idx=235    id=11331982
-------------------------------------INPUTS-------------------------------------

tags: regex, url, replace
score: 48
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['text']}
intent: remove any url within string `text`
body(Left in tags for better readability):
<p> I want to remove all URLs inside a string (replace them with "")
I searched around but couldn't really find what I want.
<p> Example:
<code_block>
 text1
text2
http://url.com/bla1/blah1/
text3
text4
http://url.com/bla2/blah2/
text5
text6
http://url.com/bla3/blah3/

<p> I want the result to be:
<code_block>
 text1
text2
text3
text4
text5
text6


-------------------------------------OUTPUT-------------------------------------

                Expected= "text = re.sub('^https?:\\\\/\\\\/.*[\\\\r\\\\n]*', '', text, flags=re.MULTILINE)"
           base:Baseline= r = re.sub('[^a-zA-Z]', text)
           body:Baseline= text = re.sub('/', text)
            body:-Blocks= re.sub('(?=)', '', text)
              body:-Code= re.sub('(?=\\)', text)
            body:-Inline= re.sub('(?=)', text)
                body:-NL= text = re.sub('[^]', '', text)
             base:+Mined= re.sub('\\s+', '', text)
     body+mined:Baseline= text = re.sub('(.*?\\)', '\\1', text)
        body+mined:-Code= re.sub('[^"]', '', text)
          body+mined:-NL= text = url.replace('/', '')
      body+mined:-Blocks= re.sub('[^"]*', '', text)
      body+mined:-Inline= text = re.sub('(.*?\\)', '\\1', text)

================================================================================

QUESTION: idx=236    id=34945274
-------------------------------------INPUTS-------------------------------------

tags: arrays, performance, numpy, vectorization
score: 4
slot_map: {'key': ['var_0', 'str_0', '[str_0]'], 'quote': ['`', '`', '`'], 'type': ['var', 'str', 'str'], 'value': ['A', '[1, 3, 4]', '[1, 3, 4]']}
intent: replace all elements in array `a` that are not present in array `[1, 3, 4]` with zeros
body(Left in tags for better readability):
<p> I have a 2-dimensional NumPy array, for example:
<code_block>
 array([[1, 1, 0, 2, 2],
       [1, 1, 0, 2, 0],
       [0, 0, 0, 0, 0],
       [3, 3, 0, 4, 4],
       [3, 3, 0, 4, 4]])

<p> I would like to get all elements from that array which are in a
certain list, for example (1, 3, 4). The desired result in the example
case would be:
<code_block>
 array([[1, 1, 0, 0, 0],
       [1, 1, 0, 0, 0],
       [0, 0, 0, 0, 0],
       [3, 3, 0, 4, 4],
       [3, 3, 0, 4, 4]])

<p> I know that I can just do (as recommended here <a> Numpy: find
elements within range <p> ):
<code_block>
 np.logical_or(
    np.logical_or(cc_labeled == 1, cc_labeled == 3),
    cc_labeled == 4
)

<p> , but this will be only reasonably effective in the example case.
In reality iteratively using for loop and numpy.logical_or turned out
to be really slow since the list of possible values is in thousands
(and numpy array has approximately the dimension of 1000 x 1000).

-------------------------------------OUTPUT-------------------------------------

                Expected= 'np.where(np.in1d(A, [1, 3, 4]).reshape(A.shape), A, 0)'
           base:Baseline= [x for x in a if x not in [1, 3, 4])
           body:Baseline= np.all(a != [1, 3, 4], zeros=1)
            body:-Blocks= np.all(a != [1, 3, 4])
              body:-Code= numpy.replace([1, 3, 4])
            body:-Inline= np.all(a != [1, 3, 4])
                body:-NL= np.all(a == [1, 3, 4], axis=1)
             base:+Mined= np.in1d(a, [1, 3, 4])
     body+mined:Baseline= [x for x in a if x not in [1, 3, 4]]
        body+mined:-Code= a[np.any(a != [1, 3, 4])]
          body+mined:-NL= np.logical_or(a, [1, 3, 4], axis=1)
      body+mined:-Blocks= np.all(a!= [1, 3, 4]]
      body+mined:-Inline= np.logical_or(a[i] for i in a[1, 3, 4]]

================================================================================

QUESTION: idx=237    id=15819980
-------------------------------------INPUTS-------------------------------------

tags: arrays, multidimensional-array, numpy, mean
score: 85
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['a']}
intent: calculate mean across dimension in a 2d array `a`
body(Left in tags for better readability):
<p> I have an array <code> a <p>  like this:
<code_block>
 a = [[40, 10], [50, 11]]

<p> I need to calculate the mean for each dimension separately, the
result should be this:
<code_block>
 [45, 10.5]

<code> 45 <p>  being the mean of <code> a[*][0] <p>  and <code> 10.5
<p>  the mean of <code> a[*][1] <p> .
<p> What is the most elegant way of solving this without using a loop?

-------------------------------------OUTPUT-------------------------------------

                Expected= 'np.mean(a, axis=1)'
           base:Baseline= np.mean(a, axis=1)
           body:Baseline= sum(np.arange(a), axis=1)
            body:-Blocks= np.mean(a, a[*][1])
              body:-Code= np.mean(a, axis=1)
            body:-Inline= np.mean(a, axis=1)
                body:-NL= sum(np.mean(a))
             base:+Mined= np.mean(a, axis=1)
     body+mined:Baseline= a.mean(axis=1)
        body+mined:-Code= A.mean(axis=1)
          body+mined:-NL= np.mean(a, axis=1)
      body+mined:-Blocks= a.mean(axis=1)
      body+mined:-Inline= A.mean(axis=1)

================================================================================

QUESTION: idx=238    id=19894365
-------------------------------------INPUTS-------------------------------------

tags: r
score: 46
slot_map: {'key': ['str_0'], 'quote': ["'"], 'type': ['str'], 'value': ['/pathto/MyrScript.r']}
intent: running r script '/pathto/myrscript.r' from python
body(Left in tags for better readability):
<p> I searched for this question and found some answers on this, but
none of them seem to work. This is the script that I'm using in python
to run my R script.
<code_block>
 import subprocess
retcode = subprocess.call("/usr/bin/Rscript --vanilla -e
'source(\"/pathto/MyrScript.r\")'", shell=True)

<p> and I get this error:
<code_block>
 Error in read.table(file = file, header = header, sep = sep, quote =
quote,  :
  no lines available in input
Calls: source <console_out> withVisible -> eval -> eval -> read.csv ->
read.table
Execution halted

<p> and here is the content of my R script (pretty simple!)
<code_block>
 data = read.csv('features.csv')
data1 = read.csv("BagofWords.csv")
merged = merge(data,data1)
write.table(merged, "merged.csv",quote=FALSE,sep=",",row.names=FALSE)
for (i in 1:length(merged$fileName))
{
        fileConn
<-file(paste("output/",toString(merged$fileName[i]),".txt",sep=""))
        writeLines((toString(merged$BagofWord[i])),fileConn)
        close(fileConn)
}

<p> The r script is working fine, when I use <code>
source('MyrScript.r') <p>  in r commandline. Moreover, when I try to
use the exact command which I pass to the <code> subprocess.call <p>
function (i.e., <code> /usr/bin/Rscript --vanilla -e
'source("/pathto/MyrScript.r")' <p> ) in my commandline it works find,
I don't really get what's the problem.

-------------------------------------OUTPUT-------------------------------------

                Expected= "subprocess.call(['/usr/bin/Rscript', '--vanilla', '/pathto/MyrScript.r'])"
           base:Baseline= os.system('/pathTo/myrscript.r')
           body:Baseline= subprocess.call('/usr/bin/Rscript --vanilla -e'source('/pathto/MyrScript.r')')
            body:-Blocks= subprocess.call('/pathto/myrscript.r')
              body:-Code= os.system('/pathTo/myrscript.r')
            body:-Inline= subprocess.call('/pathto/myrscript.r')
                body:-NL= subprocess.call('/pathto/myrscript.r')
             base:+Mined= os.system('/pathTo/myrscript.r')
     body+mined:Baseline= subprocess.call('/pathto/myrscript.r', shell=True)
        body+mined:-Code= subprocess.call('/path/to/myrscript.r', shell=True)
          body+mined:-NL= subprocess.call('/pathto/myrscript.r')
      body+mined:-Blocks= subprocess.call('/pathto/myrscript.r', shell=True)
      body+mined:-Inline= subprocess.call('/pathto/myrscript.r', shell=True)

================================================================================

QUESTION: idx=239    id=19894365
-------------------------------------INPUTS-------------------------------------

tags: r
score: 46
slot_map: {'key': ['str_0'], 'quote': ["'"], 'type': ['str'], 'value': ['/usr/bin/Rscript --vanilla /pathto/MyrScript.r']}
intent: run r script '/usr/bin/rscript --vanilla /pathto/myrscript.r'
body(Left in tags for better readability):
<p> I searched for this question and found some answers on this, but
none of them seem to work. This is the script that I'm using in python
to run my R script.
<code_block>
 import subprocess
retcode = subprocess.call("/usr/bin/Rscript --vanilla -e
'source(\"/pathto/MyrScript.r\")'", shell=True)

<p> and I get this error:
<code_block>
 Error in read.table(file = file, header = header, sep = sep, quote =
quote,  :
  no lines available in input
Calls: source <console_out> withVisible -> eval -> eval -> read.csv ->
read.table
Execution halted

<p> and here is the content of my R script (pretty simple!)
<code_block>
 data = read.csv('features.csv')
data1 = read.csv("BagofWords.csv")
merged = merge(data,data1)
write.table(merged, "merged.csv",quote=FALSE,sep=",",row.names=FALSE)
for (i in 1:length(merged$fileName))
{
        fileConn
<-file(paste("output/",toString(merged$fileName[i]),".txt",sep=""))
        writeLines((toString(merged$BagofWord[i])),fileConn)
        close(fileConn)
}

<p> The r script is working fine, when I use <code>
source('MyrScript.r') <p>  in r commandline. Moreover, when I try to
use the exact command which I pass to the <code> subprocess.call <p>
function (i.e., <code> /usr/bin/Rscript --vanilla -e
'source("/pathto/MyrScript.r")' <p> ) in my commandline it works find,
I don't really get what's the problem.

-------------------------------------OUTPUT-------------------------------------

                Expected= "subprocess.call('/usr/bin/Rscript --vanilla /pathto/MyrScript.r', shell=True)"
           base:Baseline= os.system('/usr/bin/rscript --vanilla /pathto/myrscript.r')
           body:Baseline= subprocess.call('/usr/bin/Rscript --vanilla /pathto/MyrScript.r')
            body:-Blocks= subprocess.call('/usr/bin/Rscript --vanilla /pathto/MyrScript.r')
              body:-Code= os.system('/usr/bin/rscript --vanilla /pathto/myrscript.r')
            body:-Inline= subprocess.call('/usr/bin/Rscript --vanilla /pathto/MyrScript.r')
                body:-NL= subprocess.call('/usr/bin/Rscript --vanilla /pathto/myrscript.r')
             base:+Mined= os.system('/usr/bin/rscript --vanilla /pathTo/myrscript.r')
     body+mined:Baseline= subprocess.call('/usr/bin/Rscript --vanilla -e'source('/pathto/MyrScript.r')', shell=True)
        body+mined:-Code= subprocess.call('/usr/bin/rscript --vanilla /pathto/myrscript.r', shell=True)
          body+mined:-NL= subprocess.call('/usr/bin/Rscript --vanilla -e'source('/pathto/MyrScript.r')', shell=True)
      body+mined:-Blocks= subprocess.call('/usr/bin/rscript --vanilla /pathto/myrscript.r')
      body+mined:-Inline= subprocess.call('/usr/bin/Rscript --vanilla -e'source(\\/pathto/MyrScript.r')', shell=True)

================================================================================

QUESTION: idx=240    id=15907200
-------------------------------------INPUTS-------------------------------------

tags: csv
score: 12
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: add a header to a csv file
body(Left in tags for better readability):
<p> I've tried many solutions to add a header to my csv file, but
nothing's working properly. Here they are :

<p> I used the writerow method, but my data are overwriting the first
row.
<p> I used the DictWriter method, but I don't know how to fill it
correctly. Here is my code:
<code_block>
 csv = csv.DictWriter(open(directory +'/csv.csv', 'wt'), fieldnames =
["stuff1", "stuff2", "stuff3"], delimiter = ';')
csv.writeheader(["stuff1", "stuff2", "stuff3"])

<p> I got a "2 arguments instead of one" error and I really don't know
why.
<p> Any advice?

-------------------------------------OUTPUT-------------------------------------

                Expected= 'writer.writeheader()'
           base:Baseline= writer.writerow(os.path.realpath(__file__))
           body:Baseline= csv.writeheader(['stuff1', 'stuff2'], delimiter=';')
            body:-Blocks= df.writeheader('\\d+', header=False)
              body:-Code= df.writeheader('\\d+', header=False)
            body:-Inline= csv.writeheader(['stuff1', 'stuff2'])
                body:-NL= csv.writeheader(['stuff1', 'stuff2'], delimiter=',')
             base:+Mined= writer.writerows(header=None)
     body+mined:Baseline= csv.writeheader(['{}_{}'.format(x) for x in data])
        body+mined:-Code= writerow(row, header=None)
          body+mined:-NL= csv.writeheader(['stuff1','stuff2', "stuff3'])
      body+mined:-Blocks= writer.writerow(row, header=None)
      body+mined:-Inline= csv.writeheader('{}'.format(df))

================================================================================

QUESTION: idx=241    id=33058590
-------------------------------------INPUTS-------------------------------------

tags: pandas, dataframe, missing-data
score: 24
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['df']}
intent: replacing nan in the dataframe `df` with row average
body(Left in tags for better readability):
<p> I am  trying to learn pandas but i have been puzzled with the
following please. I want to replace NaNs is a dataframe with the row
average. Hence something like <code> df.fillna(df.mean(axis=1)) <p>
should work but for some reason it fails for me. Am I missing anything
please, something I'm doing wrong? Is is because its not implemented;
see <a> link here
<code_block>
 import pandas as pd
import numpy as np
pd.__version__
<console_out>
'0.15.2'

<console_in>
<console_out> df = pd.DataFrame()
df['c1'] = [1, 2, 3]
df['c2'] = [4, 5, 6]
df['c3'] = [7, np.nan, 9]
df

<console_out>
    c1  c2  c3
0   1   4   7
1   2   5   NaN
2   3   6   9

<console_in>
<console_out> df.fillna(df.mean(axis=1))

<console_out>
    c1  c2  c3
0   1   4   7
1   2   5   NaN
2   3   6   9

<p> However something like this looks to work fine
<code_block>
 df.fillna(df.mean(axis=0))

<console_out>
    c1  c2  c3
0   1   4   7
1   2   5   8
2   3   6   9


-------------------------------------OUTPUT-------------------------------------

                Expected= 'df.fillna(df.mean(axis=1), axis=1)'
           base:Baseline= df.fillna(axis=1)
           body:Baseline= df.fillna(df.mean(axis=1))
            body:-Blocks= df.fillna(df.mean(axis=1))
              body:-Code= df.fillna(axis=1)
            body:-Inline= df.fillna(df.mean(axis=1))
                body:-NL= df.fillna(df.mean(axis=1))
             base:+Mined= df.fillna(axis=1)
     body+mined:Baseline= df.fillna(df.mean(axis=1)
        body+mined:-Code= df.fillna(axis=1)
          body+mined:-NL= df.fillna(df.mean(axis=1)
      body+mined:-Blocks= df.fillna(df.mean(axis=1))
      body+mined:-Inline= df.fillna(df.mean(axis=0)

================================================================================

QUESTION: idx=242    id=12400256
-------------------------------------INPUTS-------------------------------------

tags: 
score: 346
slot_map: {'key': ['str_0', 'str_1'], 'quote': ["'", "'"], 'type': ['str', 'str'], 'value': ['1347517370', '%Y-%m-%d %H:%M:%S']}
intent: convert unix timestamp '1347517370' to formatted string '%y-%m-%d %h:%m:%s'
body(Left in tags for better readability):
<p> I am getting a response from the rest is an Epoch time format like
<code_block>
 start_time = 1234566
end_time = 1234578

<p> I want to convert that epoch seconds in MySQL format time so that
I could store the differences in my MySQL database.
<p> I tried:
<code_block>
 <console_in> import time
<console_in> time.gmtime(123456)
<console_out> time.struct_time(tm_year=1970, tm_mon=1, tm_mday=2,
tm_hour=10, tm_min=17, tm_sec=36, tm_wday=4, tm_yday=2, tm_isdst=0)

<p> The above result is not what I am expecting. I want it be like
<code_block>
 2012-09-12 21:00:00

<p> Please suggest how can I achieve this?
<p> Also,
Why I am getting <code> TypeError: a float is required <p>  for
<code_block>
 <console_in> getbbb_class.end_time = 1347516459425
<console_in> mend = time.gmtime(getbbb_class.end_time).tm_hour
<console_out> Traceback (most recent call last):
  <console_out>
TypeError: a float is required


-------------------------------------OUTPUT-------------------------------------

                Expected= "time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(1347517370))"
           base:Baseline= struct.unix('1347517370', '%Y-%m-%d %H:%M:%S')
           body:Baseline= time.gmtime(1237517370, '%Y-%m-%d %H:%M:%S')
            body:-Blocks= timestamp('1347517370', '%Y-%m-%d %H:%M:%S')
              body:-Code= timestamp('1347517370', '%Y-%m-%d %H:%M:%S')
            body:-Inline= struct.unix('1347517370', '%Y-%m-%d %H:%M:%S')
                body:-NL= struct.unix('1347517370', '%Y-%m-%d %H:%M:%S')
             base:+Mined= datetime.strptime('1347517370', '%Y-%m-%d %H:%M:%S')
     body+mined:Baseline= time.strftime('%Y-%m-%d %H:%M:%S')
        body+mined:-Code= time.strftime('%Y-%m-%d %H:%M:%S')
          body+mined:-NL= struct.unpack('1347517370', '%Y-%m-%d %H:%M:%S')
      body+mined:-Blocks= time.strptime('1347517370', '%Y-%m-%d %H:%M:%S')
      body+mined:-Inline= '%Y-%m-%d %H:%M:%S')

================================================================================

QUESTION: idx=243    id=1269217
-------------------------------------INPUTS-------------------------------------

tags: class, overriding, class-method
score: 112
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['do', 'Derived']}
intent: call a base class's class method `do` from derived class `derived`
body(Left in tags for better readability):
<p> Consider the following code:
<code_block>
 class Base(object):

    @classmethod
    def do(cls, a):
        print cls, a

class Derived(Base):

    @classmethod
    def do(cls, a):
        print 'In derived!'
        # Base.do(cls, a) -- can't pass `cls`
        Base.do(a)

if __name__ == '__main__':
    d = Derived()
    d.do('hello')

> $ python play.py
> In derived!
> <class '__main__.Base'> msg

<p> From <code> Derived.do <p> , how do I call <code> Base.do <p> ?
<p> I would normally use <code> super <p>  or even the base class name
directly if this is a normal object method, but apparently I can't
find a way to call the classmethod in the base class.
<p> In the above example, <code> Base.do(a) <p>  prints <code> Base
<p>  class instead of <code> Derived <p>  class.

-------------------------------------OUTPUT-------------------------------------

                Expected= 'super(Derived, cls).do(a)'
           base:Baseline= print(super(name, class) for name, class inderived.__class__))
           body:Baseline= Base.do(a).__class__
            body:-Blocks= base.objects.__class__.__name__
              body:-Code= print(p.class__name__ for p in derived.objects())
            body:-Inline= Base.call(class__name__ == '__main__.Base')
                body:-NL= Base.call(['__main__.Base'])
             base:+Mined= super(MyClass, self).__init__(*args, **kwargs)
     body+mined:Baseline= super(Base, self).__class__.__do__
        body+mined:-Code= print(super(Foo, self).__init__(*args, **kwargs)
          body+mined:-NL= do_list = Base.__init__(*args, **kwargs)
      body+mined:-Blocks= Base.__class__.__name__
      body+mined:-Inline= super(Base, self).__name__

================================================================================

QUESTION: idx=244    id=23359886
-------------------------------------INPUTS-------------------------------------

tags: numpy, multidimensional-array
score: 21
slot_map: {'key': ['str_0'], 'quote': ["'"], 'type': ['str'], 'value': ['a']}
intent: selecting rows in numpy ndarray 'a', where the value in the first column is 0 and value in the second column is 1
body(Left in tags for better readability):
<p> I have a big <code> np.ndarray (3600000,3) <p> , the <code> HUE
<p> , the <code> VALUE <p> , and an associated <code> CLASS <p>
number. For each pairs of <code> HUE <p>  and <code> VALUE <p>  I
would like to find, using this array the corresponding <code> Class
<p>  number. I'm a very beginner in Python and have a hard time doing
it. Do you know a way to do it?
<p> Thank you in advance!

-------------------------------------OUTPUT-------------------------------------

                Expected= 'a[np.where((a[:, (0)] == 0) * (a[:, (1)] == 1))]'
           base:Baseline= numpy.select(a, key=lambda x: x[1]) == 1
           body:Baseline= np.ndarray(a, key=operator.itemgetter(0, 1))
            body:-Blocks= numpy.array(a, key=lambda x: x[0], reverse=True)
              body:-Code= np.array(a, key=lambda x: -1)
            body:-Inline= numpy.array(a, key=lambda x: x[1])
                body:-NL= numpy.select(a, key=lambda x: np.ndarray(x[1], x[2]]))
             base:+Mined= np.where(a == 0, axis=1)
     body+mined:Baseline= numpy.where(a == 0, a == 1, axis=1)
        body+mined:-Code= np.where(a == 0, axis=1)
          body+mined:-NL= a[np.arange(len(a)) == 1]
      body+mined:-Blocks= a[np.ndarray([[1, 2], [3, 4]])
      body+mined:-Inline= np.where(a == 0, axis=1)

================================================================================

QUESTION: idx=245    id=4383082
-------------------------------------INPUTS-------------------------------------

tags: regex, string, list
score: 7
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: separate words delimited by one or more spaces into a list
body(Left in tags for better readability):
<p> If I have a string = "hello world sample text"
<p> I want to be able to convert it to a list = ["hello", "world",
"sample", "text"]
<p> How can I do that with regular expressions? (other methods not
using re are acceptable)

-------------------------------------OUTPUT-------------------------------------

                Expected= "re.split(' +', 'hello world sample text')"
           base:Baseline= [k for k, v in re.findall('\\d+', '', delimiter=',') if v]
           body:Baseline= list(re.findall('\\w+)', '\\w')
            body:-Blocks= [x for x in re.findall('\\w+', 'hello world sample text'])
              body:-Code= list(re.findall('\\w', 'hello world sample text')
            body:-Inline= list(re.split('\\w', 'hello world sample text')
                body:-NL= list(itertools.org.from_iterable(1, len(word)))
             base:+Mined= [word for word in words if word.strip() != '']
     body+mined:Baseline= ['hello', 'world', 'sample', 'text']
        body+mined:-Code= ['world', 'sample', 'text']
          body+mined:-NL= list(re.findall('\\w+', s))
      body+mined:-Blocks= ['hello', 'world', 'sample', 'text']
      body+mined:-Inline= ['hello world sample text', 'world', 'sample', 'text']

================================================================================

QUESTION: idx=246    id=14637696
-------------------------------------INPUTS-------------------------------------

tags: string, performance, list, coding-style
score: 7
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['words']}
intent: length of longest element in list `words`
body(Left in tags for better readability):
<p> What is the more pythonic way of getting the length of the longest
word:
<code> len(max(words, key=len))
<p> Or:
<code> max(len(w) for w in words)
<p> Or.. something else?   <code> words <p>  is a list of strings.
I am finding I need to do this often and after timing with a few
different sample sizes the first way seems to be consistently faster,
despite seeming less efficient at face value (the redundancy of <code>
len <p>  being called twice seems not to matter - does more happen in
C code in this form?).

-------------------------------------OUTPUT-------------------------------------

                Expected= 'len(max(words, key=len))'
           base:Baseline= words[len(x) for x in words]
           body:Baseline= len(max(words, key=len))
            body:-Blocks= words = len(max(words, key=len))
              body:-Code= print(len(word) for word in words)
            body:-Inline= len(words) - len(len(word))
                body:-NL= len(words, key=len))
             base:+Mined= words[len(word) for word in words]
     body+mined:Baseline= len(words, key=lambda x: len(x))
        body+mined:-Code= len(words) - len(word)
          body+mined:-NL= len(words, key=lambda x: len(x))
      body+mined:-Blocks= len(max(words, key=len))
      body+mined:-Inline= [len(word) for word inwords]

================================================================================

QUESTION: idx=247    id=3933478
-------------------------------------INPUTS-------------------------------------

tags: dictionary
score: 5
slot_map: {'key': ['str_0', 'var_0'], 'quote': ["'", '`'], 'type': ['str', 'var'], 'value': ['from_user', 'result']}
intent: get the value associated with unicode key 'from_user' of first dictionary in list `result`
body(Left in tags for better readability):
<p> I am writing code that will search twitter for key words and store
them in a python dictionary:
<code_block>
         base_url =
'http://search.twitter.com/search.json?rpp=100&q=4sq.com/'
        query = '7bOHRP'
        url_string = base_url + query
        logging.info("url string = " + url_string)
        json_text = fetch(url_string)
        json_response = simplejson.loads(json_text.content)
        result = json_response['results']
        print "Contents"
        print result

<p> The resulting dictionary is :
<code_block>
 Contents[{
    u 'iso_language_code': u 'en',
    u 'text': u "I'm at Cafe en Seine (40 Dawson Street, Dublin) w/ 2
others. http://4sq.com/7bOHRP",
    u 'created_at': u 'Wed, 06 Oct 2010 23:37:02 +0000',
    u 'profile_image_url': u 'http://a1.twimg.com/profile_images/57313
0785/twitterProfilePhoto_normal.jpg',
    u 'source': u '&lt;a href=&quot;http://foursquare.com&quot;
rel=&quot;nofollow&quot;&gt;foursquare&lt;/a&gt;',
    u 'place': {
        u 'type': u 'neighborhood',
        u 'id': u '898cf727ca504e96',
        u 'full_name': u 'Mansion House B, Dublin'
    },
    u 'from_user': u 'pkerssemakers',
    u 'from_user_id': 60241195,
    u 'to_user_id': None,
    u 'geo': None,
    u 'id': 26597357992,
    u 'metadata': {
        u 'result_type': u 'recent'
    }
}]
Status: 200 OK
Content - Type: text / html;charset = utf - 8
Cache - Control: no - cache
Expires: Fri, 01 Jan 1990 00: 00: 00 GMT
Content - Length: 0

<p> How can I access the 'from_user' and what is the 'u' before the
key and value?

-------------------------------------OUTPUT-------------------------------------

                Expected= "result[0]['from_user']"
           base:Baseline= result['from_user'] = result[0]
           body:Baseline= dict((k, v) for k, v in urllib.request.urlretrieve(url_string, 'from_user'))
            body:-Blocks= result['from_user'] = {'u': 1}
              body:-Code= result['from_user'] = {}
            body:-Inline= [k for k, v in Result if 'from_user' in k]
                body:-NL= result = json_response['from_user']
             base:+Mined= [x['from_user'] for x in result]
     body+mined:Baseline= result = json_response['results'].encode('utf8')
        body+mined:-Code= result['from_user'] = {'key1': 'value2'}
          body+mined:-NL= result = json_response['results'].encode('utf8')
      body+mined:-Blocks= result['from_user'] = result[0]
      body+mined:-Inline= print(d['from_user']['unicode_escape'])

================================================================================

QUESTION: idx=248    id=39112645
-------------------------------------INPUTS-------------------------------------

tags: 
score: 4
slot_map: {'key': ['str_0'], 'quote': ["'"], 'type': ['str'], 'value': ['File.txt']}
intent: retrieve each line from a file 'file.txt' as a list
body(Left in tags for better readability):
<code_block>
 file = input('Name: ')

with open(file) as infile:
    for line in infile:
        for name in infile:
            name
            print(name[line])

<p> So if a user were to pass a file of vertical list of sentences,
how would I save each sentence to its own list?
<p> Sample input:
<code_block>
 'hi'
'hello'
'cat'
'dog'

<p> Output:
<code_block>
 ['hi']
['hello']
and so on...


-------------------------------------OUTPUT-------------------------------------

                Expected= "[line.split() for line in open('File.txt')]"
           base:Baseline= [x for x in open('file.txt', 'rb').read()]
           body:Baseline= [line for line in open(file.txt, 'Name: ')]
            body:-Blocks= [x for x in open('file.txt') if x.split()]
              body:-Code= [line for line in open('file.txt').split()]
            body:-Inline= with open(file.txt) as input:
    pass
                body:-NL= [line for line in open('file.txt')]
             base:+Mined= [line for line in open('file.txt').split()]
     body+mined:Baseline= [line for line in open('file.txt').read()]
        body+mined:-Code= [line.split() for line in open('file.txt').split()]
          body+mined:-NL= [line for line in open(file) if 'hi' in line]
      body+mined:-Blocks= [line for line in open('file.txt').read()]
      body+mined:-Inline= ['hi', 'hello', 'cat', 'dog']

================================================================================

QUESTION: idx=249    id=1031851
-------------------------------------INPUTS-------------------------------------

tags: dictionary
score: 109
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['a']}
intent: swap keys with values in a dictionary `a`
body(Left in tags for better readability):
<p> I receive a dictionary as input, and would like to to return a
dictionary whose keys will be the input's values and whose value will
be the corresponding input keys. Values are unique.
<p> For example, say my input is:
<code_block>
 a = dict()
a['one']=1
a['two']=2

<p> I would like my output to be:
<code_block>
 {1: 'one', 2: 'two'}

<p> To clarify I would like my result to be the equivalent of the
following:
<code_block>
 res = dict()
res[1] = 'one'
res[2] = 'two'

<p> Any neat Pythonic way to achieve this?

-------------------------------------OUTPUT-------------------------------------

                Expected= 'res = dict((v, k) for k, v in a.items())'
           base:Baseline= dict((k, v) for k, v in a.items())
           body:Baseline= dict((k, v) for k, v in a.items()))
            body:-Blocks= {k: v for k, v in a.items()}
              body:-Code= dict((k, v) for k, v in a.items())
            body:-Inline= {k: v for k, v in a.items()}
                body:-NL= dict((k, v) for k, v in a.items())
             base:+Mined= {k: v for k, v in a.items()}
     body+mined:Baseline= {k: v for k, v in list(a.items())}
        body+mined:-Code= {k: v for k, v in a.items()}
          body+mined:-NL= dict((k, v) for k, v in a.items() if v == 2)
      body+mined:-Blocks= dict((k, v) for k, v in a.items())
      body+mined:-Inline= dict((k, v) for k, v in a.items() if v)

================================================================================

QUESTION: idx=250    id=8577137
-------------------------------------INPUTS-------------------------------------

tags: 
score: 72
slot_map: {'key': ['str_0'], 'quote': ['`'], 'type': ['str'], 'value': ['path/to/FILE_NAME.ext']}
intent: open a file `path/to/file_name.ext` in write mode
body(Left in tags for better readability):
<p> I have this function that references the path of a file:
<code_block>
 some_obj.file_name(FILE_PATH)

<p> where FILE_PATH is a string of the path of a file, i.e. <code>
H:/path/FILE_NAME.ext
<p> I want to create a file FILE_NAME.ext inside my python script with
the content of a string:
<code_block>
 some_string = 'this is some content'

<p> How to go about this? The Python script will be placed inside a
Linux box.

-------------------------------------OUTPUT-------------------------------------

                Expected= "new_file = open('path/to/FILE_NAME.ext', 'w')"
           base:Baseline= write(path / to / file_name.ext)
           body:Baseline= some_obj.file_name(FILE_PATH)
            body:-Blocks= os.path.open('path/to/file_name.ext')
              body:-Code= open('path/to/file_name.ext')
            body:-Inline= open('path/to/file_name.ext')
                body:-NL= os.path.write('path/to/file_name.ext')
             base:+Mined= f = open('path/to/file_name.ext')
     body+mined:Baseline= some_obj.file_name(FILE_PATH)
        body+mined:-Code= f = open('path/to/file_name.ext', 'r')
          body+mined:-NL= open('path/to/file_name.ext', some_string)
      body+mined:-Blocks= f.write('H:/path/to/file_name.ext')
      body+mined:-Inline= os.path.expanduser('path/to/file_name.ext')

================================================================================

QUESTION: idx=251    id=17926273
-------------------------------------INPUTS-------------------------------------

tags: group-by, pandas
score: 23
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: how to count distinct values in a column of a pandas group by object?
body(Left in tags for better readability):
<p> I have a pandas data frame and group it by two columns (for
example <code> col1 <p>  and <code> col2 <p> ). For fixed values of
<code> col1 <p>  and <code> col2 <p>  (i.e. for a group) I can have
several different values in the <code> col3 <p> . I would like to
count the number of distinct values from the third columns.
<p> For example, If I have this as my input:
<code_block>
 1  1  1
1  1  1
1  1  2
1  2  3
1  2  3
1  2  3
2  1  1
2  1  2
2  1  3
2  2  3
2  2  3
2  2  3

<p> I would like to have this table (data frame) as the output:
<code_block>
 1  1  2
1  2  1
2  1  3
2  2  1


-------------------------------------OUTPUT-------------------------------------

                Expected= "df.groupby(['col1', 'col2'])['col3'].nunique().reset_index()"
           base:Baseline= df.groupby(lambda x: x[1])
           body:Baseline= df.groupby(df.columns, axis=1).sum()
            body:-Blocks= df.groupby(['col1', 'col2'], axis=1)
              body:-Code= df.groupby(lambda x: x[1])
            body:-Inline= df.groupby(df.values())
                body:-NL= df.groupby(df.values())
             base:+Mined= df.groupby(['A', 'B'])['C'].reset_index()
     body+mined:Baseline= df.groupby(['col1', 'col2'], axis=1).sum()
        body+mined:-Code= df.groupby(['a', 'b'])['c'].sum()
          body+mined:-NL= df.groupby(['col1', 'col2'], ascending=[True, False], inplace=True)
      body+mined:-Blocks= df.groupby(['col1', 'col2']).sum()
      body+mined:-Inline= pd.concat([df1, df2], axis=1)

================================================================================

QUESTION: idx=252    id=3735814
-------------------------------------INPUTS-------------------------------------

tags: dictionary
score: 7
slot_map: {'key': ['var_0', 'str_0'], 'quote': ['`', '`'], 'type': ['var', 'str'], 'value': ['dict1', 'EMP$$']}
intent: check if any key in the dictionary `dict1` starts with the string `emp$$`
body(Left in tags for better readability):
<code_block>
     dict1=({"EMP$$1":1,"EMP$$2":2,"EMP$$3":3})

<p> How to check if EMP exists in the dictionary using python
<code_block>
    dict1.get("EMP##") ??


-------------------------------------OUTPUT-------------------------------------

                Expected= "any(key.startswith('EMP$$') for key in dict1)"
           base:Baseline= any(dict1.isdigit() == 'emp$$')
           body:Baseline= any(dict1.isdigit() == 'emp$$')
            body:-Blocks= any(dict1.isdigit() == 'emp$$')
              body:-Code= any(dict1.isdigit() == 'emp$$')
            body:-Inline= any(dict1.isdigit() == 'emp$$')
                body:-NL= any(dict1.isdigit() == 'emp$$')
             base:+Mined= any(x in dict1.items() for x in list(dict1.values()))
     body+mined:Baseline= any(x.startswith('emp$$') for x in dict1)
        body+mined:-Code= any(item.startswith('emp$$') for item in dict1)
          body+mined:-NL= any(d.startswith('emp$$') for d in dict1)
      body+mined:-Blocks= any(d.startswith('emp$$') for d in dict1)
      body+mined:-Inline= any(x.startswith('emp$$') for x in dict1)

================================================================================

QUESTION: idx=253    id=3735814
-------------------------------------INPUTS-------------------------------------

tags: dictionary
score: 7
slot_map: {'key': ['var_0', 'str_0'], 'quote': ['`', "'"], 'type': ['var', 'str'], 'value': ['dict1', 'EMP$$']}
intent: create list of values from dictionary `dict1` that have a key that starts with 'emp$$'
body(Left in tags for better readability):
<code_block>
     dict1=({"EMP$$1":1,"EMP$$2":2,"EMP$$3":3})

<p> How to check if EMP exists in the dictionary using python
<code_block>
    dict1.get("EMP##") ??


-------------------------------------OUTPUT-------------------------------------

                Expected= "[value for key, value in list(dict1.items()) if key.startswith('EMP$$')]"
           base:Baseline= [k for k, v in dict1.items() if 'emp$$' in k]
           body:Baseline= dict1 = dict1.get('emp$$')
            body:-Blocks= [x for x in dict1 if 'emp$$' in x]
              body:-Code= [x for x in dict1 if 'emp$$' in x]
            body:-Inline= dict1.values('emp$$')
                body:-NL= dict1 = {k: v for k, v in dict1 if 'emp$$' in k}
             base:+Mined= [d['emp$$'] for d in dict1]
     body+mined:Baseline= {k: v for k, v in list(dict1.items()) if 'emp$$' in k}
        body+mined:-Code= [key for key, value in list(dict1.items()) if 'emp$$' in key]
          body+mined:-NL= {k: v for k, v in dict1.items() if 'emp$$' in k}
      body+mined:-Blocks= [key for key, value in dict1 if 'emp$$' in key]
      body+mined:-Inline= {k: v for k, v in list(dict1.items()) if 'emp$$' in k}

================================================================================

QUESTION: idx=254    id=26097916
-------------------------------------INPUTS-------------------------------------

tags: pandas, dataframe, series
score: 97
slot_map: {'key': ['var_0', 'var_1', 'var_2', 'var_3'], 'quote': ['`', '`', '`', '`'], 'type': ['var', 'var', 'var', 'var'], 'value': ['sf', 'df', 'email', 'list']}
intent: convert a pandas series `sf` into a pandas dataframe `df` with columns `email` and `list`
body(Left in tags for better readability):
<p> I have a Pandas series sf:
<code_block>
 email
email1@email.com    [1.0, 0.0, 0.0]
email2@email.com    [2.0, 0.0, 0.0]
email3@email.com    [1.0, 0.0, 0.0]
email4@email.com    [4.0, 0.0, 0.0]
email5@email.com    [1.0, 0.0, 3.0]
email6@email.com    [1.0, 5.0, 0.0]

<p> And I would like to transform it to the following DataFrame:
<code_block>
 index | email             | list
_____________________________________________
0     | email1@email.com  | [1.0, 0.0, 0.0]
1     | email2@email.com  | [2.0, 0.0, 0.0]
2     | email3@email.com  | [1.0, 0.0, 0.0]
3     | email4@email.com  | [4.0, 0.0, 0.0]
4     | email5@email.com  | [1.0, 0.0, 3.0]
5     | email6@email.com  | [1.0, 5.0, 0.0]

<p> I found a way to do it, but I doubt it's the more efficient one:
<code_block>
 df1 = pd.DataFrame(data=sf.index, columns=['email'])
df2 = pd.DataFrame(data=sf.values, columns=['list'])
df = pd.merge(df1, df2, left_index=True, right_index=True)


-------------------------------------OUTPUT-------------------------------------

                Expected= "pd.DataFrame({'email': sf.index, 'list': sf.values})"
           base:Baseline= df.set_index(['email', 'list'])
           body:Baseline= df = pd.DataFrame(data=sf.index, columns=['email'])
            body:-Blocks= df.to_pd.concat([df['email'], df['list'])
              body:-Code= df.concat([df.columns, 'email', 'list'])
            body:-Inline= pd.DataFrame(df.index, columns=['email'])
                body:-NL= df = pd.DataFrame(data=sf.values, columns=['email', 'list'])
             base:+Mined= df.to_pickle(['email', 'list'])
     body+mined:Baseline= df.pivot_table(index='email', columns=['list'])
        body+mined:-Code= pd.concat([df, pd.Series(['email', 'list'])], axis=1)
          body+mined:-NL= pd.merge(df1, df2, left_index=True, right_index='list', how='inner')
      body+mined:-Blocks= pd.concat([df, pd.Series(['email', 'list'])], axis=1)
      body+mined:-Inline= df = pd.DataFrame(df.index, columns=['email', 'list'])

================================================================================

QUESTION: idx=255    id=4048964
-------------------------------------INPUTS-------------------------------------

tags: printing
score: 31
slot_map: {'key': ['var_0', 'str_0'], 'quote': ['`', '`'], 'type': ['var', 'str'], 'value': ['list', '\t']}
intent: print elements of list `list` seperated by tabs `\t`
body(Left in tags for better readability):
<p> Here's my current code:
<code_block>
 print(list[0], list[1], list[2], list[3], list[4], sep = '\t')

<p> I'd like to write it better. But
<code_block>
 print('\t'.join(list))

<p> won't work because list elements may numbers, other lists, etc.,
so <code> join <p>  would complain.

-------------------------------------OUTPUT-------------------------------------

                Expected= "print('\\t'.join(map(str, list)))"
           base:Baseline= print(list.split(\t))
           body:Baseline= print('\t'.join(list))
            body:-Blocks= print(list.split(\t))
              body:-Code= print('\t'.join(list))
            body:-Inline= print('\t'.join(list))
                body:-NL= print('\t'.join(list))
             base:+Mined= print('\t'.join(list))
     body+mined:Baseline= print('\t'.join(list))
        body+mined:-Code= print(element.finditer('\t') for element in list))
          body+mined:-NL= print(list(itertools.chain.from_iterable(list)))
      body+mined:-Blocks= print('\t'.join(str(x) for x in seperated by tabs))
      body+mined:-Inline= print('\t'.join(list))

================================================================================

QUESTION: idx=256    id=3182716
-------------------------------------INPUTS-------------------------------------

tags: unicode
score: 7
slot_map: {'key': ['str_0'], 'quote': ["'"], 'type': ['str'], 'value': ['Ð¿Ñ\x80Ð¸']}
intent: print unicode string '\xd0\xbf\xd1\x80\xd0\xb8' with utf-8
body(Left in tags for better readability):
<p> I'm getting back from a library what looks to be an incorrect
unicode string:
<code_block>
 <console_in> title
<console_out> u'Sopet\xc3\xb3n'

<p> Now, those two hex escapes there are the UTF-8 encoding for U+00F3
LATIN SMALL LETTER O WITH ACUTE.  So far as I understand, a unicode
string in Python should have the actual character, not the the UTF-8
encoding for the character, so I think this is incorrect and
presumably a bug either in the library or in my input, right?
<p> The question is, how do I (a) recognize that I have UTF-8 encoded
text in my unicode string, and (b) convert this to a proper unicode
string?
<p> I'm stumped on (a), as there's nothing wrong, encoding-wise, about
that original string (i.e, both are valid characters in their own
right, <code> u'\xc3\xb3' <p>  == A3, but they're not what's supposed
to be there)
<p> It looks like I can achieve (b) by eval()ing that repr() output
minus the "u" in front to get a str and then decoding the str with
UTF-8:
<code_block>
 <console_in> eval(repr(title)[1:]).decode("utf-8")
<console_out> u'Sopet\xf3n'
<console_in> print eval(repr(title)[1:]).decode("utf-8")
<console_out> Sopeton

<p> But that seems a bit kludgy.  Is there an officially-sanctioned
way to get the raw data out of a unicode string and treat that as a
regular string?

-------------------------------------OUTPUT-------------------------------------

                Expected= "print('Ð¿Ñ\\x80Ð¸'.encode('raw_unicode_escape'))"
           base:Baseline= print('\xd0\xbf\xd1\x80\xd9\xb8'.encode('utf8')
           body:Baseline= print(repr(title)[1:]).decode('utf-8')
            body:-Blocks= print('\xd0\xbf\xd1\x80\xd 0\xb8'.encode('utf-8')
              body:-Code= print('\xd0\xbf\xd1\x80\xd00\xb8'.encode('utf-8')
            body:-Inline= print(repr(title)[1:]).decode('utf-8')
                body:-NL= print(repr(title)[1:]).decode('utf8')
             base:+Mined= print(s.encode('utf8'))
     body+mined:Baseline= print(repr(title)[1:]).decode('utf-8')
        body+mined:-Code= print(repr('Ð¿Ñ\x80Ð0¸', my_unicode_string))
          body+mined:-NL= print(repr(title)[1:])
      body+mined:-Blocks= print(s.encode('utf-8'))
      body+mined:-Inline= print(u.decode('utf8'))

================================================================================

QUESTION: idx=257    id=3182716
-------------------------------------INPUTS-------------------------------------

tags: unicode
score: 7
slot_map: {'key': ['str_0'], 'quote': ['`'], 'type': ['str'], 'value': ['SopetÃ³n']}
intent: encode a latin character in string `sopet\xc3\xb3n` properly
body(Left in tags for better readability):
<p> I'm getting back from a library what looks to be an incorrect
unicode string:
<code_block>
 <console_in> title
<console_out> u'Sopet\xc3\xb3n'

<p> Now, those two hex escapes there are the UTF-8 encoding for U+00F3
LATIN SMALL LETTER O WITH ACUTE.  So far as I understand, a unicode
string in Python should have the actual character, not the the UTF-8
encoding for the character, so I think this is incorrect and
presumably a bug either in the library or in my input, right?
<p> The question is, how do I (a) recognize that I have UTF-8 encoded
text in my unicode string, and (b) convert this to a proper unicode
string?
<p> I'm stumped on (a), as there's nothing wrong, encoding-wise, about
that original string (i.e, both are valid characters in their own
right, <code> u'\xc3\xb3' <p>  == A3, but they're not what's supposed
to be there)
<p> It looks like I can achieve (b) by eval()ing that repr() output
minus the "u" in front to get a str and then decoding the str with
UTF-8:
<code_block>
 <console_in> eval(repr(title)[1:]).decode("utf-8")
<console_out> u'Sopet\xf3n'
<console_in> print eval(repr(title)[1:]).decode("utf-8")
<console_out> Sopeton

<p> But that seems a bit kludgy.  Is there an officially-sanctioned
way to get the raw data out of a unicode string and treat that as a
regular string?

-------------------------------------OUTPUT-------------------------------------

                Expected= '"""SopetÃ³n""".encode(\'latin-1\').decode(\'utf-8\')'
           base:Baseline= sopet\xc3\xb3n.encode('utf-8')
           body:Baseline= rept(repr(title)[1:]).decode('utf-8').encode('SopetÃ³n')
            body:-Blocks= sopet\xc3\xb3n.encode('utf-8')
              body:-Code= sopet\xc3\xb3n.encode('utf-8')
            body:-Inline= print(repr(title)[1:]).decode('utf-8')
                body:-NL= """SopetÃ³n""".encode('utf-8')
             base:+Mined= sopet\xc3\xb3n'.encode('latin-1')
     body+mined:Baseline= eval(repr(title)[1:]).decode('utf-8')
        body+mined:-Code= print(sopet\xc3\xb3n.decode('utf-8'))
          body+mined:-NL= """Sopet\\xc3³n""".encode('utf8')
      body+mined:-Blocks= sopet\xc3\xb3n.encode('utf-8')
      body+mined:-Inline= """SopetÃ³n""".decode('utf-8')

================================================================================

QUESTION: idx=258    id=1405602
-------------------------------------INPUTS-------------------------------------

tags: 
score: 58
slot_map: {'key': ['var_0', 'str_0', 'var_1', '(str_0)'], 'quote': ['`', '`', '`', '`'], 'type': ['var', 'str', 'var', 'str'], 'value': ['image', '(x, y)', 'ANTIALIAS', '(x, y)']}
intent: resized image `image` to width, height of `(x, y)` with filter of `antialias`
body(Left in tags for better readability):
<p> I am working on PIL and need to know if the image quality can be
adjusted while resizing or thumbnailing an image. From what I have
known is the default quality is set to 85. Can this parameter be
tweaked during resizing?
<p> I am currently using the following code:
<code_block>
 image = Image.open(filename)
image.thumbnail((x, y), img.ANTIALIAS)

<p> The <code> ANTIALIAS <p>  parameter presumably gives the best
quality. I need to know if we can get more granularity on the quality
option.

-------------------------------------OUTPUT-------------------------------------

                Expected= 'image = image.resize((x, y), Image.ANTIALIAS)'
           base:Baseline= image.resized(x, y)
           body:Baseline= image.reshape(image.x, y, img.ANTIALIAS)
            body:-Blocks= image.resized(image, width, height='(x, y)', color='antialias')
              body:-Code= image.resize(x, y, filter=antialias)
            body:-Inline= image = Image.open(filename) + Image.filter(antialias)
                body:-NL= image.reshape(x, y), img.ANTIALIAS)
             base:+Mined= imagedata.resize(x, y)
     body+mined:Baseline= image.resize(image.thumbnail((x, y), img.ANTIALIAS)
        body+mined:-Code= imagedata.resize(image, (x, y), (255, 255, 1))
          body+mined:-NL= image.resize(x, y)
      body+mined:-Blocks= im.save('image.png', (x, y))
      body+mined:-Inline= image.thumbnail((x, y), img.ANTIALIAS)

================================================================================

QUESTION: idx=259    id=35622945
-------------------------------------INPUTS-------------------------------------

tags: regex
score: 5
slot_map: {'key': ['str_0', 'var_0'], 'quote': ['"', '`'], 'type': ['str', 'var'], 'value': ['n', 's']}
intent: regex, find "n"s only in the middle of string `s`
body(Left in tags for better readability):
<p> I am using python 2.6 and trying to find a bunch of repeating
characters in a string, let's say a bunch of <code> n <p> 's, e.g.
<code> nnnnnnnABCnnnnnnnnnDEF <p> . In any place of the string the
number of <code> n <p> 's can be variable.
<p> If I construct a regex like this:
<code> re.findall(r'^(((?i)n)\2{2,})', s) <p> ,
<p> I can find occurences of case-insensitive <code> n <p> 's only in
the beginning of the string, which is fine. If I do it like this:
<code> re.findall(r'(((?i)n)\2{2,}$)', s) <p> ,
<p> I can detect the ones only in the end of the sequence. But what
about just in the middle?
<p> At first, I thought of using <code> re.findall(r'(((?i)n)\2{2,})',
s) <p>  and the two previous regex(-ices?) to check the length of the
returned list and the presence of <code> n <p> 's either in the
beginning or end of the string and make logical tests, but it became
an ugly if-else mess very quickly.
<p> Then, I tried <code> re.findall(r'(?!^)(((?i)n)\2{2,})', s) <p> ,
which seems to exlude the beginning just fine but <code> (?!$) <p>  or
<code> (?!\z) <p>  at the end of the regex only excludes the last
<code> n <p>  in <code> ABCnnnn <p> . Finally, I tried <code>
re.findall(r'(?!^)(((?i)n)\2{2,})\w+', s) <p>  which seems to work
sometimes, but I get weird results at others. It feels like I need a
lookahead or lookbehind, but I can't wrap my head around them.

-------------------------------------OUTPUT-------------------------------------

                Expected= "re.findall('n(?<=[^n]n)n+(?=[^n])(?i)', s)"
           base:Baseline= re.findall('n', s)
           body:Baseline= re.findall('((?i)n)\x02{2,})\\w+', s)
            body:-Blocks= re.findall('(?i)n)\x02{2,})', s)
              body:-Code= re.findall('\\n', s)
            body:-Inline= re.findall('n', s)
                body:-NL= re.findall('(?i)n)\x02{2,})', s)
             base:+Mined= re.findall('\\n', s)
     body+mined:Baseline= re.findall('(?!^)(((?i)n)\\2{2,}$)', s)
        body+mined:-Code= re.findall('\\s+', s)
          body+mined:-NL= re.findall('(?!^)(((?i)n)\\2{2,}$)', s)
      body+mined:-Blocks= re.findall('(?!^)(((?i)n)\x02{2,})\\w+', s)
      body+mined:-Inline= regexp = re.compile('[^a-zA-Z]', s)

================================================================================

QUESTION: idx=260    id=5306756
-------------------------------------INPUTS-------------------------------------

tags: 
score: 204
slot_map: {'key': ['str_0'], 'quote': ['`'], 'type': ['str'], 'value': ['1/3*100']}
intent: display the float `1/3*100` as a percentage
body(Left in tags for better readability):
<p> this is my code:
<code_block>
 print str(float(1/3))+'%'

<p> and it shows:
<code_block>
 0.0%

<p> but I want to get <code> 33%
<p> What can I do?

-------------------------------------OUTPUT-------------------------------------

                Expected= "print('{0:.0f}%'.format(1.0 / 3 * 100))"
           base:Baseline= float(1 / 3 * 100)
           body:Baseline= print(float(1 / 3 * 100))
            body:-Blocks= """1/3*100""".isnull()
              body:-Code= float(1/3*100))
            body:-Inline= print(str(float(1/3*100))
                body:-NL= print(float(1 / 3 * 100))
             base:+Mined= print(float(1 / 3 * 100))
     body+mined:Baseline= print(float(1 / 3 * 100))
        body+mined:-Code= float(1 / 3 * 100)
          body+mined:-NL= print(float(1 / 3 * 100))
      body+mined:-Blocks= """{:.2f}""".format(1 / 3 * 100)
      body+mined:-Inline= print('{0:.0f}'.format(1 / 3 * 100))

================================================================================

QUESTION: idx=261    id=2878084
-------------------------------------INPUTS-------------------------------------

tags: sorting, dictionary
score: 17
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['mylist', 'title']}
intent: sort a list of dictionary `mylist` by the key `title`
body(Left in tags for better readability):
<p> I have a list of dictionaries:
<code_block>
 [{'title':'New York Times', 'title_url':'New_York_Times','id':4},
 {'title':'USA Today','title_url':'USA_Today','id':6},
 {'title':'Apple News','title_url':'Apple_News','id':2}]

<p> I'd like to sort it by the title, so elements with A go before Z:
<code_block>
 [{'title':'Apple News','title_url':'Apple_News','id':2},
 {'title':'New York Times', 'title_url':'New_York_Times','id':4},
 {'title':'USA Today','title_url':'USA_Today','id':6}]

<p> What's the best way to do this?
Also, is there a way to ensure the order of each dictionary key stays
constant, e.g., always title, title_url, then id?

-------------------------------------OUTPUT-------------------------------------

                Expected= "mylist.sort(key=lambda x: x['title'])"
           base:Baseline= mylist.sort(key=lambda x: x[1])
           body:Baseline= sorted(list(mylist.items()), key=lambda x: x[1])
            body:-Blocks= mylist.sort(key=lambda x: x[1])
              body:-Code= mylist.sort(key=lambda x: x[1])
            body:-Inline= sorted(mylist, key=lambda x: x[1])
                body:-NL= mylist.sort(key=lambda x: x[1])
             base:+Mined= mylist.sort(key=operator.itemgetter(1))
     body+mined:Baseline= sorted(mylist, key=lambda x: x['title'], reverse=True)
        body+mined:-Code= sorted(mylist, key=lambda x: x['title'], reverse=True)
          body+mined:-NL= mylist.sort(key=lambda x: x[1]['title'], reverse=True)
      body+mined:-Blocks= mylist.sort(key=lambda x: x[1])
      body+mined:-Inline= sorted(mylist, key=lambda d: d['title'], reverse=True)

================================================================================

QUESTION: idx=262    id=2878084
-------------------------------------INPUTS-------------------------------------

tags: sorting, dictionary
score: 17
slot_map: {'key': ['var_0', 'str_0'], 'quote': ['`', "'"], 'type': ['var', 'str'], 'value': ['l', 'title']}
intent: sort a list `l` of dicts by dict value 'title'
body(Left in tags for better readability):
<p> I have a list of dictionaries:
<code_block>
 [{'title':'New York Times', 'title_url':'New_York_Times','id':4},
 {'title':'USA Today','title_url':'USA_Today','id':6},
 {'title':'Apple News','title_url':'Apple_News','id':2}]

<p> I'd like to sort it by the title, so elements with A go before Z:
<code_block>
 [{'title':'Apple News','title_url':'Apple_News','id':2},
 {'title':'New York Times', 'title_url':'New_York_Times','id':4},
 {'title':'USA Today','title_url':'USA_Today','id':6}]

<p> What's the best way to do this?
Also, is there a way to ensure the order of each dictionary key stays
constant, e.g., always title, title_url, then id?

-------------------------------------OUTPUT-------------------------------------

                Expected= "l.sort(key=lambda x: x['title'])"
           base:Baseline= sorted(l, key=lambda x: dicts['title'])
           body:Baseline= sorted(l, key=dict.get('title')))
            body:-Blocks= sorted(l, key=lambda x: x['title']))
              body:-Code= sorted(l, key=dict.get('title')
            body:-Inline= sorted(l, key=lambda x: x['title']))
                body:-NL= sorted(l, key=lambda x: x['title']))
             base:+Mined= l.sort(key=operator.itemgetter('title'))
     body+mined:Baseline= sorted(l, key=lambda x: x['title'], reverse=True)
        body+mined:-Code= sorted(L, key=lambda x: x['title'], reverse=True)
          body+mined:-NL= sorted(l, key=lambda d: d['title'], reverse=True)
      body+mined:-Blocks= sorted(l, key=lambda d: d['title'], reverse=True)
      body+mined:-Inline= sorted(l, key=lambda d: d['title'], reverse=True)

================================================================================

QUESTION: idx=263    id=2878084
-------------------------------------INPUTS-------------------------------------

tags: sorting, dictionary
score: 17
slot_map: {'key': ['str_0', 'str_1', 'str_2'], 'quote': ["'", "'", "'"], 'type': ['str', 'str', 'str'], 'value': ['title', 'title_url', 'id']}
intent: sort a list of dictionaries by the value of keys 'title', 'title_url', 'id' in ascending order.
body(Left in tags for better readability):
<p> I have a list of dictionaries:
<code_block>
 [{'title':'New York Times', 'title_url':'New_York_Times','id':4},
 {'title':'USA Today','title_url':'USA_Today','id':6},
 {'title':'Apple News','title_url':'Apple_News','id':2}]

<p> I'd like to sort it by the title, so elements with A go before Z:
<code_block>
 [{'title':'Apple News','title_url':'Apple_News','id':2},
 {'title':'New York Times', 'title_url':'New_York_Times','id':4},
 {'title':'USA Today','title_url':'USA_Today','id':6}]

<p> What's the best way to do this?
Also, is there a way to ensure the order of each dictionary key stays
constant, e.g., always title, title_url, then id?

-------------------------------------OUTPUT-------------------------------------

                Expected= "l.sort(key=lambda x: (x['title'], x['title_url'], x['id']))"
           base:Baseline= sorted(list(d.items()), key=lambda x: x['title', 'title_url', 'id'])
           body:Baseline= sorted(list(dictionary.items()), key=lambda k: k.index('title', 'title_url',
    'id'))
            body:-Blocks= sorted(list(d.items()), key=lambda x: x['title', 'title_url', 'id'])
              body:-Code= sorted(list(d.items()), key=lambda x: x['title', 'title_url', 'id'])
            body:-Inline= sorted(list(d.items()), key=lambda x: x['title', 'title_url', 'id'])
                body:-NL= sorted(list(d.items()), key=lambda x: x['title', 'title_url', 'id']))
             base:+Mined= sorted(list(d.items()), key=lambda x: x['title', 'title_url', 'id'])
     body+mined:Baseline= sorted(d, key=lambda x: x['title'], reverse=True)
        body+mined:-Code= sorted(list_of_dicts, key=lambda x: x['title', 'title_url', 'id']), reverse=True)
          body+mined:-NL= sorted(dic, key=lambda x: x['title'], reverse=True)
      body+mined:-Blocks= sorted(lst, key=lambda x: (x['title', 'title_url'], x['id']))
      body+mined:-Inline= sorted(list(d.items()), key=lambda x: x['title_url'], reverse=True)

================================================================================

QUESTION: idx=264    id=9323159
-------------------------------------INPUTS-------------------------------------

tags: algorithm, data-structures, ordereddictionary
score: 5
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['l1', 'l2']}
intent: find 10 largest differences between each respective elements of list `l1` and list `l2`
body(Left in tags for better readability):
<p> I have two lists <code> old <p>  and <code> new <p> , with the
same number of elements.
<p> I'm trying to write an efficient function that takes <code> n <p>
as a parameter, compares the elements of two lists at the same
locations (by index), finds <code> n <p>  largest differences, and
returns the indices of those <code> n <p>  elements.
<p> I was thinking this would be best solved by a value-sorted
dictionary, but one <a> isn't available <p>  in Python (and I'm not
aware of any libraries that offer it). Perhaps there's a better
solution?

-------------------------------------OUTPUT-------------------------------------

                Expected= 'heapq.nlargest(10, range(len(l1)), key=lambda i: abs(l1[i] - l2[i]))'
           base:Baseline= [i for i, j in zip(l1, l2)]
           body:Baseline= sum(i, j) for i, j in zip(l1, l2)]
            body:-Blocks= [i for i, j in zip(l1, l2)]
              body:-Code= [i for i, j in zip(l1, l2)]
            body:-Inline= sum(x[0] for x in zip(l1, l2)]
                body:-NL= [i for i, j in zip(l1, l2)]
             base:+Mined= [max(x, y) for x, y in zip(l1, l2)]
     body+mined:Baseline= [i for i, j in zip(l1, l2)]
        body+mined:-Code= zip(list(zip(l1, l2))
          body+mined:-NL= max(l1, l2)
      body+mined:-Blocks= [(x / y) for x, y in zip(old, new)]
      body+mined:-Inline= max(l1, l2)

================================================================================

QUESTION: idx=265    id=29877663
-------------------------------------INPUTS-------------------------------------

tags: beautifulsoup
score: 9
slot_map: {'key': ['str_0', 'var_0', 'str_1'], 'quote': ["'", '`', "'"], 'type': ['str', 'var', 'str'], 'value': ['span', 'soup', 'starGryB sp']}
intent: beautifulsoup find all 'span' elements in html string `soup` with class of 'stargryb sp'
body(Left in tags for better readability):
<p> There are two values that i am looking to scrape from a website.
These are present in the following tags:
<code_block>
 <span class="sp starBig">4.1 </span>
<span class="sp starGryB">2.9 </span>

<p> I need the values sp starBig, sp starGryB.
<p> The findAll expression that i am using is -
<code_block>
 soup.findAll('span', {'class': ['sp starGryB', 'sp starBig']}):

<p> The code gets executed without any errors yet no results get
displayed.

-------------------------------------OUTPUT-------------------------------------

                Expected= "soup.find_all('span', {'class': 'starGryB sp'})"
           base:Baseline= soup.findAll(text='Stargryb sp')
           body:Baseline= soup.findAll('span', {'class': ['sp starGryB','sp starBig'})
            body:-Blocks= soup.findAll('span')
              body:-Code= soup.findAll('span')
            body:-Inline= soup.findAll('span', {'class': ['sp starGryB sp'})
                body:-NL= soup.findAll('span', {'class': ['sp starGryB','sp starBig'})
             base:+Mined= soup.findAll('span', class='stargryb sp')
     body+mined:Baseline= soup.findAll('span', {'class': ['sp starGryB','sp starBig']}
        body+mined:-Code= print(soup.findAll('span', class='StargryB sp').all())
          body+mined:-NL= soup.find_all('span', {'class': ['sp starGryB', 'sp starBig']})
      body+mined:-Blocks= soup.findAll('span', class='stargryb sp')
      body+mined:-Inline= soup.findAll('span', {'class': ['sp starGryB', 'sp starBig']})

================================================================================

QUESTION: idx=266    id=24189150
-------------------------------------INPUTS-------------------------------------

tags: sql, postgresql, pandas, sqlalchemy
score: 17
slot_map: {'key': ['var_0', 'str_0', 'str_1'], 'quote': ['`', "'", "'"], 'type': ['var', 'str', 'str'], 'value': ['df', 'test', 'a_schema']}
intent: write records in dataframe `df` to table 'test' in schema 'a_schema'
body(Left in tags for better readability):
<p> I am trying to write a pandas DataFrame to a PostgreSQL database,
using a schema-qualified table.
<p> I use the following code:
<code_block>
 import pandas.io.sql as psql
from sqlalchemy import create_engine

engine = create_engine(r'postgresql://some:user@host/db')

c = engine.connect()
conn = c.connection

df = psql.read_sql("SELECT * FROM xxx", con=conn)
df.to_sql('a_schema.test', engine)

conn.close()

<p> What happens is that pandas writes in schema "public", in a table
named 'a_schema.test',
instead of writing in the "test" table in the "a_schema" schema.
<p> How can I instruct pandas to use a schema different than public?
<p> Thanks

-------------------------------------OUTPUT-------------------------------------

                Expected= "df.to_sql('test', engine, schema='a_schema')"
           base:Baseline= df.to_test('test')
           body:Baseline= df.to_sql('a_schema.test', engine)
            body:-Blocks= df.set_table('test')
              body:-Code= df.set_index('test')
            body:-Inline= df.to_sql('a_schema.test', engine)
                body:-NL= df.to_sql('a_schema.test', table='test')
             base:+Mined= df.to_csv('test.csv', index=False)
     body+mined:Baseline= df.to_sql('a_schema.test', engine)
        body+mined:-Code= df.set_index('a_schema.test')
          body+mined:-NL= df.to_sql('a_schema.test', engine)
      body+mined:-Blocks= df.set_index('test')
      body+mined:-Inline= df.to_sql('a_schema.test', engine)

================================================================================

QUESTION: idx=267    id=30766151
-------------------------------------INPUTS-------------------------------------

tags: regex
score: 5
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['s']}
intent: extract brackets from string `s`
body(Left in tags for better readability):
<p> I have a string which has multiple brackets. Let says
<code_block>
 s="(a(vdwvndw){}]"

<p> I want to extract all the brackets as a separate string.
<p> I tried this:
<code_block>
 <console_in> brackets=re.search(r"[(){}[]]+",s)
<console_in> brackets.group()
<console_out>
<p> But it is only giving me last two brackets.
<code_block>
 '}]'

<p> Why is that? Shouldn't it fetch one or more of any of the brackets
in the character set?

-------------------------------------OUTPUT-------------------------------------

                Expected= "brackets = re.sub('[^(){}[\\\\]]', '', s)"
           base:Baseline= re.sub('\\d+', s)
           body:Baseline= re.search(r"[(){}[]]+', s)
            body:-Blocks= re.findall('\\d+', s)
              body:-Code= re.findall('\\d+', s)
            body:-Inline= re.search('(\\wvvndw){}]', s)
                body:-NL= re.search('(a(vdwvndw){}]"
             base:+Mined= re.findall('\\s+', s)
     body+mined:Baseline= re.findall('\\s+', s)
        body+mined:-Code= re.findall('\\[\\]', s)
          body+mined:-NL= re.search('(a(vdwvndw){}', s)
      body+mined:-Blocks= re.findall('\\S+', s)
      body+mined:-Inline= re.findall('\\[(\\w+)\\]', s)

================================================================================

QUESTION: idx=268    id=1143379
-------------------------------------INPUTS-------------------------------------

tags: list
score: 13
slot_map: {'key': ['str_0'], 'quote': ["'"], 'type': ['str'], 'value': ['L']}
intent: remove duplicate elements from list 'l'
body(Left in tags for better readability):
<p> Can anyone suggest a good solution to remove duplicates from
nested lists if wanting to evaluate duplicates based on first element
of each nested list?
<p> The main list looks like this:
<code_block>
 L = [['14', '65', 76], ['2', '5', 6], ['7', '12', 33], ['14', '22',
46]]

<p> If there is another list with the same element at first position
<code> [k][0] <p>  that had already occurred, then I'd like to remove
that list and get this result:
<code_block>
 L = [['14', '65', 76], ['2', '5', 6], ['7', '12', 33]]

<p> Can you suggest an algorithm to achieve this goal?

-------------------------------------OUTPUT-------------------------------------

                Expected= 'list(dict((x[0], x) for x in L).values())'
           base:Baseline= [x for x in L if x not in x]
           body:Baseline= [x[0] for x in L]
            body:-Blocks= l = [x[0] for x in l]
              body:-Code= [k for k, v in l if v != 0]
            body:-Inline= [x for x in L if x not in x]
                body:-NL= [x[0] for x in L]
             base:+Mined= [x for x in L if x not in duplicate]
     body+mined:Baseline= [x for x in L if x[0]]
        body+mined:-Code= set(L).sort(key=lambda x: x[1])
          body+mined:-NL= [x for x in L if x not in l]
      body+mined:-Blocks= result = [x for x in l if x[0] == [k][0] for y in l]
      body+mined:-Inline= [list(x) for x in L if x[0]]

================================================================================

QUESTION: idx=269    id=12330522
-------------------------------------INPUTS-------------------------------------

tags: line-breaks, readlines
score: 448
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['file']}
intent: read a file `file` without newlines
body(Left in tags for better readability):
<p> In Python, calling
<code_block>
 temp = open(filename,'r').readlines()

<p> results in a list in which each element is a line in the file.
It's a little stupid but still: <code> readlines() <p>  also writes
newline character to each element, something I do not wish to happen.
<p> How can I avoid it?

-------------------------------------OUTPUT-------------------------------------

                Expected= "[line.rstrip('\\n') for line in file]"
           base:Baseline= os.path.isfile(file)
           body:Baseline= Temp = open(filename, 'r').readlines()
            body:-Blocks= os.path.isfile(file)
              body:-Code= print(os.path.isfile(file))
            body:-Inline= Temp = open(filename, 'r').readlines()
                body:-NL= Temp = open(filename, 'r').readlines()
             base:+Mined= file = open('file', 'wb')
     body+mined:Baseline= temp = open(filename, 'r').readlines()
        body+mined:-Code= for line in open(file):
    pass
          body+mined:-NL= temp = open(filename, 'r').readlines()
      body+mined:-Blocks= for line in open(file):
    pass
      body+mined:-Inline= temp = open(filename, 'r').readlines()

================================================================================

QUESTION: idx=270    id=364621
-------------------------------------INPUTS-------------------------------------

tags: list
score: 177
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['testlist']}
intent: get the position of item 1 in `testlist`
body(Left in tags for better readability):
<p> I am iterating over a list and I want to print out the index of
the item if it meets a certain condition. How would I do this?
<p> Example:
<code_block>
 testlist = [1,2,3,5,3,1,2,1,6]
for item in testlist:
    if item == 1:
        print position


-------------------------------------OUTPUT-------------------------------------

                Expected= '[i for i, x in enumerate(testlist) if x == 1]'
           base:Baseline= testlist.get_position(1)
           body:Baseline= [i for i in testlist if i == 1]
            body:-Blocks= print(testlist.index(1))
              body:-Code= print(item in testlist[1]
            body:-Inline= [x for x in testlist if item == 1]
                body:-NL= for item in testlist:
    pass
             base:+Mined= len(testlist) == (1)[-1]
     body+mined:Baseline= next((1) if item == 1)
        body+mined:-Code= next((1, 1) for item in testlist)
          body+mined:-NL= len(testlist) - 1 - testlist[1]
      body+mined:-Blocks= next((1, 1) for item in testlist)
      body+mined:-Inline= next((1, 1) for item in testlist)

================================================================================

QUESTION: idx=271    id=364621
-------------------------------------INPUTS-------------------------------------

tags: list
score: 177
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['testlist']}
intent: get the position of item 1 in `testlist`
body(Left in tags for better readability):
<p> I am iterating over a list and I want to print out the index of
the item if it meets a certain condition. How would I do this?
<p> Example:
<code_block>
 testlist = [1,2,3,5,3,1,2,1,6]
for item in testlist:
    if item == 1:
        print position


-------------------------------------OUTPUT-------------------------------------

                Expected= '[i for i, x in enumerate(testlist) if x == 1]'
           base:Baseline= testlist.get_position(1)
           body:Baseline= [i for i in testlist if i == 1]
            body:-Blocks= print(testlist.index(1))
              body:-Code= print(item in testlist[1]
            body:-Inline= [x for x in testlist if item == 1]
                body:-NL= for item in testlist:
    pass
             base:+Mined= len(testlist) == (1)[-1]
     body+mined:Baseline= next((1) if item == 1)
        body+mined:-Code= next((1, 1) for item in testlist)
          body+mined:-NL= len(testlist) - 1 - testlist[1]
      body+mined:-Blocks= next((1, 1) for item in testlist)
      body+mined:-Inline= next((1, 1) for item in testlist)

================================================================================

QUESTION: idx=272    id=364621
-------------------------------------INPUTS-------------------------------------

tags: list
score: 177
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['testlist']}
intent: get the position of item 1 in `testlist`
body(Left in tags for better readability):
<p> I am iterating over a list and I want to print out the index of
the item if it meets a certain condition. How would I do this?
<p> Example:
<code_block>
 testlist = [1,2,3,5,3,1,2,1,6]
for item in testlist:
    if item == 1:
        print position


-------------------------------------OUTPUT-------------------------------------

                Expected= 'for i in [i for i, x in enumerate(testlist) if x == 1]:\n    pass'
           base:Baseline= testlist.get_position(1)
           body:Baseline= [i for i in testlist if i == 1]
            body:-Blocks= print(testlist.index(1))
              body:-Code= print(item in testlist[1]
            body:-Inline= [x for x in testlist if item == 1]
                body:-NL= for item in testlist:
    pass
             base:+Mined= len(testlist) == (1)[-1]
     body+mined:Baseline= next((1) if item == 1)
        body+mined:-Code= next((1, 1) for item in testlist)
          body+mined:-NL= len(testlist) - 1 - testlist[1]
      body+mined:-Blocks= next((1, 1) for item in testlist)
      body+mined:-Inline= next((1, 1) for item in testlist)

================================================================================

QUESTION: idx=273    id=364621
-------------------------------------INPUTS-------------------------------------

tags: list
score: 177
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['testlist']}
intent: get the position of item 1 in `testlist`
body(Left in tags for better readability):
<p> I am iterating over a list and I want to print out the index of
the item if it meets a certain condition. How would I do this?
<p> Example:
<code_block>
 testlist = [1,2,3,5,3,1,2,1,6]
for item in testlist:
    if item == 1:
        print position


-------------------------------------OUTPUT-------------------------------------

                Expected= 'for i in (i for i, x in enumerate(testlist) if x == 1):\n    pass'
           base:Baseline= testlist.get_position(1)
           body:Baseline= [i for i in testlist if i == 1]
            body:-Blocks= print(testlist.index(1))
              body:-Code= print(item in testlist[1]
            body:-Inline= [x for x in testlist if item == 1]
                body:-NL= for item in testlist:
    pass
             base:+Mined= len(testlist) == (1)[-1]
     body+mined:Baseline= next((1) if item == 1)
        body+mined:-Code= next((1, 1) for item in testlist)
          body+mined:-NL= len(testlist) - 1 - testlist[1]
      body+mined:-Blocks= next((1, 1) for item in testlist)
      body+mined:-Inline= next((1, 1) for item in testlist)

================================================================================

QUESTION: idx=274    id=364621
-------------------------------------INPUTS-------------------------------------

tags: list
score: 177
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['testlist']}
intent: get the position of item 1 in `testlist`
body(Left in tags for better readability):
<p> I am iterating over a list and I want to print out the index of
the item if it meets a certain condition. How would I do this?
<p> Example:
<code_block>
 testlist = [1,2,3,5,3,1,2,1,6]
for item in testlist:
    if item == 1:
        print position


-------------------------------------OUTPUT-------------------------------------

                Expected= 'gen = (i for i, x in enumerate(testlist) if x == 1)\nfor i in gen:\n    pass'
           base:Baseline= testlist.get_position(1)
           body:Baseline= [i for i in testlist if i == 1]
            body:-Blocks= print(testlist.index(1))
              body:-Code= print(item in testlist[1]
            body:-Inline= [x for x in testlist if item == 1]
                body:-NL= for item in testlist:
    pass
             base:+Mined= len(testlist) == (1)[-1]
     body+mined:Baseline= next((1) if item == 1)
        body+mined:-Code= next((1, 1) for item in testlist)
          body+mined:-NL= len(testlist) - 1 - testlist[1]
      body+mined:-Blocks= next((1, 1) for item in testlist)
      body+mined:-Inline= next((1, 1) for item in testlist)

================================================================================

QUESTION: idx=275    id=364621
-------------------------------------INPUTS-------------------------------------

tags: list
score: 177
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['element', 'testlist']}
intent: get the position of item `element` in list `testlist`
body(Left in tags for better readability):
<p> I am iterating over a list and I want to print out the index of
the item if it meets a certain condition. How would I do this?
<p> Example:
<code_block>
 testlist = [1,2,3,5,3,1,2,1,6]
for item in testlist:
    if item == 1:
        print position


-------------------------------------OUTPUT-------------------------------------

                Expected= 'print(testlist.index(element))'
           base:Baseline= print(len(element) for element in testlist)
           body:Baseline= [i for i, j in testlist if i == 1]
            body:-Blocks= print(element.index(1))
              body:-Code= print(element in testlist[:1])
            body:-Inline= [x for x in testlist if item == 1]
                body:-NL= [x for x in testlist if x == 1]
             base:+Mined= [x for x in testlist if x not inelement]
     body+mined:Baseline= next((i, j) for i, j in testlist)
        body+mined:-Code= element.index(level=0)
          body+mined:-NL= [item for item in testlist if item == 1]
      body+mined:-Blocks= element.index(level=0)
      body+mined:-Inline= next(i for i, j in enumerate(testlist) if j == 1)

================================================================================

QUESTION: idx=276    id=364621
-------------------------------------INPUTS-------------------------------------

tags: list
score: 177
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['element', 'testlist']}
intent: get the position of item `element` in list `testlist`
body(Left in tags for better readability):
<p> I am iterating over a list and I want to print out the index of
the item if it meets a certain condition. How would I do this?
<p> Example:
<code_block>
 testlist = [1,2,3,5,3,1,2,1,6]
for item in testlist:
    if item == 1:
        print position


-------------------------------------OUTPUT-------------------------------------

                Expected= 'try:\n    print(testlist.index(element))\nexcept ValueError:\n    pass'
           base:Baseline= print(len(element) for element in testlist)
           body:Baseline= [i for i, j in testlist if i == 1]
            body:-Blocks= print(element.index(1))
              body:-Code= print(element in testlist[:1])
            body:-Inline= [x for x in testlist if item == 1]
                body:-NL= [x for x in testlist if x == 1]
             base:+Mined= [x for x in testlist if x not inelement]
     body+mined:Baseline= next((i, j) for i, j in testlist)
        body+mined:-Code= element.index(level=0)
          body+mined:-NL= [item for item in testlist if item == 1]
      body+mined:-Blocks= element.index(level=0)
      body+mined:-Inline= next(i for i, j in enumerate(testlist) if j == 1)

================================================================================

QUESTION: idx=277    id=13145368
-------------------------------------INPUTS-------------------------------------

tags: list, tuples
score: 95
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['lis']}
intent: find the first element of the tuple with the maximum second element in a list of tuples `lis`
body(Left in tags for better readability):

<strong> Possible Duplicate:
<a> Sorting or Finding Max Value by the second element in a nested
list. Python

<p> I have a list with ~10^6 tuples in it like this:
<code_block>
 [(101, 153), (255, 827), (361, 961), <console_out>]
  ^     ^
  X     Y

<p> I want to find the maximum value of the Ys in this list, but also
want to know the X that it is bound to.
<p> How do I do this?

-------------------------------------OUTPUT-------------------------------------

                Expected= 'max(lis, key=lambda item: item[1])[0]'
           base:Baseline= [max(x[1] for x inlis]
           body:Baseline= max(x, y) == 10
            body:-Blocks= max(lis, key=lambda x: x[1])
              body:-Code= max(zip(lis, key=lambda x: x[1])
            body:-Inline= max(x[1] for x inlis)
                body:-NL= [x[0] for x in l]
             base:+Mined= max(lis, key=lambda x: x[1])
     body+mined:Baseline= max(lis, key=lambda x: x[1])
        body+mined:-Code= max(lis, key=lambda x: x[1])
          body+mined:-NL= [x[0] for x in lst]
      body+mined:-Blocks= max(lis, key=lambda x: x[1])
      body+mined:-Inline= max(lis, key=lambda x: x[1])

================================================================================

QUESTION: idx=278    id=13145368
-------------------------------------INPUTS-------------------------------------

tags: list, tuples
score: 95
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['lis']}
intent: get the item at index 0 from the tuple that has maximum value at index 1 in list `lis`
body(Left in tags for better readability):

<strong> Possible Duplicate:
<a> Sorting or Finding Max Value by the second element in a nested
list. Python

<p> I have a list with ~10^6 tuples in it like this:
<code_block>
 [(101, 153), (255, 827), (361, 961), <console_out>]
  ^     ^
  X     Y

<p> I want to find the maximum value of the Ys in this list, but also
want to know the X that it is bound to.
<p> How do I do this?

-------------------------------------OUTPUT-------------------------------------

                Expected= 'max(lis, key=itemgetter(1))[0]'
           base:Baseline= max(len(lis, key=lambda x: x[1])
           body:Baseline= max(x, y) for x, y in zip(lis, 1)]
            body:-Blocks= max(zip(lis, key=lambda x: x[1])
              body:-Code= max(zip(lis, key=lambda x: x[1])
            body:-Inline= max(zip(lis, 1))
                body:-NL= [max(x, y) for x, y in zip(lis, 1)]
             base:+Mined= max(lis, key=lambda x: x[1])
     body+mined:Baseline= max(lis, key=lambda x: x[1])
        body+mined:-Code= max(lis, key=lambda x: x[1])
          body+mined:-NL= max(lis, key=lambda x: x[1])
      body+mined:-Blocks= max(lis, key=lambda x: x[1])
      body+mined:-Inline= max(lis, key=lambda x: x[1])

================================================================================

QUESTION: idx=279    id=2689189
-------------------------------------INPUTS-------------------------------------

tags: command-line
score: 5
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: make a delay of 1 second
body(Left in tags for better readability):
<p> My Python program does a series of things and prints some
diagnostic output. I would also like to have a progress counter like
this:
<code_block>
 Percentage done: 25%

<p> where the number increases "in place". If I use only string
statements I can write separate numbers, but that would clutter the
screen. Is there some way to achieve this, for example using some
escape char for backspace in order to clear a number and write the
next one?
<p> Thanks

-------------------------------------OUTPUT-------------------------------------

                Expected= 'time.sleep(1)'
           base:Baseline= time.sleep(1, 1)
           body:Baseline= sys.exit(1, 1)
            body:-Blocks= sys.stdout.sleep(1)
              body:-Code= sys.sleep(1)
sys.exit(0)
            body:-Inline= sys.sleep(1, 1)
                body:-NL= time.sleep(1, 1)
             base:+Mined= time.sleep(0.1)
     body+mined:Baseline= sys.stdout.flush()[0]
        body+mined:-Code= sys.stdout.write('\r\n')
          body+mined:-NL= sys.stdout.flush()[0]
      body+mined:-Blocks= sys.stdout.flush()[1]
      body+mined:-Inline= time.sleep(1.1)

================================================================================

QUESTION: idx=280    id=12485244
-------------------------------------INPUTS-------------------------------------

tags: 
score: 4
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['L']}
intent: convert list of tuples `l` to a string
body(Left in tags for better readability):
<p> I have the following list:
<code_block>
 [('Steve Buscemi', 'Mr. Pink'), ('Chris Penn', 'Nice Guy Eddie'),
<console_out>]

<p> I need to convert it to a string in the following format:
<code_block>
 "(Steve Buscemi, Mr. Pink), (Chris Penn, Nice Guy Eddit),
<console_out>"

<p> I tried doing
<code_block>
 str = ', '.join(item for item in items)

<p> but run into the following error:
<code_block>
 TypeError: sequence item 0: expected string, tuple found

<p> How would I do the above formatting?

-------------------------------------OUTPUT-------------------------------------

                Expected= '""", """.join(\'(\' + \', \'.join(i) + \')\' for i in L)'
           base:Baseline= """""".join(zip(*l))
           body:Baseline= """""".join(item for item in L))
            body:-Blocks= """""".join(str(x) for x in L))
              body:-Code= """""".join(str(x) for x in L)
            body:-Inline= """""".join(item for item in L)
                body:-NL= """""".join(item for item in L)
             base:+Mined= """""".join(map(str, L))
     body+mined:Baseline= str = ', '.join(item for item in items)
        body+mined:-Code= """""".join(str(x) for x in l)
          body+mined:-NL= """(Steve Buscemi, Mr. Pink), (Chris Penn, Nice Guy Eddit), """.join(l)
      body+mined:-Blocks= """""".join(map(str, L))
      body+mined:-Inline= str = ', '.join(item) for item in items)

================================================================================

QUESTION: idx=281    id=755857
-------------------------------------INPUTS-------------------------------------

tags: django, django-models, django-admin
score: 104
slot_map: {'key': ['var_0', 'str_0'], 'quote': ['`', "'"], 'type': ['var', 'str'], 'value': ['b', '0000000']}
intent: django set default value of field `b` equal to '0000000'
body(Left in tags for better readability):
<p> Suppose I have a model:
<code_block>
 class SomeModel(models.Model):
    id = models.AutoField(primary_key=True)
    a = models.CharField(max_length=10)
    b = models.CharField(max_length=7)

<p> Currently I am using the default admin to create/edit objects of
this type.
How do I remove the field <code> b <p>  from the admin so that each
object <em> cannot <p>  be created with a value, and rather will
receive a default value of <code> 0000000 <p> ?

-------------------------------------OUTPUT-------------------------------------

                Expected= "b = models.CharField(max_length=7, default='0000000', editable=False)"
           base:Baseline= django.setdefault_value(b, '0000000')
           body:Baseline= SomeModel(models.Model).default_value=False)
            body:-Blocks= admin.objects.setdefault_value(b, '0000000')
              body:-Code= b = admin.objects.default('0000000')
            body:-Inline= b.setdefault_value(0, '0000000')
                body:-NL= SomeModel.setdefault('b')
             base:+Mined= Book.objects.default(b=['0000000'])
     body+mined:Baseline= SomeModel.objects.default_value('b')
        body+mined:-Code= admin.site.register(b, '0000000')
          body+mined:-NL= SomeModel.objects.extra(**kwargs)
      body+mined:-Blocks= super(Admin, self).save(*args, **kwargs)
      body+mined:-Inline= SomeModel.objects.default('b', '0000000')

================================================================================

QUESTION: idx=282    id=16193578
-------------------------------------INPUTS-------------------------------------

tags: 
score: 29
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['list5']}
intent: sort lis `list5` in ascending order based on the degrees value of its elements
body(Left in tags for better readability):
<p> If i have a list of numbers <code> [4,2,5,1,3] <p>
I want to sort it first by some function <code> f <p>  and then for
numbers with the same value of <code> f <p>  i want it to be sorted by
the magnitude of the number.
<p> This code does not seem to be working.
<code_block>
 list5 = sorted(list5)
list5 = sorted(list5, key = lambda vertex: degree(vertex))

<p> Secondary sorting first: list5 is sorted based on magnitude.
Primary sorting next: list5 is sorted based on some function of the
numbers.

-------------------------------------OUTPUT-------------------------------------

                Expected= 'sorted(list5, lambda x: (degree(x), x))'
           base:Baseline= sorted(list5, key=lambda x: x[1])
           body:Baseline= sorted(list5, key=lambda k: k.sum(), reverse=True)
            body:-Blocks= sorted(list5, key=lambda x: x[1], reverse=True)
              body:-Code= sorted(list5, key=lambda x: x[1])
            body:-Inline= list5 = sorted(list5, key=lambda vertex: degree(vertex))
                body:-NL= list5 = sorted(list5, key=lambda x: x[1])
             base:+Mined= sorted(list5, key=lambda x: x.degrees(x))
     body+mined:Baseline= sorted(list5, key=lambda v: (v[1], v[2]))
        body+mined:-Code= sorted(list5, key=lambda x: (int(x[1], x[0]))
          body+mined:-NL= sorted(list5, key=lambda x: (x[0], x[1]))
      body+mined:-Blocks= sorted(list5, key=lambda x: (int(x[1], x[1]))
      body+mined:-Inline= sorted(list5, key=lambda v: v.degrees(v))

================================================================================

QUESTION: idx=283    id=16193578
-------------------------------------INPUTS-------------------------------------

tags: 
score: 29
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: how do i perform secondary sorting in python?
body(Left in tags for better readability):
<p> If i have a list of numbers <code> [4,2,5,1,3] <p>
I want to sort it first by some function <code> f <p>  and then for
numbers with the same value of <code> f <p>  i want it to be sorted by
the magnitude of the number.
<p> This code does not seem to be working.
<code_block>
 list5 = sorted(list5)
list5 = sorted(list5, key = lambda vertex: degree(vertex))

<p> Secondary sorting first: list5 is sorted based on magnitude.
Primary sorting next: list5 is sorted based on some function of the
numbers.

-------------------------------------OUTPUT-------------------------------------

                Expected= 'sorted(list5, key=lambda vertex: (degree(vertex), vertex))'
           base:Baseline= sorted(list(range(10)), key=lambda x: x[1])
           body:Baseline= sorted(list5, key=lambda x: x[4, 2, 5, 1, 3])
            body:-Blocks= sorted(list5, key=lambda x: [4, 2, 5, 1, 3])
              body:-Code= sorted(list(range(5)), key=lambda x: x[1])
            body:-Inline= list5 = sorted(list5, key=lambda vertex: degree(vertex))
                body:-NL= list5 = sorted(list5, key=lambda x: x[1])
             base:+Mined= sorted(list(range(10)), key=lambda x: x[1])
     body+mined:Baseline= sorted(list5, key=lambda v: (v[1], v[2]))
        body+mined:-Code= sorted(list5, key=lambda x: (int(x[1], x[2]))
          body+mined:-NL= [4, 2, 5, 1, 3]
      body+mined:-Blocks= sorted(lst, key=lambda x: (x[1], x[1]))
      body+mined:-Inline= sorted(list5, key=lambda vertex: degree(vertex))

================================================================================

QUESTION: idx=284    id=16041405
-------------------------------------INPUTS-------------------------------------

tags: 
score: 37
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: convert a list  into a generator object
body(Left in tags for better readability):
<p> Say I have a list
<code_block>
 data = []
data.append("A")
data.append("B")
data.append("C")
data.append("D")

<p> How do I convert this to a generator?
Any help with sample code would be highly appreciated...
<p> Found a URL: <a>
http://eli.thegreenplace.net/2012/04/05/implementing-a-generatoryield-
in-a-python-c-extension/
<p> Is this what I want to do?

-------------------------------------OUTPUT-------------------------------------

                Expected= '(n for n in [1, 2, 3, 5])'
           base:Baseline=  generator.from_iterable(key=lambda x: x[1])
           body:Baseline= data = [i for i, v in enumerate(data.items()])]
            body:-Blocks=  generator.from_iterable(list, key=lambda x: x[1])
              body:-Code= [item[0] for item in enumerate(list(itertools.product()))]
            body:-Inline= data.append('A')[::-1]
                body:-NL= generator.from_iterable(data)
             base:+Mined= my_list = [i for i in range(10)]
     body+mined:Baseline= print(list(itertools.chain.from_iterable(data)))
        body+mined:-Code= from functools import reduce
reduce(lambda x, y: x + y, [1, 2, 3])
          body+mined:-NL= list(itertools.chain(*data))
      body+mined:-Blocks= from functools import reduce
reduce(lambda x, y: x + y, [1, 2, 3, 4, 5, 6, 7]))
      body+mined:-Inline= from functools import reduce
reduce(lambda x, y: x + y, [1, 2, 3])

================================================================================

QUESTION: idx=285    id=18837607
-------------------------------------INPUTS-------------------------------------

tags: list
score: 15
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['oldlist', 'removelist']}
intent: remove elements from list `oldlist` that have an index number mentioned in list `removelist`
body(Left in tags for better readability):
<p> So, for example, I got a list: <code>
myList=["asdf","ghjk","qwer","tyui"] <p>
I also have a list of index numbers of the items I want to remove:
<code> removeIndexList=[1,3] <p>  (I want to remove items 1 and 3 from
the list above)
<p> What would be the best way to do this?

-------------------------------------OUTPUT-------------------------------------

                Expected= 'newlist = [v for i, v in enumerate(oldlist) if i not in removelist]'
           base:Baseline= [x for x in oldlist if x not inremovelist]
           body:Baseline= [x for x in oldlist if x not in x]
            body:-Blocks= [x for x in oldlist if x not inremovelist]
              body:-Code= [x for x in oldlist if x not inremovelist]
            body:-Inline= [x for x in oldlist if x not inremovelist]
                body:-NL= [x for x in oldlist if x not inremovelist]
             base:+Mined= oldlist = [x for x in oldlist if x not in index]
     body+mined:Baseline= [x for x in oldlist if x.index == 'removelist']
        body+mined:-Code= oldlist = [item for item in oldlist if item.index()]
          body+mined:-NL= removelist = [x for x in oldlist if x not in indexList]
      body+mined:-Blocks= oldlist = [x for x in oldList if x[i] == 2]
      body+mined:-Inline= oldlist = [x for x in oldlist if x != 3]

================================================================================

QUESTION: idx=286    id=4710067
-------------------------------------INPUTS-------------------------------------

tags: file, input
score: 165
slot_map: {'key': ['str_0'], 'quote': ['`'], 'type': ['str'], 'value': ['yourfile.txt']}
intent: open a file `yourfile.txt` in write mode
body(Left in tags for better readability):
<p> Let's say I have a text file full of nicknames. How can I delete a
specific nickname from this file, using Python?

-------------------------------------OUTPUT-------------------------------------

                Expected= "f = open('yourfile.txt', 'w')"
           base:Baseline= open('yourfile.txt', 'write')
           body:Baseline= open('yourfile.txt', 'write mode')
            body:-Blocks= open('yourfile.txt', 'write')
              body:-Code= open('yourfile.txt', 'write')
            body:-Inline= open('yourfile.txt', 'rb')
                body:-NL= open('yourfile.txt', 'write')
             base:+Mined= f = open('yourfile.txt', 'wb')
     body+mined:Baseline= open('yourfile.txt', 'wb')
        body+mined:-Code= f.write('yourfile.txt', 'r')
          body+mined:-NL= f = open('yourfile.txt', 'rb')
      body+mined:-Blocks= f.write(yourfile.txt)
      body+mined:-Inline= yourfile.txt.write('\n')

================================================================================

QUESTION: idx=287    id=7373219
-------------------------------------INPUTS-------------------------------------

tags: 
score: 5
slot_map: {'key': ['str_0', 'var_0'], 'quote': ["'", '`'], 'type': ['str', 'var'], 'value': ['attr', 'obj']}
intent: get attribute 'attr' from object `obj`
body(Left in tags for better readability):
<p> I vaguely remember learning about some sort of built-in function
that would do the equivalent of
<code_block>
 f = lambda x: x.attr

<p> Am I just imagining this or does such a thing exist?

-------------------------------------OUTPUT-------------------------------------

                Expected= "getattr(obj, 'attr')"
           base:Baseline= obj.getattr('attr', 1)
           body:Baseline= obj = lambda x: x.attr(obj)
            body:-Blocks= obj['attr'] = obj.attr
              body:-Code= obj['attr'] = obj.getattr()
            body:-Inline= f = obj.getattr('attr')
                body:-NL= obj = obj.attribute('attr')
             base:+Mined= obj.getattr(obj, 'attr')
     body+mined:Baseline= f = obj.getattr(obj)
        body+mined:-Code= obj.getattr(__builtins__)
          body+mined:-NL= obj = obj.getattr(obj)
      body+mined:-Blocks= obj.getattr(obj, 'attr')
      body+mined:-Inline= obj.attrgetter('attr')

================================================================================

QUESTION: idx=288    id=8171751
-------------------------------------INPUTS-------------------------------------

tags: list, cursor, tuples
score: 5
slot_map: {'key': ['str_0', '(str_0)'], 'quote': ['`', '`'], 'type': ['str', 'str'], 'value': ["(('aa',), ('bb',), ('cc',))", "(('aa',), ('bb',), ('cc',))"]}
intent: convert tuple of tuples `(('aa',), ('bb',), ('cc',))` to tuple
body(Left in tags for better readability):
<code_block>
 query = 'select mydata from mytable'
cursor.execute(query)
myoutput = cursor.fetchall()
print myoutput

(('aa',), ('bb',), ('cc',))

<p> Why is it (cursor.fetchall) returning a tuple of tuples instead of
a tuple since my query is asking for only one column of data?
<p> What is the best way of converting it to <code> ['aa', 'bb', 'cc']
<p>  ?
<p> I can do something like this :
<code_block>
 mylist = []
myoutput = list(myoutput)
for each in myoutput:
   mylist.append(each[0])

<p> I am sure this isn't the best way of doing it. Please enlighten
me!

-------------------------------------OUTPUT-------------------------------------

                Expected= "from functools import reduce\nreduce(lambda a, b: a + b, (('aa',), ('bb',), ('cc',)))"
           base:Baseline= tuple(map(lambda x: (('aa', ('bb',), ('cc',))))
           body:Baseline= cursor.execute(query, ('aa', 'bb'), ('cc',))
            body:-Blocks= cursor.fetchall(('aa', ('bb',), ('cc',))
              body:-Code= cursor.fetchall(('aa', (bb',), ('cc',))
            body:-Inline= cursor.set_tuple(('aa', ('bb',), ('cc',))
                body:-NL= cursor.execute(list(myoutput))
             base:+Mined= tuple(map(lambda tup: tup[::-1], (('aa',), ('bb',), 'cc',))])
     body+mined:Baseline= myoutput = tuple(map(lambda t: t[0]))
        body+mined:-Code= tuple(map(lambda x: x[1], ('BB',), ('cc',))
          body+mined:-NL= myoutput = tuple(map(lambda t: t[0]), cursor.fetchall())
      body+mined:-Blocks= tuple(map(lambda tup: tup[1], (('aa',), 'bb',), ('cc',))])
      body+mined:-Inline= tuple(map(lambda t: t[0]) for t in myoutput)

================================================================================

QUESTION: idx=289    id=8171751
-------------------------------------INPUTS-------------------------------------

tags: list, cursor, tuples
score: 5
slot_map: {'key': ['str_0', '(str_0)'], 'quote': ['`', '`'], 'type': ['str', 'str'], 'value': ["(('aa',), ('bb',), ('cc',))", "(('aa',), ('bb',), ('cc',))"]}
intent: convert tuple of tuples `(('aa',), ('bb',), ('cc',))` to list in one line
body(Left in tags for better readability):
<code_block>
 query = 'select mydata from mytable'
cursor.execute(query)
myoutput = cursor.fetchall()
print myoutput

(('aa',), ('bb',), ('cc',))

<p> Why is it (cursor.fetchall) returning a tuple of tuples instead of
a tuple since my query is asking for only one column of data?
<p> What is the best way of converting it to <code> ['aa', 'bb', 'cc']
<p>  ?
<p> I can do something like this :
<code_block>
 mylist = []
myoutput = list(myoutput)
for each in myoutput:
   mylist.append(each[0])

<p> I am sure this isn't the best way of doing it. Please enlighten
me!

-------------------------------------OUTPUT-------------------------------------

                Expected= "map(lambda a: a[0], (('aa',), ('bb',), ('cc',)))"
           base:Baseline= [(('aa',), ('bb',), 'cc',)) for i in range(1)]
           body:Baseline= cursor.execute(query, (('aa', 'bb',), ('cc',))
            body:-Blocks= cursor.fetchall(('aa', ('bb',), ('cc',))
              body:-Code= cursor.fetchall(('aa', (bb',), ('cc',))
            body:-Inline= query = [[(('aa', ('bb',), ('cc',))] for i in range(0)]
                body:-NL= cursor.execute(list(myoutput))
             base:+Mined= map(lambda t: t[(('aa',), ('bb',), 'cc',))]
     body+mined:Baseline= myoutput = list(myoutput)
        body+mined:-Code= cursor.fetchall('(('aa',), ('bb',), 'cc',))
          body+mined:-NL= ['aa', 'bb', 'cc']
      body+mined:-Blocks= [tuple(i) for i in (('aa',), ('bb',), 'cc')]
      body+mined:-Inline= myoutput = list(mytable)

================================================================================

QUESTION: idx=290    id=28986489
-------------------------------------INPUTS-------------------------------------

tags: replace, pandas, dataframe
score: 117
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: python pandas: how to replace a characters in a column of a dataframe?
body(Left in tags for better readability):
<p> I have a column in my dataframe like this:
<code_block>
 range
"(2,30)"
"(50,290)"
"(400,1000)"
<console_out>

<p> and I want to replace the <code> , <p>  comma with <code> - <p>
dash. I'm currently using this method but nothing is changed.
<code_block>
 org_info_exc['range'].replace(',', '-', inplace=True)

<p> Can anybody help?

-------------------------------------OUTPUT-------------------------------------

                Expected= "df['range'].replace(',', '-', inplace=True)"
           base:Baseline= df.dropna(df.columns, axis=1)
           body:Baseline= df['range'].replace(',', '-', inplace=True)
            body:-Blocks= df['collections'] = df['Collections']
              body:-Code= df['s'].replace('', '')
            body:-Inline= df['range'].replace(',', '-', inplace=True)
                body:-NL= df['range'].replace(',', '-', inplace=True)
             base:+Mined= df = df.replace(' ', '')
     body+mined:Baseline= df['range'].replace(',', '-', inplace=True)
        body+mined:-Code= df['column_name'].replace('', '')
          body+mined:-NL= df['range'].replace(',', '-', inplace=True)
      body+mined:-Blocks= df['dash'] = df['dash'].replace(' ', '')
      body+mined:-Inline= df['range'].replace(',', '-', inplace=True)

================================================================================

QUESTION: idx=291    id=19339
-------------------------------------INPUTS-------------------------------------

tags: list, matrix, transpose
score: 535
slot_map: {'key': ['str_0', '[str_0]'], 'quote': ['`', '`'], 'type': ['str', 'str'], 'value': ["[('a', 1), ('b', 2), ('c', 3), ('d', 4)]", "[('a', 1), ('b', 2), ('c', 3), ('d', 4)]"]}
intent: unzip the list `[('a', 1), ('b', 2), ('c', 3), ('d', 4)]`
body(Left in tags for better readability):
<p> I have a list of 2-item tuples and I'd like to convert them to 2
lists where the first contains the first item in each tuple and the
second list holds the second item.
<strong> For example:
<code_block>
 original = [('a', 1), ('b', 2), ('c', 3), ('d', 4)]
# and I want to become...
result = (['a', 'b', 'c', 'd'], [1, 2, 3, 4])

<p> Is there a builtin function that does that?

-------------------------------------OUTPUT-------------------------------------

                Expected= "zip(*[('a', 1), ('b', 2), ('c', 3), ('d', 4)])"
           base:Baseline= zip([('A', 1), ('B', 2), ('C', 3), ('D', 4)])
           body:Baseline= [('a', 1), ('b', 2), ('c', 3), ('d', 4)]
            body:-Blocks= zip([('A', 1), ('B', 2), ('C', 3), ('D', 4)])
              body:-Code= zip([('A', 1), ('B', 2), ('C', 3), ('D', 4)])
            body:-Inline= zip(*[('a', 1), ('b', 2), ('c', 3), ('d', 4)])
                body:-NL= zip(*[('a', 1), ('b', 2), ('c', 3), ('d', 4)]
             base:+Mined= zip(*([('a', 1), ('b', 2), ('c', 3), ('d', 4)])
     body+mined:Baseline= zip(*[('a', 1), ('b', 2), ('c', 3), ('d', 4)])
        body+mined:-Code= zip(*([('A', 1), ('B', 2), ('C', 3), ('D', 4)])
          body+mined:-NL= new = zip(*[('a', 1), ('b', 2), ('c', 3), ('d', 4)]
      body+mined:-Blocks= zip(*[('a', 1), ('b', 2), ('c', 3), ('d', 4)])
      body+mined:-Inline= zip(*[('a', 1), ('b', 2), ('c', 3), ('d', 4)])

================================================================================

QUESTION: idx=292    id=19339
-------------------------------------INPUTS-------------------------------------

tags: list, matrix, transpose
score: 535
slot_map: {'key': ['str_0', '[str_0]'], 'quote': ['`', '`'], 'type': ['str', 'str'], 'value': ["[('a', 1), ('b', 2), ('c', 3), ('d', 4)]", "[('a', 1), ('b', 2), ('c', 3), ('d', 4)]"]}
intent: unzip the list `[('a', 1), ('b', 2), ('c', 3), ('d', 4)]`
body(Left in tags for better readability):
<p> I have a list of 2-item tuples and I'd like to convert them to 2
lists where the first contains the first item in each tuple and the
second list holds the second item.
<strong> For example:
<code_block>
 original = [('a', 1), ('b', 2), ('c', 3), ('d', 4)]
# and I want to become...
result = (['a', 'b', 'c', 'd'], [1, 2, 3, 4])

<p> Is there a builtin function that does that?

-------------------------------------OUTPUT-------------------------------------

                Expected= "zip(*[('a', 1), ('b', 2), ('c', 3), ('d', 4)])"
           base:Baseline= zip([('A', 1), ('B', 2), ('C', 3), ('D', 4)])
           body:Baseline= [('a', 1), ('b', 2), ('c', 3), ('d', 4)]
            body:-Blocks= zip([('A', 1), ('B', 2), ('C', 3), ('D', 4)])
              body:-Code= zip([('A', 1), ('B', 2), ('C', 3), ('D', 4)])
            body:-Inline= zip(*[('a', 1), ('b', 2), ('c', 3), ('d', 4)])
                body:-NL= zip(*[('a', 1), ('b', 2), ('c', 3), ('d', 4)]
             base:+Mined= zip(*([('a', 1), ('b', 2), ('c', 3), ('d', 4)])
     body+mined:Baseline= zip(*[('a', 1), ('b', 2), ('c', 3), ('d', 4)])
        body+mined:-Code= zip(*([('A', 1), ('B', 2), ('C', 3), ('D', 4)])
          body+mined:-NL= new = zip(*[('a', 1), ('b', 2), ('c', 3), ('d', 4)]
      body+mined:-Blocks= zip(*[('a', 1), ('b', 2), ('c', 3), ('d', 4)])
      body+mined:-Inline= zip(*[('a', 1), ('b', 2), ('c', 3), ('d', 4)])

================================================================================

QUESTION: idx=293    id=19339
-------------------------------------INPUTS-------------------------------------

tags: list, matrix, transpose
score: 535
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['original']}
intent: unzip list `original`
body(Left in tags for better readability):
<p> I have a list of 2-item tuples and I'd like to convert them to 2
lists where the first contains the first item in each tuple and the
second list holds the second item.
<strong> For example:
<code_block>
 original = [('a', 1), ('b', 2), ('c', 3), ('d', 4)]
# and I want to become...
result = (['a', 'b', 'c', 'd'], [1, 2, 3, 4])

<p> Is there a builtin function that does that?

-------------------------------------OUTPUT-------------------------------------

                Expected= 'result = [a for a, b in original], [b for a, b in original]'
           base:Baseline= original.unzip(key=operator.itemgetter(1))
           body:Baseline= zip(original, key=lambda x: x[1], reverse=True)
            body:-Blocks= original.zip(key=operator.itemgetter(1))
              body:-Code= original.zip(key=operator.itemgetter(1))
            body:-Inline= original = zip(original, key=lambda x: x[1])
                body:-NL= original = [('a', 1), ('b', 2), ('c', 3), ('d', 4)]
             base:+Mined= original = zip(*sorted(original))
     body+mined:Baseline= zip(original, result[:]))
        body+mined:-Code= original.zip(key=operator.itemgetter(1))
          body+mined:-NL= result = [(x[0], x[1] for x in original]
      body+mined:-Blocks= new_list = zip(*original)
      body+mined:-Inline= zip(*original)[::-1]

================================================================================

QUESTION: idx=294    id=19339
-------------------------------------INPUTS-------------------------------------

tags: list, matrix, transpose
score: 535
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['original']}
intent: unzip list `original` and return a generator
body(Left in tags for better readability):
<p> I have a list of 2-item tuples and I'd like to convert them to 2
lists where the first contains the first item in each tuple and the
second list holds the second item.
<strong> For example:
<code_block>
 original = [('a', 1), ('b', 2), ('c', 3), ('d', 4)]
# and I want to become...
result = (['a', 'b', 'c', 'd'], [1, 2, 3, 4])

<p> Is there a builtin function that does that?

-------------------------------------OUTPUT-------------------------------------

                Expected= 'result = (a for a, b in original), (b for a, b in original)'
           base:Baseline= original = [i for i in range(0, len(original), 1)]
           body:Baseline= re.unzip(original, key=lambda x: x[1], reverse=True)
            body:-Blocks= original.unzip(key=operator.itemgetter(1))
              body:-Code=  generator.unzip(original, key=operator.itemgetter(1))
            body:-Inline= new = [zip(original, key=lambda x: x[1])
                body:-NL= return generator.unzip(original)
             base:+Mined= from functools import reduce
reduce(lambda x, y: x + y, [1, 2, 3, 4, 5, 6])
     body+mined:Baseline= new = zip(*original, result)
        body+mined:-Code= new_list = zip(*original)
          body+mined:-NL= new_list = [random.sample(list(original.items())) for _ in range(0, len(
    original), 3)]
      body+mined:-Blocks= new_list = zip(*original)
      body+mined:-Inline= [(x + y) for x, y in zip(original, result)]

================================================================================

QUESTION: idx=295    id=19339
-------------------------------------INPUTS-------------------------------------

tags: list, matrix, transpose
score: 535
slot_map: {'key': ['str_0', '[str_0]'], 'quote': ['`', '`'], 'type': ['str', 'str'], 'value': ["[('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e', )]", "[('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e', )]"]}
intent: unzip list `[('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e', )]`
body(Left in tags for better readability):
<p> I have a list of 2-item tuples and I'd like to convert them to 2
lists where the first contains the first item in each tuple and the
second list holds the second item.
<strong> For example:
<code_block>
 original = [('a', 1), ('b', 2), ('c', 3), ('d', 4)]
# and I want to become...
result = (['a', 'b', 'c', 'd'], [1, 2, 3, 4])

<p> Is there a builtin function that does that?

-------------------------------------OUTPUT-------------------------------------

                Expected= "zip(*[('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e',)])"
           base:Baseline= zip(*[[('A', 1), ('B', 2), ('C', 3), ('D', 4), ('E', 5)])
           body:Baseline= zip(*('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e', )])
            body:-Blocks= zip(*[[('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e', )])]
              body:-Code= zip(*[[('A', 1), ('B', 2), ('C', 3), ('D', 4), ('E', )]))
            body:-Inline= zip(*[('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e', 5)]
                body:-NL= zip(*[('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e',)])
             base:+Mined= zip(*[('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e', 5), ('f', 6), ('g', 7), ('h', 8)]
     body+mined:Baseline= zip(*[('a', 1), ('b', 2), ('c', 3), ('d', 4)])
        body+mined:-Code= zip(*[('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e', 5)]
          body+mined:-NL= new = zip(*new)[::-1]
      body+mined:-Blocks= zip(*[('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e', 5)]
      body+mined:-Inline= zip(*[('a', 1), ('b', 2), ('c', 3), ('d', 4)])

================================================================================

QUESTION: idx=296    id=19339
-------------------------------------INPUTS-------------------------------------

tags: list, matrix, transpose
score: 535
slot_map: {'key': ['str_0', '[str_0]'], 'quote': ['`', '`'], 'type': ['str', 'str'], 'value': ["[('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e', )]", "[('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e', )]"]}
intent: unzip list `[('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e', )]` and fill empty results with none
body(Left in tags for better readability):
<p> I have a list of 2-item tuples and I'd like to convert them to 2
lists where the first contains the first item in each tuple and the
second list holds the second item.
<strong> For example:
<code_block>
 original = [('a', 1), ('b', 2), ('c', 3), ('d', 4)]
# and I want to become...
result = (['a', 'b', 'c', 'd'], [1, 2, 3, 4])

<p> Is there a builtin function that does that?

-------------------------------------OUTPUT-------------------------------------

                Expected= "map(None, *[('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e',)])"
           base:Baseline= zip(*[[('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e', 5)])
           body:Baseline= results = [('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e', )]]
            body:-Blocks= zip(*[[('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e',)]])
              body:-Code= zip(*[[('A', 1), ('B', 2), ('C', 3), ('D', 4), ('E', )]))
            body:-Inline= result = [(('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e', 5))
                body:-NL= result = [('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e',)]
             base:+Mined= zip(*[[('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e', 5), ('n'])])
     body+mined:Baseline= zip(*[('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e', 5)]
        body+mined:-Code= zip(*((a', 1), ('b', 2), ('c', 3), ('d', 4), ('e', 5))
          body+mined:-NL= new = [x for x in original if x is not None]
      body+mined:-Blocks= [('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e', 5)]
      body+mined:-Inline= zip(*[('a', 1), ('b', 2), ('c', 3), ('d', 4)])

================================================================================

QUESTION: idx=297    id=1960516
-------------------------------------INPUTS-------------------------------------

tags: json, floating-point, decimal
score: 267
slot_map: {'key': ['str_0'], 'quote': ['`'], 'type': ['str'], 'value': ["Decimal('3.9')"]}
intent: encode `decimal('3.9')` to a json string
body(Left in tags for better readability):
<p> I have a <code> Decimal('3.9') <p>  as part of an object, and wish
to encode this to a JSON string which should look like <code> {'x':
3.9} <p> . I don't care about precision on the client side, so a float
is fine.
<p> Is there a good way to serialize this? JSONDecoder doesn't accept
Decimal objects, and converting to a float beforehand yields <code>
{'x': 3.8999999999999999} <p>  which is wrong, and will be a big waste
of bandwidth.

-------------------------------------OUTPUT-------------------------------------

                Expected= "json.dumps(Decimal('3.9'))"
           base:Baseline= json.encode('3.9')
           body:Baseline= json.decimal('3.9')
            body:-Blocks= json.decimal('3.9')
              body:-Code= json.decimal('3.9')
            body:-Inline= json.decimal('3.9')
                body:-NL= json.decimal('3.9')
             base:+Mined= json.dumps(decimal('3.9')).encode('utf-8')
     body+mined:Baseline= json.dumps(decimal('3.9')))
        body+mined:-Code= json.dumps(decimal('3.9')).encode('float')
          body+mined:-NL= json.dumps(decimal('3.9')).encode('utf-8')
      body+mined:-Blocks= json.dumps(decimal('3.9').encode('utf-8')
      body+mined:-Inline= json.dumps(decimal('3.9'))

================================================================================

QUESTION: idx=298    id=1024847
-------------------------------------INPUTS-------------------------------------

tags: dictionary, lookup
score: 2913
slot_map: {'key': ['str_0', 'var_0', 'str_1'], 'quote': ['"', '`', '"'], 'type': ['str', 'var', 'str'], 'value': ['mynewkey', 'd', 'mynewvalue']}
intent: add key "mynewkey" to dictionary `d` with value "mynewvalue"
body(Left in tags for better readability):
<p> Is it possible to add a key to a Python dictionary after it has
been created?
<p> It doesn't seem to have an <code> .add() <p>  method.

-------------------------------------OUTPUT-------------------------------------

                Expected= "d['mynewkey'] = 'mynewvalue'"
           base:Baseline= d = {'mynewkey': d.get('mynewvalue'})
           body:Baseline= d = list(d.items()))
            body:-Blocks= d = {'mynewkey': d.get('mynewvalue'})
              body:-Code= d = {'mynewkey':'mynewvalue'})
            body:-Inline= d['mynewkey'] = 'mynewvalue'
                body:-NL= d = d.update({'mynewkey': 'mynewvalue'})
             base:+Mined= d = {'mynewkey': 'mynewvalue'}
     body+mined:Baseline= d['mynewkey'] = 'mynewvalue'
        body+mined:-Code= d['mynewkey'] = 'Mynewvalue'
          body+mined:-NL= d.update({'mynewkey': 'mynewvalue'})
      body+mined:-Blocks= d.update({'mynewkey': 'mynewvalue'})
      body+mined:-Inline= d = {'mynewkey': 'mynewvalue'}

================================================================================

QUESTION: idx=299    id=1024847
-------------------------------------INPUTS-------------------------------------

tags: dictionary, lookup
score: 2913
slot_map: {'key': ['str_0', 'var_0'], 'quote': ["'", '`'], 'type': ['str', 'var'], 'value': ['a', 'data']}
intent: add key 'a' to dictionary `data` with value 1
body(Left in tags for better readability):
<p> Is it possible to add a key to a Python dictionary after it has
been created?
<p> It doesn't seem to have an <code> .add() <p>  method.

-------------------------------------OUTPUT-------------------------------------

                Expected= "data.update({'a': 1})"
           base:Baseline= data.update({'a': 1})
           body:Baseline= data.update({'a': 1})
            body:-Blocks= data.update({'a': 1})
              body:-Code= data.update({'a': 1})
            body:-Inline= data.update({'a': 1})
                body:-NL= data.update({'a': 1})
             base:+Mined= data['a'].update({'a': 1})
     body+mined:Baseline= data.update({'a': 1})
        body+mined:-Code= data.update({'a': 1})
          body+mined:-NL= data.update({'a': 1})
      body+mined:-Blocks= data.update({'a': 1, 'b': 1})
      body+mined:-Inline= data.update({'a': 1})

================================================================================

QUESTION: idx=300    id=1024847
-------------------------------------INPUTS-------------------------------------

tags: dictionary, lookup
score: 2913
slot_map: {'key': ['str_0', 'var_0'], 'quote': ["'", '`'], 'type': ['str', 'var'], 'value': ['a', 'data']}
intent: add key 'a' to dictionary `data` with value 1
body(Left in tags for better readability):
<p> Is it possible to add a key to a Python dictionary after it has
been created?
<p> It doesn't seem to have an <code> .add() <p>  method.

-------------------------------------OUTPUT-------------------------------------

                Expected= 'data.update(dict(a=1))'
           base:Baseline= data.update({'a': 1})
           body:Baseline= data.update({'a': 1})
            body:-Blocks= data.update({'a': 1})
              body:-Code= data.update({'a': 1})
            body:-Inline= data.update({'a': 1})
                body:-NL= data.update({'a': 1})
             base:+Mined= data['a'].update({'a': 1})
     body+mined:Baseline= data.update({'a': 1})
        body+mined:-Code= data.update({'a': 1})
          body+mined:-NL= data.update({'a': 1})
      body+mined:-Blocks= data.update({'a': 1, 'b': 1})
      body+mined:-Inline= data.update({'a': 1})

================================================================================

QUESTION: idx=301    id=1024847
-------------------------------------INPUTS-------------------------------------

tags: dictionary, lookup
score: 2913
slot_map: {'key': ['str_0', 'var_0'], 'quote': ["'", '`'], 'type': ['str', 'var'], 'value': ['a', 'data']}
intent: add key 'a' to dictionary `data` with value 1
body(Left in tags for better readability):
<p> Is it possible to add a key to a Python dictionary after it has
been created?
<p> It doesn't seem to have an <code> .add() <p>  method.

-------------------------------------OUTPUT-------------------------------------

                Expected= 'data.update(a=1)'
           base:Baseline= data.update({'a': 1})
           body:Baseline= data.update({'a': 1})
            body:-Blocks= data.update({'a': 1})
              body:-Code= data.update({'a': 1})
            body:-Inline= data.update({'a': 1})
                body:-NL= data.update({'a': 1})
             base:+Mined= data['a'].update({'a': 1})
     body+mined:Baseline= data.update({'a': 1})
        body+mined:-Code= data.update({'a': 1})
          body+mined:-NL= data.update({'a': 1})
      body+mined:-Blocks= data.update({'a': 1, 'b': 1})
      body+mined:-Inline= data.update({'a': 1})

================================================================================

QUESTION: idx=302    id=35837346
-------------------------------------INPUTS-------------------------------------

tags: for-loop, max
score: 14
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['matrix']}
intent: find maximal value in matrix `matrix`
body(Left in tags for better readability):
<p> To find the maximal value in a matrix of numbers, we can code 5
lines to solve the problem:
<code_block>
 ans = matrix[0][0]
for x in range(len(matrix)):
    for y in range(len(matrix[0])):
        ans = max(ans, matrix[x][y])
return ans

<p> Is there a one line solution for this problem?
The one that I came up with is pretty awkward actually:
<code_block>
 return max(max(matrix, key=max))

<p> or
<code_block>
 return max(map(max, matrix))


-------------------------------------OUTPUT-------------------------------------

                Expected= 'max([max(i) for i in matrix])'
           base:Baseline= max(matrix, key=lambda x: x[1])
           body:Baseline= max(len(matrix, key=max))
            body:-Blocks= max(matrix, key=lambda x: x[1])
              body:-Code= max(matrix, key=lambda x: x[1])
            body:-Inline= max(matrix, key=max)
                body:-NL= max(ans, matrix[x][y])
             base:+Mined= np.max(matrix, axis=1)
     body+mined:Baseline= max(abs, matrix[x][y])
        body+mined:-Code= np.max(matrix, axis=1)
          body+mined:-NL= max(ans, matrix[x][y])
      body+mined:-Blocks= matrix[np.max(matrix, axis=1)]
      body+mined:-Inline= max(abs, matrix[x][y])

================================================================================

QUESTION: idx=303    id=20457038
-------------------------------------INPUTS-------------------------------------

tags: rounding
score: 340
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['answer']}
intent: round number `answer` to 2 precision after the decimal point
body(Left in tags for better readability):
<p> I am getting a lot of decimals in the output of this code
(Fahrenheit to Celsius converter).
<p> My code currently looks like this:
<code_block>
 def main():
    printC(formeln(typeHere()))

def typeHere():
    global Fahrenheit
    try:
        Fahrenheit = int(raw_input("Hi! Enter Fahrenheit value, and
get it in Celsius!\n"))
    except ValueError:
        print "\nYour insertion was not a digit!"
        print "We've put your Fahrenheit value to 50!"
        Fahrenheit = 50
    return Fahrenheit

def formeln(c):
    Celsius = (Fahrenheit - 32.00) * 5.00/9.00
    return Celsius

def printC(answer):
    answer = str(answer)
    print "\nYour Celsius value is " + answer + " C.\n"

main()

<p> So my question is, how do I make the program round every answer to
the 2nd decimal place?

-------------------------------------OUTPUT-------------------------------------

                Expected= 'answer = str(round(answer, 2))'
           base:Baseline= round(answer.round(2))
           body:Baseline= round(answer, 2, 1)
            body:-Blocks= answer.round(2, 2)
              body:-Code= print(answer.round(2))
            body:-Inline= print('{0:.2f}'.format(answer))
                body:-NL= answer = str(answer) + 2
             base:+Mined= round(answer, 2, 2)
     body+mined:Baseline= print('Celsius = (Fahrenheit - 32.00) * 5.00 / 9.00')
        body+mined:-Code= round(answer.split('.')[2])
          body+mined:-NL= print('\n'.join(round(answer))
      body+mined:-Blocks= print('%.2f' % round(answer))
      body+mined:-Inline= round(Fahrenheit - 32.0, 2)

================================================================================

QUESTION: idx=304    id=2890896
-------------------------------------INPUTS-------------------------------------

tags: regex, string
score: 27
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: extract ip address from an html string
body(Left in tags for better readability):
<p> I want to extract an IP address from a string (actually a one-line
HTML) using Python.
<code_block>
 <console_in> s = " <html> <head> <title>Current IP Check </title>
</head> <body>Current IP Address: 165.91.15.131 </body> </html>"
<console_out>
<p> -- '165.91.15.131' is what I want!
<p> I tried using regular expressions, but so far I can only get to
the first number.
<code_block>
 <console_in> import re
<console_in> ip = re.findall( r'([0-9]+)(?:\.[0-9]+){3}', s )
<console_in> ip
<console_out> ['165']

<p> But I don't have a firm grasp on reg-expression; the above code
was found and modified from elsewhere on the web.

-------------------------------------OUTPUT-------------------------------------

                Expected= "ip = re.findall('[0-9]+(?:\\\\.[0-9]+){3}', s)"
           base:Baseline= urllib.parse.unquote(id=0, ip=0)
           body:Baseline=  ip = re.findall('([0-9]+)(?:\.[0- 9]+){3}', s)
            body:-Blocks= urllib.parse.rpath.retrieve(IP address)
              body:-Code= urllib.parse.unquote(IP address, '165.91.15.131')
            body:-Inline= s = re.findall('([0-9]+)(?:\\.[0- 9]+){3}', s)
                body:-NL= """.join(re.findall('([0-9]+)(?:\.[0- 9]+){3}', s))
             base:+Mined= soup.find_elements_by_xpath('//ip address[@ip address]')
     body+mined:Baseline= s = re.findall('(?<!>[0-9]+)(?:\\.[0-10]+){3}', s)
        body+mined:-Code= socket.gethostbyname('168.91.15.131')
          body+mined:-NL= print(s.encode('utf-8'))
      body+mined:-Blocks= urllib.request.urlopen('http://www.google.com')
      body+mined:-Inline= print(s.encode('utf-8'))

================================================================================

QUESTION: idx=305    id=29836836
-------------------------------------INPUTS-------------------------------------

tags: pandas, filtering, dataframe
score: 51
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['df', 'A']}
intent: filter dataframe `df` by values in column `a` that appear more than once
body(Left in tags for better readability):
<p> I'm working in Python with a pandas DataFrame of video games, each
with a genre. I'm trying to remove any video game with a genre that
appears less than some number of times in the DataFrame, but I have no
clue how to go about this. I did find <a> a StackOverflow question <p>
that seems to be related, but I can't decipher the solution at all
(possibly because I've never heard of R and my memory of functional
programming is rusty at best).
<p> Help?

-------------------------------------OUTPUT-------------------------------------

                Expected= "df.groupby('A').filter(lambda x: len(x) > 1)"
           base:Baseline= df.filter(['a'], axis=1)
           body:Baseline= df.filter(['a'], a)
            body:-Blocks= df.filter(df.columns, 'a' == 0)
              body:-Code= df.filter(df.a)
            body:-Inline= df.filter(['a'], a)
                body:-NL= df.filter(['a'], axis=1)
             base:+Mined= df.filter(lambda x: len(x), axis=1)
     body+mined:Baseline= df.ix[df.genre.str.count('a') > 0]
        body+mined:-Code= df.filter(df.genre == 'genre' > 0)
          body+mined:-NL= df.filter(df.columns, axis=1)
      body+mined:-Blocks= df.filter(df.genre.str.counts(a))
      body+mined:-Inline= df.ix[df.genre.str.count('a') > 1]

================================================================================

QUESTION: idx=306    id=2545397
-------------------------------------INPUTS-------------------------------------

tags: 
score: 9
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['myfile']}
intent: append each line in file `myfile` into a list
body(Left in tags for better readability):
<p> I have a text document that contains a list of numbers and I want
to convert it to a list. Right now I can only get the entire list in
the 0th entry of the list, but I want each number to be an element of
a list. Does anyone know of an easy way to do this in Python?
<code_block>
 1000
2000
3000
4000

<p> to
<code_block>
 ['1000','2000','3000','4000']


-------------------------------------OUTPUT-------------------------------------

                Expected= "[x for x in myfile.splitlines() if x != '']"
           base:Baseline= myfile.append('\n'.join(myfile))
           body:Baseline= [x[0] for x in myfile]
            body:-Blocks= [x for x in myfile if not x in x]
              body:-Code= [x for x in myfile]
            body:-Inline= [x for x in myfile]
                body:-NL= [line for line in myfile]
             base:+Mined= myfile = [line[0] for line in myfile]
     body+mined:Baseline= ['1000', '2000', '3000', '4000']
        body+mined:-Code= [line for line in open('myfile').read()]
          body+mined:-NL= ['1000', '2000', '3000', '4000']
      body+mined:-Blocks= [line for line in open('myfile').read()]
      body+mined:-Inline= [int(x) for x in myfile]

================================================================================

QUESTION: idx=307    id=2545397
-------------------------------------INPUTS-------------------------------------

tags: 
score: 9
slot_map: {'key': ['var_0', 'str_0'], 'quote': ['`', '`'], 'type': ['var', 'str'], 'value': ['lst', 'filename.txt']}
intent: get a list of integers `lst` from a file `filename.txt`
body(Left in tags for better readability):
<p> I have a text document that contains a list of numbers and I want
to convert it to a list. Right now I can only get the entire list in
the 0th entry of the list, but I want each number to be an element of
a list. Does anyone know of an easy way to do this in Python?
<code_block>
 1000
2000
3000
4000

<p> to
<code_block>
 ['1000','2000','3000','4000']


-------------------------------------OUTPUT-------------------------------------

                Expected= "lst = map(int, open('filename.txt').readlines())"
           base:Baseline= [int(x) for x in open('filename.txt')]
           body:Baseline= [int(x) for x in open('filename.txt')]
            body:-Blocks= [int(x) for x in open('filename.txt')]
              body:-Code= [int(x) for x in open('filename.txt')]
            body:-Inline= [int(x) for x in open('filename.txt')]
                body:-NL= [int(x) for x in open('filename.txt')]
             base:+Mined= lst = [int(i) for i in open('filename.txt')]
     body+mined:Baseline= [int(x) for x in open('filename.txt')]
        body+mined:-Code= lst = [int(i) for i in open(filename.txt)]
          body+mined:-NL= lst = [int(x) for x infilename.txt]
      body+mined:-Blocks= lst = [int(i) for i in open('filename.txt')]
      body+mined:-Inline= [int(x) for x in open('filename.txt')]

================================================================================

QUESTION: idx=308    id=35420052
-------------------------------------INPUTS-------------------------------------

tags: spectrogram
score: 10
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['mappable', 'plt']}
intent: add color bar with image `mappable` to plot `plt`
body(Left in tags for better readability):
<p> I'm trying to add a Colorbar to a spectrogram. I have tried every
example and question thread I have found online and none have solved
this issue
<p> Note that 'spl1' (data splice 1) is a trace from ObsPy.
<strong> My code is:
<code_block>
 fig = plt.figure()
ax1 = fig.add_axes([0.1, 0.75, 0.7, 0.2]) #[left bottom width height]
ax2 = fig.add_axes([0.1, 0.1, 0.7, 0.60], sharex=ax1)
ax3 = fig.add_axes([0.83, 0.1, 0.03, 0.6])

t = np.arange(spl1[0].stats.npts) / spl1[0].stats.sampling_rate
ax1.plot(t, spl1[0].data, 'k')

ax,spec = spectrogram(spl1[0].data,spl1[0].stats.sampling_rate,
show=False, axes=ax2)
ax2.set_ylim(0.1, 15)
fig.colorbar(spec, cax=ax3)

<p> It comes out with the error:
<code_block>
 Traceback (most recent call last):

  File " <ipython-input-18-61226ccd2d85>", line 14, in <module>
    ax,spec = spectrogram(spl1[0].data,spl1[0].stats.sampling_rate,
show=False, axes=ax2)

TypeError: 'Axes' object is not iterable

<strong> Best result so far:
<p> Replacing the last 3 lines above with:
<code_block>
 ax = spectrogram(spl1[0].data,spl1[0].stats.sampling_rate,
show=False, axes=ax2)
ax2.set_ylim(0.1, 15)
fig.colorbar(ax,cax=ax3)

<p> Produces this:

<p> and this error for the colorbar:
<code_block>
 axes object has no attribute 'autoscale_None'

<p> I don't seem to be able to find a way to get the colorbar on the
right to work.
<strong> Solutions?
<p> One of the solutions I have seen is that you need to create an
'image' of your data using imshow(), however I don't get an output for
that from Spectrogram(), only 'ax'. I have seen places try with the
'ax,spec' output from spectrogram() but that is causing the TypeError.

<li> Very similar code I found but didn't work <a>
https://www.nicotrebbin.de/wp-
content/uploads/2012/03/bachelorthesis.pdf <li>  (ctrl+f 'colorbar')
<li> Looked at code examples <a> from a related question
<li> imshow() <a> suggestions <li>  and <a> example <li>  - can't get
an output from spectrogram to turn into an image. That second link, I
also can't get the mlpy module to work (it doesn't think there's a
mlpy.wavelet function)
<li> This problem was addressed in <a> an improvement post for obspy
<li>  but the solution he stated he found was not given

<p> I hope someone can give a hand with this - I've been working on
this all day now!

-------------------------------------OUTPUT-------------------------------------

                Expected= 'plt.colorbar(mappable=mappable, cax=ax3)'
           base:Baseline= plt.set_color_bar('mappable')
           body:Baseline= plt.set_ylim(0.1, 15)
            body:-Blocks= plt.set_image_bar('mappable')
              body:-Code= plt.set_colorbar('mappable')
            body:-Inline= plt.colorbar(mappable)
                body:-NL= plt.plot(t, spl1[0].mappable)
             base:+Mined= plt.colorbar(mappable)
     body+mined:Baseline= plt.colorbar(mappable)
        body+mined:-Code= plt.imshow('mappable')
          body+mined:-NL= plt.colorbar(ax, cax=ax3)
      body+mined:-Blocks= plt.imshow('spl1', interpolation='mappable')
      body+mined:-Inline= plt.colorbar(t, spl1[0].data, 'k')

================================================================================

QUESTION: idx=309    id=29903025
-------------------------------------INPUTS-------------------------------------

tags: pandas
score: 20
slot_map: {'key': ['str_0', 'var_0'], 'quote': ["'", '`'], 'type': ['str', 'var'], 'value': ['text', 'df']}
intent: count most frequent 100 words in column 'text' of dataframe `df`
body(Left in tags for better readability):
<p> I have text reviews in one column in Pandas dataframe and I want
to count the N-most frequent words with their frequency counts (in
whole column - NOT in single cell). One approach is Counting the words
using a counter, by iterating through each row. Is there a better
alternative?
<p> Representative data.
<code_block>
 0    a heartening tale of small victories and endu
1    no sophomore slump for director sam mendes  w
2    if you are an actor who can relate to the sea
3    it's this memory-as-identity obviation that g
4    boyd's screenplay ( co-written with guardian


-------------------------------------OUTPUT-------------------------------------

                Expected= "Counter(' '.join(df['text']).split()).most_common(100)"
           base:Baseline= df['text'] = df['text'].max(100)
           body:Baseline= df['text'] = df['text'].count(100)
            body:-Blocks= df['text'] = df['text'].count()
              body:-Code= df.count_common_words('text')
            body:-Inline= df['text'] = df['text'].sum()
                body:-NL= df['text'].count(100)
             base:+Mined= df.groupby(['text'])['value'].count()
     body+mined:Baseline= df.groupby(['text', 'reaction']).sum()
        body+mined:-Code= df.reindex_words('text', inplace=True)
          body+mined:-NL= df['text'].apply(lambda x: len(x), axis=1)
      body+mined:-Blocks= df['text'] = df['text'].nunique()
      body+mined:-Inline= df.words.apply(lambda x: len(x), axis=1)

================================================================================

QUESTION: idx=310    id=16330838
-------------------------------------INPUTS-------------------------------------

tags: regex, string, split
score: 5
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: python split a string using regex
body(Left in tags for better readability):
<p> I would like to split a string by ':' and ' ' characters. However,
i would like to ignore two spaces '  ' and  two colons '::'. for e.g.
<code_block>
 text = "s:11011 i:11010 ::110011  :110010 d:11000"

<p> should split into
<code_block>
 [s,11011,i,11010,:,110011, ,110010,d,11000]

<p> after following the Regular Expressions HOWTO on the python
website, i managed to comeup with the following
<code_block>
 regx= re.compile('([\s:]|[^\s\s]|[^::])')
regx.split(text)

<p> However this does not work as intended as it splits on the : and
spaces, but it still includes the ':' and ' ' in the split.
<code_block>
 [s,:,11011, ,i,:,11010, ,:,:,110011, , :,110010, ,d,:,11000]

<p> How can I fix this?
<strong> EDIT: <p>  In case of a double space, i only want one space
to appear

-------------------------------------OUTPUT-------------------------------------

                Expected= "re.findall('(.+?):(.+?)\\\\b?', text)"
           base:Baseline= re.split('[^a-zA-Z]', '', shell=True)
           body:Baseline= re.compile('([\\s:]|[^\\s\\s]', '::')
            body:-Blocks= re.findall('\\d+', '', '', re.MULTILINE)
              body:-Code= re.split('\\', '', re.IGNORECASE)
            body:-Inline= re.compile('([^\\s\\s]|[^^]\\s+', '', text)
                body:-NL= re.compile('([^\\s\\s]|[^::])', '', text)
             base:+Mined= re.split('(?<=.)(?=.)', s)
     body+mined:Baseline= regx = re.compile('([^\\s\\s]|[^::])')
        body+mined:-Code= re.findall('\\((?:(?:[a-zA-Z]*?)\\)', s)
          body+mined:-NL= regx.split('s:11011 i:11010 ::110011  :110010 d:11000')
      body+mined:-Blocks= re.split('(?<=\\w+)', s)
      body+mined:-Inline= regx.split(re.compile('([^\\s\\s]|[^::])')

================================================================================

QUESTION: idx=311    id=7378180
-------------------------------------INPUTS-------------------------------------

tags: set, tuples, subset
score: 17
slot_map: {'key': ['str_0', '(str_0)'], 'quote': ['`', '`'], 'type': ['str', 'str'], 'value': ['(1, 2, 3)', '(1, 2, 3)']}
intent: generate all 2-element subsets of tuple `(1, 2, 3)`
body(Left in tags for better readability):
<p> I have a set of values and would like to create list of all
subsets containing 2 elements.
<p> For example, a source set <code> ([1,2,3]) <p>  has the following
2-element subsets:
<code_block>
 set([1,2]), set([1,3]), set([2,3])

<p> Is there a way to do this in python?

-------------------------------------OUTPUT-------------------------------------

                Expected= 'list(itertools.combinations((1, 2, 3), 2))'
           base:Baseline= [(1, 2, 3)]
           body:Baseline= set([1, 2, 3])
            body:-Blocks= [(1, 2, 3) for (2, 3)]
              body:-Code= [(1, 2, 3) for k, v in subsets]
            body:-Inline= list(zip(*(1, 2, 3))
                body:-NL= [(1, 2, 3)]
             base:+Mined= [(1, 2, 3) for i in range(0, len(a), 2)]
     body+mined:Baseline= [(1, 2, 3)], (2, 3)]
        body+mined:-Code= [(1, 2, 3), (1, 3, 4)]
          body+mined:-NL= [(1, 2, 3), (2, 3)]
      body+mined:-Blocks= [subset[0] for subset in (1, 2, 3)]
      body+mined:-Inline= list(itertools.chain(*(1, 2, 3))

================================================================================

QUESTION: idx=312    id=4530069
-------------------------------------INPUTS-------------------------------------

tags: datetime, date, timezone
score: 354
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: get a value of datetime.today() in the utc time zone
body(Left in tags for better readability):
<p> I am trying to subtract one date value from the value of <code>
datetime.today() <p>  to calculate how long ago something was. But it
complains:
<code_block>
 TypeError: can't subtract offset-naive and offset-aware datetimes

<p> The value <code> datetime.today() <p>  doesn't seem to be
"timezone aware", while my other date value is. How do I get a value
of <code> datetime.today() <p>  that is timezone aware?
<p> Right now, it's giving me the time in local time, which happens to
be PST, i.e. UTC - 8 hours. Worst case, is there a way I can manually
enter a timezone value into the <code> datetime <p>  object returned
by <code> datetime.today() <p>  and set it to UTC-8?
<p> Of course, the ideal solution would be for it to automatically
know the timezone.

-------------------------------------OUTPUT-------------------------------------

                Expected= 'datetime.now(pytz.utc)'
           base:Baseline= datetime.today() - datetime.timedelta(days=1)
           body:Baseline= datetime.today(), datetime.time.now().date()
            body:-Blocks= datetime.today().strftime('%Y-%m-%d')
              body:-Code= datetime.today().strftime('%B')
            body:-Inline= datetime.today().strftime('%B')
                body:-NL= datetime.today().strftime('%B')
             base:+Mined= datetime.today().strftime('%Y-%m-%d')
     body+mined:Baseline= datetime.today() - datetime.timedelta(hours=1)
        body+mined:-Code= datetime.today().strftime('%Y-%m-%d %H:%M:%S')
          body+mined:-NL= dt = datetime.utcnow().date()
      body+mined:-Blocks= datetime.today().strftime('%Y-%m-%d')
      body+mined:-Inline= datetime.today().strftime('%Y-%m-%d')

================================================================================

QUESTION: idx=313    id=4842956
-------------------------------------INPUTS-------------------------------------

tags: list
score: 78
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['list2', 'list1']}
intent: get a new list `list2`by removing empty list from a list of lists `list1`
body(Left in tags for better readability):
<p> I have a list with empty lists in it:
<code_block>
 list1 = [[], [], [], [], [], 'text', 'text2', [], 'moreText']

<p> How can I remove the empty lists so that I get:
<code_block>
 list2 = ['text', 'text2', 'moreText']

<p> I tried list.remove('') but that doesn't work.

-------------------------------------OUTPUT-------------------------------------

                Expected= 'list2 = [x for x in list1 if x != []]'
           base:Baseline= [x for x in zip(list1, list2)]
           body:Baseline= [x for x in list1 if x not in list2]
            body:-Blocks= list2 = [x for x in zip(list1, list2)]
              body:-Code= list2 = [x for x in list1]
            body:-Inline= list2 = [x for x in list1]
                body:-NL= list2 = [[], [x for x in list1]
             base:+Mined= list2 = [x for x in list1 if x != []]
     body+mined:Baseline= list2 = [x for x in list1 if x != '']
        body+mined:-Code= list2 = [x for x in list1 if x != '']
          body+mined:-NL= list2 = [x for x in list1 if x != 'moreText']
      body+mined:-Blocks= list2 = [x for x in list1 if x != '']
      body+mined:-Inline= list2 = [x for x in list1 if x != '']

================================================================================

QUESTION: idx=314    id=4842956
-------------------------------------INPUTS-------------------------------------

tags: list
score: 78
slot_map: {'key': ['var_0', 'var_1', 'var_2'], 'quote': ['`', '`', '`'], 'type': ['var', 'var', 'var'], 'value': ['list2', 'list1', 'list1']}
intent: create `list2` to contain the lists from list `list1` excluding the empty lists from `list1`
body(Left in tags for better readability):
<p> I have a list with empty lists in it:
<code_block>
 list1 = [[], [], [], [], [], 'text', 'text2', [], 'moreText']

<p> How can I remove the empty lists so that I get:
<code_block>
 list2 = ['text', 'text2', 'moreText']

<p> I tried list.remove('') but that doesn't work.

-------------------------------------OUTPUT-------------------------------------

                Expected= 'list2 = [x for x in list1 if x]'
           base:Baseline= list2 = [x for x in zip(list1, list2)]
           body:Baseline= [x for x in list1 if x not in list2]
            body:-Blocks= list2 = [x for x in zip(list1, list2)]
              body:-Code= list2 = [item for item in list1 if item in item1]
            body:-Inline= list2 = [[], [], [] for i in range(list1)]
                body:-NL= list2 = [[], [x for x in zip(list1, list2)]
             base:+Mined= list2 = [x for x in list1 if x not in list2]
     body+mined:Baseline= list2 = [x for x in list1 if x is not None]
        body+mined:-Code= list2 = [x for x in list1 if x != '']
          body+mined:-NL= list2 = [x for x in list1 if x != 'moreText']
      body+mined:-Blocks= list2 = [x for x in list1 if x not in list2]
      body+mined:-Inline= list2 = [x for x in list1 if x != '']

================================================================================

QUESTION: idx=315    id=9262278
-------------------------------------INPUTS-------------------------------------

tags: json, django, django-views
score: 83
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['data']}
intent: django response with json `data`
body(Left in tags for better readability):
<p> This is related to this question: <a> Django return json and html
depending on client python

<p> I have a command line Python API for a Django app. When I access
the app through the API it should return JSON and with a browser it
should return HTML. I can use different URLs to access the different
versions but how do I render the HTML template and JSON in the
<strong> views.py <p>  with just one template?
<p> To render the HTML I would use:
<code_block>
 return render_to_response('sample/sample.html....')

<p> But how would I do the same for JSON without putting a JSON
template? (the <code> content-type <p>  should be <code>
application/json <p>  instead of <code> text/html <p> )
<p> What would determine the JSON and HTML outputs?
<p> So in my <strong> views.py <p> :
<code_block>
 if something:
    return render_to_response('html_template',.....)
else:
    return HttpReponse(jsondata,mimetype='application/json')


-------------------------------------OUTPUT-------------------------------------

                Expected= "return HttpResponse(data, mimetype='application/json')"
           base:Baseline= data = json.loads(data)
           body:Baseline= httpReponse(jsondata, mimetype='application/json')
            body:-Blocks= response = json.loads(data)
              body:-Code= response = json.loads(data)
            body:-Inline= return HttpReponse(json, data)
                body:-NL= return HttpReponse(jsondata, mimetype='application/json')
             base:+Mined= return HttpResponse(json.dumps(data))
     body+mined:Baseline= return HttpReponse(jsondata, mimetype='application/json')
        body+mined:-Code= return HttpResponse(json.dumps(data))
          body+mined:-NL= return HttpReponse(jsondata, mimetype='application/json')
      body+mined:-Blocks= return HttpResponse(json.dumps(data))
      body+mined:-Inline= return HttpReponse(jsondata, mimetype='application/json')

================================================================================

QUESTION: idx=316    id=17284947
-------------------------------------INPUTS-------------------------------------

tags: regex
score: 9
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['example_str']}
intent: get all text that is not enclosed within square brackets in string `example_str`
body(Left in tags for better readability):
<p> I'm trying to grab any text outside of brackets with a regex.
<strong> Example string

<p> Josie Smith [3996 COLLEGE AVENUE, SOMETOWN, MD 21003]Mugsy Dog
Smith
  [2560 OAK ST, GLENMEADE, WI 14098]

<p> I'm able to get the text <em> inside <p>  the square brackets
successfully with:
<code_block>
 addrs = re.findall(r"\[(.*?)\]", example_str)
print addrs
[u'3996 COLLEGE AVENUE, SOMETOWN, MD 21003',u'2560 OAK ST, GLENMEADE,
WI 14098']

<p> but I'm having trouble getting anything <em> outside <p>  of the
square brackets.  I've tried something like the following:
<code_block>
 names = re.findall(r"(.*?)\[.*\]+", example_str)

<p> but that only finds the first name:
<code_block>
 print names
[u'Josie Smith ']

<p> So far I've only seen a string containing one to two <code> name
[address] <p>  combos, but I'm assuming there could be any number of
them in a string.

-------------------------------------OUTPUT-------------------------------------

                Expected= "re.findall('(.*?)\\\\[.*?\\\\]', example_str)"
           base:Baseline= re.findall('\\w+', example_str)
           body:Baseline= re.findall('\\[.*\\]+', example_str)
            body:-Blocks= re.findall('\\d+', example_str)
              body:-Code= re.findall('\\w+\\s+', example_str)
            body:-Inline= re.findall('\\[.*\\]', example_str)
                body:-NL= re.findall('\\[(.*?)\\]', example_str)
             base:+Mined= re.findall('\\w+', example_str)
     body+mined:Baseline= re.findall('\\[(.*?)\\]', example_str)
        body+mined:-Code= re.findall('\\s+', example_str)
          body+mined:-NL= re.findall('\\[(.*?)\\]', example_str)
      body+mined:-Blocks= re.findall('\\w+', example_str)
      body+mined:-Inline= re.findall('\\[(.*?)\\[.*\\]+', example_str)

================================================================================

QUESTION: idx=317    id=17284947
-------------------------------------INPUTS-------------------------------------

tags: regex
score: 9
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['example_str']}
intent: use a regex to get all text in a string `example_str` that is not surrounded by square brackets
body(Left in tags for better readability):
<p> I'm trying to grab any text outside of brackets with a regex.
<strong> Example string

<p> Josie Smith [3996 COLLEGE AVENUE, SOMETOWN, MD 21003]Mugsy Dog
Smith
  [2560 OAK ST, GLENMEADE, WI 14098]

<p> I'm able to get the text <em> inside <p>  the square brackets
successfully with:
<code_block>
 addrs = re.findall(r"\[(.*?)\]", example_str)
print addrs
[u'3996 COLLEGE AVENUE, SOMETOWN, MD 21003',u'2560 OAK ST, GLENMEADE,
WI 14098']

<p> but I'm having trouble getting anything <em> outside <p>  of the
square brackets.  I've tried something like the following:
<code_block>
 names = re.findall(r"(.*?)\[.*\]+", example_str)

<p> but that only finds the first name:
<code_block>
 print names
[u'Josie Smith ']

<p> So far I've only seen a string containing one to two <code> name
[address] <p>  combos, but I'm assuming there could be any number of
them in a string.

-------------------------------------OUTPUT-------------------------------------

                Expected= "re.findall('(.*?)(?:\\\\[.*?\\\\]|$)', example_str)"
           base:Baseline= re.findall('\\w+', example_str)
           body:Baseline= re.findall('\\[.*\\]+', example_str)
            body:-Blocks= re.findall('\\d+', example_str)
              body:-Code= re.findall('\\w+', example_str)
            body:-Inline= re.findall('\\[(.*?)\\]', example_str)
                body:-NL= re.findall('\\[.*\\]', example_str)
             base:+Mined= re.findall('\\w+', example_str)
     body+mined:Baseline= re.findall('\\[(.*?)\\]', example_str)
        body+mined:-Code= re.findall('\\s+', example_str)
          body+mined:-NL= re.findall('\\[(.*?)\\]', example_str)
      body+mined:-Blocks= re.findall('\\w+', example_str)
      body+mined:-Inline= re.findall('\\[(.*?)\\[.*\\]+', example_str)

================================================================================

QUESTION: idx=318    id=14182339
-------------------------------------INPUTS-------------------------------------

tags: regex, regex-alternation
score: 12
slot_map: {'key': ['str_0'], 'quote': ["'"], 'type': ['str'], 'value': ['(zyx)bc']}
intent: get whatever is between parentheses as a single match, and any char outside as an individual match in string '(zyx)bc'
body(Left in tags for better readability):
<p> I ran into a small problem using Python Regex.
<p> Suppose this is the input:
<code_block>
 (zyx)bc

<p> What I'm trying to achieve is obtain whatever is between
parentheses as a single match, and any char outside as an individual
match. The desired result would be along the lines of:
<code_block>
 ['zyx','b','c']

<p> The order of matches should be kept.
<p> I've tried obtaining this with Python 3.3, but can't seem to
figure out the correct Regex. So far I have:
<code_block>
 matches = findall(r'\((.*?)\)|\w', '(zyx)bc')

<code> print(matches) <p>  yields the following:
<code_block>
 ['zyx','','']

<p> Any ideas what I'm doing wrong?

-------------------------------------OUTPUT-------------------------------------

                Expected= "re.findall('\\\\(.+?\\\\)|\\\\w', '(zyx)bc')"
           base:Baseline= re.findall('\\w+', '(zyx)bc')
           body:Baseline= re.findall('\\((.*?)\\)\\)', '(zyx)bc')
            body:-Blocks= re.findall('\\w+', '(zyx)bc', re.IGNORECASE)
              body:-Code= re.findall('\\w+', '(zyx)bc')
            body:-Inline= re.findall('\\((.*?)\\)', '(zyx)bc')
                body:-NL= print(re.findall('\\((.*?)\\)', '(zyx)bc')
             base:+Mined= re.findall('((\\w+)', '(zyx)bc')
     body+mined:Baseline= match = re.compile('\\((.*?)\\)', '(zyx)bc')
        body+mined:-Code= re.findall('\\((?<=.)\\)', '\\1bc', s)
          body+mined:-NL= re.findall('\\((.*?)\\)|\\w', '(zyx)bc')
      body+mined:-Blocks= re.findall('\\s+(?<=\\s)bc', '', s)
      body+mined:-Inline= match = re.findall('\\((.*?)\\)|\\w', 'zyx)bc')

================================================================================

QUESTION: idx=319    id=14182339
-------------------------------------INPUTS-------------------------------------

tags: regex, regex-alternation
score: 12
slot_map: {'key': ['str_0', 'str_1'], 'quote': ["'", "'"], 'type': ['str', 'str'], 'value': ['\\((.*?)\\)|(\\w)', '(zyx)bc']}
intent: match regex '\\((.*?)\\)|(\\w)' with string '(zyx)bc'
body(Left in tags for better readability):
<p> I ran into a small problem using Python Regex.
<p> Suppose this is the input:
<code_block>
 (zyx)bc

<p> What I'm trying to achieve is obtain whatever is between
parentheses as a single match, and any char outside as an individual
match. The desired result would be along the lines of:
<code_block>
 ['zyx','b','c']

<p> The order of matches should be kept.
<p> I've tried obtaining this with Python 3.3, but can't seem to
figure out the correct Regex. So far I have:
<code_block>
 matches = findall(r'\((.*?)\)|\w', '(zyx)bc')

<code> print(matches) <p>  yields the following:
<code_block>
 ['zyx','','']

<p> Any ideas what I'm doing wrong?

-------------------------------------OUTPUT-------------------------------------

                Expected= "re.findall('\\\\((.*?)\\\\)|(\\\\w)', '(zyx)bc')"
           base:Baseline= re.match('\\((.*?)\\)|(\\w)', 'zyx)bc')
           body:Baseline= re.findall('\\((.*?)\\)|(\\w)', '(zyx)bc')
            body:-Blocks= re.match('\\((.*?)\\)|(\\w)', '(zyx)bc')
              body:-Code= re.match('\\((.*?)\\)|(\\w)', '(zyx)bc')
            body:-Inline= match('\\((.*?)\\)|(\\w)', '(zyx)bc')
                body:-NL= match('\\((.*?)\\)|(\\w)', '(zyx)bc')
             base:+Mined= re.match('\\((.*?)\\)|(\\w)', '(zyx)bc')
     body+mined:Baseline= match = re.compile('\\((.*?)\\)|(\\w)', '(zyx)bc')
        body+mined:-Code= match = re.compile('\\((.*?)\\)|(\\w)', '(zyx)bc')
          body+mined:-NL= match = re.match('\\((.*?)\\)|(\\w)', '(zyx)bc')
      body+mined:-Blocks= re.findall('\\((.*?)\\)|(\\w)', '(zyx)bc')
      body+mined:-Inline= match = re.compile('\\((.*?)\\)|(\\w)', 'zyx)bc')

================================================================================

QUESTION: idx=320    id=14182339
-------------------------------------INPUTS-------------------------------------

tags: regex, regex-alternation
score: 12
slot_map: {'key': ['str_0', 'str_1'], 'quote': ['`', '`'], 'type': ['str', 'str'], 'value': ['|', '(zyx)bc']}
intent: match multiple regex patterns with the alternation operator `|` in a string `(zyx)bc`
body(Left in tags for better readability):
<p> I ran into a small problem using Python Regex.
<p> Suppose this is the input:
<code_block>
 (zyx)bc

<p> What I'm trying to achieve is obtain whatever is between
parentheses as a single match, and any char outside as an individual
match. The desired result would be along the lines of:
<code_block>
 ['zyx','b','c']

<p> The order of matches should be kept.
<p> I've tried obtaining this with Python 3.3, but can't seem to
figure out the correct Regex. So far I have:
<code_block>
 matches = findall(r'\((.*?)\)|\w', '(zyx)bc')

<code> print(matches) <p>  yields the following:
<code_block>
 ['zyx','','']

<p> Any ideas what I'm doing wrong?

-------------------------------------OUTPUT-------------------------------------

                Expected= "re.findall('\\\\(.*?\\\\)|\\\\w', '(zyx)bc')"
           base:Baseline= re.findall('(zyx)bc', '|')
           body:Baseline= re.findall('\\((.*?)\\)\\)', '(zyx)bc')
            body:-Blocks= re.compile('(zyx)bc', '|')
              body:-Code= re.compile('(zyx)bc)', '|')
            body:-Inline= match(re.findall('\\((.*?)\\)', '(zyx)bc))
                body:-NL= re.findall('\\((.*?)\\)', '(zyx)bc')
             base:+Mined= re.findall('(zyx)bc', '|')
     body+mined:Baseline= match = re.compile('\\((.*?)\\)|(zyx)bc')
        body+mined:-Code= re.findall('\\([^|])+|', (zyx)bc)
          body+mined:-NL= match = re.findall('\\((.*?)\\)|\\w', (zyx)bc)
      body+mined:-Blocks= re.findall('\\((\\w+)\\)', '(zyx)bc')
      body+mined:-Inline= match = re.findall('\\((.*?)\\)|\\w', (zyx)bc)

================================================================================

QUESTION: idx=321    id=7126916
-------------------------------------INPUTS-------------------------------------

tags: string, list
score: 62
slot_map: {'key': ['var_0', 'str_0'], 'quote': ['`', "'"], 'type': ['var', 'str'], 'value': ['elements', '%{0}%']}
intent: formate each string cin list `elements` into pattern '%{0}%'
body(Left in tags for better readability):
<p> I have a list of strings in Python - <code> elements <p> . I would
like to edit each <code> element <p>  in <code> elements <p> . See the
code below (it doesn't work, but you'll get the idea):
<code_block>
 for element in elements:
    element = "%" + element + "%"

<p> Is there a way to do this?

-------------------------------------OUTPUT-------------------------------------

                Expected= "elements = ['%{0}%'.format(element) for element in elements]"
           base:Baseline= print('%{0}%')
           body:Baseline= print('%{0}%'.format(elements))
            body:-Blocks= pattern = re.compile('%{0}%', elements)
              body:-Code= pattern = re.compile('%{0}%', elelements)
            body:-Inline= print('%{0}%'.join(elements))
                body:-NL= print('%{0}%'.join(elements))
             base:+Mined= print('%{0}%'.format(elements))
     body+mined:Baseline= """""".join(elements)
        body+mined:-Code= print('%{0}%'.format(elements))
          body+mined:-NL= print('%{0}%'.format(element))
      body+mined:-Blocks= print('%{0}%'.format(elements))
      body+mined:-Inline= print('%{0}%'.format(elements))

================================================================================

QUESTION: idx=322    id=3595685
-------------------------------------INPUTS-------------------------------------

tags: 
score: 5
slot_map: {'key': ['str_0', 'str_1'], 'quote': ["'", "'"], 'type': ['str', 'str'], 'value': ['background-process', 'arguments']}
intent: open a background process 'background-process' with arguments 'arguments'
body(Left in tags for better readability):
<p> My python script needs to start a background process and then
continue processing to completion without waiting for a return.
<p> The background script will process for some time and will not
generate any screen output.
<p> There is no inter-process data required.
<p> I have tried using various methods subprocess, multiprocessing but
am clearly missing something.
<p> Does anyone have a simple example?
<p> TIA

-------------------------------------OUTPUT-------------------------------------

                Expected= "subprocess.Popen(['background-process', 'arguments'])"
           base:Baseline= background - process.set_argument('Arguments')
           body:Baseline= sys.system('background-process', args=['Arguments'])
            body:-Blocks= backgroundprocess.call(['background-process', 'arguments'])
              body:-Code= backgroundProcess.call('Arguments')
            body:-Inline= backgroundprocess.call('Arguments')
                body:-NL= backgroundprocess.open('background-process', arguments='Arguments')
             base:+Mined= subprocess.call(['background-process', 'arguments'])
     body+mined:Baseline= subprocess.call(['background-process', 'arguments'])
        body+mined:-Code= p.start_process('background-process', args='arguments')
          body+mined:-NL= process.call(['background-process', 'arguments'])
      body+mined:-Blocks= subprocess.Popen('background-process', args={'arguments': Arguments})
      body+mined:-Inline= subprocess.call('background-process', shell=True)

================================================================================

QUESTION: idx=323    id=18453566
-------------------------------------INPUTS-------------------------------------

tags: list, dictionary, key
score: 210
slot_map: {'key': ['str_0', 'str_1'], 'quote': ["'", "'"], 'type': ['str', 'str'], 'value': ['mydict', 'mykeys']}
intent: get list of values from dictionary 'mydict' w.r.t. list of keys 'mykeys'
body(Left in tags for better readability):
<p> Is there a built-in/quick way to use a list of keys to a
dictionary to get a list of corresponding items?
<p> For instance I have:
<code_block>
 <console_in> mydict = {'one': 1, 'two': 2, 'three': 3}
<console_in> mykeys = ['three', 'one']
<console_out>
<p> How can I use <code> mykeys <p>  to get the corresponding values
in the dictionary as a list?
<code_block>
 <console_in> mydict.WHAT_GOES_HERE(mykeys)
<console_out> [3, 1]


-------------------------------------OUTPUT-------------------------------------

                Expected= '[mydict[x] for x in mykeys]'
           base:Baseline= [k for k, v in list(mydict.keys()) if v != 'mykeys']
           body:Baseline= dict((k, v) for k, v in list(mydict.items()))
            body:-Blocks= [item for item in list(mydict.items()) if item in item]
              body:-Code= [k for k, v in list(mydict.keys()) if v in k]
            body:-Inline= [v for k, v in list(mydict.items()) if v in mykeys]
                body:-NL= dict((k, v) for k, v in list(mydict.items()))
             base:+Mined= [key for key, value in list(mydict.items()) if 'mykeys' in value]
     body+mined:Baseline= [list(mydict.keys() for _ in range(len(mykeys))]
        body+mined:-Code= [key for key, value in list(mydict.items()) if 'mykeys' in value]
          body+mined:-NL= {k: v for k, v in list(mydict.items()) if v}
      body+mined:-Blocks= [k for k, v in list(mydict.items()) for k in mykeys]
      body+mined:-Inline= list(mydict.get(key) for key in mykeys)

================================================================================

QUESTION: idx=324    id=12692135
-------------------------------------INPUTS-------------------------------------

tags: 
score: 5
slot_map: {'key': ['str_0', '[str_0]'], 'quote': ['`', '`'], 'type': ['str', 'str'], 'value': ["[('Name', 'Joe'), ('Age', 22)]", "[('Name', 'Joe'), ('Age', 22)]"]}
intent: convert list `[('name', 'joe'), ('age', 22)]` into a dictionary
body(Left in tags for better readability):
<p> I have two lists:
<code_block>
 header = ["Name", "Age"]
detail = ["Joe", 22, "Dave", 43, "Herb", 32]

<p> And would like to create a list of dictonaries like this:
<code_block>
 [{"Name": "Joe", "Age": 22}, {"Name": "Dave", "Age": 32}, {"Name":
"Herb", "Age": 32}]

<p> This method <a> zip <p>  gets me partially there, but only adds
the first set of values to the dictionary:
<code_block>
 <console_in> dict(zip(header, detail))
<console_out> {'Age': 22, 'Name': 'Joe'}

<p> How can I output as one dictionary for all values in the <code>
detail <p>  list? I found this <a> answer <p> , but this depends on
<code> detail <p>  containing nested lists.

-------------------------------------OUTPUT-------------------------------------

                Expected= "dict([('Name', 'Joe'), ('Age', 22)])"
           base:Baseline= dict([('name', 'joe'), ('age', 22)]
           body:Baseline= dict(zip(list(name', 'Joe'), ('Age', 22)]
            body:-Blocks= dict([('name', 'joe'), ('age', 22)]
              body:-Code= dict((k, v) for k, v in ['name', 'joe'), ('age', 22)]
            body:-Inline= dict(zip(header, detail) for key, value in [('name', 'joe'), ('age', 22)]
                body:-NL= dict(zip(header, detail))
             base:+Mined= dict(zip(*('name', 'joe'), ('age', 22))
     body+mined:Baseline= dict(zip(header, detail))
        body+mined:-Code= zip([('name', 'joe'), ('age', 22)]
          body+mined:-NL= dict(zip(header, detail))
      body+mined:-Blocks= {k: v for k, v in [('name', 'joe'), ('age', 22)]}
      body+mined:-Inline= dict(zip(header, detail))

================================================================================

QUESTION: idx=325    id=14401047
-------------------------------------INPUTS-------------------------------------

tags: numpy
score: 4
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['data']}
intent: average each two columns of array `data`
body(Left in tags for better readability):
<p> Right now I am doing this by iterating, but there has to be a way
to accomplish this task using numpy functions.  My goal is to take a
2D array and average J columns at a time, producing a new array with
the same number of rows as the original, but with columns/J columns.
<p> So I want to take this:
<code_block>
 J = 2 // two columns averaged at a time

[[1 2 3 4]
 [4 3 7 1]
 [6 2 3 4]
 [3 4 4 1]]

<p> and produce this:
<code_block>
 [[1.5 3.5]
 [3.5 4.0]
 [4.0 3.5]
 [3.5 2.5]]

<p> Is there a simple way to accomplish this task?  I also need a way
such that if I never end up with an unaveraged remainder column.  So
if, for example, I have an input array with 5 columns and J=2, I would
average the first two columns, then the last three columns.
<p> Any help you can provide would be great.

-------------------------------------OUTPUT-------------------------------------

                Expected= 'data.reshape(-1, j).mean(axis=1).reshape(data.shape[0], -1)'
           base:Baseline= np.arange(data, axis=1)
           body:Baseline= np.sqrt(np.arange(data, axis=1), reverse=True)
            body:-Blocks= np.arange(data, axis=1).sum()
              body:-Code= np.arange(data, axis=2).sum()
            body:-Inline= np.arange(data, axis=2)
                body:-NL= np.sqrt(np.arange(data, axis=2), axis=1)
             base:+Mined= data.mean(axis=1)
     body+mined:Baseline= data[:, ([1, 2])]
        body+mined:-Code= data[:, (0)] = np.array([[1, 2], [3, 4]])
          body+mined:-NL= np.mean(data, axis=1)
      body+mined:-Blocks= data[:, ([1, 2], [3, 4]])
      body+mined:-Inline= data[(np.arange(len(data)) - len(data), axis=1)]

================================================================================

QUESTION: idx=326    id=18886596
-------------------------------------INPUTS-------------------------------------

tags: string, replace
score: 42
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['s']}
intent: double backslash escape all double quotes in string `s`
body(Left in tags for better readability):
<p> Given a string in python, such as:
<code_block>
 s = 'This sentence has some "quotes" in it\n'

<p> I want to create a new copy of that string with any quotes escaped
(for further use in Javascript). So, for example, what I want is to
produce this:
<code_block>
 'This sentence has some \"quotes\" in it\n'

<p> I tried using <code> replace() <p> , such as:
<code_block>
 s.replace('"', '\"')

<p> but that returns the same string. So then I tried this:
<code_block>
 s.replace('"', '\\"')

<p> but that returns double-escaped quotes, such as:
<code_block>
 'This sentence has some \\"quotes\\" in it.\n'

<p> How to replace <code> " <p>  with <code> \" <p> ?
<p> UPDATE:
<p> I need as output from this copyable text that shows both the
quotes and the newlines as escaped.  In other words, I want to be able
to copy:
<code_block>
 'This sentence has some \"quotes\" in it.\n'

<p> If I use the raw string and <code> print <p>  the result I get the
correctly escaped quote, but the escaped newline doesn't print. If I
don't use <code> print <p>  then I get my newlines but double-escaped
quotes. How can I create a string I can copy that shows both newline
and quote escaped?

-------------------------------------OUTPUT-------------------------------------

                Expected= 'print(s.encode(\'unicode-escape\').replace(\'"\', \'\\\\"\'))'
           base:Baseline= re.sub('\\w+', s)
           body:Baseline= re.sub('\\"\\n', s)
            body:-Blocks= re.sub('(\\w+)', '', s)
              body:-Code= re.compile('\\w+\\s+', s)
            body:-Inline= re.sub('\\n\\s\\n', s)
                body:-NL= re.sub('\\n', s)
             base:+Mined= re.sub('\\s+', '', s)
     body+mined:Baseline= """This sentence has some "quotes" in it\\n"""
        body+mined:-Code= print(re.sub('[^"]*', '', s))
          body+mined:-NL= s.replace('"', '\\"')
      body+mined:-Blocks= re.sub('\\(\\w+)', '', s)
      body+mined:-Inline= """This sentence has some "quotes" in it""".replace('"', '"')

================================================================================

QUESTION: idx=327    id=5932059
-------------------------------------INPUTS-------------------------------------

tags: regex, split, whitespace
score: 11
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: split a string into a list of words and whitespace
body(Left in tags for better readability):
<p> I need to split a string into an array on word boundaries
(whitespace) while maintaining the whitespace.
<p> For example:
<code_block>
 'this is  a\nsentence'

<p> Would become
<code_block>
 ['this', ' ', 'is', '  ', 'a' '\n', 'sentence']

<p> I know about <a> str.partition <p>  and <a> re.split <p> , but
neither of them quite do what I want and there is no <code>
re.partition <p> .
<p> How should I partition strings on whitespace in Python with
reasonable efficiency?

-------------------------------------OUTPUT-------------------------------------

                Expected= "re.split('(\\\\W+)', s)"
           base:Baseline= """{0:.2f}""".format(map(int, x))
           body:Baseline= re.findall('\\n', '\\n')
            body:-Blocks= re.split('\\w+', '', str)
              body:-Code= re.split('\\w+', '', str)
            body:-Inline= re.split('\\n', '\\n')
                body:-NL= re.split('\\n', """This is  a
sentence""")
             base:+Mined= [word.split() for word in s.split(',')]
     body+mined:Baseline= ['this', '', 'is', ' ', 'a\n', 'sentence']
        body+mined:-Code= ['a', 'b', 'c', 'd', 'e', 'f']
          body+mined:-NL= re.findall('\\n', s)
      body+mined:-Blocks= """ """.join(['a', 'b', 'c', 'd'])
      body+mined:-Inline= ['this', '', 'is', ' ', 'a', '\n', 'sentence']

================================================================================

QUESTION: idx=328    id=9938130
-------------------------------------INPUTS-------------------------------------

tags: pandas
score: 5
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: plotting stacked barplots on a panda data frame
body(Left in tags for better readability):
<p> This is my first attempt at playing with Pandas library after
attending Wesley's tutorial at pycon.
<p> After poking around a bit with the dataframe I am glad I was able
to massage the data in the way I wanted but having trouble in plotting
it. I guess it also points to my naiveness with the matplotlib
library.
<p> What I have is pandas Series object with the following data. I
would like to plot as a barplot with col 1 ('file') as the labels
oriented vertically.
<code_block>
 sample data here:
http://pastebin.com/y2w0uJPQ


-------------------------------------OUTPUT-------------------------------------

                Expected= "df.plot(kind='barh', stacked=True)"
           base:Baseline= pd.concat([x, y], axis=1)
           body:Baseline= pandas.set_to_barplot('', 1)
            body:-Blocks= pandas.set_barplots('barplot', cols=1)
              body:-Code= df.set_barplots('file')
            body:-Inline= pandas.set_barplots()
                body:-NL= df = panda.plot(df, axis=1)
             base:+Mined= df.plot(kind='bar')
     body+mined:Baseline= df.plot(x, y, 'file')
        body+mined:-Code= df.plot(kind='bar', stacked=True)
          body+mined:-NL= df.groupby('col').size().plot(kind='bar')
      body+mined:-Blocks= ax.set_xticklabels([])
      body+mined:-Inline= df.set_index('file')

================================================================================

QUESTION: idx=329    id=35945473
-------------------------------------INPUTS-------------------------------------

tags: dictionary
score: 17
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['myDictionary']}
intent: reverse the keys and values in a dictionary `mydictionary`
body(Left in tags for better readability):
<p> I would like to write a function that receives a dictionary as
input argument and returns a reverse of the input dictionary where the
values of the original dictionary are used as keys for the returned
dictionary and the keys of the original dictionary are used as value
for the returned dictionary as explained below:
<code_block>
 dict = {'Accurate': ['exact', 'precise'],
        'exact': ['precise'],
        'astute': ['Smart', 'clever'],
        'smart': ['clever', 'bright', 'talented']}

<p> to
<code_block>
 dict = {'precise': ['accurate', 'exact'],
        'clever': ['astute', 'smart'],
        'talented': ['smart'],
        'bright': ['smart'],
        'exact': ['accurate'],
        'smart': ['astute']}

<p> The list of values in the returned dictionary should be sorted in
ascending order.  Capitalization does not matter. This means that all
the words should be converted to lower case letters. For example the
word "Accurate" is capitalized in the original dictionary but in the
returned dictionary it is written with all lower case letters.
<code_block>
 #My code is:
from collections import defaultdict
def reverse_dictionary(input_dict):
   d = defaultdict(list)
   for v,k in input_dict.items():
       d[k].append(v)
       return d

<p> But it returns this error though:
<code_block>
 Error in evaluating function:
TypeError at line 6
unhashable type: 'list'


-------------------------------------OUTPUT-------------------------------------

                Expected= '{i[1]: i[0] for i in list(myDictionary.items())}'
           base:Baseline= dict((k, v) for k, v in myDictionary.items())
           body:Baseline= dict((k, v) for k, v in list(mydictionary.items()))
            body:-Blocks= dict((k, v) for k, v in list(mydictionary.items()))
              body:-Code= dict((k, v) for k, v in list(myDictionary.items()))
            body:-Inline= dict((k, v) for k, v in mydictionary.items())
                body:-NL= dict((k, v) for k, v in mydictionary.items())
             base:+Mined= dict((k, v) for k, v in myDict.items())
     body+mined:Baseline= dict((v, k) for v, k in list(mydictionary.items()))
        body+mined:-Code= dict((k, v) for k, v in myDict.items())
          body+mined:-NL= {k: v for k, v in list(d.items()) for d in v}
      body+mined:-Blocks= dict((k, v) for k, v in list(mydictionary.items()))
      body+mined:-Inline= {k: v for k, v in list(mydictionary.items()) if v}

================================================================================

QUESTION: idx=330    id=30729735
-------------------------------------INPUTS-------------------------------------

tags: string, list
score: 6
slot_map: {'key': ['str_0', 'str_1', 'str_2'], 'quote': ["'", "'", "'"], 'type': ['str', 'str', 'str'], 'value': ['how', 'what', 'myList']}
intent: finding the index of elements containing substring 'how' and 'what' in a list of strings 'mylist'.
body(Left in tags for better readability):
<p> I have a list
<code_block>
 myList = ["what is your name", "Hi, how are you",
          "What about you", "How about a coffee", "How are you"]

<p> Now I want to search index of all occurrence of <code> "How" <p>
and <code> "what" <p> . How can I do this in Pythonic way?

-------------------------------------OUTPUT-------------------------------------

                Expected= "[i for i, j in enumerate(myList) if 'how' in j.lower() or 'what' in j.lower()]"
           base:Baseline= mylist.index(['how', 'what'], key=lambda x: x[1])
           body:Baseline= [i for i, j in enumerate(myList, 'How', 'What']) if i not in j]
            body:-Blocks= mylist.index(key=lambda x: x['how'], x['what']))
              body:-Code= mylist.index('how', 'what')
            body:-Inline= myList.index('how', 'what')
                body:-NL= myList.index('how', 'what')
             base:+Mined= [i for i in myList if 'how' in i]
     body+mined:Baseline= [x for x in myList if x.startswith('How')]
        body+mined:-Code= [x for x in myList if 'how' and 'what' in x]
          body+mined:-NL= [i for i, j in enumerate(myList) if j == 'How']
      body+mined:-Blocks= [x for x in mylist if 'How' in x]
      body+mined:-Inline= [x for x in myList if 'how' in x]

================================================================================

QUESTION: idx=331    id=1303243
-------------------------------------INPUTS-------------------------------------

tags: string, types, compatibility
score: 433
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['obj']}
intent: check if object `obj` is a string
body(Left in tags for better readability):
<p> How can I check if a Python object is a string (either regular or
Unicode)?

-------------------------------------OUTPUT-------------------------------------

                Expected= 'isinstance(obj, str)'
           base:Baseline= if obj == string:
    pass
           body:Baseline= if obj.isString():
    pass
            body:-Blocks= isinstance(obj, 'a')
              body:-Code= print(obj.__string__))
            body:-Inline= if (obj.isString())):
    pass
                body:-NL= if (obj.isString())):
    pass
             base:+Mined= obj.isalpha().isalpha()
     body+mined:Baseline= isinstance(obj, 'string')
        body+mined:-Code= isinstance(obj, 'a')
          body+mined:-NL= if obj.isalpha()):
    pass
      body+mined:-Blocks= obj.str.isdigit()
      body+mined:-Inline= isinstance(obj, 'unicode_escape')

================================================================================

QUESTION: idx=332    id=1303243
-------------------------------------INPUTS-------------------------------------

tags: string, types, compatibility
score: 433
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['o']}
intent: check if object `o` is a string
body(Left in tags for better readability):
<p> How can I check if a Python object is a string (either regular or
Unicode)?

-------------------------------------OUTPUT-------------------------------------

                Expected= 'isinstance(o, str)'
           base:Baseline= if not 'o':
    pass
           body:Baseline= if (o not a string):
    pass
            body:-Blocks= if (o =='string':
    pass
              body:-Code= if (not a string):
    pass
            body:-Inline= if not 'o':
    pass
                body:-NL= if o.isdigit():
    pass
             base:+Mined= isinstance(o, 'string')
     body+mined:Baseline= if o.isdigit():
    pass
        body+mined:-Code= isinstance(o, 'a')
          body+mined:-NL= if o.isdigit():
    pass
      body+mined:-Blocks= if o.isalpha():
    pass
      body+mined:-Inline= isinstance(o, 'unicode_escape')

================================================================================

QUESTION: idx=333    id=1303243
-------------------------------------INPUTS-------------------------------------

tags: string, types, compatibility
score: 433
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['o']}
intent: check if object `o` is a string
body(Left in tags for better readability):
<p> How can I check if a Python object is a string (either regular or
Unicode)?

-------------------------------------OUTPUT-------------------------------------

                Expected= 'type(o) is str'
           base:Baseline= if not 'o':
    pass
           body:Baseline= if (o not a string):
    pass
            body:-Blocks= if (o =='string':
    pass
              body:-Code= if (not a string):
    pass
            body:-Inline= if not 'o':
    pass
                body:-NL= if o.isdigit():
    pass
             base:+Mined= isinstance(o, 'string')
     body+mined:Baseline= if o.isdigit():
    pass
        body+mined:-Code= isinstance(o, 'a')
          body+mined:-NL= if o.isdigit():
    pass
      body+mined:-Blocks= if o.isalpha():
    pass
      body+mined:-Inline= isinstance(o, 'unicode_escape')

================================================================================

QUESTION: idx=334    id=1303243
-------------------------------------INPUTS-------------------------------------

tags: string, types, compatibility
score: 433
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['o']}
intent: check if object `o` is a string
body(Left in tags for better readability):
<p> How can I check if a Python object is a string (either regular or
Unicode)?

-------------------------------------OUTPUT-------------------------------------

                Expected= 'isinstance(o, str)'
           base:Baseline= if not 'o':
    pass
           body:Baseline= if (o not a string):
    pass
            body:-Blocks= if (o =='string':
    pass
              body:-Code= if (not a string):
    pass
            body:-Inline= if not 'o':
    pass
                body:-NL= if o.isdigit():
    pass
             base:+Mined= isinstance(o, 'string')
     body+mined:Baseline= if o.isdigit():
    pass
        body+mined:-Code= isinstance(o, 'a')
          body+mined:-NL= if o.isdigit():
    pass
      body+mined:-Blocks= if o.isalpha():
    pass
      body+mined:-Inline= isinstance(o, 'unicode_escape')

================================================================================

QUESTION: idx=335    id=1303243
-------------------------------------INPUTS-------------------------------------

tags: string, types, compatibility
score: 433
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['obj_to_test']}
intent: check if `obj_to_test` is a string
body(Left in tags for better readability):
<p> How can I check if a Python object is a string (either regular or
Unicode)?

-------------------------------------OUTPUT-------------------------------------

                Expected= 'isinstance(obj_to_test, str)'
           base:Baseline= if obj_to_test == string:
    pass
           body:Baseline= if obj_to_test.isString():
    pass
            body:-Blocks= if obj_to_test:
    pass
              body:-Code= if obj_to_test:
    pass
            body:-Inline= obj_to_test.is_string()
                body:-NL= if obj_to_test == string:
    pass
             base:+Mined= isinstance(obj_to_test, bool)
     body+mined:Baseline= obj_to_test.isdigit()
        body+mined:-Code= obj_to_test.isdigit()
          body+mined:-NL= obj_to_test.isdigit()
      body+mined:-Blocks= obj_to_test.isdigit()
      body+mined:-Inline= obj_to_test.isdigit()

================================================================================

QUESTION: idx=336    id=8177079
-------------------------------------INPUTS-------------------------------------

tags: list
score: 215
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['list1', 'list2']}
intent: append list `list1` to `list2`
body(Left in tags for better readability):
<p> I am trying to understand if it makes sense to take the content of
a list and append it to another list.
<p> I have the first list created through a loop function, that will
get specific lines out of a file and will save them in a list.
<p> Then a second list is used to save these lines, and start a new
cycle over another file.
<p> My idea was to get the list once that the for cycle is done, dump
it into the second list, then start a new cycle, dump the content of
the first list again into the second but appending it, so the second
list will be the sum of all the smaller list files created in my loop.
The list has to be appended only if certain conditions met.
<p> It looks like something similar to this:
<code_block>
 # This is done for each log in my directory, i have a loop running
for logs in mydir:

    for line in mylog:
        #...if the conditions are met
        list1.append(line)

    for item in list1:
        if "string" in item: #if somewhere in the list1 i have a match
for a string
            list2.append(list1) # append every line in list1 to list2
            del list1 [:] # delete the content of the list1
            break
        else:
            del list1 [:] # delete the list content and start all over

<p> Does this makes sense or should I go for a different route?
<p> I need something efficient that would not take up too many cycles,
since the list of logs is long and each text file is pretty big; so I
thought that the lists would fit the purpose.

-------------------------------------OUTPUT-------------------------------------

                Expected= 'list2.extend(list1)'
           base:Baseline= list2 = [x for x in zip(list1, list2)]
           body:Baseline= list1.append(list1, list2)
            body:-Blocks= list2 = [i for i in list1]
              body:-Code= list1 = list2.append(list1)
            body:-Inline= list1.append(list2)
                body:-NL= list1.append(list1, list2)
             base:+Mined= list2.append(list1, list2)
     body+mined:Baseline= list1.append(list2)
        body+mined:-Code= list2.append(list1)
          body+mined:-NL= list1.append(list1)
      body+mined:-Blocks= list2.append(list1, list2)
      body+mined:-Inline= list2.append(list1)

================================================================================

QUESTION: idx=337    id=8177079
-------------------------------------INPUTS-------------------------------------

tags: list
score: 215
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['mylog', 'list1']}
intent: append list `mylog` to `list1`
body(Left in tags for better readability):
<p> I am trying to understand if it makes sense to take the content of
a list and append it to another list.
<p> I have the first list created through a loop function, that will
get specific lines out of a file and will save them in a list.
<p> Then a second list is used to save these lines, and start a new
cycle over another file.
<p> My idea was to get the list once that the for cycle is done, dump
it into the second list, then start a new cycle, dump the content of
the first list again into the second but appending it, so the second
list will be the sum of all the smaller list files created in my loop.
The list has to be appended only if certain conditions met.
<p> It looks like something similar to this:
<code_block>
 # This is done for each log in my directory, i have a loop running
for logs in mydir:

    for line in mylog:
        #...if the conditions are met
        list1.append(line)

    for item in list1:
        if "string" in item: #if somewhere in the list1 i have a match
for a string
            list2.append(list1) # append every line in list1 to list2
            del list1 [:] # delete the content of the list1
            break
        else:
            del list1 [:] # delete the list content and start all over

<p> Does this makes sense or should I go for a different route?
<p> I need something efficient that would not take up too many cycles,
since the list of logs is long and each text file is pretty big; so I
thought that the lists would fit the purpose.

-------------------------------------OUTPUT-------------------------------------

                Expected= 'list1.extend(mylog)'
           base:Baseline= list1 = [item for item in mylog]
           body:Baseline= list1.append(mylog)
            body:-Blocks= list1.append(mylog)
              body:-Code= list1.append(mylog)
            body:-Inline= list1.append(mylog)
                body:-NL= list1.append(mylog)
             base:+Mined= list1.append(mylog)
     body+mined:Baseline= list1.append(mylog)
        body+mined:-Code= list1.append(mylog)
          body+mined:-NL= list1.append(mylog)
      body+mined:-Blocks= list1.append(mylog)
      body+mined:-Inline= list1 = [line for line in mylog if 'string' in line]

================================================================================

QUESTION: idx=338    id=8177079
-------------------------------------INPUTS-------------------------------------

tags: list
score: 215
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['a', 'c']}
intent: append list `a` to `c`
body(Left in tags for better readability):
<p> I am trying to understand if it makes sense to take the content of
a list and append it to another list.
<p> I have the first list created through a loop function, that will
get specific lines out of a file and will save them in a list.
<p> Then a second list is used to save these lines, and start a new
cycle over another file.
<p> My idea was to get the list once that the for cycle is done, dump
it into the second list, then start a new cycle, dump the content of
the first list again into the second but appending it, so the second
list will be the sum of all the smaller list files created in my loop.
The list has to be appended only if certain conditions met.
<p> It looks like something similar to this:
<code_block>
 # This is done for each log in my directory, i have a loop running
for logs in mydir:

    for line in mylog:
        #...if the conditions are met
        list1.append(line)

    for item in list1:
        if "string" in item: #if somewhere in the list1 i have a match
for a string
            list2.append(list1) # append every line in list1 to list2
            del list1 [:] # delete the content of the list1
            break
        else:
            del list1 [:] # delete the list content and start all over

<p> Does this makes sense or should I go for a different route?
<p> I need something efficient that would not take up too many cycles,
since the list of logs is long and each text file is pretty big; so I
thought that the lists would fit the purpose.

-------------------------------------OUTPUT-------------------------------------

                Expected= 'c.extend(a)'
           base:Baseline= c = [a[i] for i in c]
           body:Baseline= c = [a[:] for a in c]
            body:-Blocks= c = [a[i] for i in c]
              body:-Code= c = [a.append(c))
            body:-Inline= c = [a[:] for a in c]
                body:-NL= c = list(a.append(c))
             base:+Mined= c = c.append(a)
     body+mined:Baseline= list(a) + list(c)
        body+mined:-Code= c = [i for i in a]
          body+mined:-NL= list1.append(a, c)
      body+mined:-Blocks= c.append(a, c)
      body+mined:-Inline= c = [i for i in a if 'string' in i]

================================================================================

QUESTION: idx=339    id=8177079
-------------------------------------INPUTS-------------------------------------

tags: list
score: 215
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['mylog', 'list1']}
intent: append items in list `mylog` to `list1`
body(Left in tags for better readability):
<p> I am trying to understand if it makes sense to take the content of
a list and append it to another list.
<p> I have the first list created through a loop function, that will
get specific lines out of a file and will save them in a list.
<p> Then a second list is used to save these lines, and start a new
cycle over another file.
<p> My idea was to get the list once that the for cycle is done, dump
it into the second list, then start a new cycle, dump the content of
the first list again into the second but appending it, so the second
list will be the sum of all the smaller list files created in my loop.
The list has to be appended only if certain conditions met.
<p> It looks like something similar to this:
<code_block>
 # This is done for each log in my directory, i have a loop running
for logs in mydir:

    for line in mylog:
        #...if the conditions are met
        list1.append(line)

    for item in list1:
        if "string" in item: #if somewhere in the list1 i have a match
for a string
            list2.append(list1) # append every line in list1 to list2
            del list1 [:] # delete the content of the list1
            break
        else:
            del list1 [:] # delete the list content and start all over

<p> Does this makes sense or should I go for a different route?
<p> I need something efficient that would not take up too many cycles,
since the list of logs is long and each text file is pretty big; so I
thought that the lists would fit the purpose.

-------------------------------------OUTPUT-------------------------------------

                Expected= 'for line in mylog:\n    list1.append(line)'
           base:Baseline= list1 = [item for item in mylog]
           body:Baseline= list1 = [i for i in mylog]
            body:-Blocks= list1 = [item for item in mylog]
              body:-Code= list1 = [item for item in mylog]
            body:-Inline= list1 = list1.append(line)
                body:-NL= list1 = [item for item in mylog]
             base:+Mined= list1 = [item for item in mylog]
     body+mined:Baseline= list1 = [line for line in mylog if 'string' in line]
        body+mined:-Code= list1 = [i for i in mylog]
          body+mined:-NL= list1 = [line for line in mylog if 'string' in line]
      body+mined:-Blocks= list1.append(myLog)
      body+mined:-Inline= list1 = [line for line in mylog if 'string' in line]

================================================================================

QUESTION: idx=340    id=4126227
-------------------------------------INPUTS-------------------------------------

tags: list, tuples
score: 5
slot_map: {'key': ['var_0', 'str_0', 'var_1', '[str_0]'], 'quote': ['`', "'", '`', "'"], 'type': ['var', 'str', 'var', 'str'], 'value': ['a', '[0][0] [0][2]', 'b', '[0][0] [0][2]']}
intent: append a tuple of elements from list `a` with indexes '[0][0] [0][2]' to list `b`
body(Left in tags for better readability):
<p> What's the proper syntax for adding a recomposed tuple to a list?
<p> For example, if I had two lists:
<code_block>
 <console_in> a = [(1,2,3),(4,5,6)]
<console_in> b = [(0,0)]
<console_out>
<p> Then I would expect the following to work:
<code_block>
 <console_in> b.append((a[0][0],a[0,2]))
<console_out> Traceback (most recent call last):
  File " <stdin>", line 1, in <module>
TypeError: list indices must be integers, not tuple

<p> Furthermore, when it informs me that indices must be integers, how
come this works?
<code_block>
 <console_in> b.append((7,7))
<console_in> b
<console_out> [(0, 0), (7, 7)]


-------------------------------------OUTPUT-------------------------------------

                Expected= 'b.append((a[0][0], a[0][2]))'
           base:Baseline= b = [[0][0][0][2]]
           body:Baseline= b = [(a[0][0], (0, 2])
            body:-Blocks= b = [(i, j) for i, j in zip(a, b)]
              body:-Code= b = [(i, j) for i, j in [(0][0] [0][2]]
            body:-Inline= b = [(a[0][0] [0][2])
                body:-NL= b = [(a[0][0] [0][2])
             base:+Mined= b = [i[0] for i in range(0, len(a), 2)]
     body+mined:Baseline= b = [(0, 0], (7, 7)]
        body+mined:-Code= b = [(i + j) for i, j in zip(a, b)]
          body+mined:-NL= b = [(x[0] for x in a]
      body+mined:-Blocks= b = [(i + j) for i, j in zip(a, b)]
      body+mined:-Inline= b.append((a[0][0], b[0]), (7, 7))

================================================================================

QUESTION: idx=341    id=34902378
-------------------------------------INPUTS-------------------------------------

tags: flask
score: 71
slot_map: {'key': ['var_0', 'str_0'], 'quote': ['`', '`'], 'type': ['var', 'str'], 'value': ['SECRET_KEY', 'Your_secret_string']}
intent: initialize `secret_key` in flask config with `your_secret_string `
body(Left in tags for better readability):
<p> I am trying to set up Flask-Debugtoolbar, but I get the message
"DebugToolBar requires a SECRET_KEY".  Where do I get the secret key?

-------------------------------------OUTPUT-------------------------------------

                Expected= "app.config['SECRET_KEY'] = 'Your_secret_string'"
           base:Baseline= config.initialize('secret_key')
           body:Baseline= your_secret_string = config.get('SECRET_KEY')
            body:-Blocks= your_secret_key = auth.SECRET_KEY
              body:-Code= your_secret_string = Flask.config('DebugToolBar requires a SECRET_KEY')
            body:-Inline= your_secret_string = 'SECRET_KEY'
                body:-NL= your_secret_string = config.initialize('secret_key')
             base:+Mined= app.config['secret_key'] = 'your_secret_string'
     body+mined:Baseline= app.run(debug=True)
        body+mined:-Code= app.run(debug=True)
          body+mined:-NL= app.run(debug=True)
      body+mined:-Blocks= app.config['SECRET_KEY']
      body+mined:-Inline= app.run(debug=True)

================================================================================

QUESTION: idx=342    id=22799300
-------------------------------------INPUTS-------------------------------------

tags: pandas
score: 36
slot_map: {'key': ['str_0', 'str_1'], 'quote': ["'", "'"], 'type': ['str', 'str'], 'value': ['out-1', 'out-2']}
intent: unpack a series of tuples in pandas into a dataframe with column names 'out-1' and 'out-2'
body(Left in tags for better readability):
<p> Sometimes I end up with a series of tuples/lists when using
Pandas. This is common when, for example, doing a group-by and passing
a function that has multiple return values:
<code_block>
 import numpy as np
from scipy import stats
df = pd.DataFrame(dict(x=np.random.randn(100),
                       y=np.repeat(list("abcd"), 25)))
out = df.groupby("y").x.apply(stats.ttest_1samp, 0)
print out

y
a       (1.3066417476, 0.203717485506)
b    (0.0801133382517, 0.936811414675)
c      (1.55784329113, 0.132360504653)
d     (0.267999459642, 0.790989680709)
dtype: object

<p> What is the correct way to "unpack" this structure so that I get a
DataFrame with two columns?
<p> A related question is how I can unpack either this structure or
the resulting dataframe into two Series/array objects. This almost
works:
<code_block>
 t, p = zip(*out)

<p> but it <code> t <p>  is
<code_block>
  (array(1.3066417475999257),
 array(0.08011333825171714),
 array(1.557843291126335),
 array(0.267999459641651))

<p> and one needs to take the extra step of squeezing it.

-------------------------------------OUTPUT-------------------------------------

                Expected= "pd.DataFrame(out.tolist(), columns=['out-1', 'out-2'], index=out.index)"
           base:Baseline= df.groupby(['out-1', 'out-2'])
           body:Baseline= df = pd.groupby('n').apply(list('out-1', 'out-2'))
            body:-Blocks= pd.concat([['out-1', 'out-2']], axis=1)
              body:-Code= pd.concat([['out-1', 'out-2'])
            body:-Inline= pd.DataFrame(['out-1', 'out-2'])
                body:-NL= df.groupby('y').apply(list('out-1', 'out-2')
             base:+Mined= pd.concat([df['Out-1', 'Out-2']], axis=1)
     body+mined:Baseline= df.groupby('y').apply(stats.ttest_1samp, 0)
        body+mined:-Code= pd.concat([df1, df2], axis=1)
          body+mined:-NL= df.groupby('stats').apply(stats.ttest_1samp, 0)
      body+mined:-Blocks= pd.concat([df1, df2], axis=1)
      body+mined:-Inline= df.groupby('y').apply(stats.ttest_1samp, 0)

================================================================================

QUESTION: idx=343    id=1762484
-------------------------------------INPUTS-------------------------------------

tags: list
score: 20
slot_map: {'key': ['str_0', 'var_0'], 'quote': ["'", '`'], 'type': ['str', 'var'], 'value': ['MSFT', 'stocks_list']}
intent: find the index of an element 'msft' in a list `stocks_list`
body(Left in tags for better readability):
<code_block>
 for s in stocks_list:
    print s

<p> how do I know what "position" s is in? So that I can do <strong>
stocks_list[4] <p>  in the future?

-------------------------------------OUTPUT-------------------------------------

                Expected= "[x for x in range(len(stocks_list)) if stocks_list[x] == 'MSFT']"
           base:Baseline= [x['msft'] for x instocks_list]
           body:Baseline= print(s.index('msft') for s in stocks_list))
            body:-Blocks= stock_list.index('msft')
              body:-Code= stock_list.index('msft')
            body:-Inline= print(stock_list.index('msft') for i in stocks_list))
                body:-NL= print('msft'.index(stocks_list))
             base:+Mined= [index for index instocks_list if'msft' in index]
     body+mined:Baseline= stocks_list[i:i + 1]
        body+mined:-Code= stock_list.index('msft')
          body+mined:-NL= print(s[i:i + 1] for i in stocks_list))
      body+mined:-Blocks= sorted(stocks_list, key=itemgetter('msft'))
      body+mined:-Inline= print(s[i:i + 1] for i in stocks_list))

================================================================================

QUESTION: idx=344    id=3464359
-------------------------------------INPUTS-------------------------------------

tags: django, matlab, matplotlib
score: 6
slot_map: {'key': ['var_0', 'str_0'], 'quote': ['`', '`'], 'type': ['var', 'str'], 'value': ['ax', '45']}
intent: rotate the xtick labels of matplotlib plot `ax` by `45` degrees to make long labels readable
body(Left in tags for better readability):
<p> Anyone know if it is possible to wrap the xtick labels in
matplotlib? Right now I've got the following code (kind of messy --
been hacking at it for a while):
<code_block>
 def plotResults(request, question_id):
 responses = ResponseOption.objects.filter(question__id=question_id).o
rder_by('order').annotate(response_num=Count('response'))

 counts = []
 labels = []

 for response in responses:
  counts.append(response.response_num)
  labels.append(smart_truncate('$'+response.text+'$'))

 N = len(labels)
 labels = tuple(labels)
 counts = tuple(counts)
 ind = na.array(range(N))+0.5
 width = .35
 fig = Figure(facecolor='white',edgecolor='white')
 ax = fig.add_subplot(1,1,1)

 rects1 = ax.bar(ind, counts,linewidth=0)

 ax.set_ylabel('$Count$')

 ax.set_title('$Response Historgram$')
 ax.set_xticks(ind+width)
 ax.set_xticklabels(labels)

 print mpl.matplotlib_fname()

 canvas = FigureCanvas(fig)
 response = HttpResponse(content_type='image/png')

 canvas.print_png(response)

 return response

<p> That generates this plot:

<p> As you can see the xticks are boned. Any ideas on how to wrap
them, or baring that make them readable? Thanks again!
<p> PS: This is part of a Django project. I return the plot as a png
image -- normally call them from img tags in various views.

-------------------------------------OUTPUT-------------------------------------

                Expected= 'ax.set_xticklabels(labels, rotation=45)'
           base:Baseline= ax.set_xticklabels(45)
           body:Baseline= ax.set_xticklabels(45)
            body:-Blocks= ax.set_xtick_labels(45)
              body:-Code= ax.set_xticklabels('45')
            body:-Inline= ax.set_xticklabels(length=45)
                body:-NL= ax.set_xticklabels(labels)
             base:+Mined= ax.set_xticklabels(45)
     body+mined:Baseline= ax.set_xticklabels(labels)
        body+mined:-Code= ax.set_xticklabels(45)
          body+mined:-NL= ax.set_xticklabels(labels)
      body+mined:-Blocks= ax.set_xticklabels(45)
      body+mined:-Inline= ax.set_xticklabels(labels)

================================================================================

QUESTION: idx=345    id=875968
-------------------------------------INPUTS-------------------------------------

tags: regex, string
score: 83
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['s']}
intent: remove symbols from a string `s`
body(Left in tags for better readability):
<p> I'm a beginner with both Python and RegEx, and I would like to
know how to make a string that takes symbols and replaces them with
spaces. Any help is great.
<p> For example:
<code_block>
 how much for the maple syrup? $20.99? That's ricidulous!!!

<p> into:
<code_block>
 how much for the maple syrup 20 99 That s ridiculous


-------------------------------------OUTPUT-------------------------------------

                Expected= "re.sub('[^\\\\w]', '', s)"
           base:Baseline= s = re.sub('\\d+', '', s)
           body:Baseline= s = s.replace('\\w', '')
            body:-Blocks= s = re.sub('\\w+', '', s)
              body:-Code= s = re.sub('\\d+', '', s)
            body:-Inline= s = s.replace('', '')
                body:-NL= s = s.split()[::-1]
             base:+Mined= s = s.replace(',', '')
     body+mined:Baseline= s = s.replace('\\s', '')
        body+mined:-Code= s = re.sub('\\s+', '', s)
          body+mined:-NL= s = s.replace(' ', '')
      body+mined:-Blocks= re.sub('\\s+', '', s)
      body+mined:-Inline= s = re.sub('(?<=.)(?=.)', '', s)

================================================================================

QUESTION: idx=346    id=31258561
-------------------------------------INPUTS-------------------------------------

tags: file, getcwd
score: 36
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: get the current directory of a script
body(Left in tags for better readability):
<p> I know I can use this to get the full file path
<code_block>
 os.path.dirname(os.path.realpath(__file__))

<p> But I want just the name of the folder, my scrip is in. SO if I
have my_script.py and it is located at
<code_block>
 /home/user/test/my_script.py

<p> I want to return "test" How could I do this?
<p> Thanks

-------------------------------------OUTPUT-------------------------------------

                Expected= 'os.path.basename(os.path.dirname(os.path.realpath(__file__)))'
           base:Baseline= os.chdir(os.path.realpath(__file__))
           body:Baseline= os.path.dirname(os.Path.realpath(__file__))
            body:-Blocks= os.path.dirname(__file__)
              body:-Code= os.path.realpath(__file__)
            body:-Inline= os.path.dirname(__file__))
                body:-NL= os.path.dirname(os.Path.realpath(__file__))
             base:+Mined= os.chdir(os.path.dirname(__file__))
     body+mined:Baseline= os.path.dirname(os.file.realpath(__file__))
        body+mined:-Code= os.path.abspath(__file__)
          body+mined:-NL= os.chdir(os.path.dirname(__file__))
      body+mined:-Blocks= os.path.abspath(__file__)
      body+mined:-Inline= os.path.realpath(__file__)

================================================================================

QUESTION: idx=347    id=34750084
-------------------------------------INPUTS-------------------------------------

tags: regex, string, octal
score: 4
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['str']}
intent: find octal characters matches from a string `str` using regex
body(Left in tags for better readability):
<p> I'm attempting to write a regex that captures octal characters.
<p> For example, if the line I'm comparing to my regex is:
<code_block>
 char x = '\077';

<p> I want my regex to capture <code> '\077'
<p> I attempted to do this via the re module and a regex of the form:
<code_block>
 "'\\[0-7]{1-3}'"

<p> But this doesn't capture the octal character.  How can octal
characters be identified using regex in Python?
<p> Edit:
<p> As an example of what I mean, consider the C code:
<code_block>
 char x = '\077';
printf("%c", x);

<p> I would like to capture <code> '\077' <p>  from the first line.
<p> Edit:
<p> After testing some of the suggestions in this thread, I have a
case that works.  I realize that after adding the octal regex to a
larger regex, I needed to prefix with r for raw input, or escape each
backslash, for a total of four backslashes.
<p> For example, both of these solve the problem:
<code_block>
 regex = re.compile(r"\s*("
                        r"'\\0[0-7]{1,2}'"          # octal
                        "|[a-zA-Z_][a-zA-Z_\d]*"    # identifer
                        ")")
regex.findall(line)

<p> and
<code_block>
 regex = re.compile(r"\s*("
                        "'\\\\0[0-7]{1,2}'"         # octal
                        "|[a-zA-Z_][a-zA-Z_\d]*"    # identifer
                        ")")
regex.findall(line)

<p> Which will produce <code> '\077' <p>  if line is: <code> char =
'\077';
<p> Thanks for the help everyone.

-------------------------------------OUTPUT-------------------------------------

                Expected= 'print(re.findall("\'\\\\\\\\[0-7]{1,3}\'", str))'
           base:Baseline= re.findall('\\w+', str)
           body:Baseline= re.compile('\\[0-7]{1-3}', str)
            body:-Blocks= re.findall('\\077', str)
              body:-Code= re.findall('\\w+', str)
            body:-Inline= re.compile('\\[0-7]{1,2}')
                body:-NL= re.findall('\\[0-7]{1,2}', str)
             base:+Mined= re.findall('[a-zA-Z]', str)
     body+mined:Baseline= regex = re.compile('\\[0-7]{1-3}')
        body+mined:-Code= re.findall('(?<=.)(?=.)', str)
          body+mined:-NL= re.findall('\\[0-7]{1,2}', str)
      body+mined:-Blocks= re.findall('\\077', str)
      body+mined:-Inline= regex = re.compile('\\[0-7]{1-3}')

================================================================================

QUESTION: idx=348    id=13209288
-------------------------------------INPUTS-------------------------------------

tags: regex, split
score: 125
slot_map: {'key': ['var_0', 'str_0', '[str_0)'], 'quote': ['`', "'", "'"], 'type': ['var', 'str', 'str'], 'value': ['input', '[ ](?=[A-Z]+\\b)', '[ ](?=[A-Z]+\\b)']}
intent: split string `input` based on occurrences of regex pattern '[ ](?=[a-z]+\\b)'
body(Left in tags for better readability):
<p> What is the best way to split a string like <code> "HELLO there
HOW are YOU" <p>  by upper case words (in Python)?
<p> So I'd end up with an array like such: <code> results = ['HELLO
there', 'HOW are', 'YOU']

<p> EDIT:
<p> I have tried:
<code_block>
 p = re.compile("\b[A-Z]{2,}\b")
print p.split(page_text)

<p> It doesn't seem to work, though.

-------------------------------------OUTPUT-------------------------------------

                Expected= "re.split('[ ](?=[A-Z]+\\\\b)', input)"
           base:Baseline= re.split('[ ](?=[A-Z]+\\b)', input)
           body:Baseline= re.compile('(?=[A-Z]+\\b)', input)
            body:-Blocks= re.split('[ ](?=[A-Z]+\\b)', input)
              body:-Code= re.split('[ ](?=[A-Z]+\\b)', input)
            body:-Inline= re.compile('[ ](?=[A-Z]+\\b)', input)
                body:-NL= re.compile('[ ](?=[A-Z]+\\b)', input)
             base:+Mined= re.split('(?=[A-Z]+\\b)', input)
     body+mined:Baseline= results = re.compile('\\b[A-Z]{2,}\x08')
        body+mined:-Code= re.split('[ ](?=[A-Z]+\\b)', input)
          body+mined:-NL= re.compile('\\b[A-Z]+\\b', input)
      body+mined:-Blocks= results = re.findall('[ ](?=[A-Z]+\\b)', input)
      body+mined:-Inline= p = re.compile('\\b[A-Z]{2,}\x08')

================================================================================

QUESTION: idx=349    id=13209288
-------------------------------------INPUTS-------------------------------------

tags: regex, split
score: 125
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['input']}
intent: split string `input` at every space followed by an upper-case letter
body(Left in tags for better readability):
<p> What is the best way to split a string like <code> "HELLO there
HOW are YOU" <p>  by upper case words (in Python)?
<p> So I'd end up with an array like such: <code> results = ['HELLO
there', 'HOW are', 'YOU']

<p> EDIT:
<p> I have tried:
<code_block>
 p = re.compile("\b[A-Z]{2,}\b")
print p.split(page_text)

<p> It doesn't seem to work, though.

-------------------------------------OUTPUT-------------------------------------

                Expected= "re.split('[ ](?=[A-Z])', input)"
           base:Baseline= input = re.sub('\\w+', '', input)
           body:Baseline= re.compile('\\b[A-Z]{2,}\x08')
            body:-Blocks= input.split('HELLO there', 'HOW are', 'YOU')
              body:-Code= input.split(',', 1)[0]
            body:-Inline= re.compile('\x08[A-Z]{2,}\x08')
                body:-NL= re.compile('\\b[A-Z]\\b', input)
             base:+Mined= """ """.join(input.split())
     body+mined:Baseline= results = re.compile('\\b[A-Z]{2,}\x08')
        body+mined:-Code= re.split('\\W+', input)
          body+mined:-NL= re.compile('\\b[A-Z]{2,}\x08', input)
      body+mined:-Blocks= results = results.split(',')[-1]
      body+mined:-Inline= print(re.compile('\\b[A-Z]{2,}\b')

================================================================================

QUESTION: idx=350    id=24642040
-------------------------------------INPUTS-------------------------------------

tags: rest
score: 15
slot_map: {'key': ['var_0', 'var_1', 'var_2', 'var_3'], 'quote': ['`', '`', '`', '`'], 'type': ['var', 'var', 'var', 'var'], 'value': ['files', 'url', 'headers', 'data']}
intent: send multipart encoded file `files` to url `url` with headers `headers` and metadata `data`
body(Left in tags for better readability):
<p> I'm trying to POST to an API (Build using SlimPHP) which accepts
an image along with additional image meta data in the form of JSON.
<p> I've verified the API works correctly using a REST client tool and
can successfully POST to the service. All data is stored correctly.
<p> I'm now trying to POST using Python - however my JSON data doesn't
appear to be saving.
<p> My code:
<code_block>
     data = {'key1': 'value1', 'key2': 'value2'}
    url = 'http://mydomain.com/api/endpoint'
    headers = {'Authorization': 'my-api-key'}
    files = {'file': (FILE, open(PATH, 'rb'), 'image/jpg', {'Expires':
'0'})}
    r = requests.post(url, files=files, headers=headers, data=data)

<p> --
<p> I've attempted to set additional headers,
<p> ie:/
<code_block>
 headers = {'Authorization': 'unique-auth-key', 'Content-type':
'multipart/form-data'}

<p> or
<code_block>
 headers = {'Authorization': 'unique-auth-key', 'Content-type':
'application/json'}

<p> These result in a 500 error.

<p> UPDATE 14/07/2014:
<p> Using a chrome extension (Advanced Rest Client) my POST is
successful - here's what the console shows as the payload:
<code_block>
 ------WebKitFormBoundarysBpiwrA3hnGPUbMA
Content-Disposition: form-data; name="data"
test
------WebKitFormBoundarysBpiwrA3hnGPUbMA
Content-Disposition: form-data; name="file"; filename="image.jpg"
Content-Type: image/jpeg
------WebKitFormBoundarysBpiwrA3hnGPUbMA--

<p> I'm not quite sure what this signifies...

-------------------------------------OUTPUT-------------------------------------

                Expected= 'r = requests.post(url, files=files, headers=headers, data=data)'
           base:Baseline= urllib.parse.unquote(files, headers={'headers': 'data'})
           body:Baseline= requests.post(url, files=files, headers=headers, data=data)
            body:-Blocks= urllib.request.urlopen('files', headers={'meta': data})
              body:-Code= urllib.request.urlopen('files', headers={'headers': 'data'})
            body:-Inline= r = requests.post(url, files={'headers': headers, data={'Content-Type': 'application/json'})
                body:-NL= requests.post(url, files={'Authorization': 'my-api-key'})
             base:+Mined= urllib.parse.unquote(files).decode('utf-8')
     body+mined:Baseline= r = requests.post(url, files=files, headers=headers, data=data)
        body+mined:-Code= urllib.request.urlopen(files, headers=headers, metadata=data)
          body+mined:-NL= r = requests.post(url, files=files, headers=headers, data=data)
      body+mined:-Blocks= urllib.parse.quote(files).decode('utf-8')
      body+mined:-Inline= r = requests.post(url, files=files, headers=headers, data=data)

================================================================================

QUESTION: idx=351    id=4290716
-------------------------------------INPUTS-------------------------------------

tags: io
score: 55
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['bytes_', 'filename']}
intent: write bytes `bytes_` to a file `filename` in python 3
body(Left in tags for better readability):
<p> In Python 2.x with 'file-like' object:
<code_block>
 sys.stdout.write(bytes_)
tempfile.TemporaryFile().write(bytes_)
open('filename', 'wb').write(bytes_)
StringIO().write(bytes_)

<p> How to do the same in Python 3?
<p> How to write equivalent of this Python 2.x code:
<code_block>
 def write(file_, bytes_):
    file_.write(bytes_)

<p> Note: <code> sys.stdout <p>  is not always semantically a text
stream. It might be beneficial to consider it as a stream of bytes
sometimes. For example, <a> make encrypted archive of dir/ on remote
machine <p> :
<code_block>
 tar -c dir/ | gzip | gpg -c | ssh user@remote 'dd of=dir.tar.gz.gpg'

<p> There is no point to use Unicode in this case.

-------------------------------------OUTPUT-------------------------------------

                Expected= "open('filename', 'wb').write(bytes_)"
           base:Baseline= print(filename.write(bytes_))
           body:Baseline= sys.stdout.write(bytes_)
            body:-Blocks= filename = os.stdout.write(bytes_)
              body:-Code= print(filename.write(bytes_))
            body:-Inline= sys.stdout.write(bytes_)
                body:-NL= tempfile.TemporaryFile().write(bytes_)
             base:+Mined= f.write('\n'.join(bytes_))
     body+mined:Baseline= filename = open('filename', 'wb').write(bytes_)
        body+mined:-Code= f.write(bytes_).encode('utf-8')
          body+mined:-NL= open('filename', 'wb').write(bytes_)
      body+mined:-Blocks= filename = open('filename.txt', 'r')
      body+mined:-Inline= file_.write('\n'.join(bytes_))

================================================================================

QUESTION: idx=352    id=33078554
-------------------------------------INPUTS-------------------------------------

tags: list, dictionary
score: 57
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['lst', 'dct']}
intent: get a list from a list `lst` with values mapped into a dictionary `dct`
body(Left in tags for better readability):
<p> Given the following dictionary:
<code_block>
 dct = {'a':3, 'b':3,'c':5,'d':3}

<p> How can I apply these values to a list such as:
<code_block>
 lst = ['c', 'd', 'a', 'b', 'd']

<p> in order to get something like:
<code_block>
 lstval = [5, 3, 3, 3, 3]


-------------------------------------OUTPUT-------------------------------------

                Expected= '[dct[k] for k in lst]'
           base:Baseline= [dct for dct in lst]
           body:Baseline= [k for k, v in lst.items() if v]
            body:-Blocks= [dct for dct in lst]
              body:-Code= [dct for dct in lst]
            body:-Inline= [dct for dct, dct in lst]
                body:-NL= [dct for dct in lst]
             base:+Mined= dct = [dct[key] for key in lst]
     body+mined:Baseline= [x for x in lst for y in dct]
        body+mined:-Code= [dct[i] for i in lst]
          body+mined:-NL= dct = dict((k, v) for k, v in lst.items())
      body+mined:-Blocks= [dct[i] for i in lst]
      body+mined:-Inline= [dct[k] for k in lst]

================================================================================

QUESTION: idx=353    id=15247628
-------------------------------------INPUTS-------------------------------------

tags: group-by, pandas
score: 21
slot_map: {'key': ['str_0', 'var_0'], 'quote': ["'", '`'], 'type': ['str', 'var'], 'value': ['name', 'x']}
intent: find duplicate names in column 'name' of the dataframe `x`
body(Left in tags for better readability):
<p> I have a <code> pandas.DataFrame <p>  with a column called <code>
name <p>  containing strings.
I would like to get a list of the names which occur more than once in
the column. How do I do that?
<p> I tried:
<code_block>
 funcs_groups = funcs.groupby(funcs.name)
funcs_groups[(funcs_groups.count().name>1)]

<p> But it doesn't filter out the singleton names.

-------------------------------------OUTPUT-------------------------------------

                Expected= "x.set_index('name').index.get_duplicates()"
           base:Baseline= x.groupby(['name'])
           body:Baseline= df['name'] = funcs.groupby(funcs.name)
            body:-Blocks= df['name'] = df['name'].duplicates()
              body:-Code= x.groupby('name')['name']
            body:-Inline= x = funcs.groupby(funcs.name)
                body:-NL= x = funcs.groupby(funcs.name, names)
             base:+Mined= x.groupby(level=1).agg(['name', 'name'])
     body+mined:Baseline= df.groupby(['name', 'name'])['name'].distinct()
        body+mined:-Code= df.groupby('name').apply(lambda x: len(x), axis=1)
          body+mined:-NL= df.groupby(['name', 'name'])['name'].apply(lambda x: x.name)
      body+mined:-Blocks= df['name'] = df['name'].apply(lambda x: x.replace(' ', ''))
      body+mined:-Inline= df.find_all('name', inplace=True)

================================================================================

QUESTION: idx=354    id=783897
-------------------------------------INPUTS-------------------------------------

tags: floating-point
score: 122
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: truncate float 1.923328437452 to 3 decimal places
body(Left in tags for better readability):
<p> I want to remove digits from a float to have a fixed number of
digits after the dot, like:
<code_block>
 1.923328437452 - 1.923

<p> I need to output as a string to another function, not print.
<p> Also I want to ignore the lost digits, not round them.

-------------------------------------OUTPUT-------------------------------------

                Expected= 'round(1.923328437452, 3)'
           base:Baseline= """{0:.3f}""".format(1.923328437452)
           body:Baseline= float(1.923328437452 - 1.923)
            body:-Blocks= print('%.3f' % 1.923328437452)
              body:-Code= print('%.3f' % 1.923328437452)
            body:-Inline= print('{0:.923f}'.format(1.923328437452))
                body:-NL= float('{0:.3f}'.format(1.923328437452))
             base:+Mined= """{0:.3f}""".format(1.923328437452)
     body+mined:Baseline= """{:.3f}""".format(1.923328437452)
        body+mined:-Code= print('{0:.3f}'.format(1.923328437452))
          body+mined:-NL= """{0:.3f}""".format(1.923328437452 - 1.923)
      body+mined:-Blocks= print('{0:.3f}'.format(1.923328437452))
      body+mined:-Inline= """{:.3f}""".format(1.923328437452)

================================================================================

QUESTION: idx=355    id=22859493
-------------------------------------INPUTS-------------------------------------

tags: string, sorting, datetime
score: 5
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['li', 'li']}
intent: sort list `li` in descending order based on the date value in second element of each list in list `li`
body(Left in tags for better readability):
<code_block>
 import csv,operator
from datetime import datetime

li = [['name','01/03/2012','job'],
      ['name','02/05/2013','job'],
      ['name','03/08/2014','job']]

<h2> Sorted Method:
<code_block>
 sorted(li,key=lambda x:datetime.strptime(row[1],'%d/%m/%Y'),
reverse=True)

<strong> Output:
<p> No error, but simply not ordered
<h2> Itemgetter Method:
<code_block>
 for x in range(1,len(li)):
    li[x][6]=datetime.strptime(li[x][6],'%d/%m/%Y')

li.sort(key=operator.itemgetter(6))

<strong> Output:
<code_block>
 Traceback (most recent call last):
  File "U:/rmarshall/Work For Staff/ROB/_Python/__Python Projects
Code/April Signed Terms.py", line 35, in <module>
    li.sort(key=operator.itemgetter(6))
TypeError: unorderable types: datetime.datetime() < str()

<p> Could someone supply an example of ordering a the list li by date.
For educational purposes I would appreciate examples of both the
sorted method and itemgetter method with a comparison of efficiency.
<p> Also, by the error on the itemgetter approach, is itemgetter
simply not able to handle datetime objects.
<p> Note:  I presume the ascending or descending order doesn't matter
too much in this example as it can be simply flipped with <code>
reverse=True <p> .

-------------------------------------OUTPUT-------------------------------------

                Expected= "sorted(li, key=lambda x: datetime.strptime(x[1], '%d/%m/%Y'), reverse=True)"
           base:Baseline= li.sort(key=lambda x: (x[1], x[2]))
           body:Baseline= li.sort(key=lambda x: datetime.strptime(row[1]], reverse=True)
            body:-Blocks= sorted(li, key=lambda x: x[1])
              body:-Code= sorted(li, key=lambda x: x[1])
            body:-Inline= li.sort(key=operator.itemgetter(6))
                body:-NL= li.sort(key=lambda x: reverse=True)
             base:+Mined= li.sort(key=lambda x: x[2])
     body+mined:Baseline= li.sort(key=operator.itemgetter(6))
        body+mined:-Code= li.sort(key=lambda x: (x[1], x[0]))
          body+mined:-NL= li.sort(key=operator.itemgetter(6))
      body+mined:-Blocks= li.sort(key=lambda x: (x[1], x[2]))
      body+mined:-Inline= li.sort(key=operator.itemgetter(6))

================================================================================

QUESTION: idx=356    id=29394552
-------------------------------------INPUTS-------------------------------------

tags: matplotlib, polar-coordinates
score: 10
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['ax']}
intent: place the radial ticks in plot `ax` at 135 degrees
body(Left in tags for better readability):
<p> From <a> matplotlib examples <p> :
<code_block>
 import numpy as np
import seaborn as sbs
import matplotlib.pyplot as plt

r = np.arange(0, 3.0, 0.01)
theta = 2 * np.pi * r

ax = plt.subplot(111, polar=True)
ax.plot(theta, r, color='r', linewidth=3)
ax.set_rmax(2.0)
ax.grid(True)

ax.set_title("A line plot on a polar axis", va='bottom')
plt.show()

<p> How to move the radial tick labels (0.5, 1.0, 1.5, 2.0) to a
different angle, say 120 deg?

-------------------------------------OUTPUT-------------------------------------

                Expected= 'ax.set_rlabel_position(135)'
           base:Baseline= ax.set_index(135)
           body:Baseline= ax.set_title('A line plot')
            body:-Blocks= ax.set_radigit()
              body:-Code= ax.set_radigit()
            body:-Inline= ax.set_title('A line plot on a polar axis', 135)
                body:-NL= ax.set_title('A line plot on a polar axis', 135)
             base:+Mined= ax.set_xticklabels([])
     body+mined:Baseline= ax.plot(theta, r, color='r', linewidth=3)
        body+mined:-Code= ax.set_xlim([0, 100])
          body+mined:-NL= ax.plot(theta, r, color='r', linewidth=3)
      body+mined:-Blocks= ax.set_xlim(0.5)
      body+mined:-Inline= ax.plot(theta, r, color='r', linewidth=3)

================================================================================

QUESTION: idx=357    id=3320406
-------------------------------------INPUTS-------------------------------------

tags: path
score: 161
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['my_path']}
intent: check if path `my_path` is an absolute path
body(Left in tags for better readability):
<p> UNIX absolute path starts with '/', whereas Windows starts with
alphabet 'C:' or '\'.
Does python has a standard function to check if a path is absolute or
relative?

-------------------------------------OUTPUT-------------------------------------

                Expected= 'os.path.isabs(my_path)'
           base:Baseline= print(os.path.abspath(my_path))
           body:Baseline= print(os.path.realpath(my_path))
            body:-Blocks= print(os.path.abspath(my_path))
              body:-Code= print(os.path.abspath(my_path))
            body:-Inline= print(os.path.abspath(my_path))
                body:-NL= print(os.path.realpath(my_path))
             base:+Mined= os.path.abspath(my_path)
     body+mined:Baseline= print(os.path.realpath(my_path))
        body+mined:-Code= os.path.abspath(my_path)
          body+mined:-NL= print(os.path.abspath(my_path))
      body+mined:-Blocks= os.path.abspath(my_path)
      body+mined:-Inline= print(os.path.abspath(my_path))

================================================================================

QUESTION: idx=358    id=2212433
-------------------------------------INPUTS-------------------------------------

tags: dictionary, count, keyword
score: 263
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['yourdict']}
intent: get number of keys in dictionary `yourdict`
body(Left in tags for better readability):
<p> I have a list of words in a dictionary with the value = the
repetition of the keyword but I only want a list of distinct words so
I wanted to count the number of keywords. Is there a way to count the
number of keywords or is there another way I should look for distinct
words?

-------------------------------------OUTPUT-------------------------------------

                Expected= 'len(list(yourdict.keys()))'
           base:Baseline= sum(key for key, value in list(yourdict.items()))
           body:Baseline= sum(key for key, value in list(yourdict.items()))
            body:-Blocks= len(key) for key in list(yourdict.items())
              body:-Code= sum(key for key, value in list(yourdict.items())
            body:-Inline= sum(yourdict.keys()))
                body:-NL= sum(key for key, value in list(yourdict.items())
             base:+Mined= sum(len(yourDict))
     body+mined:Baseline= sum(1 for word in list(yourdict.items())
        body+mined:-Code= sum(1 for key, value in list(yourdict.items()) if value == 1)
          body+mined:-NL= sum(key for key, value in list(yourdict.items()))
      body+mined:-Blocks= sum(1 for key, value in list(yourdict.items()))
      body+mined:-Inline= sum(key for key, value in list(yourdict.items()))

================================================================================

QUESTION: idx=359    id=2212433
-------------------------------------INPUTS-------------------------------------

tags: dictionary, count, keyword
score: 263
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['yourdictfile']}
intent: count the number of keys in dictionary `yourdictfile`
body(Left in tags for better readability):
<p> I have a list of words in a dictionary with the value = the
repetition of the keyword but I only want a list of distinct words so
I wanted to count the number of keywords. Is there a way to count the
number of keywords or is there another way I should look for distinct
words?

-------------------------------------OUTPUT-------------------------------------

                Expected= 'len(set(open(yourdictfile).read().split()))'
           base:Baseline= sum(key for key, value in list(yourdictfile.items()))
           body:Baseline= sum(key for key, value in list(yourdictfile.items()))
            body:-Blocks= sum(key for key, value in list(yourdictfile.items()))
              body:-Code= sum(key for key, value in list(yourdictfile.items())
            body:-Inline= sum(yourdictfile.keys())
                body:-NL= count(key=lambda x: x[1])
             base:+Mined= sum(len(yourdictfile))
     body+mined:Baseline= sum(1 for word in list(yourdictfile.keys())
        body+mined:-Code= sum(1 for key, value in list(yourdictfile.items()) if value == 1)
          body+mined:-NL= sum(1 for key, value in list(yourdictfile.values()))
      body+mined:-Blocks= sum(1 for key, value in list(yourdictfile.items()))
      body+mined:-Inline= len(yourdictfile.values())

================================================================================

QUESTION: idx=360    id=20067636
-------------------------------------INPUTS-------------------------------------

tags: pandas, dataframe
score: 166
slot_map: {'key': ['str_0'], 'quote': ["'"], 'type': ['str'], 'value': ['id']}
intent: pandas dataframe get first row of each group by 'id'
body(Left in tags for better readability):
<p> I have a pandas <code> DataFrame <p>  like following.
<code_block>
 df = pd.DataFrame({'id' : [1,1,1,2,2,3,3,3,3,4,4,5,6,6,6,7,7],
                'value'  : ["first","second","second","first",
                            "second","first","third","fourth",
                            "fifth","second","fifth","first",
"first","second","third","fourth","fifth"]})

<p> I want to group this by ["id","value"] and get the first row of
each group.
<code_block>
         id   value
0        1   first
1        1  second
2        1  second
3        2   first
4        2  second
5        3   first
6        3   third
7        3  fourth
8        3   fifth
9        4  second
10       4   fifth
11       5   first
12       6   first
13       6  second
14       6   third
15       7  fourth
16       7   fifth

<p> Expected outcome
<code_block>
     id   value
     1   first
     2   first
     3   first
     4  second
     5  first
     6  first
     7  fourth

<p> I tried following which only gives the first row of the <code>
DataFrame <p> . Any help regarding this is appreciated.
<code_block>
 <console_in> for index, row in df.iterrows():
<console_out>   <console_out>.:     df2 =
pd.DataFrame(df.groupby(['id','value']).reset_index().ix[0])


-------------------------------------OUTPUT-------------------------------------

                Expected= "df.groupby('id').first()"
           base:Baseline= df.groupby('id').apply(lambda x: x[1])
           body:Baseline= df = pd.DataFrame(['id'], axis=1)
            body:-Blocks= df.groupby('id')['value']
              body:-Code= df['id'] = df['value']
            body:-Inline= df['id'] = df['value'].groupby('id')
                body:-NL= pd.DataFrame(['id'], axis=1)
             base:+Mined= df.groupby('id').apply(lambda x: x['id'], axis=1)
     body+mined:Baseline= df.groupby(['id', 'value']).head(1)
        body+mined:-Code= df.groupby('id').head()
          body+mined:-NL= df.groupby(['id', 'value'])['value'].first()
      body+mined:-Blocks= df.groupby('id').first()
      body+mined:-Inline= df.groupby('id')['value'].apply(lambda x: x['id'].tolist())

================================================================================

QUESTION: idx=361    id=40924332
-------------------------------------INPUTS-------------------------------------

tags: list, pandas, dataframe
score: 17
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: split a list in first column  into multiple columns keeping other columns as well in pandas data frame
body(Left in tags for better readability):
<p> I have a really simple <code> Pandas
<code> dataframe <p>  where each cell contains a list. I'd like to
split each element of the list into it's own column. I can do that by
exporting the values and then creating a new <code> dataframe <p> .
This doesn't seem like a good way to do this especially, if my <code>
dataframe <p>  had a column aside from the list column.
<code_block>
 import pandas as pd

df = pd.DataFrame(data=[[[8,10,12]],
                        [[7,9,11]]])

df = pd.DataFrame(data=[x[0] for x in df.values])

<p> Desired output:
<code_block>
    0   1   2
0  8  10  12
1  7   9  11

<p> Follow-up based on @Psidom answer:
<p> If I did have a second column:
<code_block>
 df = pd.DataFrame(data=[[[8,10,12], 'A'],
                        [[7,9,11], 'B']])

<p> How do I not loose the other column?
<p> Desired output:
<code_block>
    0   1   2  3
0  8  10  12  A
1  7   9  11  B


-------------------------------------OUTPUT-------------------------------------

                Expected= 'pd.concat([df[0].apply(pd.Series), df[1]], axis=1)'
           base:Baseline= pd.concat([df[1], df[2], axis=1)
           body:Baseline= df = pd.DataFrame(data=[x[0] for x in df.values])
            body:-Blocks= pd.concat([df[1], df[2], axis=1)
              body:-Code= pd.concat([df['1'], df['2'], axis=1)
            body:-Inline= df = pd.DataFrame(data=[x[0] for x in df.values])
                body:-NL= df = pd.DataFrame(data=[x[0] for x in df.values])
             base:+Mined= pd.concat([df1, df2], axis=1)
     body+mined:Baseline= df['A'].apply(lambda x: x.apply(pd.Series).astype(int)
        body+mined:-Code= df['A'] = df['B'].apply(pd.Series)
          body+mined:-NL= pd.concat([df, pd.DataFrame(data=[x[0] for x in df.values])
      body+mined:-Blocks= pd.concat([df1, df2], axis=1)
      body+mined:-Inline= df[['A', 'B']].apply(pd.Series)

================================================================================

QUESTION: idx=362    id=30759776
-------------------------------------INPUTS-------------------------------------

tags: regex
score: 5
slot_map: {'key': ['str_0', 'var_0'], 'quote': ["'", '`'], 'type': ['str', 'var'], 'value': ['src="js/([^"]*\\bjquery\\b[^"]*)"', 'data']}
intent: extract attributes 'src="js/([^"]*\\bjquery\\b[^"]*)"' from string `data`
body(Left in tags for better readability):
<p> I want to get JS file names from the input content which contains
<code> jquery <p>  as a substring by RE.
<p> This is my code:
<p> Step 1: Extract JS file from the content.
<code_block>
 <console_in> data = """    <script type="text/javascript"
src="js/jquery-1.9.1.min.js"/>
<console_out>     <script type="text/javascript" src="js/jquery-
migrate-1.2.1.min.js"/>
<console_out>     <script type="text/javascript" src="js/jquery-
ui.min.js"/>
<console_out>     <script type="text/javascript"
src="js/abc_bsub.js"/>
<console_out>     <script type="text/javascript"
src="js/abc_core.js"/>
<console_out>     <script type="text/javascript"
src="js/abc_explore.js"/>
<console_out>     <script type="text/javascript"
src="js/abc_qaa.js"/>"""
<console_in> import re
<console_in> re.findall('src="js/([^"]+)"', data)
<console_out> ['jquery-1.9.1.min.js', 'jquery-migrate-1.2.1.min.js',
'jquery-ui.min.js', 'abc_bsub.js', 'abc_core.js', 'abc_explore.js',
'abc_qaa.js']

<p> Step 2: Get JS file which have sub string as <code> jquery
<code_block>
 <console_in> [ii for ii in re.findall('src="js/([^"]+)"', data) if
"jquery" in ii]
<console_out> ['jquery-1.9.1.min.js', 'jquery-migrate-1.2.1.min.js',
'jquery-ui.min.js']

<p> Can I do above Step 2 in the Step 1 means RE Pattern to get
result?

-------------------------------------OUTPUT-------------------------------------

                Expected= 're.findall(\'src="js/([^"]*\\\\bjquery\\\\b[^"]*)"\', data)'
           base:Baseline= data = data.extract('src="js/([^"]*\\bjquery\\b[^]*)"')
           body:Baseline= re.findall('src="js/([^]*\\bjquery\\b[^"]*)"', data)
            body:-Blocks= data.translate(re.compile('src="js/([^"]*\\bjquery\\b[^]*)"))
              body:-Code= data = re.compile('src="js/([^"]*\\bjquery\\b[^]*)"
            body:-Inline= data = re.findall('src="js/([^"]*\\bjquery\\b[^]*)"', data)
                body:-NL= re.findall('src="js/([^]*\\bjquery\\b[^"]*)"', data)
             base:+Mined= data.extract('src="js/([^"]*\\bjquery\\b[^"]*))"
     body+mined:Baseline= re.findall('src="js/([^"]+\\bjquery\\b[^"]*)"', data)
        body+mined:-Code= re.compile('src="js/([^"]*\\bjquery\\b[^]*)"
          body+mined:-NL= [ii for i in re.findall('src="js/([^"]+)"', data) if 'jquery' in i]
      body+mined:-Blocks= re.compile('src="js/([^"]*\\bjquery\\b[^]*)')
      body+mined:-Inline= re.findall('src="js/([^"]+)"', data)

================================================================================

QUESTION: idx=363    id=25388796
-------------------------------------INPUTS-------------------------------------

tags: file-io, io
score: 4
slot_map: {'key': ['str_0', '[str_0]'], 'quote': ['`', '`'], 'type': ['str', 'str'], 'value': ["['', '3.4', '', '', '1.0']", "['', '3.4', '', '', '1.0']"]}
intent: sum integers contained in strings in list `['', '3.4', '', '', '1.0']`
body(Left in tags for better readability):
<p> I'm doing something like this to sum up a number of elements of a
line:
<code_block>
 for line in open(filename, 'r'):
   big_list = line.strip().split(delim)
   a = sum(int(float(item)) for item in big_list[start:end] if item)
   # do some other stuff

<p> this is done line by line with a big file, where some items may be
missing, i.e., equal to ''. If I use the statement above to compute a,
the script becomes much slower than without it. Is there a way to
speed it up?

-------------------------------------OUTPUT-------------------------------------

                Expected= "sum(int(float(item)) for item in [_f for _f in ['', '3.4', '', '', '1.0'] if\n    _f])"
           base:Baseline= sum(map(int, ['', '3.4', '', '", '1.0'])
           body:Baseline= sum(int(float(item)) for item in [', '3.4', '', '1.0'])
            body:-Blocks= sum(int(x) for x in ['', '3.4', '', '", '1.0'])
              body:-Code= sum(map(int, x) for x in ['', '3.4', '', '", '1.0'])
            body:-Inline= sum(int(float(item)) for item in ['', '3.4', '', '1.0'])
                body:-NL= sum(int(x) for x in ['', '3.4', '', '1.0'])
             base:+Mined= sum(map(int, x))
     body+mined:Baseline= sum(int(float(item)) for item in big_list[start:end] if item)
        body+mined:-Code= sum(map(int, x.split('.')))
          body+mined:-NL= sum(int(float(item)) for item in big_list[start:end] if item)
      body+mined:-Blocks= sum(map(int, ['', '3.4', '', '1.0'])
      body+mined:-Inline= sum(int(float(item)) for item in big_list[start:end])

================================================================================

QUESTION: idx=364    id=804995
-------------------------------------INPUTS-------------------------------------

tags: subprocess
score: 22
slot_map: {'key': ['str_0'], 'quote': ['`'], 'type': ['str'], 'value': ['c:\\Program Files\\VMware\\VMware Server\\vmware-cmd.bat']}
intent: call a subprocess with arguments `c:\\program files\\vmware\\vmware server\\vmware-cmd.bat` that may contain spaces
body(Left in tags for better readability):
<p> I'm working on a wrapper script that will exercise a vmware
executable, allowing for the automation of virtual machine
startup/shutdown/register/deregister actions.  I'm trying to use
subprocess to handle invoking the executable, but the spaces in the
executables path and in parameters of the executable are not being
handled correctly by subprocess.  Below is a code fragment:
<code_block>
 vmrun_cmd = r"c:/Program Files/VMware/VMware Server/vmware-cmd.bat"
def vm_start(target_vm):
    list_arg = "start"
    list_arg2 = "hard"
    if vm_list(target_vm):
            p = Popen([vmrun_cmd, target_vm, list_arg, list_arg2],
stdout=PIPE).communicate()[0]
            print p
    else:
            vm_register(target_vm)
            vm_start(target_vm)
def vm_list2(target_vm):
    list_arg = "-l"
    p = Popen([vmrun_cmd, list_arg], stdout=PIPE).communicate()[0]
    for line in p.split('\n'):
            print line

<p> If I call the vm_list2 function, I get the following output:
<code_block>
 $ ./vmware_control.py --list
C:\Virtual Machines\QAW2K3Server\Windows Server 2003 Standard
Edition.vmx
C:\Virtual Machines\ubunturouter\Ubuntu.vmx
C:\Virtual Machines\vacc\vacc.vmx
C:\Virtual Machines\EdgeAS-4.4.x\Other Linux 2.4.x kernel.vmx
C:\Virtual Machines\UbuntuServer1\Ubuntu.vmx
C:\Virtual Machines\Other Linux 2.4.x kernel\Other Linux 2.4.x
kernel.vmx
C:\Virtual Machines\QAClient\Windows XP Professional.vmx

<p> If I call the vm_start function, which requires a path-to-vm
parameter, I get the following output:
<code_block>
 $ ./vmware_control.py --start "C:\Virtual
Machines\ubunturouter\Ubuntu.vmx"
'c:\Program' is not recognized as an internal or external command,
operable program or batch file.

<p> Apparently, the presence of a second parameter with embedded
spaces is altering the way that subprocess is interpreting the first
parameter.  Any suggestions on how to resolve this?
<p> python2.5.2/cygwin/winxp

-------------------------------------OUTPUT-------------------------------------

                Expected= "subprocess.Popen(['c:\\\\Program Files\\\\VMware\\\\VMware Server\\\\vmware-cmd.bat'])"
           base:Baseline= subprocess.call('c:\\program files\\vmware\\vmWARE server\\vmWare-cmd.bat',
    shell=True)
           body:Baseline= subprocess.call('C:\\Program Files\\vmware\\VMware Server/vmware-cmd.bat',
    shell=True)
            body:-Blocks= subprocess.call(['c:\\program files\\vmware\\vmWARE server\\VMware-cmd.bat', shell=True)
              body:-Code= subprocess.call('c:\\program files\\vmware\\vmWare server\\vmWARE-cmd.bat',
    shell=True)
            body:-Inline= subprocess.call(['c:\\Program Files\\vmware\\VMware Server/vmware-cmd.bat'])
                body:-NL= subprocess.call('c:\\Program Files\\vmware\\vmWare Server\\vmWARE-cmd.bat',
    shell=True)
             base:+Mined= subprocess.call(['c:\\program files\\vmware\\vmWARE server\\vmvmware-cmd.bat', shell=True)
     body+mined:Baseline= subprocess.call(['c:\\Program Files\\vmware\\VMware Server\\vmvmware-cmd.bat', shell=True)
        body+mined:-Code= subprocess.call(['c:\\program files\\vmware\\VMware server\\mvmware-cmd.bat', shell=True)
          body+mined:-NL= subprocess.call(['c:\\Program Files\\vmware\\n', '-l', 'vmware-cmd.bat'])
      body+mined:-Blocks= subprocess.Popen([
    'c:\\program files\\vmware\\VMware server\\vmWARE-cmd.bat', 'exec'],
    shell=True)
      body+mined:-Inline= subprocess.call(['c:\\Program Files/VMware\\VMware Server\\vmware-cmd.bat', shell=True)

================================================================================

QUESTION: idx=365    id=26441253
-------------------------------------INPUTS-------------------------------------

tags: priority-queue
score: 8
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['q']}
intent: reverse a priority queue `q` in python without using classes
body(Left in tags for better readability):
<p> I am just learning the priority queues in Python, and I have made
the following code:
<code_block>
 def main():
    q=Queue.PriorityQueue()
    while True:
        n=input("numbre?")
        if n==0:
            break
        else:
            q.put(n)
            print n

while not q.empty():
        print q.get()

<p> when I input data like: 9, 1, 4, 5
<p> it prints 1,4,5,9 which it seems correct, but I would like to know
how can I do to deque in reverse order, I mean: 9,5,4,1
<p> I know how to do that with a class, but in this case it seems the
following extra code:
<code_block>
 def __cmp__():
        -cmp(q.get(),q.get())

<p> does not work, any help?

-------------------------------------OUTPUT-------------------------------------

                Expected= 'q.put((-n, n))'
           base:Baseline= [(k, v) for k, v in queue.items()]
           body:Baseline= Queue.PriorityQueue(Q).reset_index()
            body:-Blocks= q.dequeue(key=operator.itemgetter(1))
              body:-Code= q.reverse_queue(key=lambda x: x[1])
            body:-Inline= queue.reverse_queue(q)
                body:-NL= q.reverse_queue(0)
             base:+Mined= priority_queue = queue.reverse(Q, reverse=True)
     body+mined:Baseline= rdd.reverse(q, reverse=True)
        body+mined:-Code= q.queue(reverse=True)
          body+mined:-NL= Queue.PriorityQueue(queue_name, queue_name)
      body+mined:-Blocks= q.queue(reverse=True)
      body+mined:-Inline= queue.reverse_queue(q)

================================================================================

QUESTION: idx=366    id=18897261
-------------------------------------INPUTS-------------------------------------

tags: plot, pandas, bar-chart
score: 16
slot_map: {'key': ['var_0', 'var_1', 'var_2'], 'quote': ['`', '`', '`'], 'type': ['var', 'var', 'var'], 'value': ['group', 'df', 'color']}
intent: make a barplot of data in column `group` of dataframe `df` colour-coded according to list `color`
body(Left in tags for better readability):
<p> I would like to use pandas to plot a barplot with diffrent colors
for category in column.
<p> Here is a simple example: (index is variable)
<code_block>
 df:
         value   group
variable
a             10      1
b              9      1
c              8      1
d              7      2
f              6      2
g              5      3
h              4      3

<p> I would like to make a barplot with coloring on group. I would
also like to specify the colors. In my original dataset I have many
goups.
Could someone help me with this?

-------------------------------------OUTPUT-------------------------------------

                Expected= "df['group'].plot(kind='bar', color=['r', 'g', 'b', 'r', 'g', 'b', 'r'])"
           base:Baseline= df.groupby(color='green')
           body:Baseline= df.colour_coded_by='color')
            body:-Blocks= df.group.colour_coded().barplot(index='color')
              body:-Code= df.group.colour_coded('color')
            body:-Inline= df.colour_coded().barplot(group='color')
                body:-NL= df.group.colour_coded().barrier_by('color')
             base:+Mined= df.groupby(['color']).plot(kind='bar')
     body+mined:Baseline= df.group.color.diffrent('greyscale')
        body+mined:-Code= df.groupby('color').plot(kind='bar')
          body+mined:-NL= df.colour.pivot(index='group', columns='color', aggfunc='value', fill_value=0)
      body+mined:-Blocks= df.groupby('color').plot(kind='bar')
      body+mined:-Inline= df.colour_list('color')

================================================================================

QUESTION: idx=367    id=373194
-------------------------------------INPUTS-------------------------------------

tags: regex, md5
score: 21
slot_map: {'key': ['str_0', 'var_0', '(str_0)'], 'quote': ["'", '`', "'"], 'type': ['str', 'var', 'str'], 'value': ['([a-fA-F\\d]{32})', 'data', '([a-fA-F\\d]{32})']}
intent: find all matches of regex pattern '([a-fa-f\\d]{32})' in string `data`
body(Left in tags for better readability):
<p> I've come up with:
<code_block>
 re.findall("([a-fA-F\d]*)", data)

<p> but it's not very fool proof, is there a better way to grab all
MD5-hash codes?

-------------------------------------OUTPUT-------------------------------------

                Expected= "re.findall('([a-fA-F\\\\d]{32})', data)"
           base:Baseline= re.findall('([A-F\\d]{32})', data)
           body:Baseline= re.findall('([a-fa-f\\d]{32})', data)
            body:-Blocks= print(re.findall('([A-fa-f\\d]{32})', data))
              body:-Code= print(re.findall('([A-fa-f\\d]{32})', data))
            body:-Inline= re.findall('([a-fa-f\\d]{32})', data)
                body:-NL= re.findall('([a-fa-f\\d]{32})', data)
             base:+Mined= re.findall('([A-fa-f\\d]{32})', data)
     body+mined:Baseline= re.findall('([a-fa-f\\d]{32})', data)
        body+mined:-Code= re.findall('([A-fa-f\\d]{32})', data)
          body+mined:-NL= re.findall('([a-fa-f\\d]{32})', data)
      body+mined:-Blocks= re.findall('([A-fa-f\\d]{32})', data)
      body+mined:-Inline= re.findall('([a-fa-f\\d]{32})', data)

================================================================================

QUESTION: idx=368    id=518021
-------------------------------------INPUTS-------------------------------------

tags: arrays, methods
score: 739
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['my_list']}
intent: get the length of list `my_list`
body(Left in tags for better readability):
<p> In <a> Python <p> , is the following the only way to get the
number of elements?
<code_block>
 arr.__len__()

<p> If so, why the strange syntax?

-------------------------------------OUTPUT-------------------------------------

                Expected= 'len(my_list)'
           base:Baseline= len(len(my_list))
           body:Baseline= len(len(my_list))
            body:-Blocks= len(len(my_list))
              body:-Code= len(len(my_list))
            body:-Inline= len(len(my_list))
                body:-NL= len(my_list, 16)
             base:+Mined= len(set(my_list))
     body+mined:Baseline= len(my_list) - my_list
        body+mined:-Code= len(my_list):
    pass
          body+mined:-NL= [len(my_list) for _ in range(length)]
      body+mined:-Blocks= length = len(my_list)
      body+mined:-Inline= len([x for x in my_list if x != 'len'])

================================================================================

QUESTION: idx=369    id=518021
-------------------------------------INPUTS-------------------------------------

tags: arrays, methods
score: 739
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['l']}
intent: getting the length of array `l`
body(Left in tags for better readability):
<p> In <a> Python <p> , is the following the only way to get the
number of elements?
<code_block>
 arr.__len__()

<p> If so, why the strange syntax?

-------------------------------------OUTPUT-------------------------------------

                Expected= 'len(l)'
           base:Baseline= len(l, len(l))
           body:Baseline= len(L) == len(len(l))
            body:-Blocks= len(len(l) + 1
              body:-Code= len(l) + len(l))
            body:-Inline= len(l) - L[::-1]
                body:-NL= len(l) + L[::-1]
             base:+Mined= L[len(l)) == len(l)
     body+mined:Baseline= len(L) - len(l)
        body+mined:-Code= len(L) - len(len(l))
          body+mined:-NL= L[::-1].length()
      body+mined:-Blocks= len(l) - len(l))
      body+mined:-Inline= len([x for x in L])

================================================================================

QUESTION: idx=370    id=518021
-------------------------------------INPUTS-------------------------------------

tags: arrays, methods
score: 739
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['s']}
intent: getting the length of array `s`
body(Left in tags for better readability):
<p> In <a> Python <p> , is the following the only way to get the
number of elements?
<code_block>
 arr.__len__()

<p> If so, why the strange syntax?

-------------------------------------OUTPUT-------------------------------------

                Expected= 'len(s)'
           base:Baseline= np.len(s).sum()
           body:Baseline= len(s, len(s))
            body:-Blocks= len(s, len(s))
              body:-Code= len(s, len(s))
            body:-Inline= sum(len(s) for _ in range(0, len(s))
                body:-NL= [len(s)) for s in range(0, len(s)]
             base:+Mined= np.len(s), -1)
     body+mined:Baseline= len([x for x in s if x not in s])
        body+mined:-Code= len(s) - len(s - 1
          body+mined:-NL= arr[::-1].length()
      body+mined:-Blocks= len(s) - len(s))
      body+mined:-Inline= len([x for x in s if x != 0])

================================================================================

QUESTION: idx=371    id=518021
-------------------------------------INPUTS-------------------------------------

tags: arrays, methods
score: 739
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['my_tuple']}
intent: getting the length of `my_tuple`
body(Left in tags for better readability):
<p> In <a> Python <p> , is the following the only way to get the
number of elements?
<code_block>
 arr.__len__()

<p> If so, why the strange syntax?

-------------------------------------OUTPUT-------------------------------------

                Expected= 'len(my_tuple)'
           base:Baseline= len(len(my_tuple))
           body:Baseline= len(len(my_tuple))
            body:-Blocks= len(len(my_tuple))
              body:-Code= len(len(my_tuple))
            body:-Inline= len(len(my_tuple))
                body:-NL= len(my_tuple, 16)
             base:+Mined= len(my_tuple):
    pass
     body+mined:Baseline= len(len(my_tuple))
        body+mined:-Code= len(my_tuple) - 1
          body+mined:-NL= len(my_tuple) - len(my-tuple))
      body+mined:-Blocks= sum(len(my_tuple))
      body+mined:-Inline= len(arr) - my_tuple[::-1]

================================================================================

QUESTION: idx=372    id=518021
-------------------------------------INPUTS-------------------------------------

tags: arrays, methods
score: 739
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['my_string']}
intent: getting the length of `my_string`
body(Left in tags for better readability):
<p> In <a> Python <p> , is the following the only way to get the
number of elements?
<code_block>
 arr.__len__()

<p> If so, why the strange syntax?

-------------------------------------OUTPUT-------------------------------------

                Expected= 'len(my_string)'
           base:Baseline= len(len(my_string))
           body:Baseline= len(len(my_string))
            body:-Blocks= len(len(my_string))
              body:-Code= len(len(my_string))
            body:-Inline= len(len(my_string))
                body:-NL= len(my_string).__len__()
             base:+Mined= len(my_string):
    pass
     body+mined:Baseline= len(my_string) - my_string
        body+mined:-Code= len(my_string):
    pass
          body+mined:-NL= print(len(my_string))
      body+mined:-Blocks= len(my_string) - len(my - string)
      body+mined:-Inline= len(arr) - my_string

================================================================================

QUESTION: idx=373    id=40452956
-------------------------------------INPUTS-------------------------------------

tags: 
score: 7
slot_map: {'key': ['str_0'], 'quote': ['"'], 'type': ['str'], 'value': ['\\a']}
intent: remove escape character from string "\\a"
body(Left in tags for better readability):
<p> I would like to turn this string:
<code_block>
 a = '\\a'

<p> into this one
<code_block>
 b = '\a'

<p> It doesn't seem like there is an obvious way to do this with
<code> replace <p> ?
<p> EDIT: To be more precise, I want to change the escaping of the
backslash to escape the character <code> a

-------------------------------------OUTPUT-------------------------------------

                Expected= '"""\\\\a""".decode(\'string_escape\')'
           base:Baseline= re.sub('\\a', '\\a')
           body:Baseline= a = '\\a'.replace('\\a', '')
            body:-Blocks= re.sub('\\a', '\\a')
              body:-Code= re.sub('\\A', '\\A')
            body:-Inline= """\\a""".encode('escape')
                body:-NL= """\\a""".encode('escape')
             base:+Mined= re.sub('\\a', '', '\\a')
     body+mined:Baseline= a.replace('\\a', '')
        body+mined:-Code= """\\a""".replace('\\', '')
          body+mined:-NL= a.replace('\\a', '')
      body+mined:-Blocks= a.replace('\\A', '')
      body+mined:-Inline= """\\a""".encode('ascii', 'ignore')

================================================================================

QUESTION: idx=374    id=8687018
-------------------------------------INPUTS-------------------------------------

tags: string
score: 37
slot_map: {'key': ['str_0', 'str_1', 'str_2', 'str_3', 'str_4'], 'quote': ["'", "'", "'", "'", "'"], 'type': ['str', 'str', 'str', 'str', 'str'], 'value': ['a', 'b', 'b', 'a', 'obama']}
intent: replace each 'a' with 'b' and each 'b' with 'a' in the string 'obama' in a single pass.
body(Left in tags for better readability):
<p> Say I have a string, <code> "ab" <p> .
<p> I want to replace <code> "a" <p>  with <code> "b" <p>  and <code>
"b" <p>  with <code> "a" <p>  in one swoop.
<p> So in the end, the string should be <code> "ba" <p>  and not
<code> "aa" <p>  or <code> "bb" <p>  and not use more than one line.
Is this doable?

-------------------------------------OUTPUT-------------------------------------

                Expected= '"""obama""".replace(\'a\', \'%temp%\').replace(\'b\', \'a\').replace(\'%temp%\', \'b\')'
           base:Baseline= """obama""".replace('a', 'b', 'a')
           body:Baseline= obama.replace('a', 'b', 'a')
            body:-Blocks= """obama""".replace('a', 'b', 'a')
              body:-Code= """obama""".replace('a', 'b')
            body:-Inline= """obama""".replace('a', 'b', 'a')
                body:-NL= """""".join(['a', 'b'], 'a' in 'b')
             base:+Mined= """""".join(['a', 'b', 'a'])
     body+mined:Baseline= """a""".replace('a', 'b', 'a')
        body+mined:-Code= """obama""".replace('a', 'b', 'a')
          body+mined:-NL= """ab""".replace('a', 'b', 'a')
      body+mined:-Blocks= """obama""".replace('a', 'b', 'a')
      body+mined:-Inline= """""".join(['a', 'b'], ['b', 'a'])

================================================================================

QUESTION: idx=375    id=303200
-------------------------------------INPUTS-------------------------------------

tags: file
score: 923
slot_map: {'key': ['str_0'], 'quote': ["'"], 'type': ['str'], 'value': ['/folder_name']}
intent: remove directory tree '/folder_name'
body(Left in tags for better readability):
<p> I am getting an 'access is denied' error when I attempt to delete
a folder that is not empty. I used the following command in my
attempt: <code> os.remove("/folder_name") <p> .
<p> What is the most effective way of removing/deleting a
folder/directory that is not empty?

-------------------------------------OUTPUT-------------------------------------

                Expected= "shutil.rmtree('/folder_name')"
           base:Baseline= os.path.realpath('/folder_name')
           body:Baseline= os.remove('/folder_name')
            body:-Blocks= os.pop('/folder_name')
              body:-Code= os.path.remove('/folder_name')
            body:-Inline= os.path.remove_folder('folder_name')
                body:-NL= os.remove('/folder_name')
             base:+Mined= os.chdir('/folder_name')
     body+mined:Baseline= os.remove('/folder_name')
        body+mined:-Code= os.path.exists('/folder_name')
          body+mined:-NL= os.path.expanduser('/folder_name')
      body+mined:-Blocks= os.remove('/folder_name')
      body+mined:-Inline= os.path.exists('/folder_name')

================================================================================

QUESTION: idx=376    id=13740672
-------------------------------------INPUTS-------------------------------------

tags: pandas
score: 16
slot_map: {'key': ['var_0', 'var_1', 'var_2'], 'quote': ['`', '`', '`'], 'type': ['var', 'var', 'var'], 'value': ['weekday', 'data', 'my_dt']}
intent: create a new column `weekday` in pandas data frame `data` based on the values in column `my_dt`
body(Left in tags for better readability):
<p> I'd like to filter out weekend data and only look at data for
weekdays (mon(0)-fri(4)).  I'm new to pandas, what's the best way to
accomplish this in pandas?
<code_block>
 import datetime
from pandas import *

data = read_csv("data.csv")
data.my_dt

<console_out>
0     2012-10-01 02:00:39
1     2012-10-01 02:00:38
2     2012-10-01 02:01:05
3     2012-10-01 02:01:07
4     2012-10-01 02:02:03
5     2012-10-01 02:02:09
6     2012-10-01 02:02:03
7     2012-10-01 02:02:35
8     2012-10-01 02:02:33
9     2012-10-01 02:03:01
10    2012-10-01 02:08:53
11    2012-10-01 02:09:04
12    2012-10-01 02:09:09
13    2012-10-01 02:10:20
14    2012-10-01 02:10:45
<console_out>

<p> I'd like to do something like:
<code_block>
 weekdays_only = data[data.my_dt.weekday() < 5]

<p> AttributeError: 'numpy.int64' object has no attribute 'weekday'
<p> but this doesn't work, I haven't quite grasped how column datetime
objects are accessed.
<p> The eventual goal being to arrange hierarchically to weekday hour-
range, something like:
<code_block>
 monday, 0-6, 7-12, 13-18, 19-23
tuesday, 0-6, 7-12, 13-18, 19-23


-------------------------------------OUTPUT-------------------------------------

                Expected= "data['weekday'] = data['my_dt'].apply(lambda x: x.weekday())"
           base:Baseline= pd.concat([data['weekday'], axis=1)
           body:Baseline= pd.merge(df['weekday'], axis=1)
            body:-Blocks= df['weekday'] = df['My_dt'].strftime('%B')
              body:-Code= pd.concat([data['weekday'], axis=1)
            body:-Inline= pd.concat([data.my_dt.weekday()], axis=1)
                body:-NL= pd.concat([data.my_dt.weekday()], axis=1)
             base:+Mined= pd.concat([df['weekday'], axis=1)
     body+mined:Baseline= df['weekday'].str[0]
        body+mined:-Code= pd.to_datetime(data['my_dt'], how='weekday')
          body+mined:-NL= df['weekday'].apply(lambda x: x.dt.weekday() < 5).astype(float)
      body+mined:-Blocks= data['weekday'].apply(lambda x: datetime.datetime.weekday(x['my_dt'])
      body+mined:-Inline= df['weekday'].apply(lambda x: x.weekday() < 5).astype(float)

================================================================================

QUESTION: idx=377    id=20950650
-------------------------------------INPUTS-------------------------------------

tags: sorting, collections, counter
score: 171
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['x']}
intent: reverse sort counter `x` by values
body(Left in tags for better readability):
<p> Other than doing list comprehensions of reversed list
comprehension, is there a pythonic way to sort Counter by value? If
so, it is faster than this:
<code_block>
 <console_in> from collections import Counter
<console_in> x = Counter({'a':5, 'b':3, 'c':7})
<console_in> sorted(x)
<console_out> ['a', 'b', 'c']
<console_in> sorted(x.items())
<console_out> [('a', 5), ('b', 3), ('c', 7)]
<console_in> [(l,k) for k,l in sorted([(j,i) for i,j in x.items()])]
<console_out> [('b', 3), ('a', 5), ('c', 7)]
<console_in> [(l,k) for k,l in sorted([(j,i) for i,j in x.items()],
reverse=True)]
<console_out> [('c', 7), ('a', 5), ('b', 3)


-------------------------------------OUTPUT-------------------------------------

                Expected= 'sorted(x, key=x.get, reverse=True)'
           base:Baseline= sorted(x, key=lambda x: x[1])
           body:Baseline= sorted(x, key=lambda x: reverse=True)
            body:-Blocks= sorted(x, key=lambda x: x[1])
              body:-Code= sorted(x, key=operator.itemgetter(x))
            body:-Inline= x.sort(key=lambda x: reverse=True)
                body:-NL= sorted(x, key=lambda x: reverse=True)
             base:+Mined= sorted(x, key=lambda x: x[1])
     body+mined:Baseline= sorted(x, reverse=True)
        body+mined:-Code= sorted(x, key=lambda x: x[1])
          body+mined:-NL= sorted(Counter({'a': 5, 'b': 3, 'c': 7}, reverse=True)
      body+mined:-Blocks= sorted(x, key=Counter.get)
      body+mined:-Inline= sorted(x, key=lambda x: reverse=True)

================================================================================

QUESTION: idx=378    id=20950650
-------------------------------------INPUTS-------------------------------------

tags: sorting, collections, counter
score: 171
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['x']}
intent: reverse sort counter `x` by value
body(Left in tags for better readability):
<p> Other than doing list comprehensions of reversed list
comprehension, is there a pythonic way to sort Counter by value? If
so, it is faster than this:
<code_block>
 <console_in> from collections import Counter
<console_in> x = Counter({'a':5, 'b':3, 'c':7})
<console_in> sorted(x)
<console_out> ['a', 'b', 'c']
<console_in> sorted(x.items())
<console_out> [('a', 5), ('b', 3), ('c', 7)]
<console_in> [(l,k) for k,l in sorted([(j,i) for i,j in x.items()])]
<console_out> [('b', 3), ('a', 5), ('c', 7)]
<console_in> [(l,k) for k,l in sorted([(j,i) for i,j in x.items()],
reverse=True)]
<console_out> [('c', 7), ('a', 5), ('b', 3)


-------------------------------------OUTPUT-------------------------------------

                Expected= 'sorted(list(x.items()), key=lambda pair: pair[1], reverse=True)'
           base:Baseline= sorted(x, key=lambda x: x[1])
           body:Baseline= sorted(x, key=lambda x: reverse=True)
            body:-Blocks= sorted(x, key=lambda x: x[1])
              body:-Code= sorted(x, key=operator.itemgetter(x))
            body:-Inline= x.sort(key=lambda x: reverse=True)
                body:-NL= sorted(x, key=lambda x: reverse=True)
             base:+Mined= sorted(x, key=lambda x: x[1])
     body+mined:Baseline= sorted(x, reverse=True)
        body+mined:-Code= sorted(x, key=lambda x: x[1])
          body+mined:-NL= sorted(Counter({'a': 5, 'b': 3, 'c': 7})
      body+mined:-Blocks= sorted(x, key=Counter.get)
      body+mined:-Inline= sorted(x, key=lambda x: reverse=True)

================================================================================

QUESTION: idx=379    id=9775297
-------------------------------------INPUTS-------------------------------------

tags: numpy
score: 217
slot_map: {'key': ['str_0', 'str_1'], 'quote': ["'", "'"], 'type': ['str', 'str'], 'value': ['b', 'a']}
intent: append a numpy array 'b' to a numpy array 'a'
body(Left in tags for better readability):
<p> I have a numpy_array. Something like <code> [ a b c ] <p> .
<p> And then I want to concatenate it with another NumPy array (just
like we create a list of lists). How do we create a NumPy array
containing NumPy arrays?
<p> I tried to do the following without any luck
<code_block>
 <console_in> M = np.array([])
<console_in> M
<console_out> array([], dtype=float64)
<console_in> M.append(a,axis=0)
<console_out> Traceback (most recent call last):
 File " <stdin>", line 1, in <module>
AttributeError: 'numpy.ndarray' object has no attribute 'append'
<console_in> a
<console_out> array([1, 2, 3])


-------------------------------------OUTPUT-------------------------------------

                Expected= 'np.vstack((a, b))'
           base:Baseline= a.append(b, a)
           body:Baseline= numpy.ndarray(a, axis=0)
            body:-Blocks= a = np.array([a, b])
              body:-Code= np.array([a, b])
            body:-Inline= M.append(a, axis=0)
                body:-NL= M.append(a, axis=0)
             base:+Mined= a.append(b, a)
     body+mined:Baseline= M = np.array([1, 2, 3])
        body+mined:-Code= np.concatenate((a, b))
          body+mined:-NL= M = np.append(a, dtype=float64)
      body+mined:-Blocks= a.append(b, axis=1)
      body+mined:-Inline= numpy.ndarray([1, 2, 3])

================================================================================

QUESTION: idx=380    id=21887754
-------------------------------------INPUTS-------------------------------------

tags: arrays, numpy, concatenation
score: 75
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['a', 'b']}
intent: numpy concatenate two arrays `a` and `b` along the first axis
body(Left in tags for better readability):
<p> I tried the following:
<code_block>
 <console_in> a = np.array([1,2,3])
<console_in> b = np.array([4,5,6])
<console_in> np.concatenate((a,b), axis=0)
<console_out> array([1, 2, 3, 4, 5, 6])
<console_in> np.concatenate((a,b), axis=1)
<console_out> array([1, 2, 3, 4, 5, 6])

<p> However, I'd expect at least that one result looks like this
<code_block>
 array([[1, 2, 3],
       [4, 5, 6]])

<p> Why is it not concatenated vertically?

-------------------------------------OUTPUT-------------------------------------

                Expected= 'print(concatenate((a, b), axis=0))'
           base:Baseline= numpy.concat([a, b])
           body:Baseline= np.concatenate((a, b), axis=1)
            body:-Blocks= numpy.concat([a, b])
              body:-Code= numpy.concat([a, b])
            body:-Inline= np.concatenate(a, b), axis=1)
                body:-NL= np.concatenate((a, b), axis=1)
             base:+Mined= np.concatenate((a, b), axis=1)
     body+mined:Baseline= np.concatenate((a, b), axis=1)
        body+mined:-Code= np.concatenate(a, b), axis=1)
          body+mined:-NL= np.concatenate((a, b), axis=1)
      body+mined:-Blocks= np.concatenate(a, b, axis=0)
      body+mined:-Inline= np.concatenate((a, b), axis=1)

================================================================================

QUESTION: idx=381    id=21887754
-------------------------------------INPUTS-------------------------------------

tags: arrays, numpy, concatenation
score: 75
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['a', 'b']}
intent: numpy concatenate two arrays `a` and `b` along the second axis
body(Left in tags for better readability):
<p> I tried the following:
<code_block>
 <console_in> a = np.array([1,2,3])
<console_in> b = np.array([4,5,6])
<console_in> np.concatenate((a,b), axis=0)
<console_out> array([1, 2, 3, 4, 5, 6])
<console_in> np.concatenate((a,b), axis=1)
<console_out> array([1, 2, 3, 4, 5, 6])

<p> However, I'd expect at least that one result looks like this
<code_block>
 array([[1, 2, 3],
       [4, 5, 6]])

<p> Why is it not concatenated vertically?

-------------------------------------OUTPUT-------------------------------------

                Expected= 'print(concatenate((a, b), axis=1))'
           base:Baseline= numpy.concat([a, b])
           body:Baseline= np.concatenate((a, b), axis=1)
            body:-Blocks= numpy.concat([a, b])
              body:-Code= numpy.concat([a, b])
            body:-Inline= np.concatenate(a, b), axis=1)
                body:-NL= np.concatenate((a, b), axis=1)
             base:+Mined= np.concatenate((a, b), axis=1)
     body+mined:Baseline= np.concatenate((a, b), axis=1)
        body+mined:-Code= np.concatenate(a, b), axis=1)
          body+mined:-NL= np.concatenate((a, b), axis=1)
      body+mined:-Blocks= np.concatenate(a, b, axis=1)
      body+mined:-Inline= np.concatenate((a, b), axis=1)

================================================================================

QUESTION: idx=382    id=21887754
-------------------------------------INPUTS-------------------------------------

tags: arrays, numpy, concatenation
score: 75
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['a', 'b']}
intent: numpy concatenate two arrays `a` and `b` along the first axis
body(Left in tags for better readability):
<p> I tried the following:
<code_block>
 <console_in> a = np.array([1,2,3])
<console_in> b = np.array([4,5,6])
<console_in> np.concatenate((a,b), axis=0)
<console_out> array([1, 2, 3, 4, 5, 6])
<console_in> np.concatenate((a,b), axis=1)
<console_out> array([1, 2, 3, 4, 5, 6])

<p> However, I'd expect at least that one result looks like this
<code_block>
 array([[1, 2, 3],
       [4, 5, 6]])

<p> Why is it not concatenated vertically?

-------------------------------------OUTPUT-------------------------------------

                Expected= 'c = np.r_[a[(None), :], b[(None), :]]'
           base:Baseline= numpy.concat([a, b])
           body:Baseline= np.concatenate((a, b), axis=1)
            body:-Blocks= numpy.concat([a, b])
              body:-Code= numpy.concat([a, b])
            body:-Inline= np.concatenate(a, b), axis=1)
                body:-NL= np.concatenate((a, b), axis=1)
             base:+Mined= np.concatenate((a, b), axis=1)
     body+mined:Baseline= np.concatenate((a, b), axis=1)
        body+mined:-Code= np.concatenate(a, b), axis=1)
          body+mined:-NL= np.concatenate((a, b), axis=1)
      body+mined:-Blocks= np.concatenate(a, b, axis=0)
      body+mined:-Inline= np.concatenate((a, b), axis=1)

================================================================================

QUESTION: idx=383    id=21887754
-------------------------------------INPUTS-------------------------------------

tags: arrays, numpy, concatenation
score: 75
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['a', 'b']}
intent: numpy concatenate two arrays `a` and `b` along the first axis
body(Left in tags for better readability):
<p> I tried the following:
<code_block>
 <console_in> a = np.array([1,2,3])
<console_in> b = np.array([4,5,6])
<console_in> np.concatenate((a,b), axis=0)
<console_out> array([1, 2, 3, 4, 5, 6])
<console_in> np.concatenate((a,b), axis=1)
<console_out> array([1, 2, 3, 4, 5, 6])

<p> However, I'd expect at least that one result looks like this
<code_block>
 array([[1, 2, 3],
       [4, 5, 6]])

<p> Why is it not concatenated vertically?

-------------------------------------OUTPUT-------------------------------------

                Expected= 'np.array((a, b))'
           base:Baseline= numpy.concat([a, b])
           body:Baseline= np.concatenate((a, b), axis=1)
            body:-Blocks= numpy.concat([a, b])
              body:-Code= numpy.concat([a, b])
            body:-Inline= np.concatenate(a, b), axis=1)
                body:-NL= np.concatenate((a, b), axis=1)
             base:+Mined= np.concatenate((a, b), axis=1)
     body+mined:Baseline= np.concatenate((a, b), axis=1)
        body+mined:-Code= np.concatenate(a, b), axis=1)
          body+mined:-NL= np.concatenate((a, b), axis=1)
      body+mined:-Blocks= np.concatenate(a, b, axis=0)
      body+mined:-Inline= np.concatenate((a, b), axis=1)

================================================================================

QUESTION: idx=384    id=2805231
-------------------------------------INPUTS-------------------------------------

tags: dns
score: 99
slot_map: {'key': ['str_0'], 'quote': ["'"], 'type': ['str'], 'value': ['google.com']}
intent: fetch address information for host 'google.com' ion port 80
body(Left in tags for better readability):
<a> dnspython <p>  will do my DNS lookups very nicely, but it entirely
ignores the contents of <code> /etc/hosts <p> .
<p> Is there a python library call which will do the right thing? ie
check first in <code> etc/hosts <p> , and only fall back to DNS
lookups otherwise?

-------------------------------------OUTPUT-------------------------------------

                Expected= "print(socket.getaddrinfo('google.com', 80))"
           base:Baseline= fetch('google.com', port=80)
           body:Baseline= dnspython.findall('google.com', 80)
            body:-Blocks= dnspython.find('google.com', port=80)
              body:-Code= fetch('google.com', port 80)
            body:-Inline= fetch('google.com', port 80)
                body:-NL= fetch('google.com', shell=True)
             base:+Mined= server.serve_forever()
     body+mined:Baseline= dnspython.fetchhostname('google.com', port 80)
        body+mined:-Code= fetch('google.com', port 80)
          body+mined:-NL= os.environ['google.com'][0]
      body+mined:-Blocks= fetchaddr('google.com', 80)
      body+mined:-Inline= print(os.environ['google.com'][0]))

================================================================================

QUESTION: idx=385    id=17552997
-------------------------------------INPUTS-------------------------------------

tags: pandas
score: 11
slot_map: {'key': ['str_0', 'str_1', 'var_0'], 'quote': ["'", "'", '`'], 'type': ['str', 'str', 'var'], 'value': ['day', 'sat', 'df']}
intent: add a column 'day' with value 'sat' to dataframe `df`
body(Left in tags for better readability):
<p> I'm using a MultiIndexed pandas DataFrame and would like to
multiply a subset of the DataFrame by a certain number.
<p> It's the same as <a> this <p>  but with a MultiIndex.
<code_block>
 <console_in> d =
pd.DataFrame({'year':[2008,2008,2008,2008,2009,2009,2009,2009],
<console_out>
'flavour':['strawberry','strawberry','banana','banana',
                      'strawberry','strawberry','banana','banana'],
'day':['sat','sun','sat','sun','sat','sun','sat','sun'],
                      'sales':[10,12,22,23,11,13,23,24]})

<console_in> d = d.set_index(['year','flavour','day'])
<console_out>
<console_in> d
<console_out>                     sales
year flavour    day
2008 strawberry sat     10
                sun     12
     banana     sat     22
                sun     23
2009 strawberry sat     11
                sun     13
     banana     sat     23
                sun     24

<p> So far, so good. But let's say I spot that all the Saturday
figures are only half what they should be! I'd like to multiply all
<code> sat <p>  sales by 2.
<p> My first attempt at this was:
<code_block>
 sat = d.xs('sat', level='day')
sat = sat * 2
d.update(sat)

<p> but this doesn't work because the variable <code> sat <p>  has
lost the <code> day <p>  level of the index:
<code_block>
 <console_in> sat
<console_out>                 sales
year flavour
2008 strawberry     20
     banana         44
2009 strawberry     22
     banana         46

<p> so pandas doesn't know how to join the new sales figures back onto
the old dataframe.
<p> I had a quick stab at:
<code_block>
 <console_in> sat = d.xs('sat', level='day', copy=False)
<console_out> Traceback (most recent call last):
  File " <stdin>", line 1, in <module>
  File "C:\Python27\lib\site-packages\pandas\core\frame.py", line
2248, in xs
    raise ValueError('Cannot retrieve view (copy=False)')
ValueError: Cannot retrieve view (copy=False)

<p> I have no idea what that error means, but I feel like I'm making a
mountain out of a molehill. Does anyone know the right way to do this?
<p> Thanks in advance,
Rob

-------------------------------------OUTPUT-------------------------------------

                Expected= "df.xs('sat', level='day', drop_level=False)"
           base:Baseline= df['Day'].strftime('sat')
           body:Baseline= df['day'].set_index(['sat'])
            body:-Blocks= df['Day'].strftime('sat')
              body:-Code= df['Day'].strftime('sat')
            body:-Inline= df.set_index(['day', 'sat'])
                body:-NL= df['day'] = df['sat', level='day')
             base:+Mined= df['day'] = df['sat'].astype(float)
     body+mined:Baseline= df.ix['day'].apply(lambda x: x.strftime('sat'))
        body+mined:-Code= df['Sales'].fillna(0)
          body+mined:-NL= df['day'] = df['year'].apply(lambda x: x['day'], axis=1)
      body+mined:-Blocks= df.ix[(df.index.day == 2).sum()]
      body+mined:-Inline= df.loc[df['day'].isin(['year', 'day'])]

================================================================================

QUESTION: idx=386    id=4356842
-------------------------------------INPUTS-------------------------------------

tags: django
score: 52
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: return a 401 unauthorized in django
body(Left in tags for better readability):
<p> Instead of doing this:
<code_block>
 res = HttpResponse("Unauthorized")
res.status_code = 401
return res

<p> Is there a way to do it without typing it every time?

-------------------------------------OUTPUT-------------------------------------

                Expected= "return HttpResponse('Unauthorized', status=401)"
           base:Baseline= return a 401(0, 1)
           body:Baseline= res.status_code = 401 unauthorized)
            body:-Blocks= return (401)(None)
return (401)()
              body:-Code= return (401)(expand=False)
            body:-Inline= res = HttpResponse('Unauthorized')
                body:-NL= res.Response('Unauthorized')
             base:+Mined= return HttpResponse(status=401, error=False)
     body+mined:Baseline= return HttpResponse('Unauthorized')
        body+mined:-Code= return super(MyModel, self).save(*args, **kwargs)
          body+mined:-NL= return HttpResponse('Unauthorized')
      body+mined:-Blocks= return HttpResponse(status=401)
      body+mined:-Inline= return HttpResponse('Unauthorized', 401)

================================================================================

QUESTION: idx=387    id=13598363
-------------------------------------INPUTS-------------------------------------

tags: flask, jinja2
score: 58
slot_map: {'key': ['str_0'], 'quote': ["'"], 'type': ['str'], 'value': ['wherever']}
intent: flask set folder 'wherever' as the default template folder
body(Left in tags for better readability):
<p> By default flask uses template files stored in "template"
directory :
<code_block>
 /flaskapp
    /application.py
    /templates
        /hello.html

<p> Is there any way to dynamically choose template directory
according to user logged in? This is how I want the directory
structure to be :
<code_block>
 /flaskapp
    /application.py
    /templates (default template goes here)
        /hello.html
    /userdata
        /user1
            /template1
                 hello.html
            /template2
                 hello.html
        /user2
            /template1
                 hello.html
            /template2
                 hello.html

<p> Now if I have the username of logged in user and the name of
template activated by user, is it possible to dynamically select the
directory to load template files? For example,
<code_block>
 /userdata/ <username>/ <activated template name>/

<p> instead of fixed
<code_block>
 /templates/

<p> What I am trying to achieve is a wordpress like theme system for
my web application where users can upload/select themes for his
website.

-------------------------------------OUTPUT-------------------------------------

                Expected= "Flask(__name__, template_folder='wherever')"
           base:Baseline= flask.set_folder('wherever')
           body:Baseline= flaskapp.set_default_folder('wherever')
            body:-Blocks= flask.set_folder('wherever')
              body:-Code= flask.set_folder('wherever')
            body:-Inline= flaskapp.set_folder('wherever')
                body:-NL= flask.set_folder('wherever')
             base:+Mined= app.run(host='wherever')
     body+mined:Baseline= app.config['wherever'] = os.path.expanduser('template')
        body+mined:-Code= app.run(host='wherever')
          body+mined:-NL= os.path.expanduser('wherever')
      body+mined:-Blocks= app.run(host='wherever')
      body+mined:-Inline= app.run(folder='wherever')

================================================================================

QUESTION: idx=388    id=1849375
-------------------------------------INPUTS-------------------------------------

tags: sqlalchemy
score: 30
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: how do i insert into t1 (select * from t2) in sqlalchemy?
body(Left in tags for better readability):
<p> In SQLAlchemy, how do I populate or update a table from a <code>
SELECT <p>  statement?

-------------------------------------OUTPUT-------------------------------------

                Expected= "session.execute('INSERT INTO t1 (SELECT * FROM t2)')"
           base:Baseline= driver.find_element_by_xpath('select * from t2')
           body:Baseline= sqlAlchemy.insert(select * FROM t2))
            body:-Blocks= cursor.execute('INSERT INTO t1, SELECT * FROM t2')
              body:-Code= del table(select * from t2))
            body:-Inline= print([item[0] for item in t1 if item[2] not in t2])
                body:-NL= [(select * from t2) for sublist in sqlalchemy]
             base:+Mined= session.query(select * FROM t2)
     body+mined:Baseline= cursor.execute('SELECT * FROM t2')
        body+mined:-Code= print(engine.execute('SELECT * FROM t2')
          body+mined:-NL= cursor.execute('SELECT * FROM t2')
      body+mined:-Blocks= session.query('select * from t2')
      body+mined:-Inline= session.query(select([1, 2, 3], [4, 5, 6]]))

================================================================================

QUESTION: idx=389    id=3398589
-------------------------------------INPUTS-------------------------------------

tags: list, sorting
score: 9
slot_map: {'key': ['str_0'], 'quote': ["'"], 'type': ['str'], 'value': ['c2']}
intent: sort a list of lists 'c2' such that third row comes first
body(Left in tags for better readability):
<code_block>
 c2=[]
row1=[1,22,53]
row2=[14,25,46]
row3=[7,8,9]

c2.append(row2)
c2.append(row1)
c2.append(row3)

<code> c2 <p>  is now:
<code_block>
 [[14, 25, 46], [1, 22, 53], [7, 8, 9]]

<p> how do i sort <code> c2 <p>  in such a way that for example:
<code_block>
 for row in c2:

sort on row[2]

<p> the result would be:
<code_block>
 [[7,8,9],[14,25,46],[1,22,53]]

<p> the other question is how do i first sort by row[2] and within
that set by row[1]

-------------------------------------OUTPUT-------------------------------------

                Expected= 'c2.sort(key=lambda row: row[2])'
           base:Baseline= sorted(c2, key=lambda x: x[1])
           body:Baseline= sorted(list(c2.items()), key=lambda x: x[2], reverse=True)
            body:-Blocks= sorted(list(c2, key=lambda x: x[1])
              body:-Code= sorted(c2, key=lambda x: x[2])
            body:-Inline= sorted(list(c2.items()), key=lambda x: x[1])
                body:-NL= sorted(c2, key=lambda x: x[1])
             base:+Mined= sorted(c2, key=lambda x: x[1])
     body+mined:Baseline= sorted(c2, key=lambda x: x[2], reverse=True)
        body+mined:-Code= sorted(c2, key=lambda row: row[1])
          body+mined:-NL= c2.sort(key=lambda x: x[1])
      body+mined:-Blocks= sorted(c2, key=lambda row: (row[1], row[2]))
      body+mined:-Inline= sorted(c2, key=lambda x: (x[2], x[3]))

================================================================================

QUESTION: idx=390    id=3398589
-------------------------------------INPUTS-------------------------------------

tags: list, sorting
score: 9
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: sorting a list of lists in python
body(Left in tags for better readability):
<code_block>
 c2=[]
row1=[1,22,53]
row2=[14,25,46]
row3=[7,8,9]

c2.append(row2)
c2.append(row1)
c2.append(row3)

<code> c2 <p>  is now:
<code_block>
 [[14, 25, 46], [1, 22, 53], [7, 8, 9]]

<p> how do i sort <code> c2 <p>  in such a way that for example:
<code_block>
 for row in c2:

sort on row[2]

<p> the result would be:
<code_block>
 [[7,8,9],[14,25,46],[1,22,53]]

<p> the other question is how do i first sort by row[2] and within
that set by row[1]

-------------------------------------OUTPUT-------------------------------------

                Expected= 'c2.sort(key=lambda row: (row[2], row[1], row[0]))'
           base:Baseline= sorted(list, key=lambda x: x[1])
           body:Baseline= sorted(list(c2.items()), key=lambda x: x[1], reverse=True)
            body:-Blocks= sorted(list, key=lambda x: x[1])
              body:-Code= sorted(list, key=lambda x: x[1])
            body:-Inline= sorted(list(range(1)), key=lambda x: x[1])
                body:-NL= sorted(list(c2.items()), key=lambda x: x[1])
             base:+Mined= sorted(lst, key=lambda x: x[1])
     body+mined:Baseline= c2.sort(key=lambda x: x[2])
        body+mined:-Code= sorted(a, key=lambda x: x[1])
          body+mined:-NL= c2.sort(key=lambda x: x[1])
      body+mined:-Blocks= sorted(c2, key=lambda x: (x[1], x[1]))
      body+mined:-Inline= sorted(c2, key=lambda x: (x[2], x[1]))

================================================================================

QUESTION: idx=391    id=3398589
-------------------------------------INPUTS-------------------------------------

tags: list, sorting
score: 9
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: sorting a list of lists in python
body(Left in tags for better readability):
<code_block>
 c2=[]
row1=[1,22,53]
row2=[14,25,46]
row3=[7,8,9]

c2.append(row2)
c2.append(row1)
c2.append(row3)

<code> c2 <p>  is now:
<code_block>
 [[14, 25, 46], [1, 22, 53], [7, 8, 9]]

<p> how do i sort <code> c2 <p>  in such a way that for example:
<code_block>
 for row in c2:

sort on row[2]

<p> the result would be:
<code_block>
 [[7,8,9],[14,25,46],[1,22,53]]

<p> the other question is how do i first sort by row[2] and within
that set by row[1]

-------------------------------------OUTPUT-------------------------------------

                Expected= 'c2.sort(key=lambda row: (row[2], row[1]))'
           base:Baseline= sorted(list, key=lambda x: x[1])
           body:Baseline= sorted(list(c2.items()), key=lambda x: x[1], reverse=True)
            body:-Blocks= sorted(list, key=lambda x: x[1])
              body:-Code= sorted(list, key=lambda x: x[1])
            body:-Inline= sorted(list(range(1)), key=lambda x: x[1])
                body:-NL= sorted(list(c2.items()), key=lambda x: x[1])
             base:+Mined= sorted(lst, key=lambda x: x[1])
     body+mined:Baseline= c2.sort(key=lambda x: x[2])
        body+mined:-Code= sorted(a, key=lambda x: x[1])
          body+mined:-NL= c2.sort(key=lambda x: x[1])
      body+mined:-Blocks= sorted(c2, key=lambda x: (x[1], x[1]))
      body+mined:-Inline= sorted(c2, key=lambda x: (x[2], x[1]))

================================================================================

QUESTION: idx=392    id=10960463
-------------------------------------INPUTS-------------------------------------

tags: unicode, matplotlib, ascii
score: 47
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['Arial']}
intent: set font `arial` to display non-ascii characters in matplotlib
body(Left in tags for better readability):
<p> I have a problem displaying non- <a> ASCII <p>  characters in
Matplotlib, these characters are rendered as small boxes instead of a
proper font, it looks like (I filled these boxes with red paint to
hightlight them):

<p> How do I fix it?
<p> A related question is <a> Accented characters in Matplotlib <p> .

-------------------------------------OUTPUT-------------------------------------

                Expected= "matplotlib.rc('font', **{'sans-serif': 'Arial', 'family': 'sans-serif'})"
           base:Baseline= ax.set_font('arial')
           body:Baseline= matplotlib.set_font('arial')
            body:-Blocks= ax.set_font('arial')
              body:-Code= matplotlib.set_font('arial')
            body:-Inline= matplotlib.set_font('arial')
                body:-NL= arial.set_font('ignore')
             base:+Mined= plt.savefig('arial.png')
     body+mined:Baseline= matplotlib.use('font', 'arial')
        body+mined:-Code= matplotlib.rcParams.set_face(arial)
          body+mined:-NL= ax.set_font('arial')
      body+mined:-Blocks= matplotlib.rcParams.set_xlabel('arial')
      body+mined:-Inline= matplotlib.set_xticklabels(arial)

================================================================================

QUESTION: idx=393    id=20576618
-------------------------------------INPUTS-------------------------------------

tags: datetime, pandas
score: 15
slot_map: {'key': ['str_0', 'str_1'], 'quote': ["'", "'"], 'type': ['str', 'str'], 'value': ['date', 'df']}
intent: convert  datetime column 'date' of pandas dataframe 'df' to ordinal
body(Left in tags for better readability):
<p> I'm trying to create a new Pandas dataframe column with ordinal
day from a datetime column:
<code_block>
 import pandas as pd
from datetime import datetime

print df.ix[0:5]
                              date
file
gom3_197801.nc 2011-02-16 00:00:00
gom3_197802.nc 2011-02-16 00:00:00
gom3_197803.nc 2011-02-15 00:00:00
gom3_197804.nc 2011-02-17 00:00:00
gom3_197805.nc 2011-11-14 00:00:00

df['date'][0].toordinal()

<console_out>
734184

df['date'].toordinal()

----------------------------------------------------------------------
-----
AttributeError                            Traceback (most recent call
last)
<ipython-input-7-dbfd5e8b60f0> in <module>()
----> 1 df['date'].toordinal()

AttributeError: 'Series' object has no attribute 'toordinal'

<p> I guess this is a basic question, but I've struggled reading docs
for last 30 minutes.
<p> How can I create an ordinal time column for my dataframe?

-------------------------------------OUTPUT-------------------------------------

                Expected= "df['date'].apply(lambda x: x.toordinal())"
           base:Baseline= df['date'].strftime('%Y')
           body:Baseline= df['date'].toordinal()
            body:-Blocks= df['date'].strftime('%B')
              body:-Code= df['Date'] = df['OrderedDay']
            body:-Inline= df['date'].toordinal()
                body:-NL= df['date'].toordinal()
             base:+Mined= df['Date'].astype('int')
     body+mined:Baseline= df['date'].toordinal()
        body+mined:-Code= df['date'] = df['date'].astype('OrderedDict')
          body+mined:-NL= df['date'].toordinal()
      body+mined:-Blocks= df['date'] = df['date'].astype(' ordinal')
      body+mined:-Inline= df['date'].toordinal()

================================================================================

QUESTION: idx=394    id=7263824
-------------------------------------INPUTS-------------------------------------

tags: selenium, selenium-webdriver, webdriver, automated-tests
score: 527
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['element']}
intent: get html source of selenium webelement `element`
body(Left in tags for better readability):
<p> I'm using the Python bindings to run Selenium WebDriver:
<code_block>
 from selenium import webdriver
wd = webdriver.Firefox()

<p> I know I can grab a webelement like so:
<code_block>
 elem = wd.find_element_by_css_selector('#my-id')

<p> And I know I can get the full page source with...
<code_block>
 wd.page_source

<p> But is there a way to get the "element source"?
<code_block>
 elem.source   # <-- returns the HTML as a string

<p> The Selenium WebDriver documentation for Python are basically non-
existent and I don't see anything in the code that seems to enable
that functionality.
<p> What is the best way to access the HTML of an element (and its
children)?

-------------------------------------OUTPUT-------------------------------------

                Expected= "element.get_attribute('innerHTML')"
           base:Baseline= element.find_element_by_css_id()
           body:Baseline= webbrowser.find_element_by_css_selector('#my-id')
            body:-Blocks= driver.find_element_source(element)
              body:-Code= driver.find_element_by_css_selector(element)
            body:-Inline= webbrowser.find_element(element)
                body:-NL= wd.find_element_by_css_selector('#my-id')
             base:+Mined= element = webdriver.find_element_by_css_selector("//div[@class='class']"
    ).find_elements()
     body+mined:Baseline= element = webdriver.get('http://www.google.com')
        body+mined:-Code= print(element.find('http://www.google.com').read())
          body+mined:-NL= webbrowser.find_element_by_css_selector('#my-id')
      body+mined:-Blocks= driver.get('http://stackoverflow.com')
      body+mined:-Inline= element = driver.get('http://stackoverflow.com')

================================================================================

QUESTION: idx=395    id=31793195
-------------------------------------INPUTS-------------------------------------

tags: pandas
score: 6
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['bob']}
intent: get the integer location of a key `bob` in a pandas data frame
body(Left in tags for better readability):
<p> How can I get the integer location of a key to a pandas index as
quickly as possible?
<p> eg, given <code>
pd.DataFrame(data=np.asarray([[1,2,3],[4,5,6],[7,8,9]]),
index=['alice', 'bob', 'charlie'])
<p> what is the fastest way to go from 'bob' to 1

-------------------------------------OUTPUT-------------------------------------

                Expected= "df.index.get_loc('bob')"
           base:Baseline= df['bob'].loc[0]
           body:Baseline= df['bob'] = np.array([1, 2, 3], index=['charlie'])
            body:-Blocks= df.loc[:, (np.asarray([['bob'], 'charlie'])]
              body:-Code= df['bob'].loc[0]
            body:-Inline= df['bob'] = df['id']
                body:-NL= df['bob'] = df['Alice']
             base:+Mined= df.loc[df['bob'] == 1]
     body+mined:Baseline= df['a'] = df['bob'].loc[0]
        body+mined:-Code= df['bob'] = df['location']
          body+mined:-NL= pd.concat([df['bob']], axis=1)
      body+mined:-Blocks= df['bob'] = df['index']
      body+mined:-Inline= df.loc[df['bob'] == 1]

================================================================================

QUESTION: idx=396    id=7574841
-------------------------------------INPUTS-------------------------------------

tags: terminal
score: 15
slot_map: {'key': ['str_0', 'str_1'], 'quote': ["'", "'"], 'type': ['str', 'str'], 'value': ['gnome', 'sudo apt-get update']}
intent: open a 'gnome' terminal from python script and run  'sudo apt-get update' command.
body(Left in tags for better readability):
<p> I'm developing a program that has a button. When pressed, I want
to open a terminal that runs:
<code_block>
 sudo apt-get update

<p> I'm using:
<code_block>
 os.system("gnome-terminal -e 'sudo apt-get update'")

<p> This works fine. The only problem is that when the update is
finished, the terminal closes.
What can I do to leave the terminal open?

-------------------------------------OUTPUT-------------------------------------

                Expected= 'os.system(\'gnome-terminal -e \\\'bash -c "sudo apt-get update; exec bash"\\\'\')'
           base:Baseline= os.system('gnome', shell=True)
           body:Baseline= os.system('gnome-terminal -e'sudo apt-get update'')
            body:-Blocks= os.system('gnome', shell=True)
              body:-Code= os.system('gnome', shell=True)
            body:-Inline= os.system('gnome-terminal -e'sudo apt-get update'')
                body:-NL= os.system('gnome-terminal -e'sudo apt-get update'")
             base:+Mined= os.system('sudo apt-get update')
     body+mined:Baseline= os.system('gnome-terminal -e'sudo apt-get update')
        body+mined:-Code= os.system('sudo apt-get update')
          body+mined:-NL= os.system('gnome-terminal -e'sudo apt-get update'")
      body+mined:-Blocks= os.system('sudo apt-get update')
      body+mined:-Inline= os.system('gnome-terminal -e'sudo apt-get update'')

================================================================================

QUESTION: idx=397    id=10487278
-------------------------------------INPUTS-------------------------------------

tags: arrays
score: 410
slot_map: {'key': ['str_0', 'var_0'], 'quote': ["'", '`'], 'type': ['str', 'var'], 'value': ['third_key', 'my_dict']}
intent: add an item with key 'third_key' and value 1 to an dictionary `my_dict`
body(Left in tags for better readability):
<p> I'm trying to add items to an array in python.
<p> I run
<code_block>
 array = {}

<p> Then, I try to add something to this array by doing:
<code_block>
 array.append(valueToBeInserted)

<p> There doesn't seem to be a <code> .append <p>  method for this.
How do I add items to an array?

-------------------------------------OUTPUT-------------------------------------

                Expected= "my_dict.update({'third_key': 1})"
           base:Baseline= my_dict.update({'third_key': 1})
           body:Baseline= my_dict.update({'third_key': 1})
            body:-Blocks= my_dict.items()[1]
              body:-Code= my_dict.update({'third_key': 1})
            body:-Inline= my_dict.update({'third_key': 1})
                body:-NL= my_dict.update({'third_key': 1})
             base:+Mined= my_dict.update({'third_key': 1})
     body+mined:Baseline= array = {'third_key': 1, 'value1': 1}
        body+mined:-Code= my_dict.append(1, 1)
          body+mined:-NL= my_dict.append({'third_key': '1'})
      body+mined:-Blocks= my_dict.append(1)
      body+mined:-Inline= array = {'third_key': '1'}

================================================================================

QUESTION: idx=398    id=10487278
-------------------------------------INPUTS-------------------------------------

tags: arrays
score: 410
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: declare an array
body(Left in tags for better readability):
<p> I'm trying to add items to an array in python.
<p> I run
<code_block>
 array = {}

<p> Then, I try to add something to this array by doing:
<code_block>
 array.append(valueToBeInserted)

<p> There doesn't seem to be a <code> .append <p>  method for this.
How do I add items to an array?

-------------------------------------OUTPUT-------------------------------------

                Expected= 'my_list = []'
           base:Baseline= np.array([0, 1], axis=1)
           body:Baseline= array = [item for item in array]
            body:-Blocks= np.array([i for i in range(0, len(i), len(j))])
              body:-Code= np.array([0, 1], axis=1)
            body:-Inline= array = {}
    pass
                body:-NL= numpy.append(valueToBeInserted)
             base:+Mined= array([[1, 2], [3, 4], [5, 6], [7, 8]])
     body+mined:Baseline= array = [[1, 2, 3], [4, 5, 6]]
        body+mined:-Code= array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
          body+mined:-NL= array.append(valueToBeInserted)
      body+mined:-Blocks= array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
      body+mined:-Inline= array = [[1, 2, 3], [4, 5, 6]]

================================================================================

QUESTION: idx=399    id=10487278
-------------------------------------INPUTS-------------------------------------

tags: arrays
score: 410
slot_map: {'key': ['str_0', 'var_0'], 'quote': ['`', '`'], 'type': ['str', 'var'], 'value': ['12', 'my_list']}
intent: insert item `12` to a list `my_list`
body(Left in tags for better readability):
<p> I'm trying to add items to an array in python.
<p> I run
<code_block>
 array = {}

<p> Then, I try to add something to this array by doing:
<code_block>
 array.append(valueToBeInserted)

<p> There doesn't seem to be a <code> .append <p>  method for this.
How do I add items to an array?

-------------------------------------OUTPUT-------------------------------------

                Expected= 'my_list.append(12)'
           base:Baseline= my_list.insert(12)
           body:Baseline= my_list.append(12)
            body:-Blocks= my_list.pop(12)
              body:-Code= my_list.insert(12)
            body:-Inline= my_list = [item for item in my_list]
                body:-NL= my_list.pop(12)
             base:+Mined= my_list.insert(12)
     body+mined:Baseline= my_list.append(12)
        body+mined:-Code= my_list = my_list[12:]
          body+mined:-NL= my_list.append(12)
      body+mined:-Blocks= my_list.append(12)
      body+mined:-Inline= array = [item for item in my_list]

================================================================================

QUESTION: idx=400    id=10155684
-------------------------------------INPUTS-------------------------------------

tags: list, append
score: 13
slot_map: {'key': ['str_0', 'var_0'], 'quote': ["'", '`'], 'type': ['str', 'var'], 'value': ['wuggah', 'myList']}
intent: add an entry 'wuggah' at the beginning of list `mylist`
body(Left in tags for better readability):
<p> I have a <code> list <p>  of about 40 entries. And I frequently
want to append an item to the start of the list (with id 0) and want
to delete the <code> last <p>  entry (with id 40) of the list.
<p> How do I do this the best?
<p> Example with 5 entries:
<code_block>
 [0] = "herp"
[1] = "derp"
[2] = "blah"
[3] = "what"
[4] = "da..."

<p> after adding <code> "wuggah" <p>  and deleting last it should be
like:
<code_block>
 [0] = "wuggah"
[1] = "herp"
[2] = "derp"
[3] = "blah"
[4] = "what"

<p> And I don't want to end up manually moving them one after another
all of the entries to the next id.

-------------------------------------OUTPUT-------------------------------------

                Expected= "myList.insert(0, 'wuggah')"
           base:Baseline= myList[0].startswith('wuggah')
           body:Baseline= mylist[0] = 'wuggah'
            body:-Blocks= mylist.pop('wuggah')
              body:-Code= mylist.pop('wuggah')
            body:-Inline= mylist.pop('wuggah')
                body:-NL= mylist[0].startswith('wuggah')
             base:+Mined= mylist.append('wuggah')
     body+mined:Baseline= mylist.pop('wuggah')
        body+mined:-Code= myList.insert(0, 'wuggah')
          body+mined:-NL= mylist.append('wuggah')
      body+mined:-Blocks= mylist.pop('wuggah')
      body+mined:-Inline= mylist.pop('wuggah')

================================================================================

QUESTION: idx=401    id=3519125
-------------------------------------INPUTS-------------------------------------

tags: hex, representation
score: 6
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: convert a hex-string representation to actual bytes
body(Left in tags for better readability):
<p> i need to load the third column of this text file as a hex string
<a> http://www.netmite.com/android/mydroid/1.6/external/skia/emoji/gmo
jiraw.txt
<code_block>
 <console_in>
open('gmojiraw.txt').read().split('\n')[0].split('\t')[2]
<console_out> '\\xF3\\xBE\\x80\\x80'

<p> how do i open the file so that i can get the third column as hex
string:
<code_block>
 '\xF3\xBE\x80\x80'

<p> i also tried binary mode and hex mode, with no success.

-------------------------------------OUTPUT-------------------------------------

                Expected= '"""\\\\xF3\\\\xBE\\\\x80\\\\x80""".replace(\'\\\\x\', \'\').decode(\'hex\')'
           base:Baseline= struct.unpack('hex-string', 16)
           body:Baseline= open('gmojiraw.txt').read().split('\n')[2]
            body:-Blocks= [int(x) for x in open('mydroid', 'gmojiraw'])
              body:-Code= struct.unpack('hex', 3)
            body:-Inline= struct.unpack('\n')[0].decode('hex')
                body:-NL= [int(x) for x in open('gmojiraw.txt').read().split('\n')]
             base:+Mined= struct.unpack('b', 16)[0]
     body+mined:Baseline= hex_string = ''.join(open('gmojiraw.txt').read().split('\n')[0])
        body+mined:-Code= """""".join(chr(ord(c)) for c in open('mydroid.txt').read())
          body+mined:-NL= """""".join(struct.unpack('Q', s))
      body+mined:-Blocks= struct.unpack('<I', stdout=subprocess.PIPE)
      body+mined:-Inline= hex_string.decode('hex')

================================================================================

QUESTION: idx=402    id=40144769
-------------------------------------INPUTS-------------------------------------

tags: pandas
score: 85
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['df']}
intent: select the last column of dataframe `df`
body(Left in tags for better readability):
<p> I have done some searching for the answer to this question, but
all I can figure out is this:
<code_block>
 df[df.columns[len(df.columns)-1]]

<p> which to me seems unweildy, and un-pythonic (and slow?).
<p> What is the easiest way to select the data for the last column in
a pandas dataframe without specifying the name of the column?

-------------------------------------OUTPUT-------------------------------------

                Expected= 'df[df.columns[-1]]'
           base:Baseline= df.columns[:-1]
           body:Baseline= df[df].columns[len(df.columns)-1]]
            body:-Blocks= df.loc[:, (df.columns)]
              body:-Code= df.loc[:, (df.columns)]
            body:-Inline= df[df].columns[len(df.columns)-1]]
                body:-NL= df[df.loc[len(df.columns)] - 1]
             base:+Mined= df.loc[:, (df.columns[:-1])]
     body+mined:Baseline= df[df.columns[len(df)] - 1]
        body+mined:-Code= df.drop(len(df.columns), axis=1)
          body+mined:-NL= df[df.columns[len(df.values), -1]]
      body+mined:-Blocks= df.loc[df.columns[:-1]
      body+mined:-Inline= df[df.columns[len(df)) - 1]

================================================================================

QUESTION: idx=403    id=30787901
-------------------------------------INPUTS-------------------------------------

tags: pandas, dataframe
score: 126
slot_map: {'key': ['var_0', 'str_0', 'str_1'], 'quote': ['`', "'", "'"], 'type': ['var', 'str', 'str'], 'value': ['df', 'Letters', 'C']}
intent: get the first value from dataframe `df` where column 'letters' is equal to 'c'
body(Left in tags for better readability):
<p> Say I have the following DataFrame
<pre>
Letter    Number
A          1
B          2
C          3
D          4

<p> Which can be obtained through the following code
<code_block>
 import pandas as pd

letters=pd.Series(('A', 'B', 'C', 'D'))
numbers=pd.Series((1, 2, 3, 4))
keys=('Letters', 'Numbers')
df=pd.concat((letters, numbers), axis=1, keys=keys)

<p> Now I want to get the value C from the column Letters.
<p> The command line
<code_block>
 df[df.Letters=='C'].Letters

<p> will return
<pre>
2    C
Name: Letters, dtype: object

<p> How can I get only the value C and not the whole two line output?

-------------------------------------OUTPUT-------------------------------------

                Expected= "df.loc[df['Letters'] == 'C', 'Letters'].values[0]"
           base:Baseline= df[df['letters'] == 'C']
           body:Baseline= df[df.C] == 'C']
            body:-Blocks= df[df['letters'] == 'C']
              body:-Code= df[df['letters'] == 'C']
            body:-Inline= df[df.Letters == 'C')
                body:-NL= df[df.Letters == 'C')
             base:+Mined= df.loc[df['letters'] == 'c']
     body+mined:Baseline= df[df.Letters == 'C']
        body+mined:-Code= df.loc[df['Letter'] == 'C']
          body+mined:-NL= df[df.C.isin(['A', 'B', 'C'])]
      body+mined:-Blocks= df.loc[df['Letter'] == 'C']
      body+mined:-Inline= df[df.Letters == 'C'].C

================================================================================

QUESTION: idx=404    id=18730044
-------------------------------------INPUTS-------------------------------------

tags: arrays, numpy, matrix
score: 37
slot_map: {'key': ['str_0', 'str_1', '[str_0]', '[str_1]'], 'quote': ['`', '`', '`', '`'], 'type': ['str', 'str', 'str', 'str'], 'value': ['[1, 2, 3]', '[4, 5, 6]', '[1, 2, 3]', '[4, 5, 6]']}
intent: converting two lists `[1, 2, 3]` and `[4, 5, 6]` into a matrix
body(Left in tags for better readability):
<p> I'll try to be as clear as possible, and I'll start by explaining
why I want to transform two arrays into a matrix.
<p> To plot the performance of a portfolio vs an market index I need a
data structure like in this format:
<code_block>
 [[portfolio_value1, index_value1]
 [portfolio_value2, index_value2]]

<p> But I have the the data as two separate 1-D arrays:
<code_block>
 portfolio = [portfolio_value1, portfolio_value2, <console_out>]
index = [index_value1, index_value2, <console_out>]

<p> So how do I transform the second scenario into the first. I've
tried <code> np.insert <p>  to add the second array to a test matrix I
had in a python shell, my problem was to transpose the first array
into a single column matrix.
<p> Any help on how to achieve this without an imperative loop would
be great.

-------------------------------------OUTPUT-------------------------------------

                Expected= 'np.column_stack(([1, 2, 3], [4, 5, 6]))'
           base:Baseline= np.concat([1, 2, 3], [4, 5, 6])
           body:Baseline= np.insert([1, 2, 3], [4, 5, 6])
            body:-Blocks= np.concat([1, 2, 3], [4, 5, 6])
              body:-Code= np.concat([1, 2, 3], [4, 5, 6])
            body:-Inline= np.matrix([1, 2, 3], [4, 5, 6])
                body:-NL= np.concat([1, 2, 3], [4, 5, 6])
             base:+Mined= matrix([1, 2, 3], [4, 5, 6])
     body+mined:Baseline= np.concatenate(([[1, 2, 3]], [4, 5, 6]))
        body+mined:-Code= matrix([1, 2, 3], [4, 5, 6])
          body+mined:-NL= numpy.concat([1, 2, 3], axis=1)
      body+mined:-Blocks= np.concatenate([1, 2, 3], [4, 5, 6])
      body+mined:-Inline= numpy.concat([1, 2, 3], [4, 5, 6])

================================================================================

QUESTION: idx=405    id=402504
-------------------------------------INPUTS-------------------------------------

tags: types, unsigned, signed, 16-bit
score: 1764
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['i']}
intent: get the type of `i`
body(Left in tags for better readability):
<p> How do I see the type of a variable whether it is unsigned 32 bit,
signed 16 bit, etc.?
<p> How do I view it?

-------------------------------------OUTPUT-------------------------------------

                Expected= 'type(i)'
           base:Baseline= print(i.type(1))
           body:Baseline= print(i.__class__)
            body:-Blocks= print(i.__str__(16))
              body:-Code= print(i.__str__)
            body:-Inline= print(i.type(0, 16))
                body:-NL= print(i.getType(key=lambda x: x[1])
             base:+Mined= print(i[i] + str(i))
     body+mined:Baseline= print(type(i.__str__))
        body+mined:-Code= isinstance(i, 16)[0]
          body+mined:-NL= print(i.__type__)
      body+mined:-Blocks= i.__str__(16)
      body+mined:-Inline= print(i.__signal__(16))

================================================================================

QUESTION: idx=406    id=402504
-------------------------------------INPUTS-------------------------------------

tags: types, unsigned, signed, 16-bit
score: 1764
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['v']}
intent: determine the type of variable `v`
body(Left in tags for better readability):
<p> How do I see the type of a variable whether it is unsigned 32 bit,
signed 16 bit, etc.?
<p> How do I view it?

-------------------------------------OUTPUT-------------------------------------

                Expected= 'type(v)'
           base:Baseline= print(v.__dict__)
           body:Baseline= v.sort(key=operator.itemgetter(16))
            body:-Blocks= v.__str__(*(16))
              body:-Code= v.__str__(float)
            body:-Inline= print(v.type() for v in range(16))
                body:-NL= print(v.type(v))
             base:+Mined= var1, var2 = str(v)
     body+mined:Baseline= globals().unstack(v)
        body+mined:-Code= v == str(32)[0]
          body+mined:-NL= globals().set_type('v')
      body+mined:-Blocks= v.isinstance(int, 16)
      body+mined:-Inline= print(type(v.__signal__))

================================================================================

QUESTION: idx=407    id=402504
-------------------------------------INPUTS-------------------------------------

tags: types, unsigned, signed, 16-bit
score: 1764
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['v']}
intent: determine the type of variable `v`
body(Left in tags for better readability):
<p> How do I see the type of a variable whether it is unsigned 32 bit,
signed 16 bit, etc.?
<p> How do I view it?

-------------------------------------OUTPUT-------------------------------------

                Expected= 'type(v)'
           base:Baseline= print(v.__dict__)
           body:Baseline= v.sort(key=operator.itemgetter(16))
            body:-Blocks= v.__str__(*(16))
              body:-Code= v.__str__(float)
            body:-Inline= print(v.type() for v in range(16))
                body:-NL= print(v.type(v))
             base:+Mined= var1, var2 = str(v)
     body+mined:Baseline= globals().unstack(v)
        body+mined:-Code= v == str(32)[0]
          body+mined:-NL= globals().set_type('v')
      body+mined:-Blocks= v.isinstance(int, 16)
      body+mined:-Inline= print(type(v.__signal__))

================================================================================

QUESTION: idx=408    id=402504
-------------------------------------INPUTS-------------------------------------

tags: types, unsigned, signed, 16-bit
score: 1764
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['v']}
intent: determine the type of variable `v`
body(Left in tags for better readability):
<p> How do I see the type of a variable whether it is unsigned 32 bit,
signed 16 bit, etc.?
<p> How do I view it?

-------------------------------------OUTPUT-------------------------------------

                Expected= 'type(v)'
           base:Baseline= print(v.__dict__)
           body:Baseline= v.sort(key=operator.itemgetter(16))
            body:-Blocks= v.__str__(*(16))
              body:-Code= v.__str__(float)
            body:-Inline= print(v.type() for v in range(16))
                body:-NL= print(v.type(v))
             base:+Mined= var1, var2 = str(v)
     body+mined:Baseline= globals().unstack(v)
        body+mined:-Code= v == str(32)[0]
          body+mined:-NL= globals().set_type('v')
      body+mined:-Blocks= v.isinstance(int, 16)
      body+mined:-Inline= print(type(v.__signal__))

================================================================================

QUESTION: idx=409    id=402504
-------------------------------------INPUTS-------------------------------------

tags: types, unsigned, signed, 16-bit
score: 1764
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['v']}
intent: determine the type of variable `v`
body(Left in tags for better readability):
<p> How do I see the type of a variable whether it is unsigned 32 bit,
signed 16 bit, etc.?
<p> How do I view it?

-------------------------------------OUTPUT-------------------------------------

                Expected= 'type(v)'
           base:Baseline= print(v.__dict__)
           body:Baseline= v.sort(key=operator.itemgetter(16))
            body:-Blocks= v.__str__(*(16))
              body:-Code= v.__str__(float)
            body:-Inline= print(v.type() for v in range(16))
                body:-NL= print(v.type(v))
             base:+Mined= var1, var2 = str(v)
     body+mined:Baseline= globals().unstack(v)
        body+mined:-Code= v == str(32)[0]
          body+mined:-NL= globals().set_type('v')
      body+mined:-Blocks= v.isinstance(int, 16)
      body+mined:-Inline= print(type(v.__signal__))

================================================================================

QUESTION: idx=410    id=402504
-------------------------------------INPUTS-------------------------------------

tags: types, unsigned, signed, 16-bit
score: 1764
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['variable_name']}
intent: get the type of variable `variable_name`
body(Left in tags for better readability):
<p> How do I see the type of a variable whether it is unsigned 32 bit,
signed 16 bit, etc.?
<p> How do I view it?

-------------------------------------OUTPUT-------------------------------------

                Expected= 'print(type(variable_name))'
           base:Baseline= variable_name = variable_name[0]
           body:Baseline= print(variable_name.__class__))
            body:-Blocks= variable_name.__str__()
              body:-Code= variable_name.__str__()
            body:-Inline= print(variable_name.type())
                body:-NL= print(variable_name.type())
             base:+Mined= variable_name.getType(bool)
     body+mined:Baseline= variable_name.strftime('NFKD')
        body+mined:-Code= variable_name.isdigit()
          body+mined:-NL= variable_name.__get__(__builtins__)
      body+mined:-Blocks= variable_name.isdigit()
      body+mined:-Inline= variable_name.strftime('32 bit')

================================================================================

QUESTION: idx=411    id=2300756
-------------------------------------INPUTS-------------------------------------

tags: generator
score: 71
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: get the 5th item of a generator
body(Left in tags for better readability):
<p> Is there a more syntactically concise way of writing the
following?
<code_block>
 gen = (i for i in xrange(10))
index = 5
for i, v in enumerate(gen):
    if i is index:
        return v

<p> It seems almost natural that a generator should have a <code>
gen[index] <p>  expression, that acts as a list, but is functionally
identical to the above code.

-------------------------------------OUTPUT-------------------------------------

                Expected= 'next(itertools.islice(range(10), 5, 5 + 1))'
           base:Baseline=  generator.itemgetter(5)
           body:Baseline= for i, v in enumerate(gen):
    pass
            body:-Blocks= [i[0] for i in range(5)]
              body:-Code= [item[5] for item in generator]
            body:-Inline= [i[0] for i in enumerate(gen)]
                body:-NL= [i[0] for i in enumerate(gen)]
             base:+Mined= next((5, 5), 5)
     body+mined:Baseline= [i for i, j in enumerate(gen) if i == j]
        body+mined:-Code= list(itertools.product(*list(range(10)), repeat=5))
          body+mined:-NL= next(i for i, v in enumerate(gen) if i == 5)
      body+mined:-Blocks= [i for i in range(5)]
      body+mined:-Inline= [i[0] for i in enumerate(gen) if i == index]

================================================================================

QUESTION: idx=412    id=20056548
-------------------------------------INPUTS-------------------------------------

tags: 
score: 22
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['word']}
intent: print a string `word` with string format
body(Left in tags for better readability):
<p> For instance, we have:
<code_block>
 word = 'Some Random Word'
print '"' + word + '"'

<p> is there a better way to print double quotes around a variable?

-------------------------------------OUTPUT-------------------------------------

                Expected= 'print(\'"{}"\'.format(word))'
           base:Baseline= print(word.split('\n'))[0]
           body:Baseline= print('"' + word + '"' + 'Some Random Word'
            body:-Blocks= print('word'.format(word))
              body:-Code= print('word'.format(word))
            body:-Inline= print(''.join(word for word in str(format(word)))
                body:-NL= print('Some Random Word'.format(word))
             base:+Mined= print('Word is {}'.format(word))
     body+mined:Baseline= print('"' + word + '"'')
        body+mined:-Code= print('Value is "' + word)
          body+mined:-NL= print('"' + ''.join(word))
      body+mined:-Blocks= print('word with string format ')
      body+mined:-Inline= print('"' + word + '"')

================================================================================

QUESTION: idx=413    id=8546245
-------------------------------------INPUTS-------------------------------------

tags: list
score: 45
slot_map: {'key': ['var_0', 'str_0'], 'quote': ['`', "'"], 'type': ['var', 'str'], 'value': ['list', '']}
intent: join a list of strings `list` using a space ' '
body(Left in tags for better readability):
<p> I wanted to build a string from a list.
<p> I used the string.join() command, but if I have :
<code_block>
 ['hello', 'good', 'morning']

<p> I get : <code> hellogoodmorning
<p> Is there a method that allows me to put a space between every word
? (without the need to write a for loop)
<p> kind regards.

-------------------------------------OUTPUT-------------------------------------

                Expected= '""" """.join(list)'
           base:Baseline= list = [x for x in list if x.isdigit()]
           body:Baseline= list.join(key=lambda x: x.split())
            body:-Blocks= list = [x for x in list if x.split(' ']]
              body:-Code= list = [x for x in list if x.split(' ']
            body:-Inline= list = [x for x in re.findall(' '])
                body:-NL= list.join('  ['hello', 'good','morning'])
             base:+Mined= list = [x for x in list if '' in x]
     body+mined:Baseline= list.join(map(str, ''.join(list)))
        body+mined:-Code= list = [s.split(' ') for s in list]
          body+mined:-NL= list.join(['hello', 'good', 'morning'])
      body+mined:-Blocks= list.join(map(lambda x: x.split(' '))
      body+mined:-Inline= list.join(map(str, ''))

================================================================================

QUESTION: idx=414    id=2276416
-------------------------------------INPUTS-------------------------------------

tags: list, extend
score: 10
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['y']}
intent: create list `y` containing two empty lists
body(Left in tags for better readability):
<p> I might be missing something about the intended behavior of list
extend, but why does the following happen?
<code_block>
 x = [[],[]]
y = [[]] * 2

print x       # [[],[]]
print y       # [[],[]]
print x == y  # True

x[0].extend([1])
y[0].extend([1])

print x    # [[1],[]], which is what I'd expect
print y    # [[1],[1]], wtf?

<p> I would guess that the <code> * <p>  operator is doing something
unexpected here, though I'm not exactly sure what.  It seems like
something is going on under the hood that's making the original x and
y (prior to calling extend) not actually be equal even though the
<code> == <p>  operator and <code> repr <p>  both would make it seem
as though they were identical.
<p> I only came across this because I wanted to pre-populate a list of
empty lists of a size determined at runtime, and then realized that it
wasn't working the way I imagined.  I can find a better way to do the
same thing, but now I'm curious as to why this didn't work.  This is
Python 2.5.2 BTW - I don't have a newer version installed so if this
is a bug I'm not sure if it's already fixed.

-------------------------------------OUTPUT-------------------------------------

                Expected= 'y = [[] for n in range(2)]'
           base:Baseline= y = [i for i in range(2)]
           body:Baseline= y = [[] for i in range(2)]
            body:-Blocks= y = [i for i in range(0, len(x), y)]
              body:-Code= y = [i for i in range(2)]
            body:-Inline= y = [[] for i in range(2)]
                body:-NL= y = [[] for i in range(2)]
             base:+Mined= y = [list(i) for i in range(0, len(i), 2)]
     body+mined:Baseline= y = [[] for i in range(2)]
        body+mined:-Code= y = [[] for i in range(10)]
          body+mined:-NL= y = [[] for i in range(2)]
      body+mined:-Blocks= y = [x for x in range(10)]
      body+mined:-Inline= y = [[] for i in range(2)]

================================================================================

QUESTION: idx=415    id=3925614
-------------------------------------INPUTS-------------------------------------

tags: file
score: 158
slot_map: {'key': ['str_0', 'var_0'], 'quote': ["'", '`'], 'type': ['str', 'var'], 'value': ['C:/name/MyDocuments/numbers', 'data']}
intent: read a file 'c:/name/mydocuments/numbers' into a list `data`
body(Left in tags for better readability):
<p> I want to prompt a user for a number of random numbers to be
generated and saved to a file. He gave us that part. The part we have
to do is to open that file, convert the numbers into a list, then find
the mean, standard deviation, etc. without using the easy built-in
Python tools.
<p> I've tried using <code> open <p>  but it gives me invalid syntax
(the file name I chose was "numbers" and it saved into <code> "My
Documents" <p>  automatically, so I tried <code> open(numbers, 'r')
<p>  and <code> open(C:\name\MyDocuments\numbers, 'r') <p>  and
neither one worked).

-------------------------------------OUTPUT-------------------------------------

                Expected= "data = [line.strip() for line in open('C:/name/MyDocuments/numbers', 'r')]"
           base:Baseline= data = open('c:/name/mydocuments/numbers')
           body:Baseline= data = open('C:/name/MyDocuments/numbers', 'r')
            body:-Blocks= data = open('C:/name/myDocuments/numbers', 'r')
              body:-Code= data = open('c:/name/mydocuments/numbers')
            body:-Inline= data = open('c:/name/mydocuments/numbers')
                body:-NL= data = open('C:/name/myDocuments/numbers')
             base:+Mined= data = open('c:/name/mydocuments/numbers', 'r')
     body+mined:Baseline= data = open('C:/name/mydocuments/numbers')
        body+mined:-Code= data = open('c:/name/mydocuments/numbers')
          body+mined:-NL= data = open('C:/name/mydocuments/numbers', 'r')
      body+mined:-Blocks= data = open('C:/name/mydocuments/numbers', 'r')
      body+mined:-Inline= data = open('c:/name/mydocuments/numbers')

================================================================================

QUESTION: idx=416    id=22187233
-------------------------------------INPUTS-------------------------------------

tags: string, replace
score: 74
slot_map: {'key': ['str_0', 'str_1'], 'quote': ["'", "'"], 'type': ['str', 'str'], 'value': ['i', 'it is icy']}
intent: delete all occurrences of character 'i' in string 'it is icy'
body(Left in tags for better readability):
<p> How do I delete all the instances of a character in this string?
Here is my code:
<code_block>
 def findreplace(char, string):
    place = string.index(char)
    string[place] = ''
    return string

<p> However, if I run this, this is what happens:
<code_block>
 <console_in> findreplace('i', 'it is icy')
<console_out> Traceback (most recent call last):
  File " <stdin>", line 1, in <module>
  File " <stdin>", line 3, in findreplace
TypeError: 'str' object does not support item assignment

<p> Why is this?

-------------------------------------OUTPUT-------------------------------------

                Expected= '"""""".join([char for char in \'it is icy\' if char != \'i\'])'
           base:Baseline= re.sub('[^a-zA-Z]', 'it is icy')
           body:Baseline= re.sub('I', 'it is icy')
            body:-Blocks= 'it is icy'.join(c for c in 'I', 'It is icy')
              body:-Code= """it is icy""".replace('I', '')
            body:-Inline= re.sub('I', 'it is icy')
                body:-NL= re.sub('(i)', 'it is icy')
             base:+Mined= re.sub('(?<=\\I)', 'It is icy')
     body+mined:Baseline= findreplace('i', 'it is icy')
        body+mined:-Code= """IT is icy""".replace('I', '')
          body+mined:-NL= re.sub('\\b', 'I', 'It is icy')
      body+mined:-Blocks= """""".join(c for c in itertools.chain.from_iterable(c))
      body+mined:-Inline= findreplace('i', 'it is icy')

================================================================================

QUESTION: idx=417    id=22187233
-------------------------------------INPUTS-------------------------------------

tags: string, replace
score: 74
slot_map: {'key': ['str_0', 'str_1'], 'quote': ["'", "'"], 'type': ['str', 'str'], 'value': ['i', 'it is icy']}
intent: delete all instances of a character 'i' in a string 'it is icy'
body(Left in tags for better readability):
<p> How do I delete all the instances of a character in this string?
Here is my code:
<code_block>
 def findreplace(char, string):
    place = string.index(char)
    string[place] = ''
    return string

<p> However, if I run this, this is what happens:
<code_block>
 <console_in> findreplace('i', 'it is icy')
<console_out> Traceback (most recent call last):
  File " <stdin>", line 1, in <module>
  File " <stdin>", line 3, in findreplace
TypeError: 'str' object does not support item assignment

<p> Why is this?

-------------------------------------OUTPUT-------------------------------------

                Expected= "re.sub('i', '', 'it is icy')"
           base:Baseline= re.sub('[^a-zA-Z]', 'it is icy')
           body:Baseline= re.sub('I', 'it is icy')
            body:-Blocks= """it is icy""".join(lambda x: x[1])
              body:-Code= 'it is icy'.join(lambda x: x.split('I', 'I')))
            body:-Inline= re.sub('I', 'it is icy')
                body:-NL= re.sub('(i)', 'it is icy')
             base:+Mined= re.sub('[^I]', 'It is icy')
     body+mined:Baseline= findreplace('i', 'it is icy')
        body+mined:-Code= """It is icy""".join(c for c in itertools.groupby('i') if c != 'I')
          body+mined:-NL= re.sub('\\b', 'it is icy', 'I', 'It is icy')
      body+mined:-Blocks= """""".join([i for i in itertools.chain.from_iterable(i)) if i!= 'I')
      body+mined:-Inline= findreplace('i', 'it is icy')

================================================================================

QUESTION: idx=418    id=22187233
-------------------------------------INPUTS-------------------------------------

tags: string, replace
score: 74
slot_map: {'key': ['str_0', 'str_1'], 'quote': ['"', '"'], 'type': ['str', 'str'], 'value': ['i', 'it is icy']}
intent: delete all characters "i" in string "it is icy"
body(Left in tags for better readability):
<p> How do I delete all the instances of a character in this string?
Here is my code:
<code_block>
 def findreplace(char, string):
    place = string.index(char)
    string[place] = ''
    return string

<p> However, if I run this, this is what happens:
<code_block>
 <console_in> findreplace('i', 'it is icy')
<console_out> Traceback (most recent call last):
  File " <stdin>", line 1, in <module>
  File " <stdin>", line 3, in findreplace
TypeError: 'str' object does not support item assignment

<p> Why is this?

-------------------------------------OUTPUT-------------------------------------

                Expected= '"""it is icy""".replace(\'i\', \'\')'
           base:Baseline= re.sub('it is icy')
           body:Baseline= re.sub('I', 'it is icy')
            body:-Blocks= re.sub('(i)', 'it is icy')
              body:-Code= """it is icy""".replace('i', '')
            body:-Inline= re.sub('i', 'it is icy')
                body:-NL= re.sub('(i)', 'it is icy')
             base:+Mined= re.sub('[^a-zA-Z]', 'it is icy')
     body+mined:Baseline= findreplace('i', 'it is icy')
        body+mined:-Code= 'IT is icy'.join(c for c in 'I', i)
          body+mined:-NL= re.sub('\\b', 'it is icy', '', place)
      body+mined:-Blocks= """""".join([i for i in 'It is icy' if i])
      body+mined:-Inline= findreplace('i', 'it is icy')

================================================================================

QUESTION: idx=419    id=22187233
-------------------------------------INPUTS-------------------------------------

tags: string, replace
score: 74
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: how to delete all instances of a character in a string in python?
body(Left in tags for better readability):
<p> How do I delete all the instances of a character in this string?
Here is my code:
<code_block>
 def findreplace(char, string):
    place = string.index(char)
    string[place] = ''
    return string

<p> However, if I run this, this is what happens:
<code_block>
 <console_in> findreplace('i', 'it is icy')
<console_out> Traceback (most recent call last):
  File " <stdin>", line 1, in <module>
  File " <stdin>", line 3, in findreplace
TypeError: 'str' object does not support item assignment

<p> Why is this?

-------------------------------------OUTPUT-------------------------------------

                Expected= '"""""".join([char for char in \'it is icy\' if char != \'i\'])'
           base:Baseline= re.sub('[^a-zA-Z]', '\\1', '', text)
           body:Baseline= re.sub('\\w+', '')
            body:-Blocks= [x for x in re.sub('[^a-zA-Z]', '', x)
              body:-Code= re.sub('[^a-zA-Z]', '', ''.join(lambda x: x.split())
            body:-Inline= """""".join(str.replace('i', 'it is icy')
                body:-NL= re.sub('\\d+', '', place)
             base:+Mined= new_string = re.sub('\\d+', '', old_string)
     body+mined:Baseline= s = s.replace('i', 'it is icy')
        body+mined:-Code= s = s.replace('*', '')
          body+mined:-NL= re.sub('\\b', '\\1', '', place)
      body+mined:-Blocks= s = s.replace(' ', '')
      body+mined:-Inline= re.sub('(?<=\\w+)', '', 'it is icy')

================================================================================

QUESTION: idx=420    id=13413590
-------------------------------------INPUTS-------------------------------------

tags: pandas, dataframe, nan
score: 938
slot_map: {'key': ['var_0', 'str_0'], 'quote': ['`', '"'], 'type': ['var', 'str'], 'value': ['df', '1']}
intent: drop rows of pandas dataframe `df` having nan in column at index "1"
body(Left in tags for better readability):
<p> I have this <code> DataFrame <p>  and want only the records whose
<code> EPS <p>  column is not <code> NaN <p> :
<code_block>
 <console_in> df
<console_out>                 STK_ID  EPS  cash
STK_ID RPT_Date
601166 20111231  601166  NaN   NaN
600036 20111231  600036  NaN    12
600016 20111231  600016  4.3   NaN
601009 20111231  601009  NaN   NaN
601939 20111231  601939  2.5   NaN
000001 20111231  000001  NaN   NaN

<p> <console_out>i.e. something like <code> df.drop(....) <p>  to get
this resulting dataframe:
<code_block>
                   STK_ID  EPS  cash
STK_ID RPT_Date
600016 20111231  600016  4.3   NaN
601939 20111231  601939  2.5   NaN

<p> How do I do that?

-------------------------------------OUTPUT-------------------------------------

                Expected= 'df.dropna(subset=[1])'
           base:Baseline= df.loc[df.index(1)]
           body:Baseline= df.drop(['1'], axis=1)
            body:-Blocks= df.drop(['1'], axis=1)
              body:-Code= df.dropna(df.columns, axis=1)
            body:-Inline= df.dropna(df.columns, axis=1, inplace=True)
                body:-NL= df.drop(['1'], axis=1)
             base:+Mined= df.drop(df.columns, axis=1)
     body+mined:Baseline= df.drop(df.isnull().drop([' EPS'], axis=1)
        body+mined:-Code= df.dropna(df.columns, axis=1)
          body+mined:-NL= df.drop(df.columns, axis=1)
      body+mined:-Blocks= df.drop(df.isnan(['1'], axis=1)
      body+mined:-Inline= df.loc[df.columns[1].isin(['a', 'b'])]

================================================================================

QUESTION: idx=421    id=598398
-------------------------------------INPUTS-------------------------------------

tags: 
score: 96
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['myList', 'n']}
intent: get elements from list `mylist`, that have a field `n` value 30
body(Left in tags for better readability):
<p> Let's assume I'm creating a simple class to work similar to a
C-style struct, to just hold data elements.  I'm trying to figure out
how to search a list of objects for objects with an attribute equaling
a certain value.  Below is a trivial example to illustrate what I'm
trying to do.
<p> For instance:
<code_block>
 class Data:
    pass

myList = []

for i in range(20):
    data = Data()
    data.n = i
    data.n_squared = i * i
    myList.append(data)

<p> How would I go about searching the myList list to determine if it
contains an element with n == 5?
<p> I've been Googling and searching the Python docs, and I think I
might be able to do this with a list comprehension, but I'm not sure.
I might add that I'm having to use Python 2.4.3 by the way, so any new
gee-whiz 2.6 or 3.x features aren't available to me.

-------------------------------------OUTPUT-------------------------------------

                Expected= '[x for x in myList if x.n == 30]'
           base:Baseline= [x for x in mylist if x != 30]
           body:Baseline= [i for i, n in myList if i == 30]
            body:-Blocks= [x for x in myList if x == 30]
              body:-Code= [x for x in myList if x == 30]
            body:-Inline= [x for x in myList if x == 5]
                body:-NL= [x for x in myList if x != 30]
             base:+Mined= [i for i, n in enumerate(myList) if n != 30]
     body+mined:Baseline= [x for x in myList if x.n == 5]
        body+mined:-Code= [x for x in myList if x == 5]
          body+mined:-NL= [x for x in myList if x.n_squared]
      body+mined:-Blocks= [x for x in myList if x[n] == 30]
      body+mined:-Inline= [item for item in myList if n == 30]

================================================================================

QUESTION: idx=422    id=10351772
-------------------------------------INPUTS-------------------------------------

tags: list, input, integer
score: 14
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['intstringlist', 'nums']}
intent: converting list of strings `intstringlist` to list of integer `nums`
body(Left in tags for better readability):
<p> How do I convert a space separated integer input into a list of
integers?
<p> Example input:
<code_block>
 list1 = list(input("Enter the unfriendly numbers: "))

<p> Example conversion:
<code_block>
 ['1', '2', '3', '4', '5']  to  [1, 2, 3, 4, 5]


-------------------------------------OUTPUT-------------------------------------

                Expected= 'nums = [int(x) for x in intstringlist]'
           base:Baseline= [int(x) for x in int(nums)]
           body:Baseline= list(intstringlist, nums)
            body:-Blocks= nums = [int(x) for x in intstringlist]
              body:-Code= nums = [int(x) for x in zip(intStringList, nums)]
            body:-Inline= nums = [int(x) for x in enumerate(intstringlist, nums)]
                body:-NL= nums = [int(x) for x in intstringlist]
             base:+Mined= [int(nums) for nums in intstringlist]
     body+mined:Baseline= nums = [int(x) for x in intstringlist]
        body+mined:-Code= nums = [int(x) for x in intstringlist]
          body+mined:-NL= nums = [int(x) for x in intstringlist]
      body+mined:-Blocks= nums = [int(i) for i in s.split()]
      body+mined:-Inline= nums = [int(x) for x in intstringlist]

================================================================================

QUESTION: idx=423    id=10351772
-------------------------------------INPUTS-------------------------------------

tags: list, input, integer
score: 14
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: convert list of string numbers into list of integers
body(Left in tags for better readability):
<p> How do I convert a space separated integer input into a list of
integers?
<p> Example input:
<code_block>
 list1 = list(input("Enter the unfriendly numbers: "))

<p> Example conversion:
<code_block>
 ['1', '2', '3', '4', '5']  to  [1, 2, 3, 4, 5]


-------------------------------------OUTPUT-------------------------------------

                Expected= "map(int, eval(input('Enter the unfriendly numbers: ')))"
           base:Baseline= [int(x) for x in re.findall('\\d+', '', 2)]
           body:Baseline= list(map(int, re.findall('\\d+\\b', '\\1', '2', '3', '4', '5'))
            body:-Blocks= [int(x) for x in re.split('\n')]
              body:-Code= [int(x) for x in re.findall('\n')]
            body:-Inline= [int(x) for x in list1]
                body:-NL= [int(x) for x in list1]
             base:+Mined= [int(x) for x in lst]
     body+mined:Baseline= list(map(int, input('Enter the unfriendly numbers: ')))
        body+mined:-Code= [int(x) for x in lst]
          body+mined:-NL= map(int, input('Enter the unfriendly numbers: '))
      body+mined:-Blocks= [int(i) for i in s.split()]
      body+mined:-Inline= map(int, ['1', '2', '3', '4', '5'])

================================================================================

QUESTION: idx=424    id=493386
-------------------------------------INPUTS-------------------------------------

tags: newline
score: 2044
slot_map: {'key': ['str_0'], 'quote': ['"'], 'type': ['str'], 'value': ['.']}
intent: print "." without newline
body(Left in tags for better readability):
<p> I'd like to do it in  <a> python <p> . What I'd like to do in this
example in <a> c <p> :
<p> In C:
<code_block>
 #include <stdio.h>

int main() {
    int i;
    for (i=0; i <10; i++) printf(".");
    return 0;
}

<p> Output:
<code_block>
 <console_out>.......

<p> In Python:
<code_block>
 <console_in> for i in range(10): print('.')
<console_out> .
.
.
.
.
.
.
.
.
.
<console_in> print('.', '.', '.', '.', '.', '.', '.', '.', '.', '.')
<console_out> . . . . . . . . . .

<p> In Python <code> print <p>  will add a <code> \n <p>  or space,
how can I avoid that? Now, it's just an example, don't tell me I can
first build a string then print it. I'd like to know how to "append"
strings to <code> stdout <p> .

-------------------------------------OUTPUT-------------------------------------

                Expected= "sys.stdout.write('.')"
           base:Baseline= print('.' + re.sub('\\d+', '.')
           body:Baseline= print('. without newline.replace('.'))
            body:-Blocks= print('.' + stdout.stdout.replace('.'))
              body:-Code= print('.').replace('.')
            body:-Inline= print('.').replace('.')
                body:-NL= print('.' without newline.
    pass
             base:+Mined= print(' '.join(str(i) for i in '.'))
     body+mined:Baseline= print('.' + str(i) + '.')
        body+mined:-Code= print('.' + '.join(c))
          body+mined:-NL= print('.'.join(str(i) for i in range(10))
      body+mined:-Blocks= print('\n'.join(str(c)) for c in c.split())
      body+mined:-Inline= print('.'.join(['.') for i in range(10))

================================================================================

QUESTION: idx=425    id=6569528
-------------------------------------INPUTS-------------------------------------

tags: floating-point, int
score: 73
slot_map: {'key': ['str_0'], 'quote': ['`'], 'type': ['str'], 'value': ['2.52 * 100']}
intent: round off the float that is the product of `2.52 * 100` and convert it to an int
body(Left in tags for better readability):
<p> Basically, I'm converting a float to an int, but I don't always
have the expected value.
<p> Here's the code I'm executing:
<p> x = 2.51
<code_block>
 print("--------- 251.0")
y = 251.0
print(y)
print(int(y))

print("--------- 2.51 * 100")
y = x * 100
print(y)
print(int(y))

print("--------- 2.51 * 1000 / 10")
y = x * 1000 / 10
print(y)
print(int(y))

print("--------- 2.51 * 100 * 10 / 10")
y = x * 100 * 10 / 10
print(y)
print(int(y))

x = 4.02
print("--------- 402.0")
y = 402.0
print(y)
print(int(y))

print("--------- 4.02 * 100")
y = x * 100
print(y)
print(int(y))

print("--------- 4.02 * 1000 / 10")
y = x * 1000 / 10
print(y)
print(int(y))

print("--------- 4.02 * 100 * 10 / 10")
y = x * 100 * 10 / 10
print(y)
print(int(y))

<p> And here's the result (first value is the result of the operation,
second value is int() of the same operation):
<code_block>
 --------- 251.0
251.0
251
--------- 2.51 * 100
251.0
250
--------- 2.51 * 1000 / 10
251.0
251
--------- 2.51 * 100 * 10 / 10
251.0
250
--------- 402.0
402.0
402
--------- 4.02 * 100
402.0
401
--------- 4.02 * 1000 / 10
402.0
401
--------- 4.02 * 100 * 10 / 10
402.0
401

<p> 2.51 and 4.02 are the only values that lead to that strange
behaviour on the 2.50 -> 5.00 range. Every other two digits value in
that range converts to int without any problem when given the same
operations.
<p> So, what am I missing that leads to those results? I'm using
Python 2.7.2 by the way.

-------------------------------------OUTPUT-------------------------------------

                Expected= 'int(round(2.51 * 100))'
           base:Baseline= float(2.52 * 100)
           body:Baseline= int(float(2.52 * 100))
            body:-Blocks= int(round(2.52 * 100))
              body:-Code= int(float(2.52 * 100))
            body:-Inline= int(2.52 * 100)
                body:-NL= int(2.52 * 100)
             base:+Mined= int(round(2.52 * 100))
     body+mined:Baseline= int(float(2.52 * 100))
        body+mined:-Code= int(float(2.52 * 100))
          body+mined:-NL= int(2.52 * 100)
      body+mined:-Blocks= int(float(2.52 * 100))
      body+mined:-Inline= int(float(2.52 * 100))

================================================================================

QUESTION: idx=426    id=3964681
-------------------------------------INPUTS-------------------------------------

tags: file-io
score: 1041
slot_map: {'key': ['str_0', 'str_1'], 'quote': ['"', '"'], 'type': ['str', 'str'], 'value': ['/mydir', '.txt']}
intent: find all files in directory "/mydir" with extension ".txt"
body(Left in tags for better readability):
<p> How can I find all the files in a directory having the extension
<code> .txt <p>  in python?

-------------------------------------OUTPUT-------------------------------------

                Expected= "os.chdir('/mydir')\nfor file in glob.glob('*.txt'):\n    pass"
           base:Baseline= print(os.path.isfile('/mydir', ".txt')
           body:Baseline= print(os.path.dirname('/mydir'))
            body:-Blocks= print(os.path.dirname('/mydir'))
              body:-Code= print(os.path.exists('/mydir', ".txt')
            body:-Inline= print(os.path.dirname('/mydir'))
                body:-NL= os.path.exists('/mydir', '.txt')
             base:+Mined= print(os.listdir('/mydir'))
     body+mined:Baseline= [x for x in os.listdir('/mydir' if x.endswith('.txt'))]
        body+mined:-Code= [x for x in os.listdir('/mydir') if x.endswith('.')]
          body+mined:-NL= [x for x in os.walk('mydir') if x.endswith(' '.txt')]
      body+mined:-Blocks= [x for x in os.listdir('/mydir' if x.endswith('.'))]
      body+mined:-Inline= print(os.path.exists('/mydir'))

================================================================================

QUESTION: idx=427    id=3964681
-------------------------------------INPUTS-------------------------------------

tags: file-io
score: 1041
slot_map: {'key': ['str_0', 'str_1'], 'quote': ['"', '"'], 'type': ['str', 'str'], 'value': ['/mydir', '.txt']}
intent: find all files in directory "/mydir" with extension ".txt"
body(Left in tags for better readability):
<p> How can I find all the files in a directory having the extension
<code> .txt <p>  in python?

-------------------------------------OUTPUT-------------------------------------

                Expected= "for file in os.listdir('/mydir'):\n    if file.endswith('.txt'):\n        pass"
           base:Baseline= print(os.path.isfile('/mydir', ".txt')
           body:Baseline= print(os.path.dirname('/mydir'))
            body:-Blocks= print(os.path.dirname('/mydir'))
              body:-Code= print(os.path.exists('/mydir', ".txt')
            body:-Inline= print(os.path.dirname('/mydir'))
                body:-NL= os.path.exists('/mydir', '.txt')
             base:+Mined= print(os.listdir('/mydir'))
     body+mined:Baseline= [x for x in os.listdir('/mydir' if x.endswith('.txt'))]
        body+mined:-Code= [x for x in os.listdir('/mydir') if x.endswith('.')]
          body+mined:-NL= [x for x in os.walk('mydir') if x.endswith(' '.txt')]
      body+mined:-Blocks= [x for x in os.listdir('/mydir' if x.endswith('.'))]
      body+mined:-Inline= print(os.path.exists('/mydir'))

================================================================================

QUESTION: idx=428    id=3964681
-------------------------------------INPUTS-------------------------------------

tags: file-io
score: 1041
slot_map: {'key': ['str_0', 'str_1'], 'quote': ['"', '"'], 'type': ['str', 'str'], 'value': ['/mydir', '.txt']}
intent: find all files in directory "/mydir" with extension ".txt"
body(Left in tags for better readability):
<p> How can I find all the files in a directory having the extension
<code> .txt <p>  in python?

-------------------------------------OUTPUT-------------------------------------

                Expected= "for root, dirs, files in os.walk('/mydir'):\n    for file in files:\n        if file.endswith('.txt'):\n            pass"
           base:Baseline= print(os.path.isfile('/mydir', ".txt')
           body:Baseline= print(os.path.dirname('/mydir'))
            body:-Blocks= print(os.path.dirname('/mydir'))
              body:-Code= print(os.path.exists('/mydir', ".txt')
            body:-Inline= print(os.path.dirname('/mydir'))
                body:-NL= os.path.exists('/mydir', '.txt')
             base:+Mined= print(os.listdir('/mydir'))
     body+mined:Baseline= [x for x in os.listdir('/mydir' if x.endswith('.txt'))]
        body+mined:-Code= [x for x in os.listdir('/mydir') if x.endswith('.')]
          body+mined:-NL= [x for x in os.walk('mydir') if x.endswith(' '.txt')]
      body+mined:-Blocks= [x for x in os.listdir('/mydir' if x.endswith('.'))]
      body+mined:-Inline= print(os.path.exists('/mydir'))

================================================================================

QUESTION: idx=429    id=20865487
-------------------------------------INPUTS-------------------------------------

tags: pandas, plot
score: 64
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['df']}
intent: plot dataframe `df` without a legend
body(Left in tags for better readability):
<p> Using the pandas library in python and using
<code_block>
 .plot()

<p> on a dataframe,  how do I display the plot without a legend?

-------------------------------------OUTPUT-------------------------------------

                Expected= 'df.plot(legend=False)'
           base:Baseline= df.plot(legend=True)
           body:Baseline= df.set_index(' legend')
            body:-Blocks= df.plot(legend=True)
              body:-Code= df.plot(legend=True)
            body:-Inline= df.plot(key=lambda x: x.legend()
                body:-NL= df.plot(key=lambda x: x[1])
             base:+Mined= df.plot(kind='bar')
     body+mined:Baseline= df.plot(not a legend)
        body+mined:-Code= df.plot(kind='bar')
          body+mined:-NL= df.plot(x, y, 'bo')
      body+mined:-Blocks= df.plot(kind='bar')
      body+mined:-Inline= df.plot(kind='bar')

================================================================================

QUESTION: idx=430    id=13368659
-------------------------------------INPUTS-------------------------------------

tags: 
score: 12
slot_map: {'key': ['str_0'], 'quote': ['"'], 'type': ['str'], 'value': ['192.168.x.x']}
intent: loop through the ip address range "192.168.x.x"
body(Left in tags for better readability):
<p> How can I loop through an IP address range in python? Lets say I
want to loop through every IP from 192.168.1.1 to 192.168. How can
this be done?

-------------------------------------OUTPUT-------------------------------------

                Expected= "for i in range(256):\n    for j in range(256):\n        ip = '192.168.%d.%d' % (i, j)\n        print(ip)"
           base:Baseline= os.system('192.168.x.x', shell=True)
           body:Baseline= os.system('192.168.x.x').read()
            body:-Blocks= os.system('192.168.x.x')
              body:-Code= os.system('192.168.x.x')
            body:-Inline= loop((192.168).x.x)
                body:-NL= os.system('192.168.x.x', shell=True)
             base:+Mined= os.system('192.168.x.x')
     body+mined:Baseline= loop((192.168).x.x)
        body+mined:-Code= print(list(open('192.168.x.x').read())
          body+mined:-NL= print(os.environ['192.168.x.x'])
      body+mined:-Blocks= print(os.environ['192.168.x.x'])
      body+mined:-Inline= print(open('192.168.x.x').read())

================================================================================

QUESTION: idx=431    id=13368659
-------------------------------------INPUTS-------------------------------------

tags: 
score: 12
slot_map: {'key': ['str_0'], 'quote': ['"'], 'type': ['str'], 'value': ['192.168.x.x']}
intent: loop through the ip address range "192.168.x.x"
body(Left in tags for better readability):
<p> How can I loop through an IP address range in python? Lets say I
want to loop through every IP from 192.168.1.1 to 192.168. How can
this be done?

-------------------------------------OUTPUT-------------------------------------

                Expected= 'for i, j in product(list(range(256)), list(range(256))):\n    pass'
           base:Baseline= os.system('192.168.x.x', shell=True)
           body:Baseline= os.system('192.168.x.x').read()
            body:-Blocks= os.system('192.168.x.x')
              body:-Code= os.system('192.168.x.x')
            body:-Inline= loop((192.168).x.x)
                body:-NL= os.system('192.168.x.x', shell=True)
             base:+Mined= os.system('192.168.x.x')
     body+mined:Baseline= loop((192.168).x.x)
        body+mined:-Code= print(list(open('192.168.x.x').read())
          body+mined:-NL= print(os.environ['192.168.x.x'])
      body+mined:-Blocks= print(os.environ['192.168.x.x'])
      body+mined:-Inline= print(open('192.168.x.x').read())

================================================================================

QUESTION: idx=432    id=13368659
-------------------------------------INPUTS-------------------------------------

tags: 
score: 12
slot_map: {'key': ['str_0'], 'quote': ['"'], 'type': ['str'], 'value': ['192.168.x.x']}
intent: loop through the ip address range "192.168.x.x"
body(Left in tags for better readability):
<p> How can I loop through an IP address range in python? Lets say I
want to loop through every IP from 192.168.1.1 to 192.168. How can
this be done?

-------------------------------------OUTPUT-------------------------------------

                Expected= "generator = iter_iprange('192.168.1.1', '192.168.255.255', step=1)"
           base:Baseline= os.system('192.168.x.x', shell=True)
           body:Baseline= os.system('192.168.x.x').read()
            body:-Blocks= os.system('192.168.x.x')
              body:-Code= os.system('192.168.x.x')
            body:-Inline= loop((192.168).x.x)
                body:-NL= os.system('192.168.x.x', shell=True)
             base:+Mined= os.system('192.168.x.x')
     body+mined:Baseline= loop((192.168).x.x)
        body+mined:-Code= print(list(open('192.168.x.x').read())
          body+mined:-NL= print(os.environ['192.168.x.x'])
      body+mined:-Blocks= print(os.environ['192.168.x.x'])
      body+mined:-Inline= print(open('192.168.x.x').read())

================================================================================

QUESTION: idx=433    id=4065737
-------------------------------------INPUTS-------------------------------------

tags: list, numpy, scipy
score: 12
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['x']}
intent: sum the corresponding decimal values for binary values of each boolean element in list `x`
body(Left in tags for better readability):

<p> What is the fastest (or most "Pythonic") way to convert
<code_block>
 x = [False, False, True, True]

<p> into <code> 12 <p> ? (If there is such a way.)
<p> What if <code> x <p>  were instead a <code> numpy.array <p>  of
bools? Is there a special command for that?

<p> I have a large m-by-n array of booleans, where each n-element row
represents a single low-dimensional hash of a high-dimensional feature
vector. (In the example above, n = 4.) I would like to know the answer
in order to compress my data as much as possible. Thank you.

<em> Edit <p> : Thank you for the responses! Using the following test
code,
<code_block>
 t = 0
for iter in range(500):
    B = scipy.signbit(scipy.randn(1000,20))
    for b in B:
        t0 = time.clock()
        # test code here
        t1 = time.clock()
        t += (t1-t0)
print t

<p> <console_out>here were the runtimes on my Thinkpad laptop:

<a> My answer <li> : 4.26 sec
<a> Sven Marnach 1 <li> : 7.88
<a> Emil H <li> : 8.51
<a> Sven Marnach 2 <li> : 8.72
<a> delnan <li> : 10.14
<a> liori <li> : 53.49

<p> Of course, I welcome any independent tests that may confirm or
refute my data!

<em> Edit <p> : In my answer below, changing <code> int(j) <p>  to
simply <code> j <p>  still works, but runs six times as slow! Then
perhaps the other answers would become faster if the bool was casted
using <code> int <p> . But I'm too lazy to test everything again.

<em> Edit <p> : liori posted results of independent tests <a> here <p>
.

-------------------------------------OUTPUT-------------------------------------

                Expected= 'sum(1 << i for i, b in enumerate(x) if b)'
           base:Baseline= [int(x) for x in bin(x)]
           body:Baseline= sum(i, j) for i, j in zip(x, b))
            body:-Blocks= np.sum(int(x))
              body:-Code= sum(x[0] for x in bin(x))
            body:-Inline= [int(x) for x in range(500)]
                body:-NL= sum(x.decode('hex') for x in binascii.values())
             base:+Mined= [(int(x) / float(y)) for x in L]
     body+mined:Baseline= x = [(int(i) for i in range(0, len(x))])
        body+mined:-Code= [(float(i) for i in range(len(x))]
          body+mined:-NL= numpy.array(list(range(1000)), dtype=bool)
      body+mined:-Blocks= np.concatenate((i, j))
      body+mined:-Inline= x = [(int(i) for i in x) if i == 0]

================================================================================

QUESTION: idx=434    id=8691311
-------------------------------------INPUTS-------------------------------------

tags: string
score: 16
slot_map: {'key': ['var_0', 'var_1', 'var_2', 'var_3'], 'quote': ['`', '`', '`', '`'], 'type': ['var', 'var', 'var', 'var'], 'value': ['line1', 'line2', 'line3', 'target']}
intent: write multiple strings `line1`, `line2` and `line3` in one line in a file `target`
body(Left in tags for better readability):
<p> I've started to learn Python with LPTHW and I've gotten to
exercise 16:
<a> http://learnpythonthehardway.org/book/ex16.html
<p> And feel like an idiot because I can't figure out one of the
seemingly simple "extra credit" assignments that wants the following:
<code_block>
 target.write(line1)
target.write('\n')
target.write(line2)
target.write('\n')
target.write(line3)
target.write('\n')

<p> To be condensed to one line of code. I've tried some of the
following:
<code_block>
 target.write(line1 \n, line2 \n, line3 \n)

<p> Or:
<code_block>
 target.write('line1 \n, line2 \n, line3 \n')

<p> Or:
<code_block>
 target.write(%r \n, %r \n, %r \n) % (line1, line2, line3)

<p> I just can't get it to rewrite the line1, line2, and line3 strings
all in the same line.  And I've tried various other combinations with
and without commas, quotes, etc. I keep getting varying errors, like
Invalid Syntax or that I have too many arguments.

-------------------------------------OUTPUT-------------------------------------

                Expected= "target.write('%r\\n%r\\n%r\\n' % (line1, line2, line3))"
           base:Baseline= target.write(line1, line2, line3)
           body:Baseline= target.write(line1, line2, line3)
            body:-Blocks= print(target.write(line1, line2, line3))
              body:-Code= print(target.write(line1, line2, line3))
            body:-Inline= target.write(line1, line2, line3)
                body:-NL= target.write(line1, line2, line3)
             base:+Mined= f.write('\n'.join(line1, line2))
     body+mined:Baseline= target.write(line1, line2, line3)
        body+mined:-Code= f.write('\n'.join(line1, line2, line3))
          body+mined:-NL= target.write(line1, line2, line3)
      body+mined:-Blocks= f.write('\n'.join(line1, line2, line3))
      body+mined:-Inline= target.write(line1, line2, line3)

================================================================================

QUESTION: idx=435    id=10632111
-------------------------------------INPUTS-------------------------------------

tags: list, flatten
score: 4
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['data']}
intent: convert list of lists `data` into a flat list
body(Left in tags for better readability):
<p> I have a list of objects where objects can be lists or scalars. I
want an flattened list with only scalars.
Eg:
<code_block>
 L = [35,53,[525,6743],64,63,[743,754,757]]
outputList = [35,53,525,6743,64,63,743,754,757]

<p> P.S. The answers in this question does not work for heterogeneous
lists. <a> Flattening a shallow list in Python

-------------------------------------OUTPUT-------------------------------------

                Expected= '[y for x in data for y in (x if isinstance(x, list) else [x])]'
           base:Baseline= [list(data)) for i in data]
           body:Baseline= list(data, key=operator.itemgetter(1))
            body:-Blocks= [x for x in data if x is scalar]
              body:-Code= map(list, zip(*data))
            body:-Inline= map(list, zip(*data))
                body:-NL= list(data.items()), key=lambda x: x[1])
             base:+Mined= map(list, zip(*data))
     body+mined:Baseline= [[35, 53, 525, 6743, 64, 63, 743, 754, 757]]
        body+mined:-Code= [x for x in data for y in sorted(data)]
          body+mined:-NL= list(itertools.chain(*data))
      body+mined:-Blocks= [x for x in data for y in x]
      body+mined:-Inline= [[35, 53, 525, 6743, 64, 63, 743, 754, 757]]

================================================================================

QUESTION: idx=436    id=15392730
-------------------------------------INPUTS-------------------------------------

tags: escaping, newline
score: 64
slot_map: {'key': ['str_0', 'str_1'], 'quote': ['`', '`'], 'type': ['str', 'str'], 'value': ['\n', 'foo\nbar']}
intent: print new line character as `\n` in a string `foo\nbar`
body(Left in tags for better readability):
<p> I want the newline <code> \n <p>  to show up explicitly when
printing a string retrieved from elsewhere. So if the string is
'abc\ndef' I don't want this to happen:
<code_block>
 <console_in> print(line)
<console_out> abc
def

<p> but instead this:
<code_block>
 <console_in> print(line)
<console_out> abc\ndef

<p> Is there a way to modify print, or modify the argument, or maybe
another function entirely, to accomplish this?

-------------------------------------OUTPUT-------------------------------------

                Expected= "print('foo\\nbar'.encode('string_escape'))"
           base:Baseline= print('\n', 'foo\nbar')
           body:Baseline= print('foo\nbar'.format(\n))
            body:-Blocks= print('foo\nbar'.rstrip('\n')
              body:-Code= print('\n', 'foo\nbar')
            body:-Inline= print('\n'.join(line) for line in 'foo\nbar')
                body:-NL= print(('foo\nbar', '\n')
             base:+Mined= print('\n'.join(foo\nbar))
     body+mined:Baseline= print('\n'.join(foo\nbar))
        body+mined:-Code= print('\n'.join(foo\nbar))
          body+mined:-NL= print('\n'.join(foo))
      body+mined:-Blocks= print('\n'.join(foo\nbar))
      body+mined:-Inline= print('\n'.join(foo\nbar))

================================================================================

QUESTION: idx=437    id=1010961
-------------------------------------INPUTS-------------------------------------

tags: 
score: 12
slot_map: {'key': ['str_0', 'var_0'], 'quote': ["'", '`'], 'type': ['str', 'var'], 'value': [',', 's']}
intent: remove last comma character ',' in string `s`
body(Left in tags for better readability):
<p> I have a string, example:
<code_block>
 s = "this is a string, a"

<p> Where a <code> ',' <p>  (comma) will always be the 3rd to the last
character, aka <code> s[-3] <p> .
<p> I am thinking of ways to remove the ',' but can only think of
converting the string into a list, deleting it, and converting it back
to a string. This however seems a bit too much for simple task.
<p> How can I accomplish this in a simpler way?

-------------------------------------OUTPUT-------------------------------------

                Expected= '"""""".join(s.rsplit(\',\', 1))'
           base:Baseline= s = s.replace(',')
           body:Baseline= s = s.replace(',', '')
            body:-Blocks= s.replace(',', '')
              body:-Code= s = s.replace(',', '')
            body:-Inline= s = s.replace(',', '')
                body:-NL= s = s.replace(',', ',')
             base:+Mined= s = s.replace(',', '')
     body+mined:Baseline= s = s.replace(',', '')
        body+mined:-Code= s.replace(',', '')
          body+mined:-NL= s = s.replace(',', '')
      body+mined:-Blocks= s.replace(',', '')
      body+mined:-Inline= s = s.replace(',', '')

================================================================================

QUESTION: idx=438    id=23855976
-------------------------------------INPUTS-------------------------------------

tags: numpy, mean
score: 24
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['x']}
intent: calculate the mean of each element in array `x` with the element previous to it
body(Left in tags for better readability):
<p> I have an array of the form:
<code> x = np.array([ 1230.,  1230.,  1227.,  1235.,  1217.,  1153.,
1170.])
<p> and I would like to produce another array where the values are the
mean of each pair of values within my original array:
<code> xm = np.array([ 1230.,  1228.5,  1231.,  1226.,  1185.,
1161.5])
<p> Someone knows the easiest and fast way to do it without using
loops?

-------------------------------------OUTPUT-------------------------------------

                Expected= '(x[1:] + x[:-1]) / 2'
           base:Baseline= np.mean(x, y)
           body:Baseline= np.array([sum(x)) / np.mean(x, y))
            body:-Blocks= np.array([x[0], x[0] - x[1]))
              body:-Code= np.mean(x, y)
            body:-Inline= x = np.mean(np.arange(x))
                body:-NL= np.mean(np.arange(x, axis=1).mean(axis=1))
             base:+Mined= np.mean(x, y)
     body+mined:Baseline= x.mean(axis=1)
        body+mined:-Code= np.mean(x, y)
          body+mined:-NL= x = np.mean(np.arange(x.shape[0]), xm)
      body+mined:-Blocks= np.mean(x, y)
      body+mined:-Inline= x.mean(axis=1)

================================================================================

QUESTION: idx=439    id=23855976
-------------------------------------INPUTS-------------------------------------

tags: numpy, mean
score: 24
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['x']}
intent: get an array of the mean of each two consecutive values in numpy array `x`
body(Left in tags for better readability):
<p> I have an array of the form:
<code> x = np.array([ 1230.,  1230.,  1227.,  1235.,  1217.,  1153.,
1170.])
<p> and I would like to produce another array where the values are the
mean of each pair of values within my original array:
<code> xm = np.array([ 1230.,  1228.5,  1231.,  1226.,  1185.,
1161.5])
<p> Someone knows the easiest and fast way to do it without using
loops?

-------------------------------------OUTPUT-------------------------------------

                Expected= 'x[:-1] + (x[1:] - x[:-1]) / 2'
           base:Baseline= np.arange(x, y)
           body:Baseline= np.array([sum(x, y)) / np.mean(y))
            body:-Blocks= np.array([np.mean(x, y)) / np.mean([2, 3], axis=1)]
              body:-Code= np.mean(x, y)
            body:-Inline= np.mean(x, y)
                body:-NL= np.arange(np.mean(x, y))
             base:+Mined= np.mean(x, y, axis=1)
     body+mined:Baseline= x = np.mean(x[:, (np.arange(1), x[2]))
        body+mined:-Code= np.mean(x, axis=1)
          body+mined:-NL= np.mean(x[:, (np.arange(len(x)) - len(x), -1)]
      body+mined:-Blocks= np.mean(x, y)
      body+mined:-Inline= x = np.mean(axis=1)

================================================================================

QUESTION: idx=440    id=6375343
-------------------------------------INPUTS-------------------------------------

tags: unicode, numpy
score: 10
slot_map: {'key': ['str_0', 'str_1', 'var_0'], 'quote': ['`', '`', '`'], 'type': ['str', 'str', 'var'], 'value': ['utf-8', 'new.txt', 'arr']}
intent: load data containing `utf-8` from file `new.txt` into numpy array `arr`
body(Left in tags for better readability):
<p> Consider a text file called "new.txt" containing the following
elements:
<code_block>
 mm
r
l

<p> In Python 2.7, I can read the file by typing:
<code_block>
 <console_in> import codecs
<console_in> f = codecs.open('new.txt', encoding='utf-8')
<console_in> lines = [line.strip() for line in f2.readlines()]
<console_in> lines
<console_out> [u'\u03bcm', u'\u2202r', u'\u2206\u03bb']
<console_in> print lines[0]
<console_out> mm

<p> So far so good. I can easily convert this list to a numpy array
via:
<code_block>
 <console_in> import numpy as np
<console_in> arr = np.array(lines)
<console_in> arr
<console_out> array([u'\u03bcm', u'\u2202r', u'\u2206\u03bb'],
      dtype=' <U2')

<p> The issue is, I can't read this file directly via numpy's loadtxt
function:
<code_block>
 <console_in> np.loadtxt('new.txt', dtype=np.unicode_)
<console_out> Traceback (most recent call last):
  File " <stdin>", line 1, in <module>
  File "/usr/lib64/python2.7/site-packages/numpy/lib/npyio.py", line
805, in loadtxt
    X = np.array(X, dtype)
UnicodeDecodeError: 'ascii' codec can't decode byte 0xce in position
0: ordinal not in range(128)

<p> What is the correct way to read this file into numpy directly?
<p> Thanks.

-------------------------------------OUTPUT-------------------------------------

                Expected= "arr = numpy.fromiter(codecs.open('new.txt', encoding='utf-8'), dtype='<U2')"
           base:Baseline= arr.load(new.txt, encoding='utf-8')
           body:Baseline= np.loadtxt('new.txt', encoding='utf-8')
            body:-Blocks= arr = numpy.loadtxt('new.txt')
              body:-Code= arr = numpy.loadtxt(open('new.txt', 'utf-8')
            body:-Inline= arr.loadtxt('new.txt', encoding='utf-8')
                body:-NL= arr = np.loadtxt('new.txt', encoding='utf-8')
             base:+Mined= arr = numpy.loadtxt(new.txt, encoding='utf-8')
     body+mined:Baseline= arr = np.loadtxt('new.txt', encoding='utf-8')
        body+mined:-Code= arr = numpy.loadtxt(new.txt)
          body+mined:-NL= np.loadtxt('new.txt', dtype='∆λ')
      body+mined:-Blocks= arr = numpy.loadtxt(open('new.txt', 'rb').read())
      body+mined:-Inline= arr = np.loadtxt('new.txt', encoding='utf-8')

================================================================================

QUESTION: idx=441    id=1547733
-------------------------------------INPUTS-------------------------------------

tags: list
score: 5
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['l', 'time']}
intent: reverse sort list of dicts `l` by value for key `time`
body(Left in tags for better readability):
<p> [ {'time':33}, {'time':11}, {'time':66} ]
<p> How to sort by the "time" element, DESC.

-------------------------------------OUTPUT-------------------------------------

                Expected= "l = sorted(l, key=itemgetter('time'), reverse=True)"
           base:Baseline= sorted(l, key=lambda x: x[1])
           body:Baseline= sorted(L, key=itemgetter(time))
            body:-Blocks= sorted(l, key=lambda x: [{'time': 33}, {'time': 11}, {'Time': 66}])
              body:-Code= l.sort(key=lambda x: (x[1], x[1])
            body:-Inline= sorted(l, key=lambda x: x[1])
                body:-NL= sorted(L, key=lambda t: t.time)
             base:+Mined= sorted(l, key=lambda t: t.time)
     body+mined:Baseline= sorted(l, key=itemgetter(1), reverse=True)
        body+mined:-Code= sorted(l, key=lambda t: t.time())
          body+mined:-NL= sorted(L, key=time.itemgetter(1))
      body+mined:-Blocks= sorted(l, key=lambda x: (x['time'], x['time']))
      body+mined:-Inline= sorted(L, key=lambda t: t[1])

================================================================================

QUESTION: idx=442    id=1547733
-------------------------------------INPUTS-------------------------------------

tags: list
score: 5
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['l', 'time']}
intent: sort a list of dictionary `l` based on key `time` in descending order
body(Left in tags for better readability):
<p> [ {'time':33}, {'time':11}, {'time':66} ]
<p> How to sort by the "time" element, DESC.

-------------------------------------OUTPUT-------------------------------------

                Expected= "l = sorted(l, key=lambda a: a['time'], reverse=True)"
           base:Baseline= sorted(l, key=lambda x: (x[1], reverse=True)
           body:Baseline= sorted(list(L.items()), key=lambda x: x[1], reverse=True)
            body:-Blocks= sorted(l, key=lambda x: (x[1], x[1]), reverse=True)
              body:-Code= sorted(l, key=lambda x: (x[1], x[1]), reverse=True)
            body:-Inline= sorted(l, key=lambda x: x['time'])
                body:-NL= sorted(L, key=operator.itemgetter(time))
             base:+Mined= sorted(l, key=lambda x: (x[1], x[0]))
     body+mined:Baseline= sorted(l, key=itemgetter(1), reverse=True)
        body+mined:-Code= sorted(l, key=lambda x: x['time'] == 'time')
          body+mined:-NL= sorted(L, key=lambda x: x[1])
      body+mined:-Blocks= sorted(l, key=lambda item: item[1]['time'], reverse=True)
      body+mined:-Inline= sorted(L, key=lambda x: (x['time'] == 'time'])

================================================================================

QUESTION: idx=443    id=37080612
-------------------------------------INPUTS-------------------------------------

tags: regex, pandas, filter
score: 9
slot_map: {'key': ['var_0', 'str_0', '(str_0)'], 'quote': ['`', "'", "'"], 'type': ['var', 'str', 'str'], 'value': ['df', '(Hel|Just)', '(Hel|Just)']}
intent: get rows of dataframe `df` that match regex '(hel|just)'
body(Left in tags for better readability):
<p> I don't understand <code> pandas
<code> DataFrame
<code> filter <p> .
<h3> Setup
<code_block>
 import pandas as pd

df = pd.DataFrame(
    [
        ['Hello', 'World'],
        ['Just', 'Wanted'],
        ['To', 'Say'],
        ['I\'m', 'Tired']
    ]
)

<h3> Problem
<code_block>
 df.filter([0], regex=r'(Hel|Just)', axis=0)

<p> I'd expect the <code> [0] <p>  to specify the 1st column as the
one to look at and <code> axis=0 <p>  to specify filtering rows.  What
I get is this:
<code_block>
        0      1
0  Hello  World

<p> I was expecting
<code_block>
        0       1
0  Hello   World
1   Just  Wanted

<h3> Question

<li> What would have gotten me what I expected?


-------------------------------------OUTPUT-------------------------------------

                Expected= "df.loc[df[0].str.contains('(Hel|Just)')]"
           base:Baseline= df.groupby(['hel|just'])
           body:Baseline= df.filter([0], regex='(Hel|Just)', axis=0)
            body:-Blocks= df.groupby(['hel|just'])
              body:-Code= df.filter(re.search('hel|just)'))
            body:-Inline= df.groupby('(Hel|Just)', axis=0)
                body:-NL= df.set_index('(Hel|Just)', axis=0)
             base:+Mined= df.loc[df.groupby('hel|just)']
     body+mined:Baseline= df.filter([0], regex='(Hel|Just)', axis=0)
        body+mined:-Code= df.query('(hel|just)')
          body+mined:-NL= df[df.groupby('Just')['Wanted'].apply(lambda x: x.Tired)
      body+mined:-Blocks= df.groupby(['hel|just']).apply(lambda x: x[1])
      body+mined:-Inline= df.filter([0], regex=r('(Hel|Just)', axis=0)

================================================================================

QUESTION: idx=444    id=14716342
-------------------------------------INPUTS-------------------------------------

tags: string, special-characters
score: 11
slot_map: {'key': ['var_0', 'str_0', 'str_1'], 'quote': ['`', '"', '"'], 'type': ['var', 'str', 'str'], 'value': ['your_string', '[', ']']}
intent: find the string in `your_string` between two special characters "[" and "]"
body(Left in tags for better readability):
<p> For example, I need everything in between the two square brackets.
File1
<code_block>
 [Home sapiens]
[Mus musculus 1]
[virus 1 [isolated from china]]

<p> So considering the above example, I need everything in between the
first and last square brackets.

-------------------------------------OUTPUT-------------------------------------

                Expected= "re.search('\\\\[(.*)\\\\]', your_string).group(1)"
           base:Baseline= your_string.split(' ', '')
           body:Baseline= your_string.replace(' ', '')
            body:-Blocks= your_string.replace(' ', '')
              body:-Code= your_string.replace(' ', '')
            body:-Inline= your_string.replace(' ', '')
                body:-NL= print(your_string.split(', ', '))
             base:+Mined= your_string.find(string)
     body+mined:Baseline= re.findall('\\[\\]', your_string)
        body+mined:-Code= your_string.find('[^"]+)', your_string)
          body+mined:-NL= re.findall('\\s+', your_string)
      body+mined:-Blocks= your_string.find_all('["[" and ']"])
      body+mined:-Inline= your_string.split(',')[1]

================================================================================

QUESTION: idx=445    id=18684076
-------------------------------------INPUTS-------------------------------------

tags: pandas, datetime-format
score: 10
slot_map: {'key': ['str_0'], 'quote': ["'"], 'type': ['str'], 'value': ['yyyymmdd']}
intent: how to create a list of date string in 'yyyymmdd' format with python pandas?
body(Left in tags for better readability):
<p> I want a list of date range in which each element is <code>
'yyyymmdd' <p>  format string, such as : <code>
['20130226','20130227','20130228','20130301','20130302'] <p>  .
<p> I can use pandas to do so:
<code_block>
 <console_in> pandas.date_range('20130226','20130302')
<class 'pandas.tseries.index.DatetimeIndex'>
[2013-02-26 00:00:00, <console_out>, 2013-03-02 00:00:00]
Length: 5, Freq: D, Timezone: None

<p> But it is DatetimeIndex and I need to do some extra format
transform, so how to do that in a neat way ?

-------------------------------------OUTPUT-------------------------------------

                Expected= "[d.strftime('%Y%m%d') for d in pandas.date_range('20130226', '20130302')]"
           base:Baseline= df['Date'].strftime('yyyymmdd')
           body:Baseline= pandas.date_range('yyyymmdd').strftime('%Y-%m-%d')
            body:-Blocks= df = pd.datetime.strptime('yyyymmdd')
              body:-Code= df = datetime.datetime.strptime('yyyymmdd')
            body:-Inline= df.strftime('yyyymmdd')
                body:-NL= pandas.date_range('yyyymmdd').strftime('%Y-%m-%d')
             base:+Mined= df['Date'].strftime('%Y-%m-%d')
     body+mined:Baseline= pandas.date_range('20130226', '20130302')
        body+mined:-Code= df.date.strftime('%Y%m%d')
          body+mined:-NL= df.date_range('20130226', '20130302')
      body+mined:-Blocks= df['%Y%m%d'].strftime('%H:%M%S')
      body+mined:-Inline= pandas.tseries.index.date_range('20130226', '20130302')

================================================================================

QUESTION: idx=446    id=1666700
-------------------------------------INPUTS-------------------------------------

tags: 
score: 7
slot_map: {'key': ['str_0', 'str_1'], 'quote': ["'", "'"], 'type': ['str', 'str'], 'value': ['brown', 'The big brown fox is brown']}
intent: count number of times string 'brown' occurred in string 'the big brown fox is brown'
body(Left in tags for better readability):
<p> In python, I remember there is a function to do this.
<p> .count?
<p> "The big brown fox is brown"
brown = 2.

-------------------------------------OUTPUT-------------------------------------

                Expected= '"""The big brown fox is brown""".count(\'brown\')'
           base:Baseline= """The big brown fox is brown""".count('brown')
           body:Baseline= count('The big brown fox is brown')
            body:-Blocks= """The big brown fox is brown""".count('brown')
              body:-Code= """The big brown fox is brown""".count('brown')
            body:-Inline= """The big brown fox is brown""".count('brown')
                body:-NL= """The big brown fox is brown""".count('b')
             base:+Mined= len('the big brown fox is brown')
     body+mined:Baseline= """The big brown fox is brown""".count()
        body+mined:-Code= """The big brown fox is brown""".count('brown')
          body+mined:-NL= len('the big brown fox is brown') - len('brown')
      body+mined:-Blocks= """The big brown fox is brown""".count('brown')
      body+mined:-Inline= len('The big brown fox is brown').count()

================================================================================

QUESTION: idx=447    id=18979111
-------------------------------------INPUTS-------------------------------------

tags: django, angularjs, http-post
score: 21
slot_map: {'key': ['str_0'], 'quote': ['`'], 'type': ['str'], 'value': ['request.body']}
intent: decode json string `request.body` to python dict
body(Left in tags for better readability):
<p> I have a request like this:
<code_block>
 $http({
    method: 'POST',
    url: '/url/',
    data: 'test=data'
})

<p> In my django views:
<code_block>
 class SomeClass(View):
    def get(self, request):
        return HttpResponse("Hello")
    def post(self, request):
        print request.post
        print request.body
        return HttpResponse("Done")

<p> So when I do <code> request.POST <p>   I get an empty query dict :
<code> <QueryDict: {}>
<p> But my <code> request.body <p>  has: <code> test=data
<p> So I believe django receives the data as url-encoded parameters
and not as a dictionary.
<p> How do I send or receive this data as JSON/Dict ?

-------------------------------------OUTPUT-------------------------------------

                Expected= 'json.loads(request.body)'
           base:Baseline= dict(request.body.decode('utf-8'))
           body:Baseline= request.body.decode('json')
            body:-Blocks= request.body.decode('json')
              body:-Code= dict(request.body.decode('utf-8'))
            body:-Inline= request.body.decode('json')
                body:-NL= request.body.decode('json')
             base:+Mined= json.dumps(request.body, ensure_ascii=False)
     body+mined:Baseline= dict(request.body.decode('utf-8'))
        body+mined:-Code= request.body.decode('json')
          body+mined:-NL= print(request.body.decode('json'))
      body+mined:-Blocks= json.dumps(request.body.decode('utf-8'))
      body+mined:-Inline= {'data': 'test=data'}

================================================================================

QUESTION: idx=448    id=7243750
-------------------------------------INPUTS-------------------------------------

tags: 
score: 363
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['url', 'file_name']}
intent: download the file from url `url` and save it under file `file_name`
body(Left in tags for better readability):
<p> I am creating a program that will download a .jar (java) file from
a web server, by reading the URL that is specified in the .jad file of
the same game/application. I'm using Python 3.2.1
<p> I've managed to extract the URL of the JAR file from the JAD file
(every JAD file contains the URL to the JAR file), but as you may
imagine, the extracted value is type() string.
<p> Here's the relevant function:
<code_block>
 def downloadFile(URL=None):
    import httplib2
    h = httplib2.Http(".cache")
    resp, content = h.request(URL, "GET")
    return content

downloadFile(URL_from_file)

<p> However I always get an error saying that the type in the function
above has to be bytes, and not string. I've tried using the
URL.encode('utf-8'), and also bytes(URL,encoding='utf-8'), but I'd
always get the same or similar error.
<p> So basically my question is how to download a file from a server
when the URL is stored in a string type?

-------------------------------------OUTPUT-------------------------------------

                Expected= 'urllib.request.urlretrieve(url, file_name)'
           base:Baseline= urllib.request.urlretrieve(url)
           body:Baseline= urllib.request.url, filename_name=file_name)
            body:-Blocks= urllib.request.urlopen('file_name')
              body:-Code= open('file_name', url)
            body:-Inline= urllib.request.urlretrieve(file_name)
                body:-NL= urllib.request.urlretrieve(file_name)
             base:+Mined= file_name = open('url', 'rb').read()
     body+mined:Baseline= urllib.request.urlretrieve('http://example.com', file_name)
        body+mined:-Code= urllib.request.urlretrieve('download.jar', file_name)
          body+mined:-NL= urllib.request.urlretrieve('http://stackoverflow.com', filename)
      body+mined:-Blocks= urllib.request.urlopen(url, 'file_name').read()
      body+mined:-Inline= urllib.request.urlretrieve('http://example.com', file_name)

================================================================================

QUESTION: idx=449    id=743806
-------------------------------------INPUTS-------------------------------------

tags: list, split, text-segmentation
score: 592
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['text']}
intent: split string `text` by space
body(Left in tags for better readability):
<p> I want my Python function to split a sentence (input) and store
each word in a list. My current code splits the sentence, but does not
store the words as a list. How do I do that?
<code_block>
 def split_line(text):

    # split the text
    words = text.split()

    # for each word in the line:
    for word in words:

        # print the word
        print(words)


-------------------------------------OUTPUT-------------------------------------

                Expected= 'text.split()'
           base:Baseline= re.split('\\w+', text)
           body:Baseline= s = text.split(',', text)
            body:-Blocks= [x for x in text if x.split()]
              body:-Code= re.split('\\w+', text)
            body:-Inline= text = text.split(',')
                body:-NL= print(text.split()).split()
             base:+Mined= re.split('\\s+', text)
     body+mined:Baseline= words = text.split(',')
        body+mined:-Code= re.split('\\s+', text)
          body+mined:-NL= re.split('\\s+', text)
      body+mined:-Blocks= re.split('\\s+', text)
      body+mined:-Inline= words = text.split(',')

================================================================================

QUESTION: idx=450    id=743806
-------------------------------------INPUTS-------------------------------------

tags: list, split, text-segmentation
score: 592
slot_map: {'key': ['var_0', 'str_0'], 'quote': ['`', '"'], 'type': ['var', 'str'], 'value': ['text', ',']}
intent: split string `text` by ","
body(Left in tags for better readability):
<p> I want my Python function to split a sentence (input) and store
each word in a list. My current code splits the sentence, but does not
store the words as a list. How do I do that?
<code_block>
 def split_line(text):

    # split the text
    words = text.split()

    # for each word in the line:
    for word in words:

        # print the word
        print(words)


-------------------------------------OUTPUT-------------------------------------

                Expected= "text.split(',')"
           base:Baseline= text = re.sub('(?)', ',')
           body:Baseline= s = text.split(',', text)
            body:-Blocks= text = re.split(',")
              body:-Code= re.split('(?=,)', text)
            body:-Inline= text = text.split(',')
                body:-NL= print(text.split()).split()
             base:+Mined= re.split('(.)', text)
     body+mined:Baseline= words = text.split(',')
        body+mined:-Code= re.split('(?<=.)', text)
          body+mined:-NL= re.split('\\s+', text)
      body+mined:-Blocks= re.split('(?<=.)', text)
      body+mined:-Inline= words = text.split(',')

================================================================================

QUESTION: idx=451    id=743806
-------------------------------------INPUTS-------------------------------------

tags: list, split, text-segmentation
score: 592
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['line']}
intent: split string `line` into a list by whitespace
body(Left in tags for better readability):
<p> I want my Python function to split a sentence (input) and store
each word in a list. My current code splits the sentence, but does not
store the words as a list. How do I do that?
<code_block>
 def split_line(text):

    # split the text
    words = text.split()

    # for each word in the line:
    for word in words:

        # print the word
        print(words)


-------------------------------------OUTPUT-------------------------------------

                Expected= 'line.split()'
           base:Baseline= [item for item in line if item.strip()]
           body:Baseline= list(re.split('line', ''))
            body:-Blocks= [x for x in line if x.split()]
              body:-Code= [item for item in line if item in item]
            body:-Inline= list(itertools.split(line))
                body:-NL= list(itertools.groupby(line))
             base:+Mined= [line.strip() for line in line.split()]
     body+mined:Baseline= words = [split(line) for line in words]
        body+mined:-Code= [line.split() for line in input]
          body+mined:-NL= words = [line.split() for line in words]
      body+mined:-Blocks= [line.split() for line in re.split(',')]
      body+mined:-Inline= words = [line.split() for line in words]

================================================================================

QUESTION: idx=452    id=35044115
-------------------------------------INPUTS-------------------------------------

tags: regex, replace, substitution
score: 4
slot_map: {'key': ['str_0', 'var_0', 'str_1'], 'quote': ["'", '`', "'"], 'type': ['str', 'var', 'str'], 'value': ['.', 's', '']}
intent: replace dot characters  '.' associated with ascii letters in list `s` with space ' '
body(Left in tags for better readability):
<p> Using Python, I have the following strings:
<code_block>
 ['taxes.............................       .7        21.4
(6.2)','regulatory and other matters..................$   39.9
61.5        41.1','Producer contract reformation cost
recoveries............................   DASH        26.3
28.3']

<p> I need to replace each of the dots with a space, but not the
periods in the numbers.  So the result should look like this:
<code_block>
 ['taxes                                    .7        21.4
(6.2)','regulatory and other matters                  $   39.9
61.5        41.1','Producer contract reformation cost recoveries
DASH        26.3        28.3']

<p> I've tried the following:
<code_block>
 dots=re.compile('(\.{2,})(\s*?[\d\(\$]|\s*?DASH|\s*.)')
newlist=[]
for each in list:
    newline=dots.sub(r'\2'.replace('.',' '),each)
    newdoc.append(newline)

<p> But, this code doesn't retain the white space.  Thanks!

-------------------------------------OUTPUT-------------------------------------

                Expected= "[re.sub('(?<!\\\\d)\\\\.(?!\\\\d)', '', i) for i in s]"
           base:Baseline= s = s.replace('.', '.')
           body:Baseline= re.compile('(\\.{2,})(\\s*?[\\d\\(\\$]|\\S*?DASH|\\s*.)')
            body:-Blocks= s = s.replace('.', '.')
              body:-Code= s = s.replace('.', '')
            body:-Inline= re.sub('(\\.{2,})(\\s*?[\\d\\(\\$]|\\s*?)', '.')
                body:-NL= re.sub('(\\.{2,})(\\s*?)', '', s)
             base:+Mined= s = s.replace('.', '')
     body+mined:Baseline= s.replace('.', '\\2', '')
        body+mined:-Code= s = s.replace('.', '.')
          body+mined:-NL= newline = [dots.sub('\\2', '.') for dots in s.split(',')]
      body+mined:-Blocks= s = s.replace('.', '.')
      body+mined:-Inline= s = [s.replace('.', '') for s in s.split(',')]

================================================================================

QUESTION: idx=453    id=38388799
-------------------------------------INPUTS-------------------------------------

tags: list, sorting
score: 5
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['list_of_strings', 's']}
intent: sort list `list_of_strings` based on second index of each string `s`
body(Left in tags for better readability):
<p> Overview: I have data something like this (each row is a string):

<p> 81:0A:D7:19:25:7B, <strong> 2016-07-14 14:29:13 <p> , 2016-07-14
14:29:15, -69, 22:22:22:22:22:23,null,^M
3B:3F:B9:0A:83:E6, <strong> 2016-07-14 01:28:59 <p> , 2016-07-14
01:29:01, -36, 33:33:33:33:33:31,null,^M
B3:C0:6E:77:E5:31, <strong> 2016-07-14 08:26:45 <p> , 2016-07-14
08:26:47, -65, 33:33:33:33:33:32,null,^M
61:01:55:16:B5:52, <strong> 2016-07-14 06:25:32 <p> , 2016-07-14
06:25:34, -56, 33:33:33:33:33:33,null,^M

<p> And I want to sort each row based on the first timestamp that is
present in the each String, which for these four records is:

<p> 2016-07-14 01:28:59
<p> 2016-07-14 06:25:32
<p> 2016-07-14 08:26:45
<p> 2016-07-14 14:29:13

<p> Now I know the <code> sort() <p>  method but I don't understand
how can I use here to sort all the rows based on this (timestamp)
quantity, and I do need to keep the final sorted data in the same
format as some other service is going to use it.
<p> I also understand I can make the <code> key() <p>  but I am not
clear how that can be made to sort on the timestamp field.

-------------------------------------OUTPUT-------------------------------------

                Expected= "sorted(list_of_strings, key=lambda s: s.split(',')[1])"
           base:Baseline= sorted(list_of_strings, key=lambda x: x[1])
           body:Baseline= sorted(list_of_strings, key=lambda x: x[1], reverse=True)
            body:-Blocks= sorted(list_of_strings, key=lambda x: x[1])
              body:-Code= list_of_strings.sort(key=lambda x: x[1])
            body:-Inline= sorted_list(list_of_strings, key=lambda x: x[1])
                body:-NL= sorted(list_of_strings, key=lambda x: x[1])
             base:+Mined= sorted(list_of_strings, key=lambda x: x[1])
     body+mined:Baseline= sorted(list_of_strings, key=lambda x: int(x[1]))
        body+mined:-Code= sorted(list_of_strings, key=lambda x: x[1])
          body+mined:-NL= list_of_strings.sort(key=lambda x: x[1])
      body+mined:-Blocks= sorted(list_of_strings, key=lambda x: x[1]))
      body+mined:-Inline= sorted(list_of_strings, key=lambda x: int(x[1]))

================================================================================

QUESTION: idx=454    id=9609375
-------------------------------------INPUTS-------------------------------------

tags: bash, call, subprocess
score: 4
slot_map: {'key': ['str_0', 'str_1', 'str_2'], 'quote': ["'", "'", "'"], 'type': ['str', 'str', 'str'], 'value': ['vasp', 'tee tee_output', '|']}
intent: call multiple bash function 'vasp' and 'tee tee_output' using '|'
body(Left in tags for better readability):
<p> I am using a scientific software (called vasp) that works only in
bash, and using Python to create a script that will make multiple runs
for me. When I use subprocess.check_call to call the function
normally, it works fine, but when i add the '| tee tee_output' it
doesn't work.
<code_block>
 subprocess.check_call('vasp') #this works
subprocess.check_call('vasp | tee tee_output') #this doesn't

<p> I am a noobie to python and programming altogether.

-------------------------------------OUTPUT-------------------------------------

                Expected= "subprocess.check_call('vasp | tee tee_output', shell=True)"
           base:Baseline= subprocess.call('vasp', 'tee tee_output', '|')
           body:Baseline= subprocess.check_call('vasp', 'tee tee_output')
            body:-Blocks= subprocess.call('vasp', 'tee tee_output', '|')
              body:-Code= subprocess.call('vasp', 'tee tee_output', '|')
            body:-Inline= subprocess.check_call('vasp', 'tee tee_output')
                body:-NL= subprocess.call('vasp', 'tee tee_output')
             base:+Mined= subprocess.call('vasp', shell=True)
     body+mined:Baseline= subprocess.check_call('vasp | tee tee_output')
        body+mined:-Code= subprocess.check_call('vasp', shell=True)
          body+mined:-NL= subprocess.check_call('vasp | tee tee_output', shell=True)
      body+mined:-Blocks= subprocess.check_call('vasp', shell=True)
      body+mined:-Inline= subprocess.check_call('vasp | tee tee_output')

================================================================================

QUESTION: idx=455    id=37004138
-------------------------------------INPUTS-------------------------------------

tags: 
score: 5
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['lst']}
intent: eliminate all strings from list `lst`
body(Left in tags for better readability):
<p> my question is how to eliminate all strings from a list, for
example if I have  <code> list=['hello',1,2,3,4,'goodbye','help'] <p>
and the outcome to be <code> list=[1,2,3,4]

-------------------------------------OUTPUT-------------------------------------

                Expected= '[element for element in lst if isinstance(element, int)]'
           base:Baseline= del lst[::-1]
           body:Baseline= [x for x in lst if x not in x]
            body:-Blocks= [x for x in lst if x not in x]
              body:-Code= del lst[::-1]
            body:-Inline= del lst[::-1]
                body:-NL= del lst[::-1]
             base:+Mined= """""".join(lst)
     body+mined:Baseline= [x for x in lst if x not in list]
        body+mined:-Code= [k for k, v in lst if len(v)!= 'all')
          body+mined:-NL= list(itertools.chain.from_iterable(lst))
      body+mined:-Blocks= list = [x for x in lst if len(x) == 'hello')]
      body+mined:-Inline= [x for x in lst if x is not None]

================================================================================

QUESTION: idx=456    id=37004138
-------------------------------------INPUTS-------------------------------------

tags: 
score: 5
slot_map: {'key': ['str_0'], 'quote': ["'"], 'type': ['str'], 'value': ['lst']}
intent: get all the elements except strings from the list 'lst'.
body(Left in tags for better readability):
<p> my question is how to eliminate all strings from a list, for
example if I have  <code> list=['hello',1,2,3,4,'goodbye','help'] <p>
and the outcome to be <code> list=[1,2,3,4]

-------------------------------------OUTPUT-------------------------------------

                Expected= '[element for element in lst if not isinstance(element, str)]'
           base:Baseline= [x for x in lst if x not in x]
           body:Baseline= [x for x in lst if x not in x]
            body:-Blocks= [x for x in lst if x not in x]
              body:-Code= [x for x in lst if not x in x]
            body:-Inline= [x for x in Lst if x not in lst]
                body:-NL= [x for x in lst if x not in x]
             base:+Mined= [lst for lst in lst]
     body+mined:Baseline= [x for x in lst if x != 'lst']
        body+mined:-Code= [x for x in lst if x is not None]
          body+mined:-NL= list(itertools.chain.from_iterable(lst))
      body+mined:-Blocks= list = [x for x in lst if x.startswith('hello')]
      body+mined:-Inline= [x for x in lst if x != 'lst']

================================================================================

QUESTION: idx=457    id=72899
-------------------------------------INPUTS-------------------------------------

tags: list, sorting, dictionary, data-structures
score: 2137
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['list_to_be_sorted', 'name']}
intent: sort a list of dictionaries `list_to_be_sorted` by the value of the dictionary key `name`
body(Left in tags for better readability):
<p> I have a list of dictionaries and want each item to be sorted by a
specific value.
<p> Take into consideration the list:
<code_block>
 [{'name':'Homer', 'age':39}, {'name':'Bart', 'age':10}]

<p> When sorted by <code> name <p> , it should become:
<code_block>
 [{'name':'Bart', 'age':10}, {'name':'Homer', 'age':39}]


-------------------------------------OUTPUT-------------------------------------

                Expected= "newlist = sorted(list_to_be_sorted, key=lambda k: k['name'])"
           base:Baseline= sorted(list_to_be_sorted, key=lambda d: d[name])
           body:Baseline= sorted(list_to_be_sorted, key=lambda kname: kname[kname])
            body:-Blocks= sorted(list_to_be_sorted, key=lambda d: d[name])
              body:-Code= sorted(list_to_be_sorted, key=lambda d: d[name])
            body:-Inline= sorted(list_to_be_sorted, key=lambda d: d[name])
                body:-NL= sorted(list_to_be_sorted, key=lambda x: x[1])
             base:+Mined= sorted(list_to_be_sorted, key=lambda d: d['name'])
     body+mined:Baseline= sorted(list_to_be_sorted, key=lambda x: x['name'], reverse=True)
        body+mined:-Code= sorted(list_to_be_sorted, key=lambda d: d['name'])
          body+mined:-NL= sorted(list_to_be_sorted, key=lambda d: d['name'], reverse=True)
      body+mined:-Blocks= sorted(list_to_be_sorted, key=lambda d: d['name'])
      body+mined:-Inline= sorted(list_to_be_sorted, key=lambda d: d['name'], reverse=True)

================================================================================

QUESTION: idx=458    id=72899
-------------------------------------INPUTS-------------------------------------

tags: list, sorting, dictionary, data-structures
score: 2137
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['l', 'name']}
intent: sort a list of dictionaries `l` by values in key `name` in descending order
body(Left in tags for better readability):
<p> I have a list of dictionaries and want each item to be sorted by a
specific value.
<p> Take into consideration the list:
<code_block>
 [{'name':'Homer', 'age':39}, {'name':'Bart', 'age':10}]

<p> When sorted by <code> name <p> , it should become:
<code_block>
 [{'name':'Bart', 'age':10}, {'name':'Homer', 'age':39}]


-------------------------------------OUTPUT-------------------------------------

                Expected= "newlist = sorted(l, key=itemgetter('name'), reverse=True)"
           base:Baseline= sorted(l, key=lambda x: x['name'], reverse=True)
           body:Baseline= sorted(L, key=lambda x: x['name']))
            body:-Blocks= sorted(l, key=lambda x: x['name'])
              body:-Code= sorted(l, key=lambda x: (x['name'], reverse=True)
            body:-Inline= sorted(l, key=lambda x: x['name']))
                body:-NL= sorted(l, key=lambda x: x[1])
             base:+Mined= l.sort(key=lambda d: d['name'], reverse=True)
     body+mined:Baseline= sorted(l, key=lambda x: x['name'], reverse=True)
        body+mined:-Code= sorted(l, key=lambda x: x['name'], reverse=True)
          body+mined:-NL= sorted(L, key=lambda d: d['name'], reverse=True)
      body+mined:-Blocks= sorted(l, key=lambda d: d['name'], reverse=True)
      body+mined:-Inline= sorted(l, key=lambda d: d['name'], reverse=True)

================================================================================

QUESTION: idx=459    id=72899
-------------------------------------INPUTS-------------------------------------

tags: list, sorting, dictionary, data-structures
score: 2137
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: how do i sort a list of dictionaries by values of the dictionary in python?
body(Left in tags for better readability):
<p> I have a list of dictionaries and want each item to be sorted by a
specific value.
<p> Take into consideration the list:
<code_block>
 [{'name':'Homer', 'age':39}, {'name':'Bart', 'age':10}]

<p> When sorted by <code> name <p> , it should become:
<code_block>
 [{'name':'Bart', 'age':10}, {'name':'Homer', 'age':39}]


-------------------------------------OUTPUT-------------------------------------

                Expected= "list_of_dicts.sort(key=operator.itemgetter('name'))"
           base:Baseline= sorted(list(d.items()), key=lambda x: x[1])
           body:Baseline= sorted(list(dictionary.items()), key=lambda x: x[1])
            body:-Blocks= sorted(list(d.items()), key=lambda x: x[1])
              body:-Code= sorted(list(d.items()), key=lambda x: x[1])
            body:-Inline= sorted(list(d.items()), key=lambda x: x[1])
                body:-NL= sorted(list(d.items()), key=lambda x: x[1])
             base:+Mined= my_list.sort(key=lambda d: d['rank'], reverse=True)
     body+mined:Baseline= sorted(list(d.items()), key=lambda x: x['name'], reverse=True)
        body+mined:-Code= sorted(list_of_dct, key=lambda x: x[1])
          body+mined:-NL= sorted(list(d.items()), key=lambda d: d['age'], reverse=True)
      body+mined:-Blocks= sorted(lst, key=lambda d: d['name'])
      body+mined:-Inline= sorted(d, key=lambda d: d['age'], reverse=True)

================================================================================

QUESTION: idx=460    id=72899
-------------------------------------INPUTS-------------------------------------

tags: list, sorting, dictionary, data-structures
score: 2137
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: how do i sort a list of dictionaries by values of the dictionary in python?
body(Left in tags for better readability):
<p> I have a list of dictionaries and want each item to be sorted by a
specific value.
<p> Take into consideration the list:
<code_block>
 [{'name':'Homer', 'age':39}, {'name':'Bart', 'age':10}]

<p> When sorted by <code> name <p> , it should become:
<code_block>
 [{'name':'Bart', 'age':10}, {'name':'Homer', 'age':39}]


-------------------------------------OUTPUT-------------------------------------

                Expected= "list_of_dicts.sort(key=operator.itemgetter('age'))"
           base:Baseline= sorted(list(d.items()), key=lambda x: x[1])
           body:Baseline= sorted(list(dictionary.items()), key=lambda x: x[1])
            body:-Blocks= sorted(list(d.items()), key=lambda x: x[1])
              body:-Code= sorted(list(d.items()), key=lambda x: x[1])
            body:-Inline= sorted(list(d.items()), key=lambda x: x[1])
                body:-NL= sorted(list(d.items()), key=lambda x: x[1])
             base:+Mined= my_list.sort(key=lambda d: d['rank'], reverse=True)
     body+mined:Baseline= sorted(list(d.items()), key=lambda x: x['name'], reverse=True)
        body+mined:-Code= sorted(list_of_dct, key=lambda x: x[1])
          body+mined:-NL= sorted(list(d.items()), key=lambda d: d['age'], reverse=True)
      body+mined:-Blocks= sorted(lst, key=lambda d: d['name'])
      body+mined:-Inline= sorted(d, key=lambda d: d['age'], reverse=True)

================================================================================

QUESTION: idx=461    id=36402748
-------------------------------------INPUTS-------------------------------------

tags: sorting, pandas, dataframe
score: 4
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: how to sort a dataframe by the ocurrences in a column in python (pandas)
body(Left in tags for better readability):
<p> I'm trying to create a dataframe  from my data (scores between
chemicals and proteins) with pandas in python.
<p> I want my dataframe to first display the proteins that have the
most occurences, so I previously sorted my data. But when I make the
dataframe it does not get the expected result.
<p> Here's a sample of my data :
<code_block>
 chemicals   prots   scores
CID000000006    10116.ENSRNOP00000003921    196
CID000000051    10116.ENSRNOP00000003921    246
CID000000085    10116.ENSRNOP00000003921    196
CID000000119    10116.ENSRNOP00000003921    247
CID000000134    10116.ENSRNOP00000008952    159
CID000000135    10116.ENSRNOP00000008952    157
CID000000174    10116.ENSRNOP00000008952    439
CID000000175    10116.ENSRNOP00000001021    858
CID000000177    10116.ENSRNOP00000004027    760

<p> As you can see "10116.ENSRNOP00000003921" is the protein with the
most occurences in my data.
<p> So i'd like to get something like :
<code_block>
              10116.ENSRNOP00000003921     10116.ENSRNOP00000008952
CID000000006   196
CID000000051   246
CID000000085   196
CID000000119   247
CID000000134                                  159
CID000000135                                  157
CID000000174                                  439

<p> And Here's my code :
<code_block>
 import pandas as pd

df_rat= pd.read_csv("dt_matrix_rat.csv",sep="\t", header=True)
df_rat.columns = ['chemicals','proteins','scores']
df_rat1 = df_rat.pivot(index='chemicals', columns='proteins',
values='scores')

df_rat1.to_csv("rat_matrix.csv", sep='\t', index=True  )


-------------------------------------OUTPUT-------------------------------------

                Expected= "df.groupby('prots').sum().sort('scores', ascending=False)"
           base:Baseline= df.sort(key=lambda x: x[1])
           body:Baseline= df.sort(['CID'], axis=1)
            body:-Blocks= df.sort_values(['Ocurrences'], axis=1)
              body:-Code= df.sort(key=lambda x: x.OCTURITY)
            body:-Inline= df.sort_values(['CID000000006', 'ENSRNOP00000003921'])
                body:-NL= df.sort_csv(['chemicals', 'proteins', 'scores'])
             base:+Mined= df.sort(['a', 'b'], ascending=[True, False])
     body+mined:Baseline= df.sort_values(by=['prots', 'chemicals'])
        body+mined:-Code= df.sort_values(['chemistry', 'chemistry'])
          body+mined:-NL= df.sort_values(by=['chemicals', 'proteins', 'scores'])
      body+mined:-Blocks= df.sort_values(by=['chemistry', 'chemistry'])
      body+mined:-Inline= df.sort_values(by=['prots'])

================================================================================

QUESTION: idx=462    id=29881993
-------------------------------------INPUTS-------------------------------------

tags: json, list, dictionary
score: 4
slot_map: {'key': ['str_0', 'str_1', 'var_0'], 'quote': ['"', "'", '`'], 'type': ['str', 'str', 'var'], 'value': [',', 'category', 'trans']}
intent: join together with "," elements inside a list indexed with 'category' within a dictionary `trans`
body(Left in tags for better readability):
<p> I have a function that's returning a json formatted dataset.
Here's a sample:
<code_block>
 [{u'category': [u'Transfer', u'Withdrawal', u'ATM'], u'category_id':
u'21012002', u'_account': u'XARE85EJqKsjxLp6XR8ocg8VakrkXpTXmRdOo',
u'name': u'ATM Withdrawal', u'amount': 200, u'meta': {u'location':
{u'city': u'San Francisco', u'state': u'CA'}}, u'date': u'2014-07-21',
u'score': {u'location': {u'city': 1, u'state': 1}, u'name': 1},
u'_id': u'0AZ0De04KqsreDgVwM1RSRYjyd8yXxSDQ8Zxn', u'type':
{u'primary': u'special'}, u'pending': False}]

for trans in foodie_data:
            print 'Name={},Amount={},Date={}, Categories ={}\n'.format
(trans['name'],trans['amount'],trans['date'],trans['category'])

<p> This script prints:
<code_block>
 Name=ATM
Withdrawal,Amount=200,Date=2014-07-21,Categories=[u'Transfer',
u'Withdrawal', u'ATM']

<p> I want it to return Categories as a string and not a list:
<code_block>
 Name=ATM Withdrawal,Amount=200,Date=2014-07-21,Categories='Transfer,
Withdrawal,ATM']

<p> What's the most efficient way of doing so?

-------------------------------------OUTPUT-------------------------------------

                Expected= '""",""".join(trans[\'category\'])'
           base:Baseline= [item for item in list(trans.items() if item['category'] not in item]
           body:Baseline= [{'category': [{'name': 'category'}, 'id': 'ATM'}) for 'name' in Trans.items()}]
            body:-Blocks= [item['category'] for item in Trans.items() if item in item]
              body:-Code= [item['category'] for item in Trans]
            body:-Inline= [item['category'] for item in Trans.items() if item['name'])
                body:-NL= [x['category'] for x in list(trans.items() if 'category' in x]
             base:+Mined= [item['category'] for item in trans.items()]
     body+mined:Baseline= {'category': [item['name'] for item in trans.items()]
        body+mined:-Code= categories = [item['category'] for item in trans.items()]
          body+mined:-NL= [x['category'] for x in trans.items() if 'category' in x]
      body+mined:-Blocks= [item['category'] for item in Trans.items()]
      body+mined:-Inline= [{'name': 'ATM'}, {'amount': 'date'} for _ in trans}]

================================================================================

QUESTION: idx=463    id=34158494
-------------------------------------INPUTS-------------------------------------

tags: string, string-concatenation
score: 8
slot_map: {'key': ['str_0', '[str_0]'], 'quote': ['`', '`'], 'type': ['str', 'str'], 'value': ["['A', 'B', 'C', 'D']", "['A', 'B', 'C', 'D']"]}
intent: concatenate array of strings `['a', 'b', 'c', 'd']` into a string
body(Left in tags for better readability):
<p> Out of the following two variants (with or without plus-sign
between) of string literal concatenation:

<li> What's the preferred way?
<li> What's the difference?
<li> When should one or the other be used?
<li> Should non of them ever be used, if so why?
<li> Is <code> join <li>  preferred?

<p> Code:
<code_block>
 <console_in> # variant 1. Plus
<console_in> 'A'+'B'
<console_out> 'AB'
<console_in> # variant 2. Just a blank space
<console_in> 'A' 'B'
<console_out> 'AB'
<console_in> # They seems to be both equal
<console_in> 'A'+'B' == 'A' 'B'
<console_out> True


-------------------------------------OUTPUT-------------------------------------

                Expected= '"""""".join([\'A\', \'B\', \'C\', \'D\'])'
           base:Baseline= """""".join(['a', 'b', 'c', 'd'])
           body:Baseline= """""".join(['A', 'B', 'C', 'D'])
            body:-Blocks= """""".join(['a', 'b', 'c', 'd'])
              body:-Code= """""".join(['a', 'b', 'c', 'd'])
            body:-Inline= """""".join(['A', 'B', 'C', 'D'])
                body:-NL= """""".join(['A', 'B', 'C', 'D'])
             base:+Mined= """""".join(['a', 'b', 'c', 'd'])
     body+mined:Baseline= """""".join(['A', 'b', 'c', 'd'])
        body+mined:-Code= """""".join(['a', 'b', 'c', 'd'])
          body+mined:-NL= """""".join(['a', 'b', 'c', 'd'])
      body+mined:-Blocks= """""".join(['a', 'b', 'c', 'd'])
      body+mined:-Inline= """""".join(['a', 'b', 'c', 'd'])

================================================================================

QUESTION: idx=464    id=7750557
-------------------------------------INPUTS-------------------------------------

tags: json, rest, kerberos
score: 83
slot_map: {'key': ['str_0'], 'quote': ["'"], 'type': ['str'], 'value': ['url']}
intent: get json data from restful service 'url'
body(Left in tags for better readability):
<p> Is there any standard way of getting JSON data from RESTful
service using Python?
<p> I need to use kerberos for authentication.
<p> some snippet would help.

-------------------------------------OUTPUT-------------------------------------

                Expected= "json.load(urllib.request.urlopen('url'))"
           base:Baseline= json.loads(url, key=lambda x: x[1])
           body:Baseline= json = RESTful.get(url)
            body:-Blocks= json.loads(url, verify=True)
              body:-Code= urllib.request.url.get('json')
            body:-Inline= json = RESTful.get_json('url')
                body:-NL= json.get_json('url')
             base:+Mined= print(json.dumps(url))
     body+mined:Baseline= print(json.dumps(url))
        body+mined:-Code= print(json.dumps(url))
          body+mined:-NL= json.dumps(url, ensure_ascii=False)
      body+mined:-Blocks= print(json.dumps(url))
      body+mined:-Inline= print(json.dumps(url))

================================================================================

QUESTION: idx=465    id=12666897
-------------------------------------INPUTS-------------------------------------

tags: list, substring, string-matching
score: 25
slot_map: {'key': ['var_0', 'str_0', 'str_1'], 'quote': ['`', '`', '`'], 'type': ['var', 'str', 'str'], 'value': ['sents', '@$\t', '#']}
intent: remove all strings from a list a strings `sents` where the values starts with `@$\t` or `#`
body(Left in tags for better readability):
<p> How do I remove an element from a list if it matches a substring?
<p> I have tried removing an element from a list using the <code>
pop() <p>  and <code> enumerate <p>  method but seems like I'm missing
a few contiguous items that needs to be removed:
<code_block>
 sents = ['@$\tthis sentences needs to be removed', 'this doesnt',
     '@$\tthis sentences also needs to be removed',
     '@$\tthis sentences must be removed', 'this shouldnt',
     '# this needs to be removed', 'this isnt',
     '# this must', 'this musnt']

for i, j in enumerate(sents):
  if j[0:3] == "@$\t":
    sents.pop(i)
    continue
  if j[0] == "#":
    sents.pop(i)

for i in sents:
  print i

<p> Output:
<code_block>
 this doesnt
@$  this sentences must be removed
this shouldnt
this isnt
#this should
this musnt

<p> Desired output:
<code_block>
 this doesnt
this shouldnt
this isnt
this musnt


-------------------------------------OUTPUT-------------------------------------

                Expected= "[x for x in sents if not x.startswith('@$\\t') and not x.startswith('#')]"
           base:Baseline= sents = [x for x in sents if x starts with '@$\t' or '#')
           body:Baseline= sents = [x for x in sents if x.startswith('@$\t')]
            body:-Blocks= sents = [x for x in sents if x!= '@$\t' or '#')
              body:-Code= sents = [x for x in sents if '@$\t' in x]
            body:-Inline= sents = [x for x in enumerate(sents) if x.startswith('@$\t')]
                body:-NL= sents.pop(['@$\t'], 'this isnt', '#')
             base:+Mined= sents = [x for x in sents if x.startswith('@$\t', '#')]
     body+mined:Baseline= [x for x in sents if x.startswith('@$\\tthis sentences also needs to be removed', '']
        body+mined:-Code= sents = [x for x in sents if x.startswith('@$\\t')]
          body+mined:-NL= sents.pop(re.sub('\\t\\t', '@$\\tthis must', sents))
      body+mined:-Blocks= sents = [sents[i:i + 1] for i in range(0, len(sents), 1)]
      body+mined:-Inline= sents = [x for x in sents if x.startswith(
    '@$\\tthis sentences must be removed')]

================================================================================

QUESTION: idx=466    id=2984751
-------------------------------------INPUTS-------------------------------------

tags: django
score: 5
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: django filter by hour
body(Left in tags for better readability):
<p> I've found that link: <a>
http://code.djangoproject.com/attachment/ticket/8424/time_filters.diff
<p>  and changed my django 1.2 files by adding taht what you can see
there. <p>
But now, when I'm trying to  write Entry.objects.filter(pub_date__hour
= x) - the result is following error:

<p> Field has invalid lookup: hour

<p> What should I do else, to make it work?
<p> (sorry for my english)

-------------------------------------OUTPUT-------------------------------------

                Expected= "Entry.objects.filter(pub_date__contains='08:00')"
           base:Baseline= django.filter(hours=1)
           body:Baseline= Entry.objects.filter(pub_date__hour=x)
            body:-Blocks= Entry.objects.filter(pub_date__hour='8424')
              body:-Code= time.filter(pub_date__hour='8424')
            body:-Inline= Entry.objects.filter(pub_date__hour=x)
                body:-NL= django.filter(hours=1)
             base:+Mined= MyModel.objects.filter(hour=1)
     body+mined:Baseline= Entry.objects.filter(pub_date__hour__in=hour)
        body+mined:-Code= Entry.objects.filter(pub_date__hour=x)
          body+mined:-NL= super(MyModel, self).save(*args, **kwargs)
      body+mined:-Blocks= Entry.objects.filter(pub_date__hour='8424')
      body+mined:-Inline= Entry.objects.filter(pub_date__hour=x)

================================================================================

QUESTION: idx=467    id=5944630
-------------------------------------INPUTS-------------------------------------

tags: list, sorting
score: 13
slot_map: {'key': ['var_0', 'var_1', 'var_2'], 'quote': ['`', '`', '`'], 'type': ['var', 'var', 'var'], 'value': ['list', 'points', 'time']}
intent: sort a list of dictionary `list` first by key `points` and then by `time`
body(Left in tags for better readability):
<p> I want to sort this info(name, points, and time):
<code_block>
 list = [
    {'name':'JOHN', 'points' : 30, 'time' : '0:02:2'},
    {'name':'KARL','points':50,'time': '0:03:00'}
]

<p> so, what I want is the list sorted first by points made, then by
time played (in my example, matt go first because of his less time.
any help?
<p> I'm trying with this:
<code_block>
 import operator
list.sort(key=operator.itemgetter('points', 'time'))

<p> but got a <code> TypeError: list indices must be integers, not str
<p> .

-------------------------------------OUTPUT-------------------------------------

                Expected= "list.sort(key=lambda item: (item['points'], item['time']))"
           base:Baseline= sorted(list, key=lambda x: x[1])
           body:Baseline= list.sort(key=operator.itemgetter('points', 'time'))
            body:-Blocks= sorted(list, key=lambda x: x[1])
              body:-Code= sorted(list, key=lambda x: x[1])
            body:-Inline= list.sort(key=operator.itemgetter('points', 'time'))
                body:-NL= list.sort(key=operator.itemgetter('points', 'time'))
             base:+Mined= sorted(list, key=itemgetter(1), reverse=True)
     body+mined:Baseline= list.sort(key=operator.itemgetter('points', 'time'))
        body+mined:-Code= sorted(list, key=lambda k_v: (k_v[1], v[0]))
          body+mined:-NL= list.sort(key=operator.itemgetter('points', 'time'))
      body+mined:-Blocks= sorted(list, key=lambda x: (x.points, x.time))
      body+mined:-Inline= list.sort(key=operator.itemgetter('points', 'time'))

================================================================================

QUESTION: idx=468    id=7852855
-------------------------------------INPUTS-------------------------------------

tags: 
score: 248
slot_map: {'key': ['str_0', '(str_0)'], 'quote': ['`', '`'], 'type': ['str', 'str'], 'value': ['(1970, 1, 1)', '(1970, 1, 1)']}
intent: convert datetime object `(1970, 1, 1)` to seconds
body(Left in tags for better readability):
<p> Apologies for the simple question... I'm new to Python... I have
searched around and nothing seems to be working.
<p> I have a bunch of datetime objects and I want to calculate the
number of seconds since a fixed time in the past for each one (for
example since January 1, 1970).
<code_block>
 import datetime
t = datetime.datetime(2009, 10, 21, 0, 0)

<p> This seems to be only differentiating between dates that have
different days:
<code_block>
 t.toordinal()

<p> Any help is much appreciated.

-------------------------------------OUTPUT-------------------------------------

                Expected= '(t - datetime.datetime(1970, 1, 1)).total_seconds()'
           base:Baseline= time.mktime(1970, 1, 1)
           body:Baseline= datetime.datetime(1970, 1, 1)
            body:-Blocks= seconds = datetime.datetime.combine(1970, 1, 1))
              body:-Code= seconds = datetime.datetime.combine(1970, 1, 1))
            body:-Inline= datetime.datetime(1970, 1, 1)
                body:-NL= datetime.datetime(1970, 1, 1)
             base:+Mined= datetime.utcfromtimestamp(1970, 1, 1)
     body+mined:Baseline= datetime.datetime(1970, 1, 1) - datetime.timedelta(seconds=1)
        body+mined:-Code= (1970, 1, 1) + datetime.timedelta(seconds=1)
          body+mined:-NL= t = datetime.datetime(1970, 1, 1)
      body+mined:-Blocks= (1970, 1, 1).total_seconds()
      body+mined:-Inline= datetime.datetime(1970, 1, 1) - datetime.timedelta(seconds=1)

================================================================================

QUESTION: idx=469    id=2763750
-------------------------------------INPUTS-------------------------------------

tags: regex
score: 75
slot_map: {'key': ['var_0', 'str_0', 'var_1', 'var_2'], 'quote': ['`', '`', '`', '`'], 'type': ['var', 'str', 'var', 'var'], 'value': ['_suff', 'long.file.name.jpg', '_a', 'suff']}
intent: insert `_suff` before the file extension in `long.file.name.jpg` or replace `_a` with `suff` if it precedes the extension.
body(Left in tags for better readability):
<p> I need to match two cases by one reg expression and do replacement
<p> 'long.file.name.jpg' -> 'long.file.name_ <strong> suff <p> .jpg'
<p> 'long.file.name_ <strong> a <p> .jpg' -> 'long.file.name_ <strong>
suff <p> .jpg'
<p> I'm trying to do the following
<code_block>
 re.sub('(\_a)?\.[^\.]*$' , '_suff.',"long.file.name.jpg")

<p> But this is cut the extension '.jpg' and I'm getting
<p> long.file.name_suff. instead of long.file.name_suff.jpg
I understand that this is because of [^.]*$ part, but I can't exclude
it, because
I have to find last occurance of '_a' to replace or last '.'
<p> Is there a way to replace only part of the match?

-------------------------------------OUTPUT-------------------------------------

                Expected= "re.sub('(\\\\_a)?\\\\.([^\\\\.]*)$', '_suff.\\\\2', 'long.file.name.jpg')"
           base:Baseline= f = open('long.file.name.jpg', 'suff')
           body:Baseline= re.sub('(\_a)?\.[^\.]*$', '_suff.'), 'long.file.name.jpg')
            body:-Blocks= re.compile('long.file.name.jpg', '_a', 'suff')
              body:-Code= re.compile('long.file.name.jpg', '_a', 'suff')
            body:-Inline= re.sub('(\\_a)?\\.[^\\.]*$', '_suff.')
                body:-NL= re.sub('(\_a)?\.[^\\.]*$', '_suff.'), '_a')
             base:+Mined= os.path.insert(0, 'long.file.name.jpg', 'suff')
     body+mined:Baseline= re.sub('\\_a)?\\.[^\\.]*$', '(long.file.name.jpg')
        body+mined:-Code= re.sub('[^.]*$', 'long.file.name.jpg', _a)
          body+mined:-NL= re.sub('\\[^\\.]*$', '', 'long.file.name.jpg')
      body+mined:-Blocks= re.sub('_a', 'long.file.name.jpg', 'suff')
      body+mined:-Inline= re.sub('\\_a)?\\.[^\\.]*$', '_suff.', 'long.file.name.jpg')

================================================================================

QUESTION: idx=470    id=6420361
-------------------------------------INPUTS-------------------------------------

tags: 
score: 24
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['module']}
intent: reload a module `module`
body(Left in tags for better readability):
<p> After import functions into ipython, how do I reload them when I
have modified them outside of ipython ?

-------------------------------------OUTPUT-------------------------------------

                Expected= 'import imp\nimp.reload(module)'
           base:Baseline= module.load(key=operator.itemgetter(1))
           body:Baseline= module = os.load(module)
            body:-Blocks= module.load(key=module)
              body:-Code= module = module.load(module)
            body:-Inline= module = os.load(module)
                body:-NL= module.load(key=module.get())
             base:+Mined= module = subprocess.Popen(module, shell=True)
     body+mined:Baseline= sys.modules.update(module)
        body+mined:-Code= sys.modules.load(module)
          body+mined:-NL= module = module.load(module)
      body+mined:-Blocks= sys.modules.append(module)
      body+mined:-Inline= module = module.__init__(self)

================================================================================

QUESTION: idx=471    id=19546911
-------------------------------------INPUTS-------------------------------------

tags: integer, bit, unsigned
score: 6
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['number']}
intent: convert integer `number` into an unassigned integer
body(Left in tags for better readability):
<p> I currently read off pixels from an image using python PIL. These
pixels are 16bit greyscale and are unsigned. However, whenever PIL
reads them in it thinks they are signed and makes values that should
be something like <em> 45179 <p>  into <em> -20357 <p> .
<code_block>
 org_Image = Image.open(image)
org_Data = org_Image.load()
width, height = org_Image.size

    for y in range(0, height):
        temprow_data = []
        for x in range(0, width):
             temprow_data.append(org_Data[x, y])

<p> How do I go about getting PIL to output unsigned instead of signed
integers? Or is there a really easy way of taking the PIL input and
converting it after?

-------------------------------------OUTPUT-------------------------------------

                Expected= "struct.unpack('H', struct.pack('h', number))"
           base:Baseline= [int(x) for x in sorted(number)]
           body:Baseline= struct.unpack('{}'.format(number))
            body:-Blocks= print(int(s) for s in unsigned integers)
              body:-Code= int(s.encode('unsigned') for s in number)
            body:-Inline= np.arange(int(number))
                body:-NL= [int(x) for x in range(0, width)]
             base:+Mined= int(number).encode('ascii', 'ignore')
     body+mined:Baseline= int('45179'.encode('utf-8'))
        body+mined:-Code= numpy.unregister(number)
          body+mined:-NL= int(''.join(map(str, x)))
      body+mined:-Blocks= int(number).decode('greyscale')
      body+mined:-Inline= int('45179'.encode('utf-8'))

================================================================================

QUESTION: idx=472    id=9746522
-------------------------------------INPUTS-------------------------------------

tags: list, function, sum
score: 8
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['numlist']}
intent: convert int values in list `numlist` to float
body(Left in tags for better readability):
<p> I am doing my homework and it requirers me to use a sum () and len
() functions to find the mean of an input number list, when I tried to
use sum () to get the sum of the list, I got an error TypeError:
unsupported operand type(s) for +: 'int' and 'str'. Following is my
code:
<code_block>
 numlist = input("Enter a list of number separated by commas: ")

numlist = numlist.split(",")

s = sum(numlist)
l = len(numlist)
m = float(s/l)
print("mean:",m)


-------------------------------------OUTPUT-------------------------------------

                Expected= 'numlist = [float(x) for x in numlist]'
           base:Baseline= float(numList, int(numlist))
           body:Baseline= float(sum(i) for i in numlist)
            body:-Blocks= float(numlist, float(numList))
              body:-Code= float(numlist, float(str))
            body:-Inline= float(numlist, numlist)
                body:-NL= float(numlist, numlist)
             base:+Mined= float(numlist[0] + float(numList[1])
     body+mined:Baseline= sum(map(int, numlist))
        body+mined:-Code= float(numlist) / float(len(numList))
          body+mined:-NL= float(map(int, numlist))
      body+mined:-Blocks= sum(float(numlist) / float(numList))
      body+mined:-Inline= float(sum(x) for x in numlist)

================================================================================

QUESTION: idx=473    id=20107570
-------------------------------------INPUTS-------------------------------------

tags: pandas
score: 151
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['df']}
intent: write dataframe `df`, excluding index, to a csv file
body(Left in tags for better readability):
<p> I have the following code which imports a CSV file.  There are 3
columns and I want to set the first two of them to variables.  When I
set the second column to the variable "efficiency" the index column is
also tacked on.  How can I get rid of the index column?
<code_block>
 df = pd.DataFrame.from_csv('Efficiency_Data.csv', header=0,
parse_dates=False)
energy = df.index
efficiency = df.Efficiency
print efficiency

<p> I tried using
<code_block>
 del df['index']

<p> after I set
<code_block>
 energy = df.index

<p> which I found in another post but that results in "KeyError:
'index' "

-------------------------------------OUTPUT-------------------------------------

                Expected= 'df.to_csv(filename, index=False)'
           base:Baseline= df.to_csv('index')
           body:Baseline= df = pd.DataFrame.from_csv('Efficiency_Data.csv', header=0, parse_dates=False)
            body:-Blocks= df.to_csv('csv', excluding index)
              body:-Code= df.to_csv('csv', excluding index)
            body:-Inline= df.to_csv('Efficiency_Data.csv', header=0, parse_dates=False)
                body:-NL= df.to_csv('Efficiency_Data.csv', header=0, parse_dates=False)
             base:+Mined= df.to_csv('test.csv', index=False)
     body+mined:Baseline= df.to_csv('Efficiency_Data.csv', header=0, parse_dates=False)
        body+mined:-Code= df.to_csv('test.csv', excluding index)
          body+mined:-NL= df = pd.DataFrame.from_csv('Efficiency_Data.csv', header=0, parse_dates=False)
      body+mined:-Blocks= df.to_csv('test.csv', excluding index)
      body+mined:-Inline= df.to_csv('Efficiency_Data.csv', index=False)

================================================================================

QUESTION: idx=474    id=8740353
-------------------------------------INPUTS-------------------------------------

tags: json, web-services, http-post, web.py
score: 6
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['unescaped', 'json_data']}
intent: convert a urllib unquoted string `unescaped` to a json data `json_data`
body(Left in tags for better readability):
<p> Here is the sample string i am receiving from one of the web
services,
<code_block>
 body=%7B%22type%22%3A%22change%22%2C%22url%22%3A%22http%3A%2F%2Fapi.p
achube.com%2Fv2%2Ftriggers%2F4100%22%2C%22environment%22%3A%7B%22feed%
22%3A%22http%3A%2F%2Fapi.pachube.com%2Fv2%2Ffeeds%2F36133%22%2C%22titl
e%22%3A%22Current+Cost+Bridge%22%2C%22description%22%3Anull%2C%22id%22
%3A36133%7D%2C%22threshold_value%22%3Anull%2C%22timestamp%22%3A%222012
-01-05T09%3A27%3A01Z%22%2C%22triggering_datastream%22%3A%7B%22url%22%3
A%22http%3A%2F%2Fapi.pachube.com%2Fv2%2Ffeeds%2F36133%2Fdatastreams%2F
1%22%2C%22value%22%3A%7B%22value%22%3A%22523%22%2C%22max_value%22%3A12
69.0%2C%22min_value%22%3A0.0%7D%2C%22id%22%3A%221%22%2C%22units%22%3A%
7B%22symbol%22%3A%22W%22%2C%22type%22%3A%22derivedUnits%22%2C%22label%
22%3A%22watts%22%7D%7D%2C%22id%22%3A4100%7D

<p> Here is the code,
<code_block>
 class Feeds():
    def GET(self):
        print "Get request is accepted."
        return render.index(None)

    def POST(self):
        print "Post request is accepted."
        print (web.data())

<p> Now when that web-service posts the above given data, how will i
convert it to readable format? Then, i need to convert it to JSON
object and use further. So, how will i convert it?
<p> When i try this code,
<code_block>
         json_data = json.loads(web.data())
        print json_data['body']
        return render.index(json_data['body'])

<p> It gives me an error,
<code_block>
 enter code Traceback (most recent call last):
File "/usr/local/lib/python2.6/dist-packages/web/application.py", line
237, in process
return self.handle()
File "/usr/local/lib/python2.6/dist-packages/web/application.py", line
228, in handle
return self._delegate(fn, self.fvars, args)
File "/usr/local/lib/python2.6/dist-packages/web/application.py", line
409, in _delegate
return handle_class(cls)
File "/usr/local/lib/python2.6/dist-packages/web/application.py", line
385, in      handle_class
return tocall(*args)
File "/home/ubuntu/pachubeConsumer/src/controllers/feeds.py", line 17,
in POST
json_data = json.loads(web.data())
File "/usr/lib/python2.6/json/__init__.py", line 307, in loads
return _default_decoder.decode(s)
File "/usr/lib/python2.6/json/decoder.py", line 319, in decode
obj, end = self.raw_decode(s, idx=_w(s, 0).end())
File "/usr/lib/python2.6/json/decoder.py", line 338, in raw_decode
raise ValueError("No JSON object could be decoded")
ValueError: No JSON object could be decoded here

<p> Where am i going wrong ??
<p> Thanks in advance.

-------------------------------------OUTPUT-------------------------------------

                Expected= 'json_data = json.loads(unescaped)'
           base:Baseline= json_data.unquote('unescaped')
           body:Baseline= json_data = urllib.parse.unquote(unquote)
            body:-Blocks= json_data = json.loads(unquote, 'unescaped')
              body:-Code= json_data = urllib.parse.unquote(unescaped)
            body:-Inline= json_data = urllib.parse.unquote(unquote=unescaped)
                body:-NL= json_data = urllib.parse.unquote(unquote)
             base:+Mined= json_data = json.loads(unquote)
     body+mined:Baseline= json_data = urllib.parse.unquote(string)
        body+mined:-Code= json_data = json.loads(unnamed_string)
          body+mined:-NL= json_data = urllib.parse.unquote(url, data)
      body+mined:-Blocks= json_data.dumps(urllib.parse.unquote(unquote))
      body+mined:-Inline= json_data.unstack(unquote)

================================================================================

QUESTION: idx=475    id=5891453
-------------------------------------INPUTS-------------------------------------

tags: ascii
score: 104
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: create a list containing all ascii characters as its elements
body(Left in tags for better readability):
<p> Something like below:
<code_block>
 import ascii

print ascii.charlist()

<p> Which would return something like [A, B, C, D...]

-------------------------------------OUTPUT-------------------------------------

                Expected= '[chr(i) for i in range(127)]'
           base:Baseline= list(itertools.chain.from_iterable(ascii))
           body:Baseline= charlist = [A, B, C, D]
            body:-Blocks= list(itertools.product([A, B, C, D])
              body:-Code= list(itertools.product([A, B, C, D])
            body:-Inline= list(ascii.charlist()
                body:-NL= list(ascii.charlist()
             base:+Mined= list(itertools.chain.from_iterable(ascii_uppercase))
     body+mined:Baseline= print([i for i in range(0, len(ascii)))
        body+mined:-Code= list(itertools.chain.from_iterable(a))
          body+mined:-NL= """""".join(chr(i) for i in L)
      body+mined:-Blocks= ['A', 'B', 'C', 'D']
      body+mined:-Inline= print('[A, B, C, D]')

================================================================================

QUESTION: idx=476    id=18367007
-------------------------------------INPUTS-------------------------------------

tags: 
score: 139
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['newFileBytes', 'newFile']}
intent: write `newfilebytes` to a binary file `newfile`
body(Left in tags for better readability):
<p> I have a list of bytes as integers, which is something like
<code_block>
 [120, 3, 255, 0, 100]

<p> How can I write this list to a file as binary?
<p> Would this work?
<code_block>
 newFileBytes = [123, 3, 255, 0, 100]
# make file
newFile = open("filename.txt", "wb")
# write to file
newFile.write(newFileBytes)


-------------------------------------OUTPUT-------------------------------------

                Expected= "newFile.write(struct.pack('5B', *newFileBytes))"
           base:Baseline= newfile = os.walk(newfilebytes)
           body:Baseline= newFile = open('filename.txt', 'wb')
            body:-Blocks= newfilebytes = [int(x) for x in oldfile]
              body:-Code= newfilebytes = [int(x) for x in oldfile]
            body:-Inline= newFile = open('filename.txt', 'wb')
                body:-NL= newFile = open('filename.txt', 'wb')
             base:+Mined= newfile = open('newfilebytes', 'rb')
     body+mined:Baseline= newFile = open('filename.txt', 'wb')
        body+mined:-Code= newfilebytes = [int(x) for x in oldfilebytes]
          body+mined:-NL= newFile = open('filename.txt', 'wb')
      body+mined:-Blocks= newfilebytes.write('\n'.join(chr(x)) for x in oldfilebytes)
      body+mined:-Inline= newFile = open('filename.txt', 'wb')

================================================================================

QUESTION: idx=477    id=21805490
-------------------------------------INPUTS-------------------------------------

tags: regex, string
score: 6
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['string']}
intent: python regex - check for a capital letter with a following lowercase in string `string`
body(Left in tags for better readability):
<p> I am trying to check for a capital letter that has a lowercase
letter coming directly after it. The trick is that there is going to
be a bunch of garbage capital letters and number coming directly
before it. For example:
<code_block>
 AASKH317298DIUANFProgramming is fun

<p> as you can see, there is a bunch of stuff we don't need coming
directly before the phrase we do need, <code> Programming is fun <p> .
<p> I am trying to use regex to do this by taking each string and then
substituting it out with <code> '' <p>  as the original string does
not have to be kept.
<code_block>
 re.sub(r'^[A-Z0-9]*', '', string)

<p> The problem with this code is that it leaves us with <code>
rogramming is fun <p> , as the <code> P <p>  is a capital letter.
<p> How would I go about checking to make sure that if the next letter
is a lowercase, then I should leave that capital untouched. (The
<code> P <p>  in <code> Programming <p> )

-------------------------------------OUTPUT-------------------------------------

                Expected= "re.sub('^[A-Z0-9]*(?![a-z])', '', string)"
           base:Baseline= re.findall('\\d+', string)
           body:Baseline= re.sub('\\[A-Z0-9]*', '', string)
            body:-Blocks= re.sub('(?<?>\\)', string)
              body:-Code= re.compile('\\d+', string)
            body:-Inline= re.sub('^[A-Z0-9]*', string)
                body:-NL= re.sub('^[A-Z0-9]*', string)
             base:+Mined= re.findall('(?<=\\w+)', string)
     body+mined:Baseline= re.sub('^[A-Z0-9]*', '', string)
        body+mined:-Code= re.sub('(?<=.)(?=.)', '\\1', string)
          body+mined:-NL= re.sub('^[A-Z0-9]*', '', string)
      body+mined:-Blocks= re.search('(?<P<P>)', string)
      body+mined:-Inline= re.sub('^[A-Z0-9]*', '', string)

================================================================================

QUESTION: idx=478    id=16125229
-------------------------------------INPUTS-------------------------------------

tags: 
score: 63
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['dict']}
intent: get the last key of dictionary `dict`
body(Left in tags for better readability):
<p> I am having difficulty figuring out what the syntax would be for
the last key in a Python dictionary. I know that for a Python list,
one may say this to denote the last:
<code_block>
 list[-1]

<p> I also know that one can get a list of the keys of a dictionary as
follows:
<code_block>
 dict.keys()

<p> However, when I attempt to use the logical following code, it
doesnt work:
<code_block>
 dict.keys(-1)

<p> It says that keys cant take any arguments and 1 is given. If keys
cant take args, then how can I denote that I want the last key in the
list?
<p> XXXXX
I am operating under the assumption that Python dictionaries are
ordered in the order in which items are added to the dictionary with
most recent item last. For this reason, I would like to access the
last key in the dictionary.XXXXX
<p> I am now told that the dictionary keys are not in order based on
when they were added. How then would I be able to choose the most
recently added key?

-------------------------------------OUTPUT-------------------------------------

                Expected= 'list(dict.keys())[-1]'
           base:Baseline= {k: v for k, v in dict.items()}
           body:Baseline= dict((k, v) for k, v in dict.keys())
            body:-Blocks= [k for k, v in dict.items() if v != 0]
              body:-Code= [x[1] for x in list(dict.items()]
            body:-Inline= dict[-1]:
    pass
                body:-NL= [last(key) for key in dict]
             base:+Mined= dict((k, v) for k, v in list(dict.items()))
     body+mined:Baseline= list(dict.keys())[-1]
        body+mined:-Code= list(dict.items()).keys()
          body+mined:-NL= next(iter(dict.items()))
      body+mined:-Blocks= [key for key, value in list(dict.items())]
      body+mined:-Inline= list(d.keys())[-1]

================================================================================

QUESTION: idx=479    id=6159900
-------------------------------------INPUTS-------------------------------------

tags: file-io
score: 1156
slot_map: {'key': ['str_0', 'var_0'], 'quote': ['"', '`'], 'type': ['str', 'var'], 'value': ['hi there', 'f']}
intent: write line "hi there" to file `f`
body(Left in tags for better readability):
<p> I'm used to doing <code> print >>f, "hi there"
<p> However, it seems that <code> print >> <p>  is getting deprecated.
What is the recommended way to do the line above?
<b> Update <p> :
Regarding all those answers with <code> "\n" <p> <console_out>is this
universal or Unix-specific? IE, should I be doing <code> "\r\n" <p>
on Windows?

-------------------------------------OUTPUT-------------------------------------

                Expected= "print('hi there', file=f)"
           base:Baseline= f = f.write('hi there')
           body:Baseline= print(f, 'hi there'))
            body:-Blocks= f = f.write('hi there')
              body:-Code= f = f.write('hi there')
            body:-Inline= f = f.write('hi there')
                body:-NL= f.write('hi there', 'hi there')
             base:+Mined= f.write(line, 'hi there')
     body+mined:Baseline= print(f, 'hi there')
        body+mined:-Code= f.write(line.rstrip('hi there'))
          body+mined:-NL= f.write('\r\n')
      body+mined:-Blocks= f.write(('hi there')
      body+mined:-Inline= f = os.path.join(f, 'hi there')

================================================================================

QUESTION: idx=480    id=6159900
-------------------------------------INPUTS-------------------------------------

tags: file-io
score: 1156
slot_map: {'key': ['str_0', 'var_0'], 'quote': ['"', '`'], 'type': ['str', 'var'], 'value': ['hi there', 'myfile']}
intent: write line "hi there" to file `myfile`
body(Left in tags for better readability):
<p> I'm used to doing <code> print >>f, "hi there"
<p> However, it seems that <code> print >> <p>  is getting deprecated.
What is the recommended way to do the line above?
<b> Update <p> :
Regarding all those answers with <code> "\n" <p> <console_out>is this
universal or Unix-specific? IE, should I be doing <code> "\r\n" <p>
on Windows?

-------------------------------------OUTPUT-------------------------------------

                Expected= "f = open('myfile', 'w')\nf.write('hi there\\n')\nf.close()"
           base:Baseline= myfile.write('hi there')
           body:Baseline= print(f, 'hi there'))
            body:-Blocks= print(myfile.write('hi there')
              body:-Code= myfile.write('hi there')
            body:-Inline= myfile.write('hi there')
                body:-NL= myfile.write('hi there', 'hi there')
             base:+Mined= myfile.write('hi there')
     body+mined:Baseline= print(myfile.write('hi there'))
        body+mined:-Code= myfile.write('hi there')
          body+mined:-NL= myfile.write('hi there')
      body+mined:-Blocks= myfile.write('hi there')
      body+mined:-Inline= myfile.write('hi there')

================================================================================

QUESTION: idx=481    id=6159900
-------------------------------------INPUTS-------------------------------------

tags: file-io
score: 1156
slot_map: {'key': ['str_0', 'str_1'], 'quote': ['"', '`'], 'type': ['str', 'str'], 'value': ['Hello', 'somefile.txt']}
intent: write line "hello" to file `somefile.txt`
body(Left in tags for better readability):
<p> I'm used to doing <code> print >>f, "hi there"
<p> However, it seems that <code> print >> <p>  is getting deprecated.
What is the recommended way to do the line above?
<b> Update <p> :
Regarding all those answers with <code> "\n" <p> <console_out>is this
universal or Unix-specific? IE, should I be doing <code> "\r\n" <p>
on Windows?

-------------------------------------OUTPUT-------------------------------------

                Expected= "with open('somefile.txt', 'a') as the_file:\n    the_file.write('Hello\\n')"
           base:Baseline= somefile.txt.write('hello')
           body:Baseline= print(os.system('somefile.txt')
            body:-Blocks= print(os.path.isfile('somefile.txt')
              body:-Code= os.system('somefile.txt')
            body:-Inline= os.system('somefile.txt')
                body:-NL= somefile.txt.write('hello')
             base:+Mined= somefile.txt.write('hello')
     body+mined:Baseline= print(os.path.basename(somefile.txt))
        body+mined:-Code= os.system('somefile.txt')
          body+mined:-NL= print(somefile.txt, 'Hello')
      body+mined:-Blocks= print(somefile.txt, 'Hello')
      body+mined:-Inline= somefile.txt.write('hello')

================================================================================

QUESTION: idx=482    id=19527279
-------------------------------------INPUTS-------------------------------------

tags: unicode, encoding, ascii
score: 14
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['s']}
intent: convert unicode string `s` to ascii
body(Left in tags for better readability):
<p> I am unable to convert the following Unicode to ASCII without
losing data:
<code_block>
 u'ABRA\xc3O JOS\xc9'

<p> I tried <code> encode <p>  and <code> decode <p>  and they won't
do it.
<p> Does anyone have a suggestion?

-------------------------------------OUTPUT-------------------------------------

                Expected= "s.encode('iso-8859-15')"
           base:Baseline= s.decode('unicode_escape')
           body:Baseline= struct.unpack('ABRAÃO JOSÉ')
            body:-Blocks= urllib.parse.unquote(s)
              body:-Code= s.decode('unicode_escape')
            body:-Inline= s.decode('unicode_escape')
                body:-NL= s.decode('unicode_escape')
             base:+Mined= s.encode('ascii', 'ignore')
     body+mined:Baseline= unicodedata.normalize('NFKD', s)
        body+mined:-Code= s.decode('ascii')
          body+mined:-NL= s.encode('ascii', 'ignore')
      body+mined:-Blocks= s.decode('ascii')
      body+mined:-Inline= unicodedata.normalize('NFKD', s)

================================================================================

QUESTION: idx=483    id=10668585
-------------------------------------INPUTS-------------------------------------

tags: django, django-models
score: 11
slot_map: {'key': ['str_0', 'var_0'], 'quote': ["'", '`'], 'type': ['str', 'var'], 'value': ['added', 'AuthorizedEmail']}
intent: django get maximum value associated with field 'added' in model `authorizedemail`
body(Left in tags for better readability):
<code_block>
 <console_in>
AuthorizedEmail.objects.filter(group=group).values('added')
<console_out> [{'added': datetime.datetime(2012, 5, 19, 13, 8, 7)},
{'added': datetime.datetime(2012, 5, 19, 13, 8, 7)},
{'added': datetime.datetime(2012, 5, 19, 13, 7, 23)},
{'added': datetime.datetime(2012, 5, 19, 13, 8, 7)}]

<p> What would be the best way to get the max value here? In python or
in the ORM?

-------------------------------------OUTPUT-------------------------------------

                Expected= "AuthorizedEmail.objects.filter(group=group).order_by('-added')[0]"
           base:Baseline= authorizedemail.get_value('added')
           body:Baseline= AuthorizedEmail.objects.filter(group=group).values('added')
            body:-Blocks= max(authorizedemail.get('added')
              body:-Code= print(authorizedemail.get('added')
            body:-Inline= AuthorizedEmail.objects.max(value='added')
                body:-NL= AuthorizedEmail.objects.filter(group=group).values('added')
             base:+Mined= Book.objects.get('Authorizedemail')
     body+mined:Baseline= AuthorizedEmail.objects.filter(group=group).values('added')
        body+mined:-Code= Model.objects.extra(['authorizedemail']).max()
          body+mined:-NL= AuthorizedEmail.objects.values_list('added')
      body+mined:-Blocks= max(request.META['authorizedemail'] for request in params.values())
      body+mined:-Inline= AuthorizedEmail.objects.filter(group=group).values('added')

================================================================================

QUESTION: idx=484    id=356483
-------------------------------------INPUTS-------------------------------------

tags: regex, findall
score: 10
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['text']}
intent: find all numbers and dots from a string `text` using regex
body(Left in tags for better readability):
<p> I'm using re.findall() to extract some version numbers from an
HTML file:
<code_block>
 <console_in> import re
<console_in> text = " <table> <td> <a href=\"url\">Test0.2.1.zip </a>
</td> <td>Test0.2.1 </td> </table> Test0.2.1"
<console_in> re.findall("Test([\.0-9]*)", text)
<console_out> ['0.2.1.', '0.2.1', '0.2.1']

<p> but I would like to only get the ones that do not end in a dot.
The filename might not always be .zip so I can't just stick .zip in
the regex.
<p> I wanna end up with:
<code_block>
 ['0.2.1', '0.2.1']

<p> Can anyone suggest a better regex to use? :)

-------------------------------------OUTPUT-------------------------------------

                Expected= "re.findall('Test([0-9.]*[0-9]+)', text)"
           base:Baseline= re.findall('\\d+', text)
           body:Baseline= re.findall('Test([\\.0-9]*)', text)
            body:-Blocks= re.findall('(\\w+)', text)
              body:-Code= re.findall('\\w+', text)
            body:-Inline= re.findall('Test([\\.0-9]*)', text)
                body:-NL= re.findall('Test([\\.0-9]*)', text)
             base:+Mined= re.findall('\\d+', text)
     body+mined:Baseline= re.findall('Test([\\.0-9]*)', text)
        body+mined:-Code= re.findall('\\test0.2.1.zip', text)
          body+mined:-NL= re.findall('Test([\\.0-9]*)', text)
      body+mined:-Blocks= re.findall('\\test0.2.1.zip', text)
      body+mined:-Inline= re.findall('\\([^\\]*)', text)

================================================================================

QUESTION: idx=485    id=356483
-------------------------------------INPUTS-------------------------------------

tags: regex, findall
score: 10
slot_map: {'key': ['str_0'], 'quote': ["'"], 'type': ['str'], 'value': ['text']}
intent: python regex  to find all numbers and dots from 'text'
body(Left in tags for better readability):
<p> I'm using re.findall() to extract some version numbers from an
HTML file:
<code_block>
 <console_in> import re
<console_in> text = " <table> <td> <a href=\"url\">Test0.2.1.zip </a>
</td> <td>Test0.2.1 </td> </table> Test0.2.1"
<console_in> re.findall("Test([\.0-9]*)", text)
<console_out> ['0.2.1.', '0.2.1', '0.2.1']

<p> but I would like to only get the ones that do not end in a dot.
The filename might not always be .zip so I can't just stick .zip in
the regex.
<p> I wanna end up with:
<code_block>
 ['0.2.1', '0.2.1']

<p> Can anyone suggest a better regex to use? :)

-------------------------------------OUTPUT-------------------------------------

                Expected= "re.findall('Test([\\\\d.]*\\\\d+)', text)"
           base:Baseline= re.findall('\\w+', text)
           body:Baseline= re.findall('Test([\\.0-9]*)', text)
            body:-Blocks= re.findall('\\w+', text)
              body:-Code= re.findall('\\w+', text)
            body:-Inline= re.findall('Test([\\.0-9]*)', text)
                body:-NL= re.findall('Test([\\.0-9]*)', text)
             base:+Mined= re.findall('\\d+', text)
     body+mined:Baseline= re.findall('Test([\\.0-9]*)', text)
        body+mined:-Code= re.findall('\\test\\Test\\.zip', text)
          body+mined:-NL= re.findall('Test([\\.0-9]*)', text)
      body+mined:-Blocks= re.findall('\\test\\.zip', text)
      body+mined:-Inline= re.findall('\\Test([\\.0-9]*)', text)

================================================================================

QUESTION: idx=486    id=38081866
-------------------------------------INPUTS-------------------------------------

tags: powershell
score: 4
slot_map: {'key': ['str_0', 'str_1'], 'quote': ["'", "'"], 'type': ['str', 'str'], 'value': ['script.ps1', 'powershell.exe']}
intent: execute script 'script.ps1' using 'powershell.exe' shell
body(Left in tags for better readability):
<p> Is there a way to run powershell code in python? I've been
searching around and all I'm finding is how to run a separate PS
script file in python, but nothing about running PS code.
<p> Example: Let's say I want to run this command from inside a Python
script\program...
<code_block>
 Start-Process -filepath "Path\Filename.exe" -wait

<p> I understand in that example I could just run the file using
Python. I'm looking into writing a Python app, but it would use some
powershell code behind the scenes to actually do what it needs to do.
In the case for my app idea, it would connect to Office 365 and
manipulate users\account info (add, remove, etc) and things you can't
do on the 365 admin site. I already have a PS script to do most of
this, but I'm looking into a GUI interface and python seems to be the
better choice for GUI (so far as what I've seen and played with).
<p> If this isn't possible, or if it's more pain than it's worth I'd
appreciate some suggestions. Should I look into C# or something like
that? Python seemed easier to understand.
<p> Thanks.

-------------------------------------OUTPUT-------------------------------------

                Expected= "os.system('powershell.exe', 'script.ps1')"
           base:Baseline= subprocess.call('script.ps1', shell=True)
           body:Baseline= os.system('script.ps1', shell=True)
            body:-Blocks= os.system('script.ps1', shell=True)
              body:-Code= subprocess.call('script.ps1', shell=True)
            body:-Inline= os.system('script.ps1', shell=True)
                body:-NL= os.system('script.ps1', shell=True)
             base:+Mined= subprocess.call('script.ps1', shell=True)
     body+mined:Baseline= os.system('script.ps1', shell=True)
        body+mined:-Code= subprocess.call('script.ps1', shell=True)
          body+mined:-NL= os.system('script.ps1')
      body+mined:-Blocks= os.system('script.ps1')
      body+mined:-Inline= os.system('script.ps1', shell=True)

================================================================================

QUESTION: idx=487    id=7349646
-------------------------------------INPUTS-------------------------------------

tags: sorting, dictionary, tuples
score: 10
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['b']}
intent: sort a list of tuples `b` by third item in the tuple
body(Left in tags for better readability):
<p> I know there's tonnes of questions on python sorting
lists/dictionaries already, but I can't seem to find one which helps
in my case, and i'm looking for the most efficient solution as I'm
going to be sorting a rather large dataset.
<p> My data basically looks like this at the moment:
<code_block>
 a = {'a': (1, 2, 3), 'b': (3, 2, 1)}

<p> I'm basically creating a word list in which I store each word
along with some stats about it (n, Sigma(x), Sigma(x^2) )
<p> I want to sort it based on a particular stat. So far I've been
trying something along the lines of:
<code_block>
 b = a.items()
b.sort(key = itemgetter(1), reverse=True)

<p> I'm not sure how to control which index it is sorted based on when
its effectively a list of tuples of tuples? I guess I effectively need
to nest two itemgetter operations but not really sure how to do this.
<p> If there's a better data structure I should be using instead
please let me know. Should I perhaps create a small class/struct and
then use a lambda function to access a member of the class?
<p> Many Thanks

-------------------------------------OUTPUT-------------------------------------

                Expected= 'b.sort(key=lambda x: x[1][2])'
           base:Baseline= b.sort(key=operator.itemgetter(1))
           body:Baseline= b.sort(key=operator.itemgetter(1), reverse=True)
            body:-Blocks= sorted(b, key=lambda x: x[1])
              body:-Code= sorted(b, key=lambda x: x[1])
            body:-Inline= b.sort(key=itemgetter(1), reverse=True)
                body:-NL= b.sort(key=operator.itemgetter(1), reverse=True)
             base:+Mined= sorted(b, key=operator.itemgetter(1), reverse=True)
     body+mined:Baseline= b.sort(key=lambda x: x[1])
        body+mined:-Code= sorted(b, key=lambda x: x[1])
          body+mined:-NL= b.sort(key=lambda x: x[1])
      body+mined:-Blocks= sorted(b, key=lambda x: (x[1], x[2]))
      body+mined:-Inline= b.sort(key=itemgetter(1), reverse=True)

================================================================================

QUESTION: idx=488    id=2430539
-------------------------------------INPUTS-------------------------------------

tags: cassandra, pycassa
score: 6
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['cf']}
intent: get a list of all keys in cassandra database `cf` with pycassa
body(Left in tags for better readability):
<p> Is anyone having experience working with <a> pycassa <p>  I have a
doubt with it. How do I get all the keys that are stored in the
database?
<p> well in this small snippet we need to give the keys in order to
get the associated columns (here the keys are 'foo' and 'bar'),that is
fine but my requirement is to get all the keys (only keys) at once as
Python list or similar data structure.
<code_block>
 cf.multiget(['foo', 'bar'])
{'foo': {'column1': 'val2'}, 'bar': {'column1': 'val3', 'column2':
'val4'}}

<p> Thanks.

-------------------------------------OUTPUT-------------------------------------

                Expected= 'list(cf.get_range().get_keys())'
           base:Baseline= [k for k, v incf.keys() if v]
           body:Baseline= [k for k, v in cf.multiget(['foo', 'bar'])]
            body:-Blocks= [k for k, v incf.keys()]
              body:-Code= [k for k, v incf.keys())
            body:-Inline= [k for k, v in cf.keys()) for k in v]
                body:-NL= cf.multiget(['foo', 'bar'])
             base:+Mined= cf.set_index('id')
     body+mined:Baseline= [k for k, v in cf.multiget(['foo', 'bar']) if k in v]
        body+mined:-Code= cassa.find_all('cf', keys=['foo', 'bar'])
          body+mined:-NL= cf.multiget(['foo', 'bar'])
      body+mined:-Blocks= list(cassandra.database.keys())
      body+mined:-Inline= df[['foo', 'bar']]

================================================================================

QUESTION: idx=489    id=10607688
-------------------------------------INPUTS-------------------------------------

tags: 
score: 203
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: create a datetime with the current date & time
body(Left in tags for better readability):
<p> Here is a functional code (create file with success)
<code_block>
 sys.stdout = open('filename1.xml', 'w')

<p> Now I'm trying to name the file with the current date/time (I'm
not an expert in Python)
<code_block>
 filename1 = datetime.now().strftime("%Y%m%d-%H%M%S")
sys.stdout = open(filename1 + '.xml', 'w')

<p> I want to write out a file name with the exact date and time, it
is a xml file, that the program has already create, I just need to
name the file. The above code is not working.
<p> The error returned:
<code_block>
   File "./fix.py", line 226, in <module>
    filenames = datetime.now().strftime("%Y%m%d-%H%M%S")
AttributeError: 'module' object has no attribute 'now'


-------------------------------------OUTPUT-------------------------------------

                Expected= 'datetime.datetime.now()'
           base:Baseline= today = datetime.datetime.now().date()
           body:Baseline= datetime.now().strftime('%Y%m%d-%H%M%S')
            body:-Blocks= today = datetime.datetime.now().strftime('%Y-%m-%d')
              body:-Code= today = datetime.datetime.now().date()
            body:-Inline= sys.stdout = datetime.now().strftime('%Y%m%d-%H%M%S')
                body:-NL= datetime.now().strftime('%Y%m%d-%H%M%S')
             base:+Mined= dt = datetime.datetime.now().date()
     body+mined:Baseline= datetime.now().strftime('%Y%m%d-%H%M%S')
        body+mined:-Code= datetime.now().strftime('%Y-%m-%d %H:%M:%S')
          body+mined:-NL= datetime.now().strftime('%Y%m%d-%H%M%S')
      body+mined:-Blocks= time.strftime('%Y-%m-%d %H:%M:%S')
      body+mined:-Inline= datetime.now().strftime('%Y%m%d-%H%M%S')

================================================================================

QUESTION: idx=490    id=30843103
-------------------------------------INPUTS-------------------------------------

tags: list, indexing
score: 15
slot_map: {'key': ['str_0', 'var_0'], 'quote': ['`', '`'], 'type': ['str', 'var'], 'value': ['1', 'lst']}
intent: get the index of an integer `1` from a list `lst` if the list also contains boolean items
body(Left in tags for better readability):
<p> I am just starting with Python.
<p> How to get index of integer <code> 1 <p>  from a list if the list
contains a boolean <code> True <p>  object before the <code> 1 <p> ?
<code_block>
 <console_in> lst = [True, False, 1, 3]
<console_in> lst.index(1)
<console_out> 0
<console_in> lst.index(True)
<console_out> 0
<console_in> lst.index(0)
<console_out> 1

<p> I think Python considers <code> 0 <p>  as <code> False <p>  and
<code> 1 <p>  as <code> True <p>  in the argument of the <code> index
<p>  method. How can I get the index of integer <code> 1 <p>  (i.e.
<code> 2 <p> )?
<p> Also what is the reasoning or logic behind treating boolean object
this way in list?
As from the solutions, I can see it is not so straightforward.

-------------------------------------OUTPUT-------------------------------------

                Expected= 'next(i for i, x in enumerate(lst) if not isinstance(x, bool) and x == 1)'
           base:Baseline= [i for i, j in lst if j == 1]
           body:Baseline= [i for i, j in lst if i not j in j]
            body:-Blocks= [i for i in lst if i == 1]
              body:-Code= [i for i, j in lst if j in i]
            body:-Inline= [int(x) for x in lst if x else 1]
                body:-NL= [i for i, j in lst if i not in j]
             base:+Mined= [i for i, j in enumerate(lst) if j == 1]
     body+mined:Baseline= [i for i, j in enumerate(lst) if j == 1]
        body+mined:-Code= [i for i, x in enumerate(lst) if x == 2]
          body+mined:-NL= [i for i, elem in enumerate(lst) if elem is not a]
      body+mined:-Blocks= [i for i, j in enumerate(lst) if j == 1]
      body+mined:-Inline= [i for i, j in enumerate(lst) if j == 1]

================================================================================

QUESTION: idx=491    id=4918425
-------------------------------------INPUTS-------------------------------------

tags: 
score: 87
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['a']}
intent: subtract 13 from every number in a list `a`
body(Left in tags for better readability):
<p> I have a list
<code_block>
  a = [49, 51, 53, 56]

<p> How do I subtract 13 from each integer value in the list?

-------------------------------------OUTPUT-------------------------------------

                Expected= 'a[:] = [(x - 13) for x in a]'
           base:Baseline= [i for i, j in a if i != 13]
           body:Baseline= [i for i, j in a if j != 13]
            body:-Blocks= [x[0] for x in a]
              body:-Code= [x[0] for x in a]
            body:-Inline= [x[0] for x in a]
                body:-NL= [i for i, j in a if i != 13]
             base:+Mined= [(i * j) for i, j in zip(a, b)]
     body+mined:Baseline= [x for x in a if x != 13]
        body+mined:-Code= [(13 * a) for a in a]
          body+mined:-NL= [i for i, j in zip(a, a[i:13]) if j != 13]
      body+mined:-Blocks= a.sub(13, 13)
      body+mined:-Inline= [x[0] for x in a]

================================================================================

QUESTION: idx=492    id=701402
-------------------------------------INPUTS-------------------------------------

tags: file, random
score: 43
slot_map: {'key': ['str_0'], 'quote': ['`'], 'type': ['str'], 'value': ['C:\\']}
intent: choose a random file from the directory contents of the c drive, `c:\\`
body(Left in tags for better readability):
<p> What is the best way to choose a random file from a directory in
Python?
<em> Edit: <p>  Here is what I am doing:
<code_block>
 import os
import random
import dircache

dir = 'some/directory'
filename = random.choice(dircache.listdir(dir))
path = os.path.join(dir, filename)

<p> Is this particularly bad, or is there a particularly better way?

-------------------------------------OUTPUT-------------------------------------

                Expected= "random.choice(os.listdir('C:\\\\'))"
           base:Baseline= random.choice(c:\\)
           body:Baseline= random.choice(listdir(c:\\)
            body:-Blocks= random.choice(c:\\)
              body:-Code= random.choice(c:\\)
            body:-Inline= random.choice(c:\\)
                body:-NL= random.choice(dir, filename)
             base:+Mined= random.choice(os.path.dirname(c:\\))
     body+mined:Baseline= random.choice(open('C:\\'))
        body+mined:-Code= random.choice(open('C:\\').read())
          body+mined:-NL= random.choice(listdir, filename)
      body+mined:-Blocks= print(random.choice(open('C:\\').read())
      body+mined:-Inline= random.choice(listdir, c:\\)

================================================================================

QUESTION: idx=493    id=17794266
-------------------------------------INPUTS-------------------------------------

tags: numpy
score: 22
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['x']}
intent: get the highest element in absolute value in a numpy matrix `x`
body(Left in tags for better readability):
<p> Here is what I am currently doing, it works but it's a little
cumbersome:
<code_block>
 x = np.matrix([[1, 1], [2, -3]])
xmax = x.flat[abs(x).argmax()]


-------------------------------------OUTPUT-------------------------------------

                Expected= 'max(x.min(), x.max(), key=abs)'
           base:Baseline= max(x, key=lambda x: x[1])
           body:Baseline= np.matrix([1, 1], [2, -3]])
            body:-Blocks= max(x, key=lambda x: x[1])
              body:-Code= max(x, key=lambda x: x[1])
            body:-Inline= x[0].isinstance(x)
                body:-NL= np.matrix([np.arange(x).argmax()])
             base:+Mined= np.argwhere(np.arange(x))[0]
     body+mined:Baseline= xmax = x.flat[abs(x).argmax(axis=1)]
        body+mined:-Code= x.argmax(axis=1)
          body+mined:-NL= x.flat[abs(x).argmax(axis=1)]
      body+mined:-Blocks= x.argmax(axis=0)
      body+mined:-Inline= xmax = x.flat[abs(x).argmax()]

================================================================================

QUESTION: idx=494    id=30551576
-------------------------------------INPUTS-------------------------------------

tags: regex
score: 4
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['s']}
intent: get all urls within text `s`
body(Left in tags for better readability):
<p> I have parsed an html document containing javascript with
beautifulsoup, and have managed to isolate the javascript within it
and convert it into a string. The javascript looks like this:
<code_block>
 <script>
    [irrelevant javascript code here]
    sources:[{file:"http://url.com/folder1/v.html",label:"label1"},
    {file:"http://url.com/folder2/v.html",label:"label2"},
    {file:"http://url.com/folder3/v.html",label:"label3"}],
    [irrelevant javascript code here]
</script>

<p> I am trying to get an array with only urls contained in this
sources array, which would look like so:
<code_block>
 urls = ['http://url.com/folder1/v.html',
        'http://url.com/folder2/v.html',
        'http://url.com/folder3/v.html']

<p> The domains are unknown IPs, the folders are of random name-length
consisting of lowercase letters and numbers, and there are 1-5 of them
in each file(usually 3). All that is constant is that they start with
<code> http <p>  and end with <code> .html <p> .
<p> I decided to use regular expressions to deal with this
problem(which I am quite new at) and my code looks like this: <code>
urls=re.findall(r'http://[^t][^s"]+', document)
<p> The <code> [^t] <p>  is there because there are other urls in the
document whose domain names start with t. My problem is, there is
another url with a jpg from the same domain as the urls I am
extracting, which gets put into the urls array along with the others.
<p> Example:
<code_block>
 urls = ['http://123.45.67.89/asodibfo3ribawoifbadsoifasdf3/v.html'
        'http://123.45.67.89/alwefaoewifiasdof224a/v.html',
        'http://123.45.67.89/baoisdbfai235oubodsfb45/v.html',
        'http://123.45.67.89/i/0123/12345/aoief243oinsdf.jpg']

<p> How would I go about only fetching the html urls?

-------------------------------------OUTPUT-------------------------------------

                Expected= 're.findall(\'"(http.*?)"\', s, re.MULTILINE | re.DOTALL)'
           base:Baseline= print(re.findall('[^a-zA-Z]*', s))
           body:Baseline= re.findall('http://[^t][^s]+', s)
            body:-Blocks= re.findall('[^t]', s)
              body:-Code= urllib.parse.unquote(s)
            body:-Inline= urls = ['http://url.com/folder1/v.html', s)
                body:-NL= urls = re.findall('http://[^t][^s]+', s)
             base:+Mined= print(re.findall('\\s+', s))
     body+mined:Baseline= urls = [re.findall('http://[^t][^s]+)', document)
        body+mined:-Code= print(re.findall('(?P<domain>\\w+))', s))
          body+mined:-NL= urls = re.findall('http://[^t][^s]+', document)
      body+mined:-Blocks= re.findall('http://[^t][^s]+', s)
      body+mined:-Inline= print(open('http://url.com/folder1/v.html').read())

================================================================================

QUESTION: idx=495    id=30551576
-------------------------------------INPUTS-------------------------------------

tags: regex
score: 4
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['t', 'document']}
intent: match urls whose domain doesn't start with `t` from string `document` using regex
body(Left in tags for better readability):
<p> I have parsed an html document containing javascript with
beautifulsoup, and have managed to isolate the javascript within it
and convert it into a string. The javascript looks like this:
<code_block>
 <script>
    [irrelevant javascript code here]
    sources:[{file:"http://url.com/folder1/v.html",label:"label1"},
    {file:"http://url.com/folder2/v.html",label:"label2"},
    {file:"http://url.com/folder3/v.html",label:"label3"}],
    [irrelevant javascript code here]
</script>

<p> I am trying to get an array with only urls contained in this
sources array, which would look like so:
<code_block>
 urls = ['http://url.com/folder1/v.html',
        'http://url.com/folder2/v.html',
        'http://url.com/folder3/v.html']

<p> The domains are unknown IPs, the folders are of random name-length
consisting of lowercase letters and numbers, and there are 1-5 of them
in each file(usually 3). All that is constant is that they start with
<code> http <p>  and end with <code> .html <p> .
<p> I decided to use regular expressions to deal with this
problem(which I am quite new at) and my code looks like this: <code>
urls=re.findall(r'http://[^t][^s"]+', document)
<p> The <code> [^t] <p>  is there because there are other urls in the
document whose domain names start with t. My problem is, there is
another url with a jpg from the same domain as the urls I am
extracting, which gets put into the urls array along with the others.
<p> Example:
<code_block>
 urls = ['http://123.45.67.89/asodibfo3ribawoifbadsoifasdf3/v.html'
        'http://123.45.67.89/alwefaoewifiasdof224a/v.html',
        'http://123.45.67.89/baoisdbfai235oubodsfb45/v.html',
        'http://123.45.67.89/i/0123/12345/aoief243oinsdf.jpg']

<p> How would I go about only fetching the html urls?

-------------------------------------OUTPUT-------------------------------------

                Expected= 're.findall(\'http://[^t][^s"]+\\\\.html\', document)'
           base:Baseline= re.findall('\\w+', document)
           body:Baseline= re.findall('http://[^t][^s]', document)
            body:-Blocks= re.findall('[^t]', document)
              body:-Code= urllib.parse.unquote(document.startswith('t')))
            body:-Inline= re.findall('[^a-t]', document)
                body:-NL= re.findall('http://[^t][^s]+', document)
             base:+Mined= re.findall('\\w+', document)
     body+mined:Baseline= urls = re.findall('http://[^t][^s]+', document)
        body+mined:-Code= print(re.compile('^[^\\w\\s]*$').read())
          body+mined:-NL= urls = re.findall('http://[^t][^s]+', document)
      body+mined:-Blocks= re.findall('http://[^t][^s]', document)
      body+mined:-Inline= re.findall('\\w+', document)

================================================================================

QUESTION: idx=496    id=113534
-------------------------------------INPUTS-------------------------------------

tags: split
score: 12
slot_map: {'key': ['var_0', 'str_0'], 'quote': ['`', "'"], 'type': ['var', 'str'], 'value': ['mystring', '']}
intent: split a string `mystring` considering the spaces ' '
body(Left in tags for better readability):
<p> Is there a function in Python to split a string without ignoring
the spaces in the resulting list?
<p> E.g:
<code_block>
 s="This is the string I want to split".split()

<p> gives me
<code_block>
 <console_in> s
<console_out> ['This', 'is', 'the', 'string', 'I', 'want', 'to',
'split']

<p> I want something like
<code_block>
 ['This',' ','is',' ', 'the',' ','string', ' ', <console_out>..]


-------------------------------------OUTPUT-------------------------------------

                Expected= "mystring.replace(' ', '!!').split('!')"
           base:Baseline= re.split(' ', mystring)
           body:Baseline= """This is the string I want to split""".split()
            body:-Blocks= myString.split(' ', 1)
              body:-Code= myString.split(' ', 1)
            body:-Inline= s = s.split(' ', mystring)
                body:-NL= """This is the string I want to split".split()
             base:+Mined= myString.split(' ', 1)
     body+mined:Baseline= s = s.replace(' ', '')
        body+mined:-Code= myString.split(' ', 1)
          body+mined:-NL= mystring.split(' ', 1)
      body+mined:-Blocks= """ """.join(myString.split(' '))
      body+mined:-Inline= s = s.replace(' ', '')

================================================================================

QUESTION: idx=497    id=5838735
-------------------------------------INPUTS-------------------------------------

tags: django
score: 4
slot_map: {'key': ['var_0', 'str_0'], 'quote': ['`', "'"], 'type': ['var', 'str'], 'value': ['path', 'r']}
intent: open file `path` with mode 'r'
body(Left in tags for better readability):
<p> My cwd is ~/Desktop/Development/Python/djcode/mysite, and I want
to open a file on my Desktop. What is the syntax to open files in a
different directory? (for example, if the file was in the cwd I would
use open('file'). Thank you.

-------------------------------------OUTPUT-------------------------------------

                Expected= "open(path, 'r')"
           base:Baseline= os.path.open('r')
           body:Baseline= os.path.open('path', 'r')
            body:-Blocks= os.path.open('r')
              body:-Code= os.path.open('r')
            body:-Inline= os.path.open('file').r')
                body:-NL= os.path.open('r')
             base:+Mined= os.path.join(path, 'r')
     body+mined:Baseline= os.path.join(path, 'r')
        body+mined:-Code= os.path.join(path, 'r')
          body+mined:-NL= os.path.expanduser('r')
      body+mined:-Blocks= os.path.join(path, 'r')
      body+mined:-Inline= os.path.join(path, 'r')

================================================================================

QUESTION: idx=498    id=36003967
-------------------------------------INPUTS-------------------------------------

tags: list
score: 8
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['data']}
intent: sum elements at the same index in list `data`
body(Left in tags for better readability):
<p> Consider I have a list of lists as:
<code_block>
 [[5, 10, 30, 24, 100], [1, 9, 25, 49, 81]]
[[15, 10, 10, 16, 70], [10, 1, 25, 11, 19]]
[[34, 20, 10, 10, 30], [9, 20, 25, 30, 80]]

<p> Now I want the sum of all indexes of first list's index wise and
then the 2nd list   <code> 5+15+34=54   10+10+20=40 <p>
and so on as:
<code_block>
 [54,40,50, 50,200], [20,30,75,90,180]

<p> I tried:
<code_block>
 for res in results:
    print [sum(j) for j in zip(*res)]

<p> Here <code> results <p>  is the list of lists.
But it gives sum of each list item as:
<code_block>
 [6,19,55,73,181]
[25,11,35,27,89]
[43,40,35,40,110]


-------------------------------------OUTPUT-------------------------------------

                Expected= '[[sum(item) for item in zip(*items)] for items in zip(*data)]'
           base:Baseline= sum(data, key=lambda x: x[1])
           body:Baseline= sum(i, j) for i, j in zip(*data)]
            body:-Blocks= sum(zip(data, key=lambda x: x[1])
              body:-Code= sum(x, y) for x, y in data)
            body:-Inline= sum(j) for i, j in zip(*data)]
                body:-NL= [sum(x) for x, y in zip(*data)]
             base:+Mined= sum(x * y for x, y in zip(data, values))
     body+mined:Baseline= [sum(j) for i, j in zip(*data)]
        body+mined:-Code= sum(map(lambda i: sum(i[0], i[0]))
          body+mined:-NL= [sum(j) for i, j in zip(*data)]
      body+mined:-Blocks= sum(x[0] for x in data)
      body+mined:-Inline= [sum(j) for i, j in zip(*data)]

================================================================================

QUESTION: idx=499    id=7635237
-------------------------------------INPUTS-------------------------------------

tags: arrays, vector, numpy, casting
score: 6
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['a']}
intent: add a new axis to array `a`
body(Left in tags for better readability):
<p> I'd like to cast a numpy <code> ndarray <p>  object of shape (
<em> n <p> ,) into one having shape ( <em> n <p> , 1).  The best I've
come up with is to roll my own _to_col function:
<code_block>
 def _to_col(a):
    return a.reshape((a.size, 1))

<p> But it is hard for me to believe that such a ubiquitous operation
is not already built into numpy's syntax.  I figure that I just have
not been able to hit upon the right Google search to find it.

-------------------------------------OUTPUT-------------------------------------

                Expected= 'a[:, (np.newaxis)]'
           base:Baseline= a.reshape(axis=1)
           body:Baseline= a.reshape((a.size, 1))
            body:-Blocks= a.shape_adjust(axis=0)
              body:-Code= a.shape_adjust(axis=1)
            body:-Inline= a.reshape(axis=1)
                body:-NL= a.reshape((a.size, 1))
             base:+Mined= a.set_zlabel('A')
     body+mined:Baseline= a.reshape((1, 1))
        body+mined:-Code= a[np.arange(a.shape[0]) + 1]
          body+mined:-NL= a.reshape((a.size, 1), axis=1)
      body+mined:-Blocks= a.reshape(1, 1)
      body+mined:-Inline= a.reshape(a.size, 1)

