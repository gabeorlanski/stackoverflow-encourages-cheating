================================================================================

QUESTION: idx=0      id=15080500
-------------------------------------INPUTS-------------------------------------

tags: linux, signals
score: 24
slot_map: {'key': ['str_0'], 'quote': ['`'], 'type': ['str'], 'value': ['signal.SIGUSR1']}
intent: send a signal `signal.sigusr1` to the current process
body(Some added characters for better readability):
	I have this code which listens to USR1 signals
	
	start_block
	import signal
	import os
	import time
	def receive_signal(signum, stack):
	    print 'Received:', signum
	signal.signal(signal.SIGUSR1, receive_signal)
	signal.signal(signal.SIGUSR2, receive_signal)
	print 'My PID is:', os.getpid()
	while True:
	    print 'Waiting...'
	    time.sleep(3)
	
	<p>This works when I send signals with `kill -USR1 pid`
	
	<p>But how can I send the same signal from within the above python script so that after 10 seconds it automatically sends 
	`USR1` and also receives it , without me having to open two terminals to check it?


-------------------------------------OUTPUT-------------------------------------

                Expected= 'os.kill(os.getpid(), signal.SIGUSR1)'
           base:Baseline= "sys.system('signal.sigusr1')"
           base:+Canonic= "process.call('signal.SIGUSR1')"
           body:Baseline= "print(re.subprocess('SIGUSR1', 'WRITE', SIGUSR2))"
              body:-Code= "sys.system('signal.sigusr1')"
          mined:Baseline= "os.system('signal.sigusr1')"
             mined:+Body= 'signal.SIGUSR1.communicate()[0]'
        mined:+Body, -NL= 'signal.SIGUSR1.communicate()'
      mined:+Body, -Code= "os.system('signal.sigusr1')"

================================================================================

QUESTION: idx=1      id=3283984
-------------------------------------INPUTS-------------------------------------

tags: 
score: 64
slot_map: {'key': ['str_0'], 'quote': ["'"], 'type': ['str'], 'value': ['4a4b4c']}
intent: decode a hex string '4a4b4c' to utf-8.
body(Some added characters for better readability):
	In Python 2, converting the hexadecimal form of a string into the corresponding unicode was straightforward:
	
	start_block
	comments.decode("hex")
	
	<p>where the variable 'comments' is a part of a line in a file (the rest of the line does 
	not  need to be converted, as it is represented only in ASCII.
	Now in Python 3, however, this doesn't work (I assume because of the bytes/string vs. string/unicode switch. I feel like there should be a one-liner in Python 3 to do the same thing, rather than reading the entire line as a series of bytes (which I don't want to do) and then converting each part of the line separately. If it's possible, I'd like to read the entire line as a unicode string (because the rest of the line is in unicode) and only convert this one part from a hexadecimal representation.


-------------------------------------OUTPUT-------------------------------------

                Expected= "bytes.fromhex('4a4b4c').decode('utf-8')"
           base:Baseline= 'hex(4a4b4c, 16)'
           base:+Canonic= "4a4b4c.decode('utf8')"
           body:Baseline= "comments.decode('4a4b4c').encode('utf8')"
              body:-Code= "print('4a4b4c', 'utf8')"
          mined:Baseline= "print(decoded('4a4b4c', 16))"
             mined:+Body= "int('4a4b4c', 16)"
        mined:+Body, -NL= "comment.decode('4a4b4c')"
      mined:+Body, -Code= '"""4a4b4c""".decode(\'hex\')'

================================================================================

QUESTION: idx=2      id=3844801
-------------------------------------INPUTS-------------------------------------

tags: algorithm, comparison
score: 436
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['myList']}
intent: check if all elements in list `mylist` are identical
body(Some added characters for better readability):
	
	<p>I need a function which takes in a 
	`list`
	 and outputs 
	`True`
	 if all elements in the input list evaluate as equal to each other using the standard equality operator and 
	`False` otherwise.
	
	<p>I feel it would be best to iterate through the list comparing adjacent elements and then 
	`AND` all the resulting Boolean values. But I'm not sure what's the most Pythonic way to do that.


-------------------------------------OUTPUT-------------------------------------

                Expected= 'all(x == myList[0] for x in myList)'
           base:Baseline= 'all(i == j for i, j in mylist)'
           base:+Canonic= 'all(isinstance(myList, myList))'
           body:Baseline= 'all(i == j for i in mylist)'
              body:-Code= 'all(x, y) for x, y in mylist)'
          mined:Baseline= 'len(set(mylist)) == 1'
             mined:+Body= 'all(isinstance(x, y) for x, y in mylist)'
        mined:+Body, -NL= 'all(x == mylist for x in mylist)'
      mined:+Body, -Code= 'all(x == y for x, y in zip(myList, myList))'

================================================================================

QUESTION: idx=3      id=4302166
-------------------------------------INPUTS-------------------------------------

tags: string
score: 57
slot_map: {'key': ['var_0', 'str_0', 'str_1', 'str_2'], 'quote': ['`', '`', '`', '`'], 'type': ['var', 'str', 'str', 'str'], 'value': ['Python', ':', 'Very Good', '20']}
intent: format number of spaces between strings `python`, `:` and `very good` to be `20`
body(Some added characters for better readability):
	If I want to make my formatted string dynamically adjustable, I can change the following code from
	
	start_block
	print '%20s : %20s' % ("Python", "Very Good")
	to
	
	start_block
	width = 20
	print ('%' + str(width) + 's : %' + str(width) + 's') % ("Python", "Very Good")
	However, it seems that string concatenation is cumbersome here. Any other way to simplify things?


-------------------------------------OUTPUT-------------------------------------

                Expected= "print('%*s : %*s' % (20, 'Python', 20, 'Very Good'))"
           base:Baseline= '"""20""".format(python, \':\', \'very good\')'
           base:+Canonic= '"""20""".format(\':\', \'Very Good\')'
           body:Baseline= "print('%20s : %s') % ('Python', ':', 'very good')"
              body:-Code= '"""{0:.2f}""".format(python, `:\',\'very good\')'
          mined:Baseline= '"""{0:.2g}""".format(python, \':\')'
             mined:+Body= "print('%20s : %20s' % ('Python', 'Very Good')"
        mined:+Body, -NL= "print('%20s : %20s' % ('Python', 'Very Good')"
      mined:+Body, -Code= '"""{:.5f}""".format(python, \':\', \'very good\')'

================================================================================

QUESTION: idx=4      id=7555335
-------------------------------------INPUTS-------------------------------------

tags: utf-8, cp1251
score: 26
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: how to convert a string from cp-1251 to utf-8?
body(Some added characters for better readability):
	
	<p>I'm using mutagen to convert ID3 tags data from 
	CP-1251 
	/ 
	CP-1252 
	 to UTF-8. In Linux there is no problem. But on Windows, calling 
	`SetValue()` on a wx.TextCtrl produces the error:
	UnicodeDecodeError: 'ascii' codec can't decode byte 0xc3 in position
	  0: ordinal not in range(128)
	
	<p>The original string (assumed to be CP-1251 encoded) that I'm pulling from 
	mutagen  is:
	
	start_block
	u'\xc1\xe5\xeb\xe0\xff \xff\xe1\xeb\xfb\xed\xff \xe3\xf0\xee\xec\xf3'
	I've tried converting this to UTF-8:
	
	start_block
	dd = d.decode('utf-8')
	<console_out>and even changing the default encoding from ASCII to UTF-8:
	
	start_block
	sys.setdefaultencoding('utf-8')
	<console_out>But I get the same error.


-------------------------------------OUTPUT-------------------------------------

                Expected= "d.decode('cp1251').encode('utf8')"
           base:Baseline= "struct.unpack('cp1251', 'utf-8')"
           base:+Canonic= '"""""".join(c for c in cp-1251 if c.startswith(\'utf8\')))'
           body:Baseline= "struct.setdefaultencoding('cp-1251', 'utf8')"
              body:-Code= "struct.unpack('cp-1251', 'utf-8')"
          mined:Baseline= "s.decode('cp1252')"
             mined:+Body= "sys.setdefaultencoding('utf-8')"
        mined:+Body, -NL= "sys.setdefaultencoding('cp-1251', 'ignore')"
      mined:+Body, -Code= "urllib.parse.unquote(filename).decode('utf-8')"

================================================================================

QUESTION: idx=5      id=2544710
-------------------------------------INPUTS-------------------------------------

tags: 
score: 44
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['kwargs']}
intent: get rid of none values in dictionary `kwargs`
body(Some added characters for better readability):
	Something like:
	
	start_block
	for (a,b) in kwargs.iteritems():
	    if not b : del kwargs[a]
	This code raise exception because changing of dictionary when iterating.
	I discover only non pretty solution with another dictionary:
	
	start_block
	res ={}
	res.update((a,b) for a,b in kwargs.iteritems() if b is not None)
	Thanks


-------------------------------------OUTPUT-------------------------------------

                Expected= 'res = {k: v for k, v in list(kwargs.items()) if v is not None}'
           base:Baseline= 'any(None) for i in list(kwargs.values())'
           base:+Canonic= 'dict((k, v) for k, v in kwargs.items())'
           body:Baseline= 'res.update((a, b) for a, b in kwargs)'
              body:-Code= 'dict((k, v) for k, v in list(kwargs.items())'
          mined:Baseline= '{k: v for k, v in list(kwargs.items()) if v is not None}'
             mined:+Body= 'res = {k: v for k, v in list(kwargs.items()) if v is not None}'
        mined:+Body, -NL= 'res.update((a, b) for a, b in kwargs.items() if b is not None)'
      mined:+Body, -Code= '{k: v for k, v in list(kwargs.items()) if v is not None}'

================================================================================

QUESTION: idx=6      id=2544710
-------------------------------------INPUTS-------------------------------------

tags: 
score: 44
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['kwargs']}
intent: get rid of none values in dictionary `kwargs`
body(Some added characters for better readability):
	Something like:
	
	start_block
	for (a,b) in kwargs.iteritems():
	    if not b : del kwargs[a]
	This code raise exception because changing of dictionary when iterating.
	I discover only non pretty solution with another dictionary:
	
	start_block
	res ={}
	res.update((a,b) for a,b in kwargs.iteritems() if b is not None)
	Thanks


-------------------------------------OUTPUT-------------------------------------

                Expected= 'res = dict((k, v) for k, v in kwargs.items() if v is not None)'
           base:Baseline= 'any(None) for i in list(kwargs.values())'
           base:+Canonic= 'dict((k, v) for k, v in kwargs.items())'
           body:Baseline= 'res.update((a, b) for a, b in kwargs)'
              body:-Code= 'dict((k, v) for k, v in list(kwargs.items())'
          mined:Baseline= '{k: v for k, v in list(kwargs.items()) if v is not None}'
             mined:+Body= 'res = {k: v for k, v in list(kwargs.items()) if v is not None}'
        mined:+Body, -NL= 'res.update((a, b) for a, b in kwargs.items() if b is not None)'
      mined:+Body, -Code= '{k: v for k, v in list(kwargs.items()) if v is not None}'

================================================================================

QUESTION: idx=7      id=14971373
-------------------------------------INPUTS-------------------------------------

tags: subprocess
score: 4
slot_map: {'key': ['str_0'], 'quote': ['`'], 'type': ['str'], 'value': ['ps -ef | grep something | wc -l']}
intent: capture final output of a chain of system commands `ps -ef | grep something | wc -l`
body(Some added characters for better readability):
	
	<p>There are many posts here on SO, like this one: Store output of subprocess.Popen call in a string
	There is problem with complicated commands. For example, if I need to get output from this
	ps -ef|grep something|wc -l
	Subprocess won't do the job, because argument for subprocess is [name of program, arguments], so it is not possible to use more sophisicated commands (more programs, pipes, etc.). 
	Is there way to capture the output of a chain of multiple commands?


-------------------------------------OUTPUT-------------------------------------

                Expected= "subprocess.check_output('ps -ef | grep something | wc -l', shell=True)"
           base:Baseline= "sys.system('ps -ef | grep something | wc -l')"
           base:+Canonic= "sys.exit('ps -ef | grep something | wc -l')"
           body:Baseline= 'output = subprocess.Popen(ps -ef | grep something | wc -l)'
              body:-Code= "subprocess.call('ps -ef | grep something | wc -l')"
          mined:Baseline= "system('ps -ef | grep something | wc -l')"
             mined:+Body= "output = subprocess.Popen(['ps -ef', 'grep something | wc -l'])"
        mined:+Body, -NL= 'ps.communicate()[0]'
      mined:+Body, -Code= "output = subprocess.Popen('ps -ef | grep something | wc -l', shell=True)"

================================================================================

QUESTION: idx=8      id=6726636
-------------------------------------INPUTS-------------------------------------

tags: string, split, append
score: 8
slot_map: {'key': ['str_0', '[str_0]'], 'quote': ['`', '`'], 'type': ['str', 'str'], 'value': ["['a', 'b', 'c']", "['a', 'b', 'c']"]}
intent: concatenate a list of strings `['a', 'b', 'c']`
body(Some added characters for better readability):
	I was wondering if python had a built in function similar to 
	
	start_block
	string->list
	
	<p>and 
	`list->string` in scheme.
	
	<p>So for example I would like to turn 'abc' into 
	`['a','b','c']` and vice versa using a built in function.


-------------------------------------OUTPUT-------------------------------------

                Expected= '"""""".join([\'a\', \'b\', \'c\'])'
           base:Baseline= '"""""".join([\'a\', \'b\', \'c\'])'
           base:+Canonic= '"""[\'a\', \'b\', \'c\']""".encode(\'utf-8\')'
           body:Baseline= "['a', 'b', 'c']"
              body:-Code= "list(['a', 'b', 'c']))"
          mined:Baseline= '"""""".join([\'a\', \'b\', \'c\'])'
             mined:+Body= "['a', 'b', 'c']"
        mined:+Body, -NL= "['a', 'b', 'c']"
      mined:+Body, -Code= '"""""".join([\'a\', \'b\', \'c\'])'

================================================================================

QUESTION: idx=9      id=18079563
-------------------------------------INPUTS-------------------------------------

tags: pandas, series, intersection
score: 62
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['s1', 's2']}
intent: find intersection data between series `s1` and series `s2`
body(Some added characters for better readability):
	
	<p>I have two series 
	`s1`
	 and 
	`s2` in pandas and want to compute the intersection i.e. where all of the values of the series are common.
	
	<p>How would I use the 
	`concat`
	 function to do this? I have been trying to work it out but have been unable to (I don't want to compute the intersection on the indices of 
	`s1`
	 and 
	`s2`, but on the values).


-------------------------------------OUTPUT-------------------------------------

                Expected= 'pd.Series(list(set(s1).intersection(set(s2))))'
           base:Baseline= 'pandas.concatenate(Series(s1, s2))'
           base:+Canonic= 'np.intersection(s1, s2)'
           body:Baseline= 'df.intersection(s1, s2)'
              body:-Code= 'np.where(s1 == s2)'
          mined:Baseline= 's1.set_intersection(s2, set_intersects)'
             mined:+Body= 'pd.concat([s1, s2], axis=1)'
        mined:+Body, -NL= 's1.find_intersection(s2)'
      mined:+Body, -Code= 'c = pd.concat([s1, s2], axis=1)'

================================================================================

QUESTION: idx=10     id=8315209
-------------------------------------INPUTS-------------------------------------

tags: html, sockets, client
score: 7
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['client']}
intent: sending http headers to `client`
body(Some added characters for better readability):
	I've set up a little script that should feed a client with html.
	
	start_block
	import socket
	sock = socket.socket()
	sock.bind(('', 8080))
	sock.listen(5)
	client, adress = sock.accept()
	print "Incoming:", adress
	print client.recv(1024)
	print
	client.send("Content-Type: text/html\n\n")
	
	<html></body> </html>')
	print "Answering <console_out>"
	print "Finished."
	import os
	os.system("pause")
	But it is shown as plain text in the browser. Can you please tell what I need to do ? I just can't find something in google that helps me..
	Thanks.


-------------------------------------OUTPUT-------------------------------------

                Expected= "client.send('HTTP/1.0 200 OK\\r\\n')"
           base:Baseline= "webbrowser.send('HTTP headers', headers=1)"
           base:+Canonic= "client.sending('headers', headers=headers)"
           body:Baseline= "client.send('Content-Type: text/html\\n\\n')"
              body:-Code= "client.send_headers('http://www.request.org/', headers=False)"
          mined:Baseline= "client.send('HTTP/1.0 200 OK')"
             mined:+Body= "client.send('Content-Type: text/html\\n')"
        mined:+Body, -NL= "client.send('Content-Type: text/html\\\\n\\\\n')"
      mined:+Body, -Code= "client.send('http://www.google.com')"

================================================================================

QUESTION: idx=11     id=26153795
-------------------------------------INPUTS-------------------------------------

tags: datetime, strptime
score: 50
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['when']}
intent: format a datetime string `when` to extract date only
body(Some added characters for better readability):
	I have a date string and want to convert it to the date type:
	I have tried to use datetime.datetime.strptime with the format that I want but it is returning the time with the conversion.
	
	start_block
	    when = alldates[int(daypos[0])]
	    print when, type(when)
	    then = datetime.datetime.strptime(when, '%Y-%m-%d')
	    print then, type(then)
	This is what the output returns:
	
	start_block
	   2013-05-07 <type 'str'>
	   2013-05-07 00:00:00 <type 'datetime.datetime'>
	I need to remove the the time: 00:00:00.


-------------------------------------OUTPUT-------------------------------------

                Expected= "then = datetime.datetime.strptime(when, '%Y-%m-%d').date()"
           base:Baseline= "datetime.strptime('2010-03-13', '%Y-%m-%d %H:%M:%S')"
           base:+Canonic= "datetime.strptime('when', '%Y-%m-%d %H:%M:%S')"
           body:Baseline= "when = datetime.datetime.strptime(when, '%Y-%m-%d')"
              body:-Code= 'datetime.strptime(when)'
          mined:Baseline= "datetime.strptime('2012-03-13 10:33:54.227806', '%Y-%m-%d %H:%M:%S.%f')"
             mined:+Body= "date = datetime.datetime.strptime(2013-05-07, '%Y-%m-%d')"
        mined:+Body, -NL= "dt = datetime.datetime.now().strftime('%Y-%m-%d')"
      mined:+Body, -Code= "datetime.strptime('2010-11-13 10:33:54', '%Y-%m-%d %H:%M:%S')"

================================================================================

QUESTION: idx=12     id=172439
-------------------------------------INPUTS-------------------------------------

tags: string
score: 303
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['inputString']}
intent: split a multi-line string `inputstring` into separate strings
body(Some added characters for better readability):
	I have a multi-line string literal that I want to do an operation on each line, like so:
	
	start_block
	inputString = """Line 1
	Line 2
	Line 3"""
	I want to do something like the following:
	
	start_block
	for line in inputString:
	    doStuff()


-------------------------------------OUTPUT-------------------------------------

                Expected= "inputString.split('\\n')"
           base:Baseline= '"""""".join(str(inputString))'
           base:+Canonic= "re.split('\\n', inputString)"
           body:Baseline= "re.split('', inputString)"
              body:-Code= "inputString.split(',', 1)[0]"
          mined:Baseline= '""" """.join(map(str, inputstring))'
             mined:+Body= '"""""".join(map(str, inputString))'
        mined:+Body, -NL= '"""""".join(map(str, inputString))'
      mined:+Body, -Code= '"""""".join(map(str, inputstring))'

================================================================================

QUESTION: idx=13     id=172439
-------------------------------------INPUTS-------------------------------------

tags: string
score: 303
slot_map: {'key': ['str_0', 'str_1'], 'quote': ['`', '`'], 'type': ['str', 'str'], 'value': ['a \n b \r\n c', '\n']}
intent: split a multi-line string ` a \n b \r\n c ` by new line character `\n`
body(Some added characters for better readability):
	I have a multi-line string literal that I want to do an operation on each line, like so:
	
	start_block
	inputString = """Line 1
	Line 2
	Line 3"""
	I want to do something like the following:
	
	start_block
	for line in inputString:
	    doStuff()


-------------------------------------OUTPUT-------------------------------------

                Expected= "' a \\n b \\r\\n c '.split('\\n')"
           base:Baseline= '"""\\n""".join(a, b, c))'
           base:+Canonic= "re.split('a \\n b \\r\\n c', '\\n')"
           body:Baseline= "'A \\n b \\r\\n c'.replace('\\n')"
              body:-Code= "re.split('\\n', '\\n')"
          mined:Baseline= "'a \\n b \\r\\n c'.split('\\n')"
             mined:+Body= "'A \\n b \\r\\n c'.split()"
        mined:+Body, -NL= "'a \\n b \\r\\n c'.split()"
      mined:+Body, -Code= "'a \\n b \\r\\n c'.split(',')"

================================================================================

QUESTION: idx=14     id=13954222
-------------------------------------INPUTS-------------------------------------

tags: 
score: 11
slot_map: {'key': ['var_0', 'str_0'], 'quote': ['`', '"'], 'type': ['var', 'str'], 'value': ['b', ':']}
intent: concatenate elements of list `b` by a colon ":"
body(Some added characters for better readability):
	I have a list (array) with mixed 
	
	start_block
	a = ["x", "2", "y"]
	b = ["x", 2, "y"]
	print ":".join(a)
	print ":".join(b)
	The first join works, but the second one throws a TypeError exception 
	I came up with this, but is this the Python solution?
	
	start_block
	print ":".join(map(str, b))
	BTW in the end I just would like to write this string to a file, so if there is a specific solution for that, I'd appreciate that too.


-------------------------------------OUTPUT-------------------------------------

                Expected= '""":""".join(str(x) for x in b)'
           base:Baseline= '[(x + y) for x, y in zip(b, b)]'
           base:+Canonic= "[x for x in b if ':' in x]"
           body:Baseline= 'b = [(map(str, b))'
              body:-Code= '"""""".join(list(b))'
          mined:Baseline= 'b = [(c.split(\':") for c in b])'
             mined:+Body= "print(':'.join(map(str, b))"
        mined:+Body, -NL= "print(':'.join(map(str, b))"
      mined:+Body, -Code= '"""""".join(str(i) for i in b)'

================================================================================

QUESTION: idx=15     id=5123839
-------------------------------------INPUTS-------------------------------------

tags: django, performance, django-models
score: 226
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['Entry']}
intent: get the first object from a queryset in django model `entry`
body(Some added characters for better readability):
	
	<p>Often I find myself wanting to get the first object from a queryset in Django, or return 
	`None` if there aren't any.  There are lots of ways to do this which all work.  But I'm wondering which is the most performant.
	
	start_block
	qs = MyModel.objects.filter(blah = blah)
	if qs.count() > 0:
	    return qs[0]
	else:
	    return None
	Does this result in two database calls?  That seems wasteful.  Is this any faster? 
	
	start_block
	qs = MyModel.objects.filter(blah = blah)
	if len(qs) > 0:
	    return qs[0]
	else:
	    return None
	Another option would be:
	
	start_block
	qs = MyModel.objects.filter(blah = blah)
	try:
	    return qs[0]
	except IndexError:
	    return None
	This generates a single database call, which is good.  But requires creating an exception object a lot of the time, which is a very memory-intensive thing to do when all you really need is a trivial if-test.
	How can I do this with just a single database call and without churning memory with exception objects?


-------------------------------------OUTPUT-------------------------------------

                Expected= 'Entry.objects.filter()[:1].get()'
           base:Baseline= 'Entry.objects.filter(key=lambda x: x[1])'
           base:+Canonic= 'Entry.objects.first()'
           body:Baseline= 'entry.objects.first(0)'
              body:-Code= 'Entry.objects.get(0)'
          mined:Baseline= "Entry.objects.all().order_by('?')[0]"
             mined:+Body= 'MyModel.objects.filter(Q(blah=blah))'
        mined:+Body, -NL= "Entry.objects.filter(blah='blah')"
      mined:+Body, -Code= "Entry.objects.order_by('id')[0]"

================================================================================

QUESTION: idx=16     id=13567345
-------------------------------------INPUTS-------------------------------------

tags: numpy
score: 70
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: calculate sum over all rows of 2d numpy array
body(Some added characters for better readability):
	Let's say I have the following 2D numpy array consisting of four rows and three columns:
	
	
	start_block
	>>>a = numpy.arange(12).reshape(4,3)
	>>>print(a)
	...[[ 0  1  2]
	 [ 3  4  5]
	 [ 6  7  8]
	 [ 9 10 11]]
	
	<p>What would be an efficient way to generate a 1D array that contains the sum of all columns (like 
	`[18, 22, 26]`)? Can this be done without having the need to loop through all columns?


-------------------------------------OUTPUT-------------------------------------

                Expected= 'a.sum(axis=1)'
           base:Baseline= 'sum(np.sum(axis=0, axis=1))'
           base:+Canonic= 'np.sum(np.arange(2, axis=1))'
           body:Baseline= 'sum(np.arange(12), axis=1)'
              body:-Code= 'np.sum(np.arange(axis=1), axis=1)'
          mined:Baseline= 'np.sum(sum(axis=1))'
             mined:+Body= 'a.sum(axis=1)'
        mined:+Body, -NL= 'a.sum(axis=1)'
      mined:+Body, -Code= 'np.sum(axis=1)'

================================================================================

QUESTION: idx=17     id=29784889
-------------------------------------INPUTS-------------------------------------

tags: warnings
score: 15
slot_map: {'key': ['str_0'], 'quote': ["'"], 'type': ['str'], 'value': ['always']}
intent: enable warnings using action 'always'
body(Some added characters for better readability):
	I was setting up a ImportWarning as seemed appropriate but noticed this warning is not reported by default;
	How can I set python to report ImportWarning or all warnings?
	Here is the import warning i wrote:
	
	start_block
	try:
	    from markdown import markdown
	except ImportError, err:
	    warnings.warn(
	        'Unable to load Pypi package `markdown`, HTML output will be unavailable. {}'.format(err),
	        ImportWarning
	    )


-------------------------------------OUTPUT-------------------------------------

                Expected= "warnings.simplefilter('always')"
           base:Baseline= "if ('always') == 'ignore')"
           base:+Canonic= "if 'always' in action():\n    pass"
           body:Baseline= "warn(lambda x: x.exists('always')"
              body:-Code= "import('importWarning', 'always')"
          mined:Baseline= "warnings = (x.warn('always') if x!= 'always')"
             mined:+Body= "warnings.warn(('always')"
        mined:+Body, -NL= "warn('always', action='always')"
      mined:+Body, -Code= "warnings.get_warnings('always')"

================================================================================

QUESTION: idx=18     id=13550423
-------------------------------------INPUTS-------------------------------------

tags: 
score: 8
slot_map: {'key': ['var_0', 'str_0'], 'quote': ['`', "'"], 'type': ['var', 'str'], 'value': ['l', '']}
intent: concatenate items of list `l` with a space ' '
body(Some added characters for better readability):
	How can I print lists without brackets and commas?
	I have a list of permutations like this:
	
	start_block
	   [1, 2, 3]
	   [1, 3, 2] etc.. 
	
	<p>I want to print them like this: `1 2 3`


-------------------------------------OUTPUT-------------------------------------

                Expected= "print(' '.join(map(str, l)))"
           base:Baseline= "[x for x in l if x[0] == '']"
           base:+Canonic= "re.compile('', l)"
           body:Baseline= "print(' '.join(str(x) for x in L))"
              body:-Code= "print(' '.join(str(x) for x in l))"
          mined:Baseline= 'l = [str(x) for x in l]'
             mined:+Body= "print(' '.join(str(x) for x in L))"
        mined:+Body, -NL= "[item for item in L if '  ' in item]"
      mined:+Body, -Code= "print(' '.join(str(i) for i in L))"

================================================================================

QUESTION: idx=19     id=25651990
-------------------------------------INPUTS-------------------------------------

tags: subprocess
score: 46
slot_map: {'key': ['str_0', 'str_1'], 'quote': ["'", "'"], 'type': ['str', 'str'], 'value': ['hello.py', 'htmlfilename.htm']}
intent: run script 'hello.py' with argument 'htmlfilename.htm' on terminal using python executable
body(Some added characters for better readability):
	I am trying to call a python file "hello.py" from within the python interpreter with subprocess. But I am unable to resolve this error. [Python 3.4.1]. 
	
	start_block
	import subprocess    
	subprocess.call(['hello.py', 'htmlfilename.htm'])
	Traceback (most recent call last):
	  File " <pyshell#42>", line 1, in <module>
	    subprocess.call(['hello.py', 'htmlfilename.htm'])
	  File "C:\Python34\lib\subprocess.py", line 537, in call
	    with Popen(*popenargs, **kwargs) as p:
	  File "C:\Python34\lib\subprocess.py", line 858, in __init__
	    restore_signals, start_new_session)
	  File "C:\Python34\lib\subprocess.py", line 1111, in _execute_child
	    startupinfo)
	OSError: [WinError 193] %1 is not a valid Win32 application
	Also is there any alternate way to "call a python script with arguments" other than using subprocess?
	Thanks in advance.


-------------------------------------OUTPUT-------------------------------------

                Expected= "subprocess.call(['python.exe', 'hello.py', 'htmlfilename.htm'])"
           base:Baseline= "subprocess.call('hello.py', 'htmlfilename.htm', shell=True)"
           base:+Canonic= "os.system('hello.py', 'htmlfilename.htm')"
           body:Baseline= "subprocess.call('hello.py', 'htmlfilename.htm')"
              body:-Code= "subprocess.call('hello.py', 'htmlfilename.htm', shell=True)"
          mined:Baseline= "subprocess.call('hello.py', shell=True)"
             mined:+Body= "subprocess.call(['hello.py', 'htmlfilename.htm'])"
        mined:+Body, -NL= "subprocess.call(['hello.py', 'htmlfilename.htm'])"
      mined:+Body, -Code= "subprocess.call('hello.py', shell=True)"

================================================================================

QUESTION: idx=20     id=698223
-------------------------------------INPUTS-------------------------------------

tags: date, time, datetime-parsing
score: 216
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: how can i parse a time string containing milliseconds in it with python?
body(Some added characters for better readability):
	
	<p>I am able to parse strings containing date/time with time.strptime
	
	
	start_block
	>>>import time
	>>>time.strptime('30/03/09 16:31:32', '%d/%m/%y %H:%M:%S')
	...(2009, 3, 30, 16, 31, 32, 0, 89, -1)
	How can I parse a time string that contains milliseconds?
	
	
	start_block
	>>>time.strptime('30/03/09 16:31:32.123', '%d/%m/%y %H:%M:%S')
	...Traceback (most recent call last):
	  File " <stdin>", line 1, in <module>
	  File "/usr/lib/python2.5/_strptime.py", line 333, in strptime
	    data_string[found.end():])
	ValueError: unconverted data remains: .123


-------------------------------------OUTPUT-------------------------------------

                Expected= "time.strptime('30/03/09 16:31:32.123', '%d/%m/%y %H:%M:%S.%f')"
           base:Baseline= "time.strftime('%Y-%m-%d %H:%M:%S')"
           base:+Canonic= "time.strftime('%Y-%m-%d %H:%M:%S')"
           body:Baseline= "time.strptime('30/03/09 16:31:32.123', '%d/%m/%y %H:%M:%S')"
              body:-Code= "time.strptime('%Y-%m-%d %H:%M')"
          mined:Baseline= "print(datetime.strptime(datestr, '%Y-%m-%dT%H:%M:%S'))"
             mined:+Body= "time.strptime('30/03/09 16:31:32.123', '%d/%m/%y %H:%M:%S')"
        mined:+Body, -NL= "time.strptime('30/03/09 16:31:32', '%d/%m/%y %H:%M:%S')"
      mined:+Body, -Code= "print(map(strptime, '%H:%M:%S'))"

================================================================================

QUESTION: idx=21     id=6633523
-------------------------------------INPUTS-------------------------------------

tags: type-conversion
score: 102
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['my_string', 'my_float']}
intent: convert a string `my_string` with dot and comma into a float number `my_float`
body(Some added characters for better readability):
	
	<p>How can I convert a string like 
	`123,456.908`
	 to float 
	`123456.908` in Python?


-------------------------------------OUTPUT-------------------------------------

                Expected= "my_float = float(my_string.replace(',', ''))"
           base:Baseline= 'float(my_string, my_float)'
           base:+Canonic= 'float(my_string, my_float)'
           body:Baseline= "my_string.float('123456.908')"
              body:-Code= "my_string.float('my_float')"
          mined:Baseline= "float(my_string.split(','))"
             mined:+Body= "my_string.float('123456.908')"
        mined:+Body, -NL= "my_string.split(',')"
      mined:+Body, -Code= 'my_float = float(my_string.split())'

================================================================================

QUESTION: idx=22     id=6633523
-------------------------------------INPUTS-------------------------------------

tags: type-conversion
score: 102
slot_map: {'key': ['str_0'], 'quote': ['`'], 'type': ['str'], 'value': ['123,456.908']}
intent: convert a string `123,456.908` with dot and comma into a floating number
body(Some added characters for better readability):
	
	<p>How can I convert a string like 
	`123,456.908`
	 to float 
	`123456.908` in Python?


-------------------------------------OUTPUT-------------------------------------

                Expected= "float('123,456.908'.replace(',', ''))"
           base:Baseline= 'float(123,456.908))'
           base:+Canonic= '"""123,456.908""".split()'
           body:Baseline= "float('123,456.908')"
              body:-Code= "float('123,456.908')"
          mined:Baseline= 'float(123, 456.908)'
             mined:+Body= "float('123,456.908')"
        mined:+Body, -NL= '"""123,456.908""".replace(\', \', \'\')'
      mined:+Body, -Code= "float('123,456.908'.split())"

================================================================================

QUESTION: idx=23     id=3108285
-------------------------------------INPUTS-------------------------------------

tags: linux, unix, environment-variables
score: 127
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: set pythonpath in python script.
body(Some added characters for better readability):
	I know how to set it in my /etc/profile and in my environment variables.
	But what if I want to set it during a script?
	Is it import os, sys? How do I do it?


-------------------------------------OUTPUT-------------------------------------

                Expected= "sys.path.append('/path/to/whatever')"
           base:Baseline= "os.system('os.path.abspath(__file__))"
           base:+Canonic= 'os.path.join(__file__))'
           body:Baseline= "os.path.setdefault('path')"
              body:-Code= "os.set_path('/etc/profile')"
          mined:Baseline= 'os.path.setp(path)'
             mined:+Body= 'os.path.setp(path)'
        mined:+Body, -NL= 'os.path.dirname(__file__)'
      mined:+Body, -Code= "os.path.dirname(os.environ['DEBUSSY'])"

================================================================================

QUESTION: idx=24     id=2195340
-------------------------------------INPUTS-------------------------------------

tags: regex
score: 7
slot_map: {'key': ['str_0', 'str_1', '(str_1)'], 'quote': ["'", "'", "'"], 'type': ['str', 'str', 'str'], 'value': ['Words, words, words.', '(\\W+)', '(\\W+)']}
intent: split string 'words, words, words.' using a regex '(\\w+)'
body(Some added characters for better readability):
	Suppose I have a string "a foobar" and I use "^a\s*" to match "a ".
	Is there a way to easily get "foobar" returned? (What was NOT matched)
	
	<p>I want to use a regex to look for a 
	command word  and also use the regex to remove the command word from the string.
	I know how to do this using something like: 
	
	start_block
	mystring[:regexobj.start()] + email[regexobj.end():]
	But this falls apart if I have multiple matches.
	Thanks!


-------------------------------------OUTPUT-------------------------------------

                Expected= "re.split('(\\\\W+)', 'Words, words, words.')"
           base:Baseline= "re.split('words, words, words.')"
           base:+Canonic= "re.split('Words, words, words.', '(\\\\W+)')"
           body:Baseline= "re.split('words, words, words.')"
              body:-Code= "re.split('Words, words, words.')"
          mined:Baseline= "re.split('\\\\w+)', 'Words, words, words.')"
             mined:+Body= "re.split('(\\\\w+)', '', mystring)"
        mined:+Body, -NL= "re.split('\\\\w+)', 'Words, words, words.')"
      mined:+Body, -Code= "re.sub('\\\\w+(\\\\w+)', '', a)"

================================================================================

QUESTION: idx=25     id=17977584
-------------------------------------INPUTS-------------------------------------

tags: xlrd
score: 4
slot_map: {'key': ['str_0'], 'quote': ['`'], 'type': ['str'], 'value': ['Output.txt']}
intent: open a file `output.txt` in append mode
body(Some added characters for better readability):
	I want to write code to get data from Excel and write it to a text file. Here is the code I have:
	
	start_block
	import xlrd
	import os.path
	wb = xlrd.open_workbook(os.path.join('D:\TRB 2014 Data','SPS1 demo data.xlsx'))
	wb.sheet_names()
	sh = wb.sheet_by_index(0)
	i = 1
	while sh.cell(i,11).value != 0:
	   Load = sh.cell(i,11).value
	   D1 = sh.cell(i,13).value
	   D2 = sh.cell(i,14).value
	   D3 = sh.cell(i,15).value
	   D4 = sh.cell(i,16).value
	   D5 = sh.cell(i,17).value
	   D6 = sh.cell(i,18).value
	   D7 = sh.cell(i,19).value
	   DB1 = str(Load) + "  " + str(D1) + "  " + str(D2) + "  " + str(D3)+ "  " + str(D4)+ "  " + str(D5)+ "  " + str(D6)+ "  " + str(D7)
	   file = open("Output.txt", "w")
	   file.write(DB1 + '\n')
	   file.close
	   i = i + 1
	
	<p>The problem with this code is the data written to the text file is always displayed at the first row. Therefore, although I have 20 rows of data in excel, the text file only shows the last data in the excel file at the very first row in the text file. I have 
	`'\n'`
	 in 
	`file.write` but, it doesn't seem to work.


-------------------------------------OUTPUT-------------------------------------

                Expected= "file = open('Output.txt', 'a')"
           base:Baseline= "open('output.txt', shell=True)"
           base:+Canonic= "open('Output.txt', 'append')"
           body:Baseline= "file = open('Output.txt', append=True)"
              body:-Code= "open('output.txt', 1)"
          mined:Baseline= "f = open('output.txt', 'r')"
             mined:+Body= "file = open('Output.txt', 'wb')"
        mined:+Body, -NL= "file.write(DB1 + '\\n')"
      mined:+Body, -Code= "f.write('output.txt')"

================================================================================

QUESTION: idx=26     id=22676
-------------------------------------INPUTS-------------------------------------

tags: http, urllib
score: 930
slot_map: {'key': ['str_0', 'str_1'], 'quote': ['"', '"'], 'type': ['str', 'str'], 'value': ['http://www.example.com/songs/mp3.mp3', 'mp3.mp3']}
intent: download a file "http://www.example.com/songs/mp3.mp3" over http and save to "mp3.mp3"
body(Some added characters for better readability):
	I have a small utility that I use to download an MP3 file from a website on a schedule and then builds/updates a podcast XML file which I've added to iTunes.
	
	<p>The text processing that creates/updates the XML file is written in Python. However, I use wget inside a Windows 
	`.bat` file to download the actual MP3 file. I would prefer to have the entire utility written in Python.
	
	<p>I struggled to find a way to actually download the file in Python, thus why I resorted to using 
	`wget`.
	So, how do I download the file using Python?


-------------------------------------OUTPUT-------------------------------------

                Expected= "urllib.request.urlretrieve('http://www.example.com/songs/mp3.mp3', 'mp3.mp3')"
           base:Baseline= "urllib.request.urlretrieve('http://www.example.com/songs/mp3.mp3')"
           base:+Canonic= "open('http://www.example.com/songs/mp3.mp3', 'mp3.mp3').save()"
           body:Baseline= "wget.download('http://www.example.com/songs/mp3.mp3', shell=True)"
              body:-Code= "urllib.request.urlretrieve('http://www.example.com/songs/mp3.mp3')"
          mined:Baseline= "urllib.request.urlretrieve('http://www.example.com/songs/mp3.mp3')"
             mined:+Body= "urllib.request.urlretrieve('http://www.example.com/songs/mp3.mp3', files)"
        mined:+Body, -NL= "urllib.request.urlretrieve('http://www.example.com/songs/mp3.mp3', filename)"
      mined:+Body, -Code= "webbrowser.open('http://www.example.com/songs/mp3.mp3')"

================================================================================

QUESTION: idx=28     id=22676
-------------------------------------INPUTS-------------------------------------

tags: http, urllib
score: 930
slot_map: {'key': ['str_0'], 'quote': ["'"], 'type': ['str'], 'value': ['http://www.example.com/']}
intent: download a file 'http://www.example.com/' over http
body(Some added characters for better readability):
	I have a small utility that I use to download an MP3 file from a website on a schedule and then builds/updates a podcast XML file which I've added to iTunes.
	
	<p>The text processing that creates/updates the XML file is written in Python. However, I use wget inside a Windows 
	`.bat` file to download the actual MP3 file. I would prefer to have the entire utility written in Python.
	
	<p>I struggled to find a way to actually download the file in Python, thus why I resorted to using 
	`wget`.
	So, how do I download the file using Python?


-------------------------------------OUTPUT-------------------------------------

                Expected= "response = urllib.request.urlopen('http://www.example.com/')\nhtml = response.read()"
           base:Baseline= "urllib.request.urlretrieve('http://www.example.com/')"
           base:+Canonic= "download('http://www.example.com/', shell=True)"
           body:Baseline= "wget.download('http://www.example.com/', shell=True)"
              body:-Code= "wget.download('http://www.example.com/')"
          mined:Baseline= "urllib.request.urlretrieve('http://www.example.com/')"
             mined:+Body= "urllib.request.urlretrieve('http://www.example.com/', file)"
        mined:+Body, -NL= "print(open('http://www.example.com/').read())"
      mined:+Body, -Code= "webbrowser.open('http://www.example.com/')"

================================================================================

QUESTION: idx=29     id=22676
-------------------------------------INPUTS-------------------------------------

tags: http, urllib
score: 930
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['url']}
intent: download a file `url` over http
body(Some added characters for better readability):
	I have a small utility that I use to download an MP3 file from a website on a schedule and then builds/updates a podcast XML file which I've added to iTunes.
	
	<p>The text processing that creates/updates the XML file is written in Python. However, I use wget inside a Windows 
	`.bat` file to download the actual MP3 file. I would prefer to have the entire utility written in Python.
	
	<p>I struggled to find a way to actually download the file in Python, thus why I resorted to using 
	`wget`.
	So, how do I download the file using Python?


-------------------------------------OUTPUT-------------------------------------

                Expected= 'r = requests.get(url)'
           base:Baseline= 'urllib.download(url)'
           base:+Canonic= 'urllib.request.urlretrieve(url)'
           body:Baseline= "wget.download('url', shell=True)"
              body:-Code= 'urllib.request.urlopen(url)'
          mined:Baseline= 'urllib.request.urlretrieve(url)'
             mined:+Body= "urllib.request.urlretrieve('http://www.google.com', url)"
        mined:+Body, -NL= "urllib.request.urlretrieve('http://stackoverflow.com', 'url', filename)"
      mined:+Body, -Code= "webbrowser.open('url', 'w')"

================================================================================

QUESTION: idx=31     id=15405636
-------------------------------------INPUTS-------------------------------------

tags: version, argparse
score: 44
slot_map: {'key': ['str_0', 'str_1', 'var_0'], 'quote': ["'", "'", '`'], 'type': ['str', 'str', 'var'], 'value': ['--version', '%(prog)s 2.0', 'parser']}
intent: argparse add argument with flag '--version' and version action of '%(prog)s 2.0' to parser `parser`
body(Some added characters for better readability):
	What's the preferred way of specifying program name and version info within argparse?
	
	__version_info__ = ('2013','03','14')
	__version__ = '-'.join(__version_info__)
	<console_out>
	parser.add_argument('-V', '--version', action='version', version="%(prog)s ("+__version__+")")
	http://argparse.googlecode.com/svn/trunk/doc/ArgumentParser.html#prog
	http://pymotw.com/2/argparse/
	http://www.python.org/dev/peps/pep-0386/
	http://www.python.org/dev/peps/pep-0396/
	http://www.python.org/dev/peps/pep-3001/


-------------------------------------OUTPUT-------------------------------------

                Expected= "parser.add_argument('--version', action='version', version='%(prog)s 2.0')"
           base:Baseline= "parser.add_argument('--version', '%(prog)s 2.0')"
           base:+Canonic= "parser.add_argument('--version', '%(prog)s 2.0')"
           body:Baseline= "parser.add_argument('-V', '--version', action='version', version=%(prog)s 2.0')"
              body:-Code= "parser.add_argument('--version', '%(prog)s 2.0')"
          mined:Baseline= "parser.add_argument('--version', '%(prog)s 2.0')"
             mined:+Body= 'parser.add_argument(\'-V\', \'--version\', action=\'version\', version=\n    \'%(prog)s ("+__version__+\')'
        mined:+Body, -NL= "parser.add_argument('-V', '--version', action='version', version='%(prog)s ('+__version__+')"
      mined:+Body, -Code= "parser.add_argument('--version', help='%(prog)s 2.0')"

================================================================================

QUESTION: idx=32     id=17665809
-------------------------------------INPUTS-------------------------------------

tags: methods, dictionary
score: 45
slot_map: {'key': ['str_0', 'var_0'], 'quote': ["'", '`'], 'type': ['str', 'var'], 'value': ['c', 'd']}
intent: remove key 'c' from dictionary `d`
body(Some added characters for better readability):
	I have a dictionary
	
	start_block
	d = {'a':1, 'b':2, 'c':3}
	
	<p>I need to remove a key, say 
	c  and return the dictionary without that key in one function call
	
	start_block
	{'a':1, 'b':2}
	d.pop('c') will return the key value - 3 - instead of the dictionary.
	I am going to need one function solution if it exists, as this will go into comprehensions


-------------------------------------OUTPUT-------------------------------------

                Expected= "{i: d[i] for i in d if i != 'c'}"
           base:Baseline= "d['c'] = d.remove(c)"
           base:+Canonic= "d.remove('c')"
           body:Baseline= "d = {'c': 1, 'b': 2, 'c': 3}"
              body:-Code= 'dict((k, c) for k, c in d.items())'
          mined:Baseline= "d = {k: v for k, v in d.items() if 'c' in k}"
             mined:+Body= 'd = {k: v for k, v in list(d.items())}'
        mined:+Body, -NL= 'd = {k: v for k, v in list(d.items()) if v}'
      mined:+Body, -Code= 'd = {k: v for k, v in list(d.items()) if v}'

================================================================================

QUESTION: idx=33     id=41861705
-------------------------------------INPUTS-------------------------------------

tags: pandas, join, dataframe, merge
score: 3
slot_map: {'key': ['str_0', 'var_0', 'var_1', 'var_2', 'var_3', 'var_4', 'var_5'], 'quote': ['"', '`', '`', '`', '`', '`', '`'], 'type': ['str', 'var', 'var', 'var', 'var', 'var', 'var'], 'value': ['key', 'split_df', 'csv_df', 'split_df', 'csv_df', '_left', '_right']}
intent: create new dataframe object by merging columns "key" of  dataframes `split_df` and `csv_df` and rename the columns from dataframes `split_df` and `csv_df` with suffix `_left` and `_right` respectively
body(Some added characters for better readability):
	
	<p>I've seen this question a few times, but the answers are not working for me.  I have two dataframes, 
	`split_df`
	 and 
	`csv_df`
	 that I;m trying to merge on a column that is called 
	`key` in each of them.  
	
	<p>Here's the top 5 items from `split_df`
	
	start_block
	        key        tags
	2785  30000        ipv6
	2785  30000  networking
	2785  30000    wireless
	2785  30000   standards
	2785  30000      satcom
	
	<p>Here's the top 5 items from the `csv_df`
	
	start_block
	     key
	0  30000
	1  30002
	2  31288
	3  33630
	4  31663
	When I run this merge statement:
	
	start_block
	common_df = pd.merge(split_df,csv_df, on=['key'], suffixes=('_left', '_right'))
	I get:
	
	start_block
	Empty DataFrame
	Columns: [key, tags]
	Index: []
	Process finished with exit code 0
	I can't figure out why the merge isn't working for me.  Any suggestions?
	I have indexes on both (and have run the merge with them out as well)
	
	start_block
	csv_df.set_index('key')
	split_df.set_index('key')
	I am very new to Pyton and Pandas
	Thanks!


-------------------------------------OUTPUT-------------------------------------

                Expected= "pd.merge(split_df, csv_df, on=['key'], suffixes=('_left', '_right'))"
           base:Baseline= "pd.merge(['key'], 'csv_df', '_right'])"
           base:+Canonic= "pd.concat([['str_0','str_1'], var_0, var_1)]"
           body:Baseline= "common_df.set_index('key')"
              body:-Code= "pd.merge(['key', 'csv_df'], axis=1)"
          mined:Baseline= "df.merge(df.split_df, df.set_index('key')['column'])"
             mined:+Body= "df.set_index('key')"
        mined:+Body, -NL= "df.set_index('key')"
      mined:+Body, -Code= "pd.merge(df1, df2, on='key', on='_left', how='inner')"

================================================================================

QUESTION: idx=34     id=10697757
-------------------------------------INPUTS-------------------------------------

tags: regex, string, split
score: 4
slot_map: {'key': ['var_0', 'str_0'], 'quote': ['`', '`'], 'type': ['var', 'str'], 'value': ['s', '4']}
intent: split a string `s` by space with `4` splits
body(Some added characters for better readability):
	I'm quite new to regular expression in python. I have the following string and want to split them into five categories. I just use the split() but it will just split according to white spaces.
	
	start_block
	s = "1 0 A10B 1/00 Description: This is description with spaces"
	sp = s.split()
	>>>sp
	...["1", "0", "A10B", "1/00", "Description:", "This", "is", "description", "with", "spaces"]
	How can I write a regular expression to make it split like this:
	
	start_block
	 ["1", "0", "A10B", "1/00", "Description: This is description with spaces"]
	Can somebody help please? Thanks!


-------------------------------------OUTPUT-------------------------------------

                Expected= "s.split(' ', 4)"
           base:Baseline= "re.split('\\n', s)"
           base:+Canonic= "re.split('4', s)"
           body:Baseline= 'sp = s.split(4)'
              body:-Code= 's.split(4, 4)'
          mined:Baseline= "re.split('\\\\s+', s)"
             mined:+Body= "re.split('\\\\s+', s)"
        mined:+Body, -NL= "re.split('\\\\s+', s)"
      mined:+Body, -Code= "re.split('(?<=.)', s)"

================================================================================

QUESTION: idx=35     id=5404068
-------------------------------------INPUTS-------------------------------------

tags: input, keyboard
score: 127
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: read keyboard-input
body(Some added characters for better readability):
	I would like to read data from the keyboard in python
	I try this:
	
	start_block
	nb = input('Choose a number')
	print ('Number%s \n' % (nb))
	But it doesn't work, neither with eclipse nor in the terminal, it's always stop of the question. I can type a number but after nothing happen.
	Do you know why?


-------------------------------------OUTPUT-------------------------------------

                Expected= "input('Enter your input:')"
           base:Baseline= 'input = input.read().read()'
           base:+Canonic= "sys.input('input', 'input')"
           body:Baseline= "print('Number%s \\n')"
              body:-Code= 'print(input.read(), output.read())'
          mined:Baseline= "input('Press Enter to continue;')"
             mined:+Body= "nb = input('Choose a number')"
        mined:+Body, -NL= "nb = input('Choose a number')"
      mined:+Body, -Code= "sys.stdout.write('%s\\n' % input)"

================================================================================

QUESTION: idx=36     id=16344756
-------------------------------------INPUTS-------------------------------------

tags: apache, web, flask
score: 248
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['app']}
intent: enable debug mode on flask application `app`
body(Some added characters for better readability):
	
	<p>I'm investigating how to develop a decent web app with Python. Since I don't want some high-order structures to get in my way, my choice fell on the lightweight 
	Flask framework . Time will tell if this was the right choice.
	So, now I've set up an Apache server with mod_wsgi, and my test site is running fine. However, I'd like to speed up the development routine by making the site automatically reload upon any changes in py or template files I make. I see that any changes in site's .wsgi file causes reloading (even without WSGIScriptReloading On in the apache config file), but I still have to prod it manually (ie, insert extra linebreak, save). Is there some way how to cause reload when I edit some of the app's py files? Or, I am expected to use IDE that refreshes the .wsgi file for me?


-------------------------------------OUTPUT-------------------------------------

                Expected= 'app.run(debug=True)'
           base:Baseline= 'app.setDebug().set_debug()'
           base:+Canonic= 'var_0.set debug_mode(debug=True)'
           body:Baseline= 'app.config.disable debug mode()'
              body:-Code= 'app.config.disable_debug()'
          mined:Baseline= 'app.run(debug=True)'
             mined:+Body= 'app.run(debug=True)'
        mined:+Body, -NL= 'app.run(debug=True)'
      mined:+Body, -Code= 'app.run(debug=True)'

================================================================================

QUESTION: idx=37     id=40133826
-------------------------------------INPUTS-------------------------------------

tags: 
score: 4
slot_map: {'key': ['var_0', 'str_0'], 'quote': ['`', "'"], 'type': ['var', 'str'], 'value': ['mylist', 'save.txt']}
intent: python save list `mylist` to file object 'save.txt'
body(Some added characters for better readability):
	Basically I would like to save a list to python and then when the program starts I would like to retrieve the data from the file and put it back into the list.
	 
	So far this is the code I am using
	
	start_block
	mylist = pickle.load("save.txt")
	<console_out>
	saveToList = (name, data)
	mylist.append(saveList)
	import pickle
	pickle.dump(mylist, "save.txt")
	But it just returns the following error: TypeError: file must have 'read' and 'readline' attributes


-------------------------------------OUTPUT-------------------------------------

                Expected= "pickle.dump(mylist, open('save.txt', 'wb'))"
           base:Baseline= "mylist = open('save.txt')"
           base:+Canonic= "mylist.save('save.txt')"
           body:Baseline= "pickle.load('save.txt')"
              body:-Code= "mylist = os.save('save.txt')"
          mined:Baseline= "save_file('save.txt')"
             mined:+Body= "pickle.dump(mylist, 'save.txt')"
        mined:+Body, -NL= "pickle.dump(mylist, 'save.txt')"
      mined:+Body, -Code= "f.write('save.txt')"

================================================================================

QUESTION: idx=38     id=4490961
-------------------------------------INPUTS-------------------------------------

tags: matrix, numpy, scipy, linear-algebra
score: 13
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['P', 'T']}
intent: multiply a matrix `p` with a 3d tensor `t` in scipy
body(Some added characters for better readability):
	
	<p>I have a matrix 
	`P`
	 with shape 
	`MxN`
	 and a 3d tensor 
	`T`
	 with shape 
	`KxNxR`
	. I want to multiply 
	`P`
	 with every 
	`NxR`
	 matrix in 
	`T`
	, resulting in a 
	`KxMxR` 3d tensor.
	
	`P.dot(T).transpose(1,0,2)`
	 gives the desired result. Is there a 
	nicer 
	 solution (i.e. getting rid of 
	`transpose`
	) to this problem? This must be quite a common operation, so I assume, others have found different approaches, e.g. using 
	`tensordot` (which I tried but failed to get the desired result). Opinions/Views would be highly appreciated!


-------------------------------------OUTPUT-------------------------------------

                Expected= 'scipy.tensordot(P, T, axes=[1, 1]).swapaxes(0, 1)'
           base:Baseline= 'np.sqrt((p, t))'
           base:+Canonic= 'np.multiply(P, T)'
           body:Baseline= 'P.dot(T).transpose(1, 0, 2)'
              body:-Code= 'scipy.multiply(p, t)'
          mined:Baseline= 'scipy.multiply(p, t, 3, tensor=t)'
             mined:+Body= 'P.dot(T).transpose(1, 0, 2)'
        mined:+Body, -NL= 'T.transpose(1, 0, 2)'
      mined:+Body, -Code= "np.einsum('ijk,ikl->ikl', p)"

================================================================================

QUESTION: idx=39     id=2173087
-------------------------------------INPUTS-------------------------------------

tags: list, arrays, matrix, nested-lists
score: 5
slot_map: {'key': ['str_0', '(str_0)'], 'quote': ['`', '`'], 'type': ['str', 'str'], 'value': ['(3,3,3)', '(3,3,3)']}
intent: create 3d array of zeroes of size `(3,3,3)`
body(Some added characters for better readability):
	I know you can create easily nested lists in python like this:
	
	start_block
	[[1,2],[3,4]]
	But how to create a 3x3x3 matrix of zeroes?
	
	start_block
	[[[0] * 3 for i in range(0, 3)] for j in range (0,3)]
	or 
	
	start_block
	[[[0]*3]*3]*3
	Doesn't seem right. There is no way to create it just passing a list of dimensions to a method? Ex:
	
	start_block
	CreateArray([3,3,3])


-------------------------------------OUTPUT-------------------------------------

                Expected= 'numpy.zeros((3, 3, 3))'
           base:Baseline= 'zeroes = [(3, 3, 3))'
           base:+Canonic= 'zeroes = np.array([(3,3,3)])'
           body:Baseline= '[np.arange(3, 3, 3))'
              body:-Code= 'list(zip(*(3), 3, 3))'
          mined:Baseline= 'np.zeroes(3, 3, 3)'
             mined:+Body= '[[[0] * 3 for i in range(0, 3)] for j in range (3, 3)]]'
        mined:+Body, -NL= 'np.array([[0] * 3) for j in range(0, 3)]'
      mined:+Body, -Code= 'np.zeros((3, 3, 3))'

================================================================================

QUESTION: idx=40     id=6266727
-------------------------------------INPUTS-------------------------------------

tags: split, concatenation, word, text-segmentation
score: 53
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['content']}
intent: cut off the last word of a sentence `content`
body(Some added characters for better readability):
	What's the best way to slice the last word from a block of text? 
	I can think of 
	Split it to a list (by spaces) and removing the last item, then reconcatenating the list.
	Use a regular expression to replace the last word.
	I'm currently taking approach #1, but I don't know how to concatenate the list...
	
	start_block
	content = content[position-1:position+249] # Content
	words = string.split(content, ' ')
	words = words[len[words] -1] # Cut of the last word
	Any code examples are much appreciated.


-------------------------------------OUTPUT-------------------------------------

                Expected= '""" """.join(content.split(\' \')[:-1])'
           base:Baseline= "content = re.sub('(?=?=)', '', content)"
           base:+Canonic= 'content.rstrip()[-1]'
           body:Baseline= 'content = content[:-1]'
              body:-Code= "re.sub('[^a-zA-Z]', content)"
          mined:Baseline= 'content.split()[:-1]'
             mined:+Body= 'content = content[position - 1:position + 249]'
        mined:+Body, -NL= 'content = content[position - 1:position + 249]'
      mined:+Body, -Code= "re.sub('\\\\s+', '', content)"

================================================================================

QUESTION: idx=41     id=30385151
-------------------------------------INPUTS-------------------------------------

tags: numpy
score: 10
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['x']}
intent: convert scalar `x` to array
body(Some added characters for better readability):
	I am evaluating arbitrary expressions in terms of an x array, such as 3*x**2 + 4. This normally results in an array with x's shape. However if the expression is just a constant, it returns a scalar. What is the best way to ensure it has x's shape without explicitly checking the shape? Multiplying by numpy.ones(x.shape) works, but I think that uses unnecessary computations. 
	Edit:
	To be clear, I don't just want it to be an array with size one, I want it to be the same shape and size as X. 
	I'm evaluating a string using NumExpr which can contain an arbitrary function of x:
	
	start_block
	x = numpy.linspace(min, max, num)
	y = numexpr.evaluate(expr, {'x': x}, {})
	I want to get an array of y-values that could be plotted against x through matplotlib. Currently I am doing this, which works fine:
	
	start_block
	y = numpy.ones(x.size) * y
	But I'm worried that this is wasteful for large sizes. Is there a better way?


-------------------------------------OUTPUT-------------------------------------

                Expected= 'x = np.asarray(x).reshape(1, -1)[(0), :]'
           base:Baseline= 'x = np.array(x)'
           base:+Canonic= 'np.array([x])'
           body:Baseline= 'np.linspace(x.shape)'
              body:-Code= 'np.linspace(x.shape)'
          mined:Baseline= 'np.array(x).reshape(-1, -1)'
             mined:+Body= 'numpy.linspace(min, max, num) * np.ones(x.shape)'
        mined:+Body, -NL= 'numpy.linspace(min, max, num)'
      mined:+Body, -Code= "np.einsum('ij,kj->jik', x)"

================================================================================

QUESTION: idx=42     id=15856127
-------------------------------------INPUTS-------------------------------------

tags: 
score: 4
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['L']}
intent: sum all elements of nested list `l`
body(Some added characters for better readability):
	
	start_block
	import math
	lists =  [1,[2,3],4]
	total = 0
	for i in range(len(lists)):
	    total += sum(i)
	print(total)
	I want it to print,
	
	start_block
	<console_in>10
	...
	But throws a error.
	I would like it to get it to add all numbers, including the ones within the nested if.


-------------------------------------OUTPUT-------------------------------------

                Expected= 'sum(sum(i) if isinstance(i, list) else i for i in L)'
           base:Baseline= 'sum(l, key=lambda x: x[1])'
           base:+Canonic= 'sum(len(L))'
           body:Baseline= 'sum(len(l) for i in L)'
              body:-Code= "print('all(x) for x in L')"
          mined:Baseline= 'sum(l for l in L)'
             mined:+Body= 'total = sum(list(range(len(lists)))'
        mined:+Body, -NL= 'sum(list(itertools.chain.from_iterable(l)))'
      mined:+Body, -Code= 'print([x for x in l if x not in nested if])'

================================================================================

QUESTION: idx=43     id=1592158
-------------------------------------INPUTS-------------------------------------

tags: binary, floating-point, hex, decimal
score: 40
slot_map: {'key': ['str_0'], 'quote': ["'"], 'type': ['str'], 'value': ['470FC614']}
intent: convert hex string '470fc614' to a float number
body(Some added characters for better readability):
	How to convert the following hex string to float (single precision 32-bit) in Python?
	
	start_block
	"41973333" -> 1.88999996185302734375E1
	"41995C29" -> 1.91700000762939453125E1
	"470FC614" -> 3.6806078125E4


-------------------------------------OUTPUT-------------------------------------

                Expected= "struct.unpack('!f', '470FC614'.decode('hex'))[0]"
           base:Baseline= "int('470fc614', 16)"
           base:+Canonic= "float('470FC614', 16)"
           body:Baseline= "float('470FC614', 16)"
              body:-Code= "float('470fc614', 16)"
          mined:Baseline= "struct.unpack('<I', '470fc614', s)"
             mined:+Body= "int('470FC614', 16)"
        mined:+Body, -NL= "int('470FC614', 16)"
      mined:+Body, -Code= "struct.unpack('470fc614', 16)"

================================================================================

QUESTION: idx=44     id=5010536
-------------------------------------INPUTS-------------------------------------

tags: dictionary
score: 31
slot_map: {'key': ['str_0', 'var_0'], 'quote': ['`', '`'], 'type': ['str', 'var'], 'value': ['2', 'my_dict']}
intent: multiple each value by `2` for all keys in a dictionary `my_dict`
body(Some added characters for better readability):
	In python 2.6 I want to perform an operation on each dictionary value, for example, I want to multiply by 2 for each of them. How to code less for this task? 


-------------------------------------OUTPUT-------------------------------------

                Expected= 'my_dict.update((x, y * 2) for x, y in list(my_dict.items()))'
           base:Baseline= '[(x * y for x, y in list(my_dict.items())) for y in range(2)]'
           base:+Canonic= 'dict((k, v) for k, v in my_dict.values())'
           body:Baseline= 'max(my_dict, key=lambda x: x[2])'
              body:-Code= 'max(k, v) for k, v in my_dict.items()'
          mined:Baseline= 'list(dict((k, v) for k, v in list(my_dict.items()))'
             mined:+Body= 'my_dict.values.multiply(2, 2)'
        mined:+Body, -NL= 'list(my_dict.values())'
      mined:+Body, -Code= 'for (k, v) in list(my_dict.values())):\n    pass'

================================================================================

QUESTION: idx=45     id=13745648
-------------------------------------INPUTS-------------------------------------

tags: bash, call
score: 120
slot_map: {'key': ['str_0'], 'quote': ["'"], 'type': ['str'], 'value': ['sleep.sh']}
intent: running bash script 'sleep.sh'
body(Some added characters for better readability):
	I have a problem with the following code:
	callBash.py:
	
	start_block
	import subprocess
	print "start"
	subprocess.call("sleep.sh")
	print "end"
	sleep.sh:
	
	start_block
	sleep 10
	I want the "end" to be printed after 10s. (I know that this is a dumb example, I could simply sleep within python, but this simple sleep.sh file was just as a test)


-------------------------------------OUTPUT-------------------------------------

                Expected= "subprocess.call('sleep.sh', shell=True)"
           base:Baseline= "os.system('sleep.sh')"
           base:+Canonic= "subprocess.call('sleep.sh', shell=True)"
           body:Baseline= "subprocess.call('sleep.sh')"
              body:-Code= "os.system('sleep.sh')"
          mined:Baseline= "os.system('sleep.sh')"
             mined:+Body= "subprocess.call('sleep.sh', shell=True)"
        mined:+Body, -NL= "subprocess.call('sleep.sh', shell=True)"
      mined:+Body, -Code= "os.system('sleep.sh')"

================================================================================

QUESTION: idx=46     id=44778
-------------------------------------INPUTS-------------------------------------

tags: string, list
score: 593
slot_map: {'key': ['var_0', 'str_0'], 'quote': ['`', '`'], 'type': ['var', 'str'], 'value': ['l', ',']}
intent: join elements of list `l` with a comma `,`
body(Some added characters for better readability):
	
	<p>What would be your preferred way to concatenate strings from a sequence such that between every two consecutive pairs a comma is added. That is, how do you map, for instance, 
	`['a', 'b', 'c']`
	 to 
	`'a,b,c'`
	? (The cases 
	`['s']`
	 and 
	`[]`
	 should be mapped to 
	`'s'`
	 and 
	`''`, respectively.)
	
	<p>I usually end up using something like 
	`''.join(map(lambda x: x+',',l))[:-1]`, but also feeling somewhat unsatisfied.


-------------------------------------OUTPUT-------------------------------------

                Expected= '""",""".join(l)'
           base:Baseline= '[x for x in L if x.isdigit()]'
           base:+Canonic= "join(l, ',')"
           body:Baseline= "'.join(map(lambda x: x +',',l))[:-1]"
              body:-Code= "[(x, y) for x, y in L.split(',))]"
          mined:Baseline= '[(x + y) for x, y in l]'
             mined:+Body= '""", """.join(map(lambda x: x + \',\', L))[:-1]'
        mined:+Body, -NL= '"""""".join(map(lambda x: x + \',\', l))[:-1]'
      mined:+Body, -Code= '[(x + y) for x, y in zip(L, L)]'

================================================================================

QUESTION: idx=47     id=44778
-------------------------------------INPUTS-------------------------------------

tags: string, list
score: 593
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['myList']}
intent: make a comma-separated string from a list `mylist`
body(Some added characters for better readability):
	
	<p>What would be your preferred way to concatenate strings from a sequence such that between every two consecutive pairs a comma is added. That is, how do you map, for instance, 
	`['a', 'b', 'c']`
	 to 
	`'a,b,c'`
	? (The cases 
	`['s']`
	 and 
	`[]`
	 should be mapped to 
	`'s'`
	 and 
	`''`, respectively.)
	
	<p>I usually end up using something like 
	`''.join(map(lambda x: x+',',l))[:-1]`, but also feeling somewhat unsatisfied.


-------------------------------------OUTPUT-------------------------------------

                Expected= "myList = ','.join(map(str, myList))"
           base:Baseline= '"""""".join(myList[::(-1)]'
           base:+Canonic= '"""""".join(myList.split())'
           body:Baseline= '"""""".join(map(lambda x: x + \',\', l))[:-1]'
              body:-Code= '"""""".join(c for c in mylist if c.split())'
          mined:Baseline= '""" """.join(map(str, myList))'
             mined:+Body= '"""""".join(map(lambda x: x + \',\', L))[:-1]'
        mined:+Body, -NL= '"""""".join(map(lambda x: x + \',\', l))[:-1]'
      mined:+Body, -Code= '"""""".join(map(str, myList))'

================================================================================

QUESTION: idx=48     id=7286365
-------------------------------------INPUTS-------------------------------------

tags: list, range, reverse
score: 398
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: reverse the list that contains 1 to 10
body(Some added characters for better readability):
	
	<p>How can you produce the following list with 
	`range()` in Python?
	
	start_block
	[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]


-------------------------------------OUTPUT-------------------------------------

                Expected= 'list(reversed(list(range(10))))'
           base:Baseline= '[x[0] for x in range(10)]'
           base:+Canonic= '[i for i in range(10)]'
           body:Baseline= '[i for i in range(10)]'
              body:-Code= '[i for i in range(10)]'
          mined:Baseline= '[(i, j) for i, j in zip(a, b)]'
             mined:+Body= '[x for x in range(10)]'
        mined:+Body, -NL= '[x for x in range(10)]'
      mined:+Body, -Code= '[l[::-1] for l in range(10)]'

================================================================================

QUESTION: idx=49     id=18454570
-------------------------------------INPUTS-------------------------------------

tags: string, addition, subtraction
score: 24
slot_map: {'key': ['str_0', 'str_1'], 'quote': ["'", "'"], 'type': ['str', 'str'], 'value': ['bag,', 'lamp, bag, mirror']}
intent: remove substring 'bag,' from a string 'lamp, bag, mirror'
body(Some added characters for better readability):
	
	<p>I have a long string, which is basically a list like 
	`str="lamp, bag, mirror,"` (and other items)
	
	<p>I was wondering if I can add or subtract some items, in other programming languages I can easily do: 
	`str=str-"bag,"`
	 and get 
	`str="lamp, mirror,"` this doesnt work in python (I'm using 2.7 on a W8 pc)
	Is there a way to split the string across say "bag," and somehow use that as a subtraction? Then I still need to figure out how to add.


-------------------------------------OUTPUT-------------------------------------

                Expected= "print('lamp, bag, mirror'.replace('bag,', ''))"
           base:Baseline= '"""""".join(lamp, bag, mirror))'
           base:+Canonic= '"""""".join(\'lamp, bag, mirror\', \'bag,\')'
           body:Baseline= "'bag', str.replace('lamp, bag, mirror')"
              body:-Code= '"""Lamp, bag, mirror""".replace(\'bag\', \'bag\')'
          mined:Baseline= '"""lamp, bag, mirror""".replace(\'bag\', \'\')'
             mined:+Body= "re.sub('\\\\bbag\\\\b', '', 'lamp, bag, mirror', s)"
        mined:+Body, -NL= '"""lamp, bag, mirror.""".replace(\'bag\', \'\')'
      mined:+Body, -Code= '"""Lamp, bag, mirror""".split(\',\')'

================================================================================

QUESTION: idx=50     id=4357787
-------------------------------------INPUTS-------------------------------------

tags: 
score: 4
slot_map: {'key': ['str_0', 'var_0'], 'quote': ['`', '`'], 'type': ['str', 'var'], 'value': ['.', 's']}
intent: reverse the order of words, delimited by `.`, in string `s`
body(Some added characters for better readability):
	I have the following string:
	
	start_block
	apple.orange.red.green.yellow
	How can i reverse it to get the following:
	
	start_block
	yellow.green.red.orange.apple


-------------------------------------OUTPUT-------------------------------------

                Expected= '""".""".join(s.split(\'.\')[::-1])'
           base:Baseline= 'reversed(s, key=lambda x: x[1])'
           base:+Canonic= "re.split('.', s)"
           body:Baseline= "re.split('.', s)"
              body:-Code= "re.split('\\\\.', s)"
          mined:Baseline= 'sorted(reversed(s), key=itemgetter(1))'
             mined:+Body= "s = s.split(',')"
        mined:+Body, -NL= "re.split('\\\\.', s)"
      mined:+Body, -Code= '"""""".join(reversed([item for item in s.split()])'

================================================================================

QUESTION: idx=51     id=21787496
-------------------------------------INPUTS-------------------------------------

tags: ruby, datetime, epoch
score: 79
slot_map: {'key': ['var_0', 'str_0'], 'quote': ['`', "'"], 'type': ['var', 'str'], 'value': ['s', '%Y-%m-%d %H:%M:%S.%f']}
intent: convert epoch time represented as milliseconds `s` to string using format '%y-%m-%d %h:%m:%s.%f'
body(Some added characters for better readability):
	I have used a ruby script to convert iso time stamp to epoch, the files that I am parsing has following time stamp structure: 
	
	start_block
	2009-03-08T00:27:31.807
	Since I want to keep milliseconds I used following ruby code to convert it to epoch time: 
	
	start_block
	irb(main):010:0> DateTime.parse('2009-03-08T00:27:31.807').strftime("%Q")
	=> "1236472051807"
	But In python I tried following: 
	
	start_block
	import time 
	time.strftime('%Y-%m-%d %H:%M:%S', time.gmtime(1236472051807))
	But I don't get the original time date time back, 
	
	
	start_block
	>>>time.strftime('%Y-%m-%d %H:%M:%S', time.gmtime(1236472051807))
	...'41152-03-29 02:50:07'
	>>>
	...
	I wonder is it related to how I am formatting? 


-------------------------------------OUTPUT-------------------------------------

                Expected= "datetime.datetime.fromtimestamp(s).strftime('%Y-%m-%d %H:%M:%S.%f')"
           base:Baseline= "s.strftime('%Y-%m-%d %H:%M:%S.%f')"
           base:+Canonic= "time.strptime('%Y-%m-%d %H:%M:%S.%f', s)"
           body:Baseline= "time.strftime('%Y-%m-%d %H:%M:%S.%f')"
              body:-Code= "time.strftime('%Y-%m-%d %H:%M:%S.%f')"
          mined:Baseline= '"""{0:.2g}""".format(\'%Y-%m-%d %H:%M:%S.%f\')'
             mined:+Body= "time.strftime('%Y-%m-%d %H:%M:%S.%f')"
        mined:+Body, -NL= "time.strftime('%Y-%m-%d %H:%M:%S', time.gmtime(1236472051807))"
      mined:+Body, -Code= "time.strftime('%Y-%m-%d %H:%M:%S.%f')"

================================================================================

QUESTION: idx=52     id=21787496
-------------------------------------INPUTS-------------------------------------

tags: ruby, datetime, epoch
score: 79
slot_map: {'key': ['str_0', 'str_1'], 'quote': ["'", "'"], 'type': ['str', 'str'], 'value': ['1236472051807', '%Y-%m-%d %H:%M:%S']}
intent: parse milliseconds epoch time '1236472051807' to format '%y-%m-%d %h:%m:%s'
body(Some added characters for better readability):
	I have used a ruby script to convert iso time stamp to epoch, the files that I am parsing has following time stamp structure: 
	
	start_block
	2009-03-08T00:27:31.807
	Since I want to keep milliseconds I used following ruby code to convert it to epoch time: 
	
	start_block
	irb(main):010:0> DateTime.parse('2009-03-08T00:27:31.807').strftime("%Q")
	=> "1236472051807"
	But In python I tried following: 
	
	start_block
	import time 
	time.strftime('%Y-%m-%d %H:%M:%S', time.gmtime(1236472051807))
	But I don't get the original time date time back, 
	
	
	start_block
	>>>time.strftime('%Y-%m-%d %H:%M:%S', time.gmtime(1236472051807))
	...'41152-03-29 02:50:07'
	>>>
	...
	I wonder is it related to how I am formatting? 


-------------------------------------OUTPUT-------------------------------------

                Expected= "time.strftime('%Y-%m-%d %H:%M:%S', time.gmtime(1236472051807 / 1000.0))"
           base:Baseline= "datetime.strptime('1236472051807', '%Y-%m-%d %H:%M:%S')"
           base:+Canonic= "time.strptime('1236472051807', '%Y-%m-%d %H:%M:%S')"
           body:Baseline= "time.strftime('1236472051807', '%Y-%m-%d %H:%M:%S')"
              body:-Code= "time.strftime('1236472051807', '%Y-%m-%d %H:%M:%S')"
          mined:Baseline= "time.strptime('1236472051807', '%Y-%m-%d %H:%M:%S')"
             mined:+Body= "time.strftime('%Y-%m-%d %H:%M:%S')"
        mined:+Body, -NL= "time.strftime('%Y-%m-%d %H:%M:%S')"
      mined:+Body, -Code= "time.strptime('1236472051807', '%Y-%m-%d %H:%M:%S')"

================================================================================

QUESTION: idx=53     id=20573459
-------------------------------------INPUTS-------------------------------------

tags: datetime
score: 49
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: get the date 7 days before the current date
body(Some added characters for better readability):
	I'm trying to get the date that was 7 days ago starting from current date in python. Can anyone help me?


-------------------------------------OUTPUT-------------------------------------

                Expected= '(datetime.datetime.now() - datetime.timedelta(days=7)).date()'
           base:Baseline= 'datetime.now().date() + datetime.timedelta(days=7)'
           base:+Canonic= 'datetime.now().date() + datetime.timedelta(days=7)'
           body:Baseline= 'calendar.monthrange(7, 7)'
              body:-Code= 'today = datetime.datetime.now().date()'
          mined:Baseline= 'datetime.now() - datetime.timedelta(7)'
             mined:+Body= 'datetime.now() - datetime.timedelta(days=7, weeks=1)'
        mined:+Body, -NL= 'datetime.now() - datetime.timedelta(days=7, hours=7)'
      mined:+Body, -Code= 'today = datetime.datetime.now().date()'

================================================================================

QUESTION: idx=54     id=15352457
-------------------------------------INPUTS-------------------------------------

tags: for-loop
score: 15
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['column', 'data']}
intent: sum elements at index `column` of each list in list `data`
body(Some added characters for better readability):
	I have a Python array, like so:
	
	start_block
	[[1,2,3],
	 [1,2,3]]
	
	<p>I can add the row by doing 
	`sum(array[i])`, how can I sum a column, using a double for loop?
	I.E. for the first column, I could get 2, then 4, then 6.


-------------------------------------OUTPUT-------------------------------------

                Expected= 'print(sum(row[column] for row in data))'
           base:Baseline= '[sum(column) for row in data]'
           base:+Canonic= 'sum([i for i, j in zip(var_0, var_1)]'
           body:Baseline= 'sum(len(column) for row in data)'
              body:-Code= 'np.sum(iter(data), axis=1)'
          mined:Baseline= 'sum(item[0] for item in data)'
             mined:+Body= 'sum(item[0] for item in data)'
        mined:+Body, -NL= 'sum(item[0] for item in data)'
      mined:+Body, -Code= 'sum(item[0] for item in data)'

================================================================================

QUESTION: idx=55     id=15352457
-------------------------------------INPUTS-------------------------------------

tags: for-loop
score: 15
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['array']}
intent: sum columns of a list `array`
body(Some added characters for better readability):
	I have a Python array, like so:
	
	start_block
	[[1,2,3],
	 [1,2,3]]
	
	<p>I can add the row by doing 
	`sum(array[i])`, how can I sum a column, using a double for loop?
	I.E. for the first column, I could get 2, then 4, then 6.


-------------------------------------OUTPUT-------------------------------------

                Expected= '[sum(row[i] for row in array) for i in range(len(array[0]))]'
           base:Baseline= 'sum(x, y) for x, y in array'
           base:+Canonic= 'sum([i for i in zip(var_0, var_0)]'
           body:Baseline= 'sum(array[i] + 1'
              body:-Code= 'np.sum(np.arange(array))'
          mined:Baseline= 'sum(axis=1 for x in a)'
             mined:+Body= 'sum([1, 2, 3])'
        mined:+Body, -NL= 'sum(x[1] for x in array)'
      mined:+Body, -Code= 'sum(axis=1, axis=1)'

================================================================================

QUESTION: idx=56     id=23164058
-------------------------------------INPUTS-------------------------------------

tags: encoding, base64
score: 50
slot_map: {'key': ['str_0'], 'quote': ["'"], 'type': ['str'], 'value': ['your string']}
intent: encode binary string 'your string' to base64 code
body(Some added characters for better readability):
	I am trying to encode a text string to base64.
	i tried doing this :
	
	start_block
	name = "your name"
	print('encoding %s in base64 yields = %s\n'%(name,name.encode('base64','strict')))
	But this gives me the following error:
	
	start_block
	LookupError: 'base64' is not a text encoding; use codecs.encode() to handle arbitrary codecs
	How do I go about doing this ? ( using Python 3.4)


-------------------------------------OUTPUT-------------------------------------

                Expected= "base64.b64encode(bytes('your string', 'utf-8'))"
           base:Baseline= "struct.unpack('your string', 16)"
           base:+Canonic= "bin('your string', 16)"
           body:Baseline= "codecs.encode('base64', 'your string')"
              body:-Code= "struct.encode('your string')"
          mined:Baseline= "binascii.encode('base64')"
             mined:+Body= "print('encoding %s in base64 yields = %s\\n' % (name, name.encode('base64',\n    'strict')))"
        mined:+Body, -NL= "print('encoding %s in base64 yields = %s\\n'.encode('base64', 'strict'))"
      mined:+Body, -Code= "base64.b64encode('your string')"

================================================================================

QUESTION: idx=57     id=11533274
-------------------------------------INPUTS-------------------------------------

tags: dictionary
score: 8
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['dicts']}
intent: combine list of dictionaries `dicts` with the same keys in each list to a single dictionary
body(Some added characters for better readability):
	I have a list of dictionaries like so:
	
	start_block
	dicts = [
	    {'key_a': valuex1,
	     'key_b': valuex2,
	     'key_c': valuex3},
	    {'key_a': valuey1,
	     'key_b': valuey2,
	     'key_c': valuey3},
	    {'key_a': valuez1,
	     'key_b': valuez2,
	     'key_c': valuez3}
	]
	I would like to take these and construct a big dictionary like so:
	
	start_block
	big_dict = {
	    'key_a': [valuex1, valuey1, valuez1],
	    'key_b': [valuex2, valuey2, valuez2],
	    'key_c': [valuex3, valuey3, valuez3]
	}
	
	<p>Is there any elegant " 
	zip "-like way for me to do this? 
	All the keys are always going to be identical.


-------------------------------------OUTPUT-------------------------------------

                Expected= 'dict((k, [d[k] for d in dicts]) for k in dicts[0])'
           base:Baseline= 'dict((k, v) for k, v in list(dicts.items()))'
           base:+Canonic= 'dict((k, v) for k, v in dicts.items())'
           body:Baseline= 'dict((k, v) for k, v in list(dicts.items()))'
              body:-Code= 'dict((k, v) for k, v in list(dicts.items()))'
          mined:Baseline= 'dict((k, v) for d in dicts for k, v in list(dicts.items()))'
             mined:+Body= 'dict((k, v) for k, v in dicts.items() if v}'
        mined:+Body, -NL= '{k: v for d in dicts for k, v in list(d.items())}'
      mined:+Body, -Code= '{k: bigdict(v) for k, v in list(dicts.items())}'

================================================================================

QUESTION: idx=58     id=11533274
-------------------------------------INPUTS-------------------------------------

tags: dictionary
score: 8
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['dicts', 'k']}
intent: merge a nested dictionary `dicts` into a flat dictionary by concatenating nested values with the same key `k`
body(Some added characters for better readability):
	I have a list of dictionaries like so:
	
	start_block
	dicts = [
	    {'key_a': valuex1,
	     'key_b': valuex2,
	     'key_c': valuex3},
	    {'key_a': valuey1,
	     'key_b': valuey2,
	     'key_c': valuey3},
	    {'key_a': valuez1,
	     'key_b': valuez2,
	     'key_c': valuez3}
	]
	I would like to take these and construct a big dictionary like so:
	
	start_block
	big_dict = {
	    'key_a': [valuex1, valuey1, valuez1],
	    'key_b': [valuex2, valuey2, valuez2],
	    'key_c': [valuex3, valuey3, valuez3]
	}
	
	<p>Is there any elegant " 
	zip "-like way for me to do this? 
	All the keys are always going to be identical.


-------------------------------------OUTPUT-------------------------------------

                Expected= '{k: [d[k] for d in dicts] for k in dicts[0]}'
           base:Baseline= 'dict((k, v) for k, v in dicts.values())'
           base:+Canonic= 'dict((k, v) for k, v in dicts.items())'
           body:Baseline= 'dict((k, v) for k, v in list(dicts.items()))'
              body:-Code= 'dict((k, v) for k, v in list(dicts.items()))'
          mined:Baseline= 'dict((k, v) for k, v in list(dicts.items()))'
             mined:+Body= 'dict((k, v) for k, v in list(dicts.items()))'
        mined:+Body, -NL= '{k: v for k, v in list(big_dict.items()) if v}'
      mined:+Body, -Code= '{k: bigdict(v) for k, v in list(dicts.items())}'

================================================================================

QUESTION: idx=59     id=14026704
-------------------------------------INPUTS-------------------------------------

tags: html, flask
score: 21
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: how do i get the url parameter in a flask view
body(Some added characters for better readability):
	I am trying to get the url parameters from a flask view:
	
	start_block
	www.domain.com/?f=x**2
	
	<p>How do I get 
	`x**2`
	 from the 
	`url` in a Flask view?


-------------------------------------OUTPUT-------------------------------------

                Expected= "request.args['myParam']"
           base:Baseline= 'urllib.request.url()'
           base:+Canonic= "urllib.request.urlretrieve('str_id')"
           body:Baseline= "url = Flask.get('/', 1)[0]"
              body:-Code= "url = Flask.get('r', 1)"
          mined:Baseline= "request.GET.get('url')"
             mined:+Body= 'app.run(debug=True)'
        mined:+Body, -NL= 'app.run(debug=True)'
      mined:+Body, -Code= 'app.run(debug=True)'

================================================================================

QUESTION: idx=60     id=11236006
-------------------------------------INPUTS-------------------------------------

tags: arrays, list
score: 42
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['mylist']}
intent: identify duplicate values in list `mylist`
body(Some added characters for better readability):
	Is it possible to get which values are duplicates in a list using python?
	I have a list of items:
	
	start_block
	    mylist = [20, 30, 25, 20]
	
	<p>I know the best way of removing the duplicates is 
	`set(mylist)`
	, but is it possible to know what values are being duplicated? As you can see, in this list the duplicates are the first and last values. 
	`[0, 3]`.
	
	<p>Is it possible to get this result or something similar in python? I'm trying to avoid making a ridiculously big 
	`if elif` conditional statement.


-------------------------------------OUTPUT-------------------------------------

                Expected= '[k for k, v in list(Counter(mylist).items()) if v > 1]'
           base:Baseline= 'myList.groupby(key=lambda x: x[1])'
           base:+Canonic= 'communicate(set(mylist))'
           body:Baseline= '[x for x in set(mylist)]'
              body:-Code= '[x for x in mylist]'
          mined:Baseline= '[(x, y) for x, y in zip(myList, myList[1:])]'
             mined:+Body= 'print(list(set(mylist))'
        mined:+Body, -NL= 'set([x for x in mylist if x == 3])'
      mined:+Body, -Code= 'print(list(set(myList))'

================================================================================

QUESTION: idx=61     id=2354166
-------------------------------------INPUTS-------------------------------------

tags: google-app-engine, sys.path
score: 10
slot_map: {'key': ['str_0', 'var_0'], 'quote': ["'", '`'], 'type': ['str', 'var'], 'value': ['apps', '__file__']}
intent: insert directory 'apps' into directory `__file__`
body(Some added characters for better readability):
	I've tried adding the following line to my handler script (main.py), but it doesn't seem to work:
	sys.path.append('subdir')
	
	`subdir`
	 lives in the my root directory (i.e. the one containing 
	`app.yaml`).
	
	<p>This doesn't seem to work, because when I try to import modules that live in 
	`subdir`, my app explodes.


-------------------------------------OUTPUT-------------------------------------

                Expected= "sys.path.insert(1, os.path.join(os.path.dirname(__file__), 'apps'))"
           base:Baseline= 'os.path.insert(__file__)'
           base:+Canonic= "__file__ = __file__.insert('apps')"
           body:Baseline= 'sys.path.insert(__file__)'
              body:-Code= "os.path.append('subdir')"
          mined:Baseline= "__file__.append('apps')"
             mined:+Body= "sys.path.insert(0, 'apps')"
        mined:+Body, -NL= 'os.chdir(os.path.dirname(__file__))'
      mined:+Body, -Code= "__file__.append('apps')"

================================================================================

QUESTION: idx=62     id=2354166
-------------------------------------INPUTS-------------------------------------

tags: google-app-engine, sys.path
score: 10
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['subdir']}
intent: modify sys.path for python module `subdir`
body(Some added characters for better readability):
	I've tried adding the following line to my handler script (main.py), but it doesn't seem to work:
	sys.path.append('subdir')
	
	`subdir`
	 lives in the my root directory (i.e. the one containing 
	`app.yaml`).
	
	<p>This doesn't seem to work, because when I try to import modules that live in 
	`subdir`, my app explodes.


-------------------------------------OUTPUT-------------------------------------

                Expected= "sys.path.append(os.path.join(os.path.dirname(__file__), 'subdir'))"
           base:Baseline= 'sys.path.update(subdir)'
           base:+Canonic= 'sys.path.join(subdir)'
           body:Baseline= "sys.path.append('subdir')"
              body:-Code= "sys.path.append('subdir')"
          mined:Baseline= 'sys.path = sys.path(subdir)'
             mined:+Body= "sys.path.append('subdir')"
        mined:+Body, -NL= 'sys.path.append(subdir)'
      mined:+Body, -Code= "sys.path.append('subdir')"

================================================================================

QUESTION: idx=63     id=20211942
-------------------------------------INPUTS-------------------------------------

tags: sqlite, sql-insert
score: 18
slot_map: {'key': ['str_0'], 'quote': ["'"], 'type': ['str'], 'value': ['None']}
intent: insert a 'none' value into a sqlite3 table.
body(Some added characters for better readability):
	
	<p>I am trying to insert a 
	`None`
	 value into a row entry of my db. The table 
	`present` exists
	
	start_block
	db.execute("INSERT INTO present VALUES('test', ?, 9)", "This is a test!")
	db.execute("INSERT INTO present VALUES('test2', ?, 10)", None)
	but I get an error:
	
	start_block
	ValueError: parameters are of unsupported type
	how do I insert a blank value for the second field in the row?


-------------------------------------OUTPUT-------------------------------------

                Expected= 'db.execute("INSERT INTO present VALUES(\'test2\',?, 10)", (None,))'
           base:Baseline= "sqlite3.insert('none')"
           base:+Canonic= "sqlite3.insert('None')"
           body:Baseline= 'db.execute(\'INSERT INTO present VALUES(\'test\',?, 10)", None)'
              body:-Code= "cursor.execute('INSERT INTO table VALUES (%s)', None)"
          mined:Baseline= "cursor.execute('INSERT INTO table VALUES (%s)', (None, 1))"
             mined:+Body= "db.execute('INSERT INTO present VALUES('test2',?, 10', None)"
        mined:+Body, -NL= "db.execute('INSERT INTO present VALUES('test2',?, 9', None)"
      mined:+Body, -Code= "cursor.execute('INSERT INTO table VALUES (%s)', (value,))"

================================================================================

QUESTION: idx=64     id=406121
-------------------------------------INPUTS-------------------------------------

tags: list-comprehension
score: 398
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['list_of_menuitems']}
intent: flatten list `list_of_menuitems`
body(Some added characters for better readability):
	Is there a simple way to flatten a list of iterables with a list comprehension, or failing that, what would you all consider to be the best way to flatten a shallow list like this, balancing performance and readability?
	I tried to flatten such a list with a nested list comprehension, like this:
	
	start_block
	[image for image in menuitem for menuitem in list_of_menuitems]
	
	<p>But I get in trouble of the 
	`NameError`
	 variety there, because the 
	`name 'menuitem' is not defined`
	.  After googling and looking around on Stack Overflow, I got the desired results with a 
	`reduce` statement:
	
	start_block
	reduce(list.__add__, map(lambda x: list(x), list_of_menuitems))
	
	<p>But this method is fairly unreadable because I need that 
	`list(x)`
	 call there because x is a Django 
	`QuerySet` object.
	
	<strong>Conclusion : 
	Thanks to everyone who contributed to this question.  Here is a summary of what I learned.  I'm also making this a community wiki in case others want to add to or correct these observations.
	My original reduce statement is redundant and is better written this way:
	
	
	start_block
	>>>reduce(list.__add__, (list(mi) for mi in list_of_menuitems))
	...
	
	<p>This is the correct syntax for a nested list comprehension (Brilliant summary 
	dF !):
	
	
	start_block
	>>>[image for mi in list_of_menuitems for image in mi]
	...
	
	<p>But neither of these methods are as efficient as using 
	`itertools.chain`:
	
	
	start_block
	>>>from itertools import chain
	>>>list(chain(*list_of_menuitems))
	...
	
	<p>And as @cdleary notes, it's probably better style to avoid * operator magic by using 
	`chain.from_iterable` like so:
	
	
	start_block
	>>>chain = itertools.chain.from_iterable([[1,2],[3],[5,89],[],[6]])
	>>>print(list(chain))
	>>>[1, 2, 3, 5, 89, 6]
	...


-------------------------------------OUTPUT-------------------------------------

                Expected= '[image for menuitem in list_of_menuitems for image in menuitem]'
           base:Baseline= 'list_of_menuitems.flatten()'
           base:+Canonic= 'list_of_menuitems[::-1]'
           body:Baseline= 'flatten(list_of_menuitems)'
              body:-Code= 'list_of_menuitems[::-1]'
          mined:Baseline= '[list_of_menuitems for _ in range(len(mylist))]'
             mined:+Body= 'from_iterable([[1, 2], [3, 89], [6]])'
        mined:+Body, -NL= 'from itertools import list(chain(*list_of_menuitems))'
      mined:+Body, -Code= '[list_of_menuitems for _ in range(length)]'

================================================================================

QUESTION: idx=65     id=4741537
-------------------------------------INPUTS-------------------------------------

tags: list, set
score: 14
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['b', 'a']}
intent: append elements of a set `b` to a list `a`
body(Some added characters for better readability):
	How do you append the elements of a set to a list in Python in the most succinct way?
	
	
	start_block
	>>>a = [1,2]
	>>>b = set([3,4])
	>>>a.append(list(b))
	>>>a
	...[1, 2, [3, 4]]
	But what I want is:
	
	start_block
	[1, 2, 3, 4]


-------------------------------------OUTPUT-------------------------------------

                Expected= 'a.extend(b)'
           base:Baseline= 'a.append(b, a)'
           base:+Canonic= 'a = [x for x in zip(b, a)]'
           body:Baseline= 'a.append(list(b))'
              body:-Code= 'a.append(b, a)'
          mined:Baseline= 'a = a[:] + a[:-1]'
             mined:+Body= 'a = [1, 2, 3, 4]'
        mined:+Body, -NL= 'a = [list(b) for b in a]'
      mined:+Body, -Code= 'a = [b for b in a]'

================================================================================

QUESTION: idx=66     id=4741537
-------------------------------------INPUTS-------------------------------------

tags: list, set
score: 14
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: append elements of a set to a list in python
body(Some added characters for better readability):
	How do you append the elements of a set to a list in Python in the most succinct way?
	
	
	start_block
	>>>a = [1,2]
	>>>b = set([3,4])
	>>>a.append(list(b))
	>>>a
	...[1, 2, [3, 4]]
	But what I want is:
	
	start_block
	[1, 2, 3, 4]


-------------------------------------OUTPUT-------------------------------------

                Expected= 'a.extend(list(b))'
           base:Baseline= '[x[0] for x in zip(set(list(itertools.chain.from_iterable(0)))'
           base:+Canonic= 'list(itertools.chain.from_iterable(1))'
           body:Baseline= '[x[0] for x in a]'
              body:-Code= '[x for x in set(set(x)))'
          mined:Baseline= "['a', 'b', 'c', 'd', 'e', 'f']"
             mined:+Body= '[1, 2, 3, 4]'
        mined:+Body, -NL= '[1, 2, 3, 4]'
      mined:+Body, -Code= 'list(set([1, 2, 3], [4, 5, 6])'

================================================================================

QUESTION: idx=67     id=31247198
-------------------------------------INPUTS-------------------------------------

tags: pandas, file-io
score: 86
slot_map: {'key': ['var_0', 'str_0'], 'quote': ['`', '`'], 'type': ['var', 'str'], 'value': ['df', 'np.txt']}
intent: write the data of dataframe `df` into text file `np.txt`
body(Some added characters for better readability):
	I have pandas DataFrame like this
	
	start_block
	        X    Y  Z    Value 
	0      18   55  1      70   
	1      18   55  2      67 
	2      18   57  2      75     
	3      18   58  1      35  
	4      19   54  2      70   
	I want to write this data to a text file that looks like this:
	
	start_block
	18 55 1 70   
	18 55 2 67 
	18 57 2 75     
	18 58 1 35  
	19 54 2 70 
	I have tried something like 
	
	start_block
	f = open(writePath, 'a')
	f.writelines(['\n', str(data['X']), ' ', str(data['Y']), ' ', str(data['Z']), ' ', str(data['Value'])])
	f.close()
	but it's not working. How to do this?      


-------------------------------------OUTPUT-------------------------------------

                Expected= "np.savetxt('c:\\\\data\\\\np.txt', df.values, fmt='%d')"
           base:Baseline= "df.to_csv('np.txt')"
           base:+Canonic= "df.write('np.txt')"
           body:Baseline= "df.write('np.txt')"
              body:-Code= "df.write('np.txt')"
          mined:Baseline= 'np.write(df.read())'
             mined:+Body= 'np.txt.write(df)'
        mined:+Body, -NL= "np.write(df, delimiter=',')"
      mined:+Body, -Code= "df.to_csv('np.txt', header=False)"

================================================================================

QUESTION: idx=68     id=31247198
-------------------------------------INPUTS-------------------------------------

tags: pandas, file-io
score: 86
slot_map: {'key': ['var_0', 'str_0'], 'quote': ['`', "'"], 'type': ['var', 'str'], 'value': ['df', 'c:\\data\\pandas.txt']}
intent: write content of dataframe `df` into text file 'c:\\data\\pandas.txt'
body(Some added characters for better readability):
	I have pandas DataFrame like this
	
	start_block
	        X    Y  Z    Value 
	0      18   55  1      70   
	1      18   55  2      67 
	2      18   57  2      75     
	3      18   58  1      35  
	4      19   54  2      70   
	I want to write this data to a text file that looks like this:
	
	start_block
	18 55 1 70   
	18 55 2 67 
	18 57 2 75     
	18 58 1 35  
	19 54 2 70 
	I have tried something like 
	
	start_block
	f = open(writePath, 'a')
	f.writelines(['\n', str(data['X']), ' ', str(data['Y']), ' ', str(data['Z']), ' ', str(data['Value'])])
	f.close()
	but it's not working. How to do this?      


-------------------------------------OUTPUT-------------------------------------

                Expected= "df.to_csv('c:\\\\data\\\\pandas.txt', header=None, index=None, sep=' ', mode='a')"
           base:Baseline= "df.write('C:\\\\data\\\\pandas.txt')"
           base:+Canonic= "df.write('c:\\\\data\\\\pandas.txt')"
           body:Baseline= "df.write('C:\\\\data\\\\pandas.txt')"
              body:-Code= "df.write('C:\\\\data\\\\pandas.txt')"
          mined:Baseline= "df.to_csv('c:\\\\data\\\\pandas.txt')"
             mined:+Body= "f.write('C:\\\\data\\\\pandas.txt')"
        mined:+Body, -NL= "f.write('C:\\\\data\\\\pandas.txt')"
      mined:+Body, -Code= "df.to_csv('c:\\\\data\\\\pandas.txt')"

================================================================================

QUESTION: idx=69     id=15851568
-------------------------------------INPUTS-------------------------------------

tags: string, split, slice
score: 63
slot_map: {'key': ['var_0', 'str_0'], 'quote': ['`', '`'], 'type': ['var', 'str'], 'value': ['x', '-']}
intent: split a string `x` by last occurrence of character `-`
body(Some added characters for better readability):
	I am trying to print the last part of a string before a certain character.  
	I'm not quite sure whether to use the string .split() method or string slicing or maybe something else.    
	Here is some code that doesn't work but I think shows the logic:  
	
	start_block
	x = 'http://test.com/lalala-134'
	print x['-':0] # beginning at the end of the string, return everything before '-'
	Note that the number at the end will vary in size so I can't set an exact count from the end of the string.  


-------------------------------------OUTPUT-------------------------------------

                Expected= "print(x.rpartition('-')[0])"
           base:Baseline= "x.split('-')[::-1]"
           base:+Canonic= "re.split('-', x)"
           body:Baseline= "print(x['-'] + x['-'])"
              body:-Code= "x.split(',', '-')"
          mined:Baseline= "x.split(':', 1)[-1]"
             mined:+Body= "x.split('-')[-]"
        mined:+Body, -NL= "x.split(':')[-1]"
      mined:+Body, -Code= "x.split(',')[-1]"

================================================================================

QUESTION: idx=70     id=15851568
-------------------------------------INPUTS-------------------------------------

tags: string, split, slice
score: 63
slot_map: {'key': ['str_0'], 'quote': ["'"], 'type': ['str'], 'value': ['-']}
intent: get the last part of a string before the character '-'
body(Some added characters for better readability):
	I am trying to print the last part of a string before a certain character.  
	I'm not quite sure whether to use the string .split() method or string slicing or maybe something else.    
	Here is some code that doesn't work but I think shows the logic:  
	
	start_block
	x = 'http://test.com/lalala-134'
	print x['-':0] # beginning at the end of the string, return everything before '-'
	Note that the number at the end will vary in size so I can't set an exact count from the end of the string.  


-------------------------------------OUTPUT-------------------------------------

                Expected= "print(x.rsplit('-', 1)[0])"
           base:Baseline= "re.split('-'[(-1)]"
           base:+Canonic= '"""-""".rstrip()'
           body:Baseline= "print(x['-'] + '-')"
              body:-Code= '"""""".join(str.split(\'-\'))'
          mined:Baseline= '"""-""".join(c for c in s if c.isdigit())'
             mined:+Body= '"""-""".join(x[-:] for x in s.split())'
        mined:+Body, -NL= "print(x['-'] + '-')"
      mined:+Body, -Code= "print('-'.join(c for c in s if c.endswith('-'))"

================================================================================

QUESTION: idx=71     id=17438096
-------------------------------------INPUTS-------------------------------------

tags: ftp
score: 14
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: upload file using ftp
body(Some added characters for better readability):
	I am trying to upload file from windows server to a unix server (basically trying to do FTP). I have used the code below 
	
	start_block
	#!/usr/bin/python
	import ftplib
	import os
	filename = "MyFile.py"
	ftp = ftplib.FTP("xx.xx.xx.xx")
	ftp.login("UID", "PSW")
	ftp.cwd("/Unix/Folder/where/I/want/to/put/file")
	os.chdir(r"\\windows\folder\which\has\file")
	ftp.storbinary('RETR %s' % filename, open(filename, 'w').write)
	I am getting the following error: 
	
	start_block
	Traceback (most recent call last):
	  File "Windows\folder\which\has\file\MyFile.py", line 11, in <module>
	    ftp.storbinary('RETR %s' % filename, open(filename, 'w').write)
	  File "windows\folder\Python\lib\ftplib.py", line 466, in storbinary
	    buf = fp.read(blocksize)
	AttributeError: 'builtin_function_or_method' object has no attribute 'read'
	
	<p>Also all contents of 
	`MyFile.py` got deleted .
	Can anyone advise what is going wrong.I have read that ftp.storbinary is used for uploading files using FTP. 


-------------------------------------OUTPUT-------------------------------------

                Expected= "ftp.storlines('STOR' + filename, open(filename, 'r'))"
           base:Baseline= 'ftp.uploadFile(filename)'
           base:+Canonic= 'ftp.upload_file(file__name__)'
           body:Baseline= "ftp.storbinary('RETR %s', open(filename, 'w').write)"
              body:-Code= 'ftp.uploadFile(filename)'
          mined:Baseline= "ftp.retrbinary('upload_file.txt', filename)"
             mined:+Body= "ftp.storbinary('RETR %s' % filename, open(filename, 'w').write)"
        mined:+Body, -NL= "ftp.cwd('/Unix/Folder/where/I/want/to/put/file')"
      mined:+Body, -Code= "ftp.storbinary('RETR %s' % filename)"

================================================================================

QUESTION: idx=72     id=15049182
-------------------------------------INPUTS-------------------------------------

tags: selenium
score: 5
slot_map: {'key': ['str_0'], 'quote': ["'"], 'type': ['str'], 'value': ['XYZ']}
intent: add one to the hidden web element with id 'xyz' with selenium python script
body(Some added characters for better readability):
	I'm trying to write to a text box with my python selenium code but get an error since a parent tag of the text box is hidden.
	
	start_block
	driver.find_element_by_xpath("//input[@itemcode='XYZ']").send_keys(1)
	I see a Javascript executor workaround with java but need help with something similar for python script.
	Thanks in advance!!


-------------------------------------OUTPUT-------------------------------------

                Expected= 'browser.execute_script("document.getElementById(\'XYZ\').value+=\'1\'")'
           base:Baseline= "driver.find_element_by_id('xyz')"
           base:+Canonic= "driver.find_element_by_id('XYZ')"
           body:Baseline= 'driver.find_element_by_xpath("//input[@itemcode=\'XYZ\']").send_keys(1)'
              body:-Code= "driver.find_element_by_id('xyz')"
          mined:Baseline= "driver.find_element_by_id('xyz').click()"
             mined:+Body= 'driver.find_element_by_xpath("//input[@itemcode=\'XYZ\']").send_keys(1)'
        mined:+Body, -NL= 'driver.find_element_by_xpath("//input[@itemcode=\'XYZ\']").send_keys(1)'
      mined:+Body, -Code= "driver.find_element_by_id('xyz')"

================================================================================

QUESTION: idx=73     id=28742436
-------------------------------------INPUTS-------------------------------------

tags: arrays, numpy, max
score: 9
slot_map: {'key': ['str_0', 'str_1', '[str_0]', '[str_1]'], 'quote': ['`', '`', '`', '`'], 'type': ['str', 'str', 'str', 'str'], 'value': ['[2, 3, 4]', '[1, 5, 2]', '[2, 3, 4]', '[1, 5, 2]']}
intent: create array containing the maximum value of respective elements of array `[2, 3, 4]` and array `[1, 5, 2]`
body(Some added characters for better readability):
	I want to combine two numpy arrays to produce an array with the largest values from each array.
	
	start_block
	import numpy as np
	a  = np.array([[ 0.,  0.,  0.5],
	               [ 0.1,  0.5,  0.5],
	               [ 0.1,  0.,  0.]])
	b  = np.array([[ 0.,  0.,  0.0],
	               [ 0.5,  0.1,  0.5],
	               [ 0.5,  0.1,  0.]])
	I would like to produce
	
	start_block
	array([[ 0.,  0.,  0.5],
	       [ 0.5,  0.5,  0.5],
	       [ 0.5,  0.1,  0.]])
	I know you can do
	
	start_block
	a += b
	which results in
	
	start_block
	array([[ 0. ,  0. ,  0.5],
	       [ 0.6,  0.6,  1. ],
	       [ 0.6,  0.1,  0. ]])
	This is clearly not what I'm after. It seems like such an easy problem and I assume it most probably is.


-------------------------------------OUTPUT-------------------------------------

                Expected= 'np.maximum([2, 3, 4], [1, 5, 2])'
           base:Baseline= 'max(np.max([2, 3, 4], [1, 5, 2])'
           base:+Canonic= 'np.array([np.max(str_0, str_1))'
           body:Baseline= 'np.array([2, 3, 4], [1, 5, 2])'
              body:-Code= 'np.array([2, 3, 4], [2, 5, 2])'
          mined:Baseline= 'np.argmax(a, [2, 3, 4], [1, 5, 2])'
             mined:+Body= 'np.maximum(a, b)'
        mined:+Body, -NL= 'np.argmax(a, np.maximum(b, [2, 3, 4]))'
      mined:+Body, -Code= 'np.maximum(x, y)'

================================================================================

QUESTION: idx=74     id=34280147
-------------------------------------INPUTS-------------------------------------

tags: list
score: 6
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['l']}
intent: print a list `l` and move first 3 elements to the end of the list
body(Some added characters for better readability):
	
	<p>I'm trying to figure out how to print the following list while not starting by the first item. To be clear: If the list is 
	`[0,1,2,3,4,5,6,7,8]`
	, I want to print something like `4,5,6,7,8,0,1,2,3`
	Here's the code:
	
	start_block
	you_can_move_on = False
	List = [0,1,2,3,4,5,6,7,8]
	next_player = 3
	while not you_can_move_on:
	    next_player = self.get_next_player_index(next_player)
	    you_can_move_on = self.check_if_I_can_move_on
	    print(next_player)
	def get_next_player_index(self, i):
	    if i == len(self.players):
	        return 0
	    else:
	        return i+1
	def check_if_I_can_move_on(self):
	    return False


-------------------------------------OUTPUT-------------------------------------

                Expected= 'print(l[3:] + l[:3])'
           base:Baseline= '[x[0] for x in L]'
           base:+Canonic= 'print(l.split(3))'
           body:Baseline= 'print(l[0:3] + 3'
              body:-Code= 'print(l, key=lambda x: x[3])'
          mined:Baseline= 'l = [l[i:i + 3] for i in range(3)]'
             mined:+Body= "print(''.join(l[i:i + 3])"
        mined:+Body, -NL= 'print([0, 1, 2, 3, 4, 5, 6, 7, 8])'
      mined:+Body, -Code= "print(' '.join(str(i) for i in l))"

================================================================================

QUESTION: idx=75     id=11801309
-------------------------------------INPUTS-------------------------------------

tags: file-io, absolute-path
score: 62
slot_map: {'key': ['str_0'], 'quote': ["'"], 'type': ['str'], 'value': ['.']}
intent: loop over files in directory '.'
body(Some added characters for better readability):
	I have a folder with ten files in it which I want to loop through. When I print out the name of the file my code works fine:
	
	start_block
	import os
	indir = '/home/des/test'
	for root, dirs, filenames in os.walk(indir):
	    for f in filenames:
	        print(f)
	Which prints:
	
	start_block
	1
	2
	3
	4
	5
	6
	7
	8
	9
	10
	But if I try to open the file in the loop I get an IO error:
	
	start_block
	import os
	indir = '/home/des/test'
	for root, dirs, filenames in os.walk(indir):
	    for f in filenames:
	        log = open(f, 'r')
	Traceback (most recent call last):
	File "/home/des/my_python_progs/loop_over_dir.py", line 6, in <module>
	log = open(f, 'r')
	IOError: [Errno 2] No such file or directory: '1'
	>>>
	...
	
	<p>Do I need to pass the full path of the file even inside the loop to 
	`open()` them?


-------------------------------------OUTPUT-------------------------------------

                Expected= "for fn in os.listdir('.'):\n    if os.path.isfile(fn):\n        pass"
           base:Baseline= 'os.path.realpath(__file__)'
           base:+Canonic= "os.chdir('.')"
           body:Baseline= "log = open(f, '.')"
              body:-Code= "os.path.join(open('.'))"
          mined:Baseline= "for line in os.listdir('.'):\n    pass"
             mined:+Body= "os.walk(os.path.join(path, '.'))"
        mined:+Body, -NL= "f = open(f, 'r')"
      mined:+Body, -Code= "print(os.path.join(root, '.'))"

================================================================================

QUESTION: idx=76     id=11801309
-------------------------------------INPUTS-------------------------------------

tags: file-io, absolute-path
score: 62
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['source']}
intent: loop over files in directory `source`
body(Some added characters for better readability):
	I have a folder with ten files in it which I want to loop through. When I print out the name of the file my code works fine:
	
	start_block
	import os
	indir = '/home/des/test'
	for root, dirs, filenames in os.walk(indir):
	    for f in filenames:
	        print(f)
	Which prints:
	
	start_block
	1
	2
	3
	4
	5
	6
	7
	8
	9
	10
	But if I try to open the file in the loop I get an IO error:
	
	start_block
	import os
	indir = '/home/des/test'
	for root, dirs, filenames in os.walk(indir):
	    for f in filenames:
	        log = open(f, 'r')
	Traceback (most recent call last):
	File "/home/des/my_python_progs/loop_over_dir.py", line 6, in <module>
	log = open(f, 'r')
	IOError: [Errno 2] No such file or directory: '1'
	>>>
	...
	
	<p>Do I need to pass the full path of the file even inside the loop to 
	`open()` them?


-------------------------------------OUTPUT-------------------------------------

                Expected= 'for root, dirs, filenames in os.walk(source):\n    for f in filenames:\n        pass'
           base:Baseline= 'os.path.abspath(source)'
           base:+Canonic= 'for line in os.walk(source):\n    pass'
           body:Baseline= "log = open(source, 'r')"
              body:-Code= 'print(os.path.join(source))'
          mined:Baseline= 'print(os.path.join(source))'
             mined:+Body= 'os.walk(os.path.abspath(source))'
        mined:+Body, -NL= "f = open(f, 'r')"
      mined:+Body, -Code= 'print(os.path.join(source))'

================================================================================

QUESTION: idx=77     id=4172131
-------------------------------------INPUTS-------------------------------------

tags: list, random, performance
score: 71
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: create a random list of integers
body(Some added characters for better readability):
	
	<p>I'd like to create a random list of integers for testing purposes. The distribution of the numbers is not important. The only thing that is counting is 
	time . I know generating random numbers is a time-consuming task, but there must be a better way.
	Here's my current solution:
	
	start_block
	import random
	import timeit
	# Random lists from [0-999] interval
	print [random.randint(0, 1000) for r in xrange(10)] # v1
	print [random.choice([i for i in xrange(1000)]) for r in xrange(10)] # v2
	# Measurement:
	t1 = timeit.Timer('[random.randint(0, 1000) for r in xrange(10000)]', 'import random') # v1
	t2 = timeit.Timer('random.sample(range(1000), 10000)', 'import random') # v2
	print t1.timeit(1000)/1000
	print t2.timeit(1000)/1000
	v2 is faster than v1, but it is not working on such a large scale. It gives the following error:
	ValueError: sample larger than population
	Is there a fast, efficient solution that works at that scale?
	Some results from the answer
	Andrew's: 0.000290962934494
	gnibbler's: 0.0058455221653
	KennyTM's: 0.00219276118279
	NumPy came, saw, and conquered.


-------------------------------------OUTPUT-------------------------------------

                Expected= '[int(1000 * random.random()) for i in range(10000)]'
           base:Baseline= 'random.sample(list(range(0, len(random.randint(1)))'
           base:+Canonic= 'list(random.randint(1))'
           body:Baseline= 'random.sample(range(1000), 10000)'
              body:-Code= 'random.sample(range(0, len(random.values())))'
          mined:Baseline= 'random.choice(list(range(10)), 10)'
             mined:+Body= 'random.sample(range(1000), 10000)'
        mined:+Body, -NL= 'random.sample(range(1000), 10000)'
      mined:+Body, -Code= 'random.sample(range(1, 10))'

================================================================================

QUESTION: idx=78     id=6677332
-------------------------------------INPUTS-------------------------------------

tags: time, strftime
score: 115
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: using %f with strftime() in python to get microseconds
body(Some added characters for better readability):
	
	<p>I'm trying to use strftime() to microsecond precision, which seems possible using %f (as stated 
	here ). However when I try the following code:
	
	start_block
	import time
	import strftime from time
	print strftime("%H:%M:%S.%f")
	<console_out>I get the hour, the minutes and the seconds, but %f prints as %f, with no sign of the microseconds. I'm running Python 2.6.5 on Ubuntu, so it should be fine and %f should be supported (it's supported for 2.6 and above, as far as I know.)


-------------------------------------OUTPUT-------------------------------------

                Expected= "datetime.datetime.now().strftime('%H:%M:%S.%f')"
           base:Baseline= "time.strftime('%f %f')"
           base:+Canonic= "min(os.path.getmtime(0, '%f'))"
           body:Baseline= "print(strftime('%H:%M:%S.%f')"
              body:-Code= "print(strftime('%f %s %f')"
          mined:Baseline= 'time.mktime(microsecond / 1000.0)'
             mined:+Body= "print(strftime('%H:%M:%S.%f'))"
        mined:+Body, -NL= "print(strftime('%H:%M:%S.%f'))"
      mined:+Body, -Code= 'microsecond precision = (microsecond / 100.0)'

================================================================================

QUESTION: idx=79     id=852055
-------------------------------------INPUTS-------------------------------------

tags: google-app-engine, gql
score: 5
slot_map: {'key': ['str_0', 'str_1'], 'quote': ["'", '`'], 'type': ['str', 'str'], 'value': ['SELECT * FROM Schedule WHERE station = $1', 'foo.key()']}
intent: google app engine execute gql query 'select * from schedule where station = $1' with parameter `foo.key()`
body(Some added characters for better readability):
	Say I have the following model:
	
	start_block
	class Schedule(db.Model):
	    tripCode = db.StringProperty(required=True)
	    station = db.ReferenceProperty(Station, required=True)    
	    arrivalTime = db.TimeProperty(required=True)
	    departureTime = db.TimeProperty(required=True)
	
	<p>And let's say I have a Station object stored in the var 
	`foo`.
	
	<p>How do I assemble a GQL query that returns all Schedule objects with a reference to the Station object referenced by 
	`foo`?
	
	<p>This is my best (albeit 
	incorrect ) attempt to form such a query:
	
	start_block
	myQuery = "SELECT * FROM Schedule where station = " + str(foo.key())
	
	<em>Once again 
	`foo`
	 is a 
	Station  object


-------------------------------------OUTPUT-------------------------------------

                Expected= "db.GqlQuery('SELECT * FROM Schedule WHERE station = $1', foo.key())"
           base:Baseline= "gql.execute('SELECT * FROM schedule WHERE station = $1', 'foo.key()')"
           base:+Canonic= "google.engine.execute('SELECT * FROM Schedule WHERE station = $1', 'foo.key()')"
           body:Baseline= "GQL.query('SELECT * FROM Schedule WHERE station = $1', str(foo.key()))"
              body:-Code= "GQL.execute('SELECT * FROM schedule WHERE station = $1', 'foo.key()')"
          mined:Baseline= "urllib.request.urlretrieve('select * FROM schedule where station = $1',\n    'foo.key()')"
             mined:+Body= "myQuery = 'SELECT * FROM Schedule where station =' + str(foo.key())"
        mined:+Body, -NL= "myQuery = 'SELECT * FROM Schedule where station =' + str(foo.key())"
      mined:+Body, -Code= "Gql.query('select * from schedule where station = $1')"

================================================================================

QUESTION: idx=80     id=15325182
-------------------------------------INPUTS-------------------------------------

tags: regex, pandas
score: 188
slot_map: {'key': ['str_0'], 'quote': ["'"], 'type': ['str'], 'value': ['f']}
intent: filter rows in pandas starting with alphabet 'f' using regular expression.
body(Some added characters for better readability):
	I would like to cleanly filter a dataframe using regex on one of the columns.
	For a contrived example:
	
	
	start_block
	>>>foo = pd.DataFrame({'a' : [1,2,3,4], 'b' : ['hi', 'foo', 'fat', 'cat']})
	>>>foo
	...
	   a    b
	0  1   hi
	1  2  foo
	2  3  fat
	3  4  cat
	
	<p>I want to filter the rows to those that start with 
	`f` using a regex. First go:
	
	
	start_block
	>>>foo.b.str.match('f.*')
	...
	0    []
	1    ()
	2    ()
	3    []
	That's not too terribly useful. However this will get me my boolean index:
	
	
	start_block
	>>>foo.b.str.match('(f.*)').str.len() > 0
	...
	0    False
	1     True
	2     True
	3    False
	Name: b
	So I could then do my restriction by:
	
	
	start_block
	>>>foo[foo.b.str.match('(f.*)').str.len() > 0]
	...
	   a    b
	1  2  foo
	2  3  fat
	That makes me artificially put a group into the regex though, and seems like maybe not the clean way to go. Is there a better way to do this?


-------------------------------------OUTPUT-------------------------------------

                Expected= "df.b.str.contains('^f')"
           base:Baseline= "df.filter(re.search('f')"
           base:+Canonic= "df.groupby('f')"
           body:Baseline= "pd.concat([df.startswith('f').str.len()])"
              body:-Code= "df.filter(lambda x: x.startswith('f'))"
          mined:Baseline= "df[df['A'].str.contains('f')]"
             mined:+Body= "df[df.str.startswith('f')]"
        mined:+Body, -NL= "df[df.groupby('f').apply(lambda x: x.startswith('f'))]"
      mined:+Body, -Code= "df[df.str.startswith('f')]"

================================================================================

QUESTION: idx=81     id=583557
-------------------------------------INPUTS-------------------------------------

tags: coding-style
score: 4
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['tab']}
intent: print a 2 dimensional list `tab` as a table with delimiters
body(Some added characters for better readability):
	I want to print a table mixed with string and float values, as tab delimited output printout. Sure I can get the job done:
	
	
	start_block
	>>>tab = [['a', 1], ['b', 2]]
	>>>for row in tab:
	...    out = ""
	...    for col in row:
	...            out = out + str(col) + "\t"
	...    print out.rstrip()
	...
	a   1
	b   2
	
	<p>But I have a feeling there is a better way to do it in Python, at least to print each row with specified delimiter, if not the whole table. Little googling (from 
	here ) and it is already shorter:
	
	
	start_block
	>>>for row in tab:
	...    print "\t".join([str(col) for col in row])
	...
	a   1
	b   2
	Is there still a better, or more Python-ish, way to do it?


-------------------------------------OUTPUT-------------------------------------

                Expected= "print('\\n'.join('\\t'.join(str(col) for col in row) for row in tab))"
           base:Baseline= "print((' '.join(table) for table in zip(tab))"
           base:+Canonic= 'print(tab.split())'
           body:Baseline= "print('\\t'.join([str(col) for col in row])"
              body:-Code= "print(' '.join(table) for row in tab)"
          mined:Baseline= "print('\\n'.join([str(x) for x in tab])"
             mined:+Body= "print('\\t'.join([str(col) for col in row])"
        mined:+Body, -NL= "print('\\t'.join([str(col) for col in row])"
      mined:+Body, -Code= "print('\\n'.join(map(str, delimiter))"

================================================================================

QUESTION: idx=82     id=38535931
-------------------------------------INPUTS-------------------------------------

tags: pandas
score: 8
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['df']}
intent: pandas: delete rows in dataframe `df` based on multiple columns values
body(Some added characters for better readability):
	
	<p>I have a dataframe with columns 
	`A,B,C`
	. I have a list of tuples like 
	`[(x1,y1), (x2,y2), <console_out>]`. I would like to delete all rows that meet the following condition:
	
	`(B=x1 && C=y1) | (B=x2 && C=y2) |`
	...
	 How can I do that in pandas? I wanted to use the 
	`isin` function, but not sure if it is possible since my list has tuples. I could do something like this:
	
	start_block
	for x,y in tuples:   
	    df = df.drop(df[df.B==x && df.C==y].index)
	Maybe there is an easier way.


-------------------------------------OUTPUT-------------------------------------

                Expected= "df.set_index(list('BC')).drop(tuples, errors='ignore').reset_index()"
           base:Baseline= 'df.apply(lambda x: x[1])'
           base:+Canonic= 'pd.concat([var_0.columns, axis=1])'
           body:Baseline= 'df.drop(df.index, axis=1).index)'
              body:-Code= 'pd.merge(df.columns, axis=1)'
          mined:Baseline= 'df.drop(df.columns, axis=1, inplace=True)'
             mined:+Body= 'df.drop(df[df.B==x && df.C==y].index)'
        mined:+Body, -NL= 'df = df.drop(df.B==x && df.C==y).index'
      mined:+Body, -Code= 'df.drop(df.index, axis=1)'

================================================================================

QUESTION: idx=83     id=13945749
-------------------------------------INPUTS-------------------------------------

tags: string
score: 115
slot_map: {'key': ['str_0', 'str_1'], 'quote': ['`', '`'], 'type': ['str', 'str'], 'value': ['self.goals', 'self.penalties']}
intent: format the variables `self.goals` and `self.penalties` using string formatting
body(Some added characters for better readability):
	I do this in Python 2:
	
	start_block
	"(%d goals, $%d)" % (self.goals, self.penalties)
	What is the Python 3 version of this?
	I tried searching for examples online but I kept getting Python 2 versions.


-------------------------------------OUTPUT-------------------------------------

                Expected= '"""({:d} goals, ${:d})""".format(self.goals, self.penalties)'
           base:Baseline= '""" """.join(self.goals, self.penalties))'
           base:+Canonic= '"""self.goals""".format(\'self.penalties\')'
           body:Baseline= '"""%d goals, $%d)" % (self.goals, self.penalties)'
              body:-Code= '"""{}""".format(self.goals, self.penalties)'
          mined:Baseline= '"""{:.2f}""".format(self.goals, self.penalties)'
             mined:+Body= '"""{} goals, {} {}""".format(self.goals, self.penalties)'
        mined:+Body, -NL= '"""{}_{}""".format(self.goals, self.penalties)'
      mined:+Body, -Code= '"""{} {}""".format(self.goals, self.penalties)'

================================================================================

QUESTION: idx=84     id=13945749
-------------------------------------INPUTS-------------------------------------

tags: string
score: 115
slot_map: {'key': ['str_0', 'var_0', 'var_1', '(str_0)'], 'quote': ['"', '`', '`', '"'], 'type': ['str', 'var', 'var', 'str'], 'value': ['({} goals, ${})', 'goals', 'penalties', '({} goals, ${})']}
intent: format string "({} goals, ${})" with variables `goals` and `penalties`
body(Some added characters for better readability):
	I do this in Python 2:
	
	start_block
	"(%d goals, $%d)" % (self.goals, self.penalties)
	What is the Python 3 version of this?
	I tried searching for examples online but I kept getting Python 2 versions.


-------------------------------------OUTPUT-------------------------------------

                Expected= '"""({} goals, ${})""".format(self.goals, self.penalties)'
           base:Baseline= '"""({} goals, ${})"'
           base:+Canonic= '"""str_0""".format(var_0, var_1))'
           body:Baseline= '"""({} goals, ${})"'
              body:-Code= 'print(\'({} goals, ${})"'
          mined:Baseline= '"""({} goals, ${}}""".format(\'({} Goals, {} Penalties\')'
             mined:+Body= '"""{} goals, ${}""".format(goals, flags)'
        mined:+Body, -NL= '"""({} goals, ${})" % (goals, flags)'
      mined:+Body, -Code= '"""({} goals, ${})"'

================================================================================

QUESTION: idx=85     id=13945749
-------------------------------------INPUTS-------------------------------------

tags: string
score: 115
slot_map: {'key': ['str_0', '(str_0)'], 'quote': ['"', '"'], 'type': ['str', 'str'], 'value': ['({0.goals} goals, ${0.penalties})', '({0.goals} goals, ${0.penalties})']}
intent: format string "({0.goals} goals, ${0.penalties})"
body(Some added characters for better readability):
	I do this in Python 2:
	
	start_block
	"(%d goals, $%d)" % (self.goals, self.penalties)
	What is the Python 3 version of this?
	I tried searching for examples online but I kept getting Python 2 versions.


-------------------------------------OUTPUT-------------------------------------

                Expected= '"""({0.goals} goals, ${0.penalties})""".format(self)'
           base:Baseline= '"""{0.goals} goals, ${0.penalties}""".format(\',\')'
           base:+Canonic= '"""({0.goals} goals, ${0.penalties})""".format(\'\\n\')'
           body:Baseline= '"""({0.goals} goals, ${0.penalties})"'
              body:-Code= '"""{0.goals} goals, ${0.penalties}""".format(2)'
          mined:Baseline= "format('({0.goals} goals, ${0.penalties}')"
             mined:+Body= "print('({0.goals} goals, ${0.penalties})'.format(self))"
        mined:+Body, -NL= '"""({0.goals} goals, ${0.penalties}""".format(\'%d goals, %d penalties\'))'
      mined:+Body, -Code= "format('({0.goals} goals, ${0.penalties}')"

================================================================================

QUESTION: idx=86     id=18524642
-------------------------------------INPUTS-------------------------------------

tags: list
score: 6
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['L']}
intent: convert list of lists `l` to list of integers
body(Some added characters for better readability):
	I need to convert a list of lists to a list of integers.
	from: 
	
	start_block
	L1 = [[1, 2, 3, 4], [3, 7, 1, 7], [0, 5, 6, 7], [9, 4, 5, 6]]
	to:  
	
	start_block
	L2 = [1234, 3717, 0567, 9456]
	
	<p>How can I make python recognize an integer starting with 0? Like the case `L2[2]`
	The other question is, how can I check if items in a list are ordered?
	
	start_block
	A = [1, 2, 6, 9] ---->True
	Other than this:  
	
	start_block
	A == sorted(A)
	You guys are FAST. Thanks!


-------------------------------------OUTPUT-------------------------------------

                Expected= "[int(''.join(str(d) for d in x)) for x in L]"
           base:Baseline= '[int(x) for x in l]'
           base:+Canonic= '[int(x) for x in L]'
           body:Baseline= '[int(x) for x in L]'
              body:-Code= '[int(x) for x in l]'
          mined:Baseline= '[int(x) for x in L]'
             mined:+Body= '[int(x) for x in L1]'
        mined:+Body, -NL= '[int(x) for x in L2]'
      mined:+Body, -Code= '[int(x) for x in l]'

================================================================================

QUESTION: idx=87     id=18524642
-------------------------------------INPUTS-------------------------------------

tags: list
score: 6
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['L']}
intent: combine elements of each list in list `l` into digits of a single integer
body(Some added characters for better readability):
	I need to convert a list of lists to a list of integers.
	from: 
	
	start_block
	L1 = [[1, 2, 3, 4], [3, 7, 1, 7], [0, 5, 6, 7], [9, 4, 5, 6]]
	to:  
	
	start_block
	L2 = [1234, 3717, 0567, 9456]
	
	<p>How can I make python recognize an integer starting with 0? Like the case `L2[2]`
	The other question is, how can I check if items in a list are ordered?
	
	start_block
	A = [1, 2, 6, 9] ---->True
	Other than this:  
	
	start_block
	A == sorted(A)
	You guys are FAST. Thanks!


-------------------------------------OUTPUT-------------------------------------

                Expected= "[''.join(str(d) for d in x) for x in L]"
           base:Baseline= '[int(x) for x in L]'
           base:+Canonic= '[int(x) for x in L]'
           body:Baseline= '[int(x) for x in L]'
              body:-Code= '[int(x) for x in l]'
          mined:Baseline= '[int(x) for x in L]'
             mined:+Body= '[int(x) for x in L1]'
        mined:+Body, -NL= '[int(x) for x in L1 if x.isdigit()]'
      mined:+Body, -Code= 'map(int, zip(*l))'

================================================================================

QUESTION: idx=88     id=18524642
-------------------------------------INPUTS-------------------------------------

tags: list
score: 6
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['L']}
intent: convert a list of lists `l` to list of integers
body(Some added characters for better readability):
	I need to convert a list of lists to a list of integers.
	from: 
	
	start_block
	L1 = [[1, 2, 3, 4], [3, 7, 1, 7], [0, 5, 6, 7], [9, 4, 5, 6]]
	to:  
	
	start_block
	L2 = [1234, 3717, 0567, 9456]
	
	<p>How can I make python recognize an integer starting with 0? Like the case `L2[2]`
	The other question is, how can I check if items in a list are ordered?
	
	start_block
	A = [1, 2, 6, 9] ---->True
	Other than this:  
	
	start_block
	A == sorted(A)
	You guys are FAST. Thanks!


-------------------------------------OUTPUT-------------------------------------

                Expected= "L = [int(''.join([str(y) for y in x])) for x in L]"
           base:Baseline= '[int(x) for x in l]'
           base:+Canonic= '[int(x) for x in L]'
           body:Baseline= '[int(x) for x in L]'
              body:-Code= '[int(x) for x in l]'
          mined:Baseline= '[int(x) for x in L]'
             mined:+Body= '[int(x) for x in L1]'
        mined:+Body, -NL= '[int(x) for x in L2]'
      mined:+Body, -Code= '[int(x) for x in l]'

================================================================================

QUESTION: idx=89     id=7138686
-------------------------------------INPUTS-------------------------------------

tags: 
score: 29
slot_map: {'key': ['var_0', 'str_0', 'var_1'], 'quote': ['`', "'", '`'], 'type': ['var', 'str', 'var'], 'value': ['lines', '\n', 'myfile']}
intent: write the elements of list `lines` concatenated by special character '\n' to file `myfile`
body(Some added characters for better readability):
	I'm trying to write an array (list?) to a text file using Python 3. Currently I have:
	
	start_block
	def save_to_file(*text):
	    with open('/path/to/filename.txt', mode='wt', encoding='utf-8') as myfile:
	        for lines in text:
	            print(lines, file = myfile)
	    myfile.close
	This writes what looks like the array straight to the text file, i.e.,
	
	start_block
	['element1', 'element2', 'element3']
	username@machine:/path$
	What I'm looking to do is create the file with
	
	start_block
	element1
	element2
	element3
	username@machine:/path$
	
	<p>I've tried different ways to loop through and append a "\n" but it seems that the write is dumping the array in one operation. The question is similar to 
	How to write list of strings to file, adding newlines?  but the syntax looked like it was for Python 2? When I tried a modified version of it:
	
	start_block
	def save_to_file(*text):
	    myfile = open('/path/to/filename.txt', mode='wt', encoding='utf-8')
	    for lines in text:
	        myfile.write(lines)
	    myfile.close
	<console_out>the Python shell gives "TypeError: must be str, not list" which I think is because of changes between Python2 and Python 3. What am I missing to get each element on a newline?
	EDIT: Thank you to @agf and @arafangion; combining what both of you wrote, I came up with:
	
	start_block
	def save_to_file(text):
	    with open('/path/to/filename.txt', mode='wt', encoding='utf-8') as myfile:
	        myfile.write('\n'.join(text))
	        myfile.write('\n')
	It looks like I had part of the issue with "*text" (I had read that expands arguments but it didn't click until you wrote that [element] was becoming [[element]] that I was getting a str-not-list type error; I kept thinking I needed to tell the definition that it was getting a list/array passed to it and that just stating "test" would be a string.) It worked once I changed it to just text and used myfile.write with join, and the additional \n puts in the final newline at the end of the file.


-------------------------------------OUTPUT-------------------------------------

                Expected= "myfile.write('\\n'.join(lines))"
           base:Baseline= "myfile.write(lines, '\\n')"
           base:+Canonic= "myfile.write('\\n', lines)"
           body:Baseline= "myfile.write('\\n'.join(lines))"
              body:-Code= "myfile.write('\\n')"
          mined:Baseline= "with open('myfile', '\\n') as f:\n    pass"
             mined:+Body= "myfile.write('\\n')"
        mined:+Body, -NL= "myfile.write('\\n'.join(lines))"
      mined:+Body, -Code= "f.write('\\n'.join(lines))"

================================================================================

QUESTION: idx=90     id=1866343
-------------------------------------INPUTS-------------------------------------

tags: string
score: 6
slot_map: {'key': ['str_0', 'str_1'], 'quote': ["'", "'"], 'type': ['str', 'str'], 'value': ['X', 'N']}
intent: removing an element from a list based on a predicate 'x' or 'n'
body(Some added characters for better readability):
	
	<p>I want to remove an element from list, such that the element contains 
	`'X'`
	 or 
	`'N'`. I have to apply for a large genome. Here is an example:
	input:
	
	start_block
	codon=['AAT','XAC','ANT','TTA']
	expected output:  
	
	start_block
	codon=['AAT','TTA']  


-------------------------------------OUTPUT-------------------------------------

                Expected= "[x for x in ['AAT', 'XAC', 'ANT', 'TTA'] if 'X' not in x and 'N' not in x]"
           base:Baseline= '[x[i] for i in range(10)]'
           base:+Canonic= '[x for x in enumerate(X, N)]'
           body:Baseline= "[x[0] for x in ['X'], 'N']"
              body:-Code= '[x[i] for i in range(10)]'
          mined:Baseline= "[x for x in l if x == 'n']"
             mined:+Body= "[x for x in lst if x['X'] == 'N']"
        mined:+Body, -NL= "[x for x in lst if 'X' in x]"
      mined:+Body, -Code= "[x for x in my_list if 'x' in x]"

================================================================================

QUESTION: idx=91     id=17238587
-------------------------------------INPUTS-------------------------------------

tags: regex
score: 6
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['text']}
intent: remove duplicate words from a string `text` using regex
body(Some added characters for better readability):
	I am very new a Python
	I want to change sentence if there are repeated words.
	Correct
	Ex. "this just so so so nice" --> "this is just so nice"
	Ex. "this is just is is" --> "this is just is"
	Right now am I using this reg. but it do all so change on letters.
	Ex. "My friend and i is happy" --> "My friend and is happy" (it remove the "i" and space) ERROR
	
	start_block
	text = re.sub(r'(\w+)\1', r'\1', text) #remove duplicated words in row
	How can I do the same change but instead of letters it have to check on words?


-------------------------------------OUTPUT-------------------------------------

                Expected= "text = re.sub('\\\\b(\\\\w+)( \\\\1\\\\b)+', '\\\\1', text)"
           base:Baseline= "re.sub('(\\\\w+)', text)"
           base:+Canonic= "re.sub('\\\\w+', text)"
           body:Baseline= "re.sub('\\\\w+\\\\1', text)"
              body:-Code= "re.sub('(\\\\w+)', text)"
          mined:Baseline= "re.sub('\\\\w+', '\\\\1\\\\1', text)"
             mined:+Body= "re.sub('(\\\\w+)', '\\\\1', text)"
        mined:+Body, -NL= "re.sub('\\\\w+', '\\\\1', text)"
      mined:+Body, -Code= "re.sub('[^a-zA-Z]', '', text)"

================================================================================

QUESTION: idx=92     id=26053849
-------------------------------------INPUTS-------------------------------------

tags: pandas, dataframe
score: 67
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: count non zero values in each column in pandas data frame
body(Some added characters for better readability):
	I have a python-pandas-dataframe in which first column is user_id and rest of the columns are tags(tag_0 to tag_122). 
	I have the data in the following format:
	
	start_block
	UserId  Tag_0   Tag_1
	7867688 0   5
	7867688 0   3
	7867688 3   0
	7867688 3.5 3.5
	7867688 4   4
	7867688 3.5 0
	
	<p>My aim is to achieve 
	`Sum(Tag)/Count(NonZero(Tags))` for each user_id
	
	`df.groupby('user_id').sum()`
	, gives me 
	`sum(tag)`, however I am clueless about counting non zero values
	
	<p>Is it possible to achieve 
	`Sum(Tag)/Count(NonZero(Tags))` in one command?
	In MySQL I could achieve this as follows:-
	
	start_block
	select user_id, sum(tag)/count(nullif(tag,0)) from table group by 1
	Any help shall be appreciated.


-------------------------------------OUTPUT-------------------------------------

                Expected= 'df.astype(bool).sum(axis=1)'
           base:Baseline= "df['drop'].apply(lambda x: x[0])"
           base:+Canonic= 'df.groupby(lambda x: x[1])'
           body:Baseline= "df.groupby('user_id').sum().count(nullif(tag, 0))"
              body:-Code= "df['User_id'] = df['Tag_0']"
          mined:Baseline= 'df.groupby(level=0).sum()'
             mined:+Body= "df.groupby('user_id').sum()"
        mined:+Body, -NL= "df.groupby('user_id').sum()"
      mined:+Body, -Code= "df.groupby('User').apply(lambda x: x.tag_0 == 0).count()"

================================================================================

QUESTION: idx=93     id=15534223
-------------------------------------INPUTS-------------------------------------

tags: regex, match
score: 5
slot_map: {'key': ['str_0', 'str_1'], 'quote': ["'", "'"], 'type': ['str', 'str'], 'value': ['(?<!Distillr)\\\\AcroTray\\.exe', 'C:\\SomeDir\\AcroTray.exe']}
intent: search for string that matches regular expression pattern '(?<!distillr)\\\\acrotray\\.exe' in string 'c:\\somedir\\acrotray.exe'
body(Some added characters for better readability):
	
	<p>I want to search for a file called "AcroTray.exe" on my disk. The program should print a warning 
	if the file is located in a directory other than "Distillr" .
	I used the following Syntax to perform the negative match
	
	start_block
	(?!Distillr)
	The problem is that although I use the "!" it always produces a MATCH. I tried to figure out the problem using IPython but failed. 
	This is what I tried: 
	
	start_block
	import re
	filePath = "C:\Distillr\AcroTray.exe"
	if re.search(r'(?!Distillr)\\AcroTray\.exe', filePath):
	    print "MATCH"
	It prints a MATCH.
	What is wrong with my regex?
	I would like to get a match on:
	
	start_block
	C:\SomeDir\AcroTray.exe
	But not on:
	
	start_block
	C:\Distillr\AcroTray.exe


-------------------------------------OUTPUT-------------------------------------

                Expected= "re.search('(?<!Distillr)\\\\\\\\AcroTray\\\\.exe', 'C:\\\\SomeDir\\\\AcroTray.exe')"
           base:Baseline= "re.findall('(?<!distillr)\\\\\\\\acrotray\\\\.exe')"
           base:+Canonic= "re.findall('(?<!Distillr)\\\\\\\\AcroTray\\\\.exe', 'C:\\\\SomeDir\\\\AcroTray.exe')"
           body:Baseline= "re.search('(?<!distillr)\\\\\\\\acrotray\\\\.exe', 'C:\\\\Somedir\\\\AcroTray.exe')"
              body:-Code= "re.findall('(?<!distillr)\\\\\\\\acrotray\\\\.exe', 'C:\\\\somedir\\\\acroTray.exe')"
          mined:Baseline= "re.compile('(?<!distillr)\\\\\\\\acrotray\\\\.exe')"
             mined:+Body= "re.search('(?<!distillr)\\\\\\\\acrotray\\\\.exe', c)"
        mined:+Body, -NL= "re.search('(?<!distillr)\\\\\\\\acrotray\\\\.exe', s)"
      mined:+Body, -Code= "match = re.compile('(?<!distillr)\\\\\\\\acrotray\\\\.exe')"

================================================================================

QUESTION: idx=94     id=5453026
-------------------------------------INPUTS-------------------------------------

tags: string, list
score: 32
slot_map: {'key': ['str_0'], 'quote': ["'"], 'type': ['str'], 'value': ['QH QD JC KD JS']}
intent: split string 'qh qd jc kd js' into a list on white spaces
body(Some added characters for better readability):
	I'm trying to split a string:
	
	start_block
	'QH QD JC KD JS'
	into a list like:
	
	start_block
	['QH', 'QD', 'JC', 'KD', 'JS']
	How would I go about doing this? 


-------------------------------------OUTPUT-------------------------------------

                Expected= '"""QH QD JC KD JS""".split()'
           base:Baseline= "[j for i in s.split('qh qd jc kd js')]"
           base:+Canonic= '[int(x) for x in QH QD JC KD JS.split()]'
           body:Baseline= "list('QH QD JC KD JS')"
              body:-Code= "list('qh qd jc kd js')"
          mined:Baseline= "list('QH QD JC kD js')"
             mined:+Body= "['QH', 'Qd', 'JC', 'KD', 'JS']"
        mined:+Body, -NL= "['QH', 'Qd', 'JC', 'KD', 'JS']"
      mined:+Body, -Code= "['qh qd jc kd js'.split()"

================================================================================

QUESTION: idx=95     id=18168684
-------------------------------------INPUTS-------------------------------------

tags: xml, regex
score: 16
slot_map: {'key': ['str_0', 'var_0'], 'quote': ["'", '`'], 'type': ['str', 'var'], 'value': ['>.*<', 'line']}
intent: search for occurrences of regex pattern '>.*<' in xml string `line`
body(Some added characters for better readability):
	
	<p>I'm trying to use regex to parse an 
	`XML` file (in my case this seems the simplest way).
	For example a line might be:
	
	start_block
	line=' <City_State>PLAINSBORO, NJ 08536-1906 </City_State>'
	To access the text for the tag City_State, I'm using:
	
	start_block
	attr = re.match('>.* <', line)
	but nothing is being returned.
	Can someone point out what I'm doing wrong?


-------------------------------------OUTPUT-------------------------------------

                Expected= "print(re.search('>.*<', line).group(0))"
           base:Baseline= "print(re.search('>.*<')"
           base:+Canonic= "re.search('>.*<', line)"
           body:Baseline= "re.match('>.*<', line)"
              body:-Code= "print(re.search('>.*<', line))"
          mined:Baseline= "print(re.findall('>.*<', line))"
             mined:+Body= "re.findall('>.*<', line)"
        mined:+Body, -NL= "re.findall('>.*<', line)"
      mined:+Body, -Code= "print(re.search('>.*<', line))"

================================================================================

QUESTION: idx=96     id=4914277
-------------------------------------INPUTS-------------------------------------

tags: 
score: 73
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['filename']}
intent: erase all the contents of a file `filename`
body(Some added characters for better readability):
	In the Unix shell I can do this to empty a file:
	
	start_block
	cd /the/file/directory/
	:> thefile.ext
	How would I go about doing this in Python?
	
	<p>Is 
	`os.system`
	 the way here, I wouldn't know how since I would have to send 2 actions after each other i.e. the 
	`cd`
	 and then the 
	`:>`. 


-------------------------------------OUTPUT-------------------------------------

                Expected= "open(filename, 'w').close()"
           base:Baseline= "with open('filename') as f:\n    pass"
           base:+Canonic= 'os.erase(filename)'
           body:Baseline= 'os.system.exit(filename)'
              body:-Code= "os.system('shutdown', os.walk(filename)"
          mined:Baseline= "open('filename', 'w').close()"
             mined:+Body= "os.system('/the/file/directory/')"
        mined:+Body, -NL= "os.environ['filename'].close()"
      mined:+Body, -Code= "f = open('filename', 'r')"

================================================================================

QUESTION: idx=97     id=19068269
-------------------------------------INPUTS-------------------------------------

tags: datetime
score: 99
slot_map: {'key': ['str_0'], 'quote': ["'"], 'type': ['str'], 'value': ['%Y-%m-%d %H:%M:%S.%f']}
intent: convert a string into datetime using the format '%y-%m-%d %h:%m:%s.%f'
body(Some added characters for better readability):
	How do I convert a a string of datetime into datetime format in python so that it can be compared with another date?
	
	start_block
	string_date = "2013-09-28 20:30:55.78200"
	abc = datetime.datetime.now()
	if abc  > string_date :
	    print True


-------------------------------------OUTPUT-------------------------------------

                Expected= "datetime.datetime.strptime(string_date, '%Y-%m-%d %H:%M:%S.%f')"
           base:Baseline= "datetime.strptime('%Y-%m-%d %H:%M:%S.%f')"
           base:+Canonic= "datetime.strptime('%Y-%m-%d %H:%M:%S.%f')"
           body:Baseline= "time.strftime('%Y-%m-%d %H:%M:%S.%f')"
              body:-Code= "datetime.strptime('%Y-%m-%d %H:%M:%S.%f')"
          mined:Baseline= "datetime.strptime('2010-11-13 10:33:54.227806', '%Y-%m-%d %H:%M:%S.%f')"
             mined:+Body= "dt = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.%f')"
        mined:+Body, -NL= "date = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.%f')"
      mined:+Body, -Code= "datetime.strptime('2010-11-13 10:33:54.227806', '%Y-%m-%d %H:%M:%S.%f')"

================================================================================

QUESTION: idx=98     id=20683167
-------------------------------------INPUTS-------------------------------------

tags: list
score: 11
slot_map: {'key': ['str_0', 'var_0'], 'quote': ["'", '`'], 'type': ['str', 'var'], 'value': ['332', 'thelist']}
intent: find the index of a list with the first element equal to '332' within the list of lists `thelist`
body(Some added characters for better readability):
	The list is similar to this: 
	
	start_block
	[["12", "stuA", "stuB"], ["51", "stuC", "stuD"], <console_out>, ["3234", "moreStuff", "andMore"]]
	
	<p>Now I need to locate an item (get index) only by its first value (e.g. 
	`"332"`). Is there any better way to do this, apart from iterating from the first one to compare with each value?
	Code:
	
	start_block
	index = 0
	for item in thelist:
	    if item[0] == "332":
	         print index
	    index = index + 1


-------------------------------------OUTPUT-------------------------------------

                Expected= "[index for index, item in enumerate(thelist) if item[0] == '332']"
           base:Baseline= '[x[0] for x in thelist if x[0])'
           base:+Canonic= '[x[0] for x in zip(thelist, thelist)]'
           body:Baseline= "[x for x in thelist if x[0] == '332']"
              body:-Code= '[x[0] for x in thelist if x[1] == 332]'
          mined:Baseline= "[i for i, e in enumerate(thelist) if e == '332']"
             mined:+Body= "[x for x in thelist if x[0] == '332']"
        mined:+Body, -NL= "[x for x in thelist if x[0] == '332']"
      mined:+Body, -Code= "[i for i, x in enumerate(thelist) if x[0] == '332']"

================================================================================

QUESTION: idx=99     id=30693804
-------------------------------------INPUTS-------------------------------------

tags: 
score: 4
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['text']}
intent: lower a string `text` and remove non-alphanumeric characters aside from space
body(Some added characters for better readability):
	I'm trying to remove all non-alphanumeric characters except the space from a string, but can't seem to figure out how I exclude space. I'm currently doing it this way:
	
	start_block
	re.sub('[\W_]+', '', text).lower().strip()
	But running my function yields the following results:
	
	start_block
	print removePunctuation('Hi, you!')
	print removePunctuation(' No under_score!')
	hiyou
	nounderscore
	Where I want it to be:
	
	start_block
	hi you
	no underscore
	So how do I exclude space from being replaced?
	My current optimum is this:
	
	start_block
	re.sub('[^\s\w]+', '', text).lower().strip().replace('_','')


-------------------------------------OUTPUT-------------------------------------

                Expected= "re.sub('[^\\\\sa-zA-Z0-9]', '', text).lower().strip()"
           base:Baseline= "re.sub('[^a-zA-Z]', text)"
           base:+Canonic= "re.sub('[^a-zA-Z]', '', text)"
           body:Baseline= "re.sub('[^\\\\s\\\\w]+', '', text).lower().strip().replace('_', '')"
              body:-Code= "re.sub('\\\\w+\\\\s+', text)"
          mined:Baseline= "re.sub('[^a-zA-Z]+', '', text)"
             mined:+Body= "re.sub('[^\\\\s\\\\w]+', '', text).lower().strip().replace('_', '')"
        mined:+Body, -NL= "re.sub('[^\\\\s\\\\w]+', '', text).lower().strip().replace('_', '')"
      mined:+Body, -Code= "re.sub('\\\\s+', '', text)"

================================================================================

QUESTION: idx=100    id=30693804
-------------------------------------INPUTS-------------------------------------

tags: 
score: 4
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['text']}
intent: remove all non-alphanumeric characters except space from a string `text` and lower it
body(Some added characters for better readability):
	I'm trying to remove all non-alphanumeric characters except the space from a string, but can't seem to figure out how I exclude space. I'm currently doing it this way:
	
	start_block
	re.sub('[\W_]+', '', text).lower().strip()
	But running my function yields the following results:
	
	start_block
	print removePunctuation('Hi, you!')
	print removePunctuation(' No under_score!')
	hiyou
	nounderscore
	Where I want it to be:
	
	start_block
	hi you
	no underscore
	So how do I exclude space from being replaced?
	My current optimum is this:
	
	start_block
	re.sub('[^\s\w]+', '', text).lower().strip().replace('_','')


-------------------------------------OUTPUT-------------------------------------

                Expected= "re.sub('(?!\\\\s)[\\\\W_]', '', text).lower().strip()"
           base:Baseline= '"""""".join(re.sub(\'[^a-zA-Z]\', text))'
           base:+Canonic= "re.sub('[^a-zA-Z]', '', text)"
           body:Baseline= "re.sub('[^\\\\s\\\\w]+', '', text).lower().strip().replace('_', '')"
              body:-Code= "re.sub('\\\\w+', text)"
          mined:Baseline= "re.sub('[^a-zA-Z]', '', text)"
             mined:+Body= "re.sub('[^\\\\s\\\\w]+', '', text).lower().replace('_', '')"
        mined:+Body, -NL= "re.sub('[^\\\\s\\\\w]+', '', text).lower().strip().replace('_', '')"
      mined:+Body, -Code= "re.sub('\\\\s+', '', text)"

================================================================================

QUESTION: idx=101    id=17138464
-------------------------------------INPUTS-------------------------------------

tags: matplotlib, label, output, subscript
score: 4
slot_map: {'key': ['str_0', 'str_1', 'str_2', 'str_3'], 'quote': ["'", "'", "'", "'"], 'type': ['str', 'str', 'str', 'str'], 'value': ['H20', '2', 'x', 'y']}
intent: subscript text 'h20' with '2' as subscripted in matplotlib labels for arrays 'x' and 'y'.
body(Some added characters for better readability):
	this is my first question and I am a noob at python. So probably more to follow...
	I would like to create a figure with matplotlib. In the labels, I would like to include a chemical formula, which involves subscripts (I think the same would work for superscripts...).
	Anyway, I have no idea, how the label would have to look like.
	
	start_block
	import numpy as nu
	import pylab as plt
	x = nu.array([1,2,3,4])
	y = nu.array([1,2,3,4])
	plt.plot(x,y, label='H2O')
	plt.legend(loc=1)
	plt.show()
	Ok, this gives me a plot with the label "H2O". How can I subscript the "2" in the label, as is common for chemical formulae?
	I searched the web, but I didn't find anything useful yet.
	I figured that I could use 
	
	start_block
	from matplotlib import rc
	rc['text', usetex=True]
	but I don't want to use it (I know how to use LaTeX, but I don't want here). 
	Another option is:
	
	start_block
	label='H$_2$O'
	but this changes the font (math).
	There MUST be a way, how does subscripting in matplotlib-legends work?
	Thanks a lot!


-------------------------------------OUTPUT-------------------------------------

                Expected= "plt.plot(x, y, label='HO')"
           base:Baseline= "ax.set_label('h20', '2')"
           base:+Canonic= "plt.subscript('H20', '2')"
           body:Baseline= "plt.subscript('H$_2$O')"
              body:-Code= "legend.legend('H20', '2')"
          mined:Baseline= "plt.subplots_adjust(x, y, label='H20')"
             mined:+Body= "plt.plot(x, y, label='H2O')"
        mined:+Body, -NL= "rc['text', usetex=True, label='H$_2$O')"
      mined:+Body, -Code= "ax.set_xlabel('H20')"

================================================================================

QUESTION: idx=102    id=17138464
-------------------------------------INPUTS-------------------------------------

tags: matplotlib, label, output, subscript
score: 4
slot_map: {'key': ['str_0', 'str_1', 'str_2', 'str_3'], 'quote': ["'", "'", "'", "'"], 'type': ['str', 'str', 'str', 'str'], 'value': ['H20', '2', 'x', 'y']}
intent: subscript text 'h20' with '2' as subscripted in matplotlib labels for arrays 'x' and 'y'.
body(Some added characters for better readability):
	this is my first question and I am a noob at python. So probably more to follow...
	I would like to create a figure with matplotlib. In the labels, I would like to include a chemical formula, which involves subscripts (I think the same would work for superscripts...).
	Anyway, I have no idea, how the label would have to look like.
	
	start_block
	import numpy as nu
	import pylab as plt
	x = nu.array([1,2,3,4])
	y = nu.array([1,2,3,4])
	plt.plot(x,y, label='H2O')
	plt.legend(loc=1)
	plt.show()
	Ok, this gives me a plot with the label "H2O". How can I subscript the "2" in the label, as is common for chemical formulae?
	I searched the web, but I didn't find anything useful yet.
	I figured that I could use 
	
	start_block
	from matplotlib import rc
	rc['text', usetex=True]
	but I don't want to use it (I know how to use LaTeX, but I don't want here). 
	Another option is:
	
	start_block
	label='H$_2$O'
	but this changes the font (math).
	There MUST be a way, how does subscripting in matplotlib-legends work?
	Thanks a lot!


-------------------------------------OUTPUT-------------------------------------

                Expected= "plt.plot(x, y, label='$H_2O$')"
           base:Baseline= "ax.set_label('h20', '2')"
           base:+Canonic= "plt.subscript('H20', '2')"
           body:Baseline= "plt.subscript('H$_2$O')"
              body:-Code= "legend.legend('H20', '2')"
          mined:Baseline= "plt.subplots_adjust(x, y, label='H20')"
             mined:+Body= "plt.plot(x, y, label='H2O')"
        mined:+Body, -NL= "rc['text', usetex=True, label='H$_2$O')"
      mined:+Body, -Code= "ax.set_xlabel('H20')"

================================================================================

QUESTION: idx=103    id=9138112
-------------------------------------INPUTS-------------------------------------

tags: list
score: 186
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['mylist']}
intent: loop over a list `mylist` if sublists length equals 3
body(Some added characters for better readability):
	I have a list with sublists in it. I want to print all the sublists with length equal to 3.
	I am doing the following in python:
	
	start_block
	for x in values[:]:
	    if len(x) == 3:
	        print(x)
	
	`values`
	 is the original list. Does the above code print every sublist with length equal to 3 for each value of 
	`x`
	? I want to display the sublists where 
	`length == 3` only once.
	The problem is solved. The problem is with the Eclipse editor. I don't understand the reason, but it is displaying only half of my list when I run my loop.
	Are there any settings I have to change in Eclipse?


-------------------------------------OUTPUT-------------------------------------

                Expected= '[x for x in mylist if len(x) == 3]'
           base:Baseline= '[x for x in myList if x[3] == 3]'
           base:+Canonic= '[sublist for sublist in mylist if len(mylist) > 3]'
           body:Baseline= 'print(len(mylist) if len(x) == 3)'
              body:-Code= 'print(sublist for sublist in mylist if len(mylist))'
          mined:Baseline= '[list(range(len(myList)) for _ in range(3)]'
             mined:+Body= '[sublist for sublist in mylist if len(x) == 3]'
        mined:+Body, -NL= '[len(x) for x in mylist if len(y) == 3]'
      mined:+Body, -Code= 'print([list(range(len(mylist)) for i in range(3)) for y in mylist]'

================================================================================

QUESTION: idx=104    id=1807026
-------------------------------------INPUTS-------------------------------------

tags: arrays, list, initialization
score: 18
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['lst']}
intent: initialize a list `lst` of 100 objects object()
body(Some added characters for better readability):
	I'm a  looking to initialize an array/list of objects that are not empty -- the class constructor generates data. In C++ and Java I would do something like this:
	
	start_block
	Object lst = new Object[100];
	I've dug around, but is there a Pythonic way to get this done?
	This doesn't work like I thought it would (I get 100 references to the same object):
	
	start_block
	lst = [Object()]*100
	But this seems to work in the way I want:
	
	start_block
	lst = [Object() for i in range(100)]
	List comprehension seems (intellectually) like "a lot" of work for something that's so simple in Java.


-------------------------------------OUTPUT-------------------------------------

                Expected= 'lst = [Object() for _ in range(100)]'
           base:Baseline= 'lst = [x[0] for x in lst]'
           base:+Canonic= 'lst = [i for i in range(100)]'
           body:Baseline= 'lst = [Object() for i in range(100)]'
              body:-Code= 'lst = [i for i in range(100)]'
          mined:Baseline= 'lst = [i for i in range(100)]'
             mined:+Body= 'lst = [Object() for i in range(100)]'
        mined:+Body, -NL= 'lst = [Object() for i in range(100)]'
      mined:+Body, -Code= 'lst = [i for i in range(100)]'

================================================================================

QUESTION: idx=105    id=1807026
-------------------------------------INPUTS-------------------------------------

tags: arrays, list, initialization
score: 18
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['lst', 'Object']}
intent: create list `lst` containing 100 instances of object `object`
body(Some added characters for better readability):
	I'm a  looking to initialize an array/list of objects that are not empty -- the class constructor generates data. In C++ and Java I would do something like this:
	
	start_block
	Object lst = new Object[100];
	I've dug around, but is there a Pythonic way to get this done?
	This doesn't work like I thought it would (I get 100 references to the same object):
	
	start_block
	lst = [Object()]*100
	But this seems to work in the way I want:
	
	start_block
	lst = [Object() for i in range(100)]
	List comprehension seems (intellectually) like "a lot" of work for something that's so simple in Java.


-------------------------------------OUTPUT-------------------------------------

                Expected= 'lst = [Object() for i in range(100)]'
           base:Baseline= 'lst = [x[0] for x in object]'
           base:+Canonic= 'lst = [x for x in Object]'
           body:Baseline= 'lst = [Object() for i in range(100)]'
              body:-Code= 'lst = [i for i in range(100)]'
          mined:Baseline= 'lst = [x for x in range(100)]'
             mined:+Body= 'lst = [Object() for i in range(100)]'
        mined:+Body, -NL= 'lst = [x for x in range(100)]'
      mined:+Body, -Code= 'lst = [i for i in range(100)]'

================================================================================

QUESTION: idx=106    id=19664253
-------------------------------------INPUTS-------------------------------------

tags: html, css, xpath, selenium
score: 25
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['href', 'someclass']}
intent: get the content of child tag with`href` attribute whose parent has css `someclass`
body(Some added characters for better readability):
	I am trying to retrieve the data from the webpage has the html in below
	
	start_block
	       <div class="someclass">
	       <p class="name"> <a href="#/word/1/">helloworld </a> </p>
	       </div>
	My goal is to parse "#/word/1/"
	What I did is 
	
	start_block
	        target = self.driver.find_element_by_class_name('someclass')
	        print target
	        print target.text
	        print target.get_attribute("css=a@href")
	        print target.tag_name
	but the output are 
	
	start_block
	 <selenium.webdriver.remote.webelement.WebElement object at 0x10bf16210>
	 helloworld
	 None
	 div 
	I tried so many ways , it seems there is no way i can get the content of 'a href' within the targeted class.
	I really dont want to do is get the source code of the page, and then do a string searching, that seems dumb....
	anyway to get that?


-------------------------------------OUTPUT-------------------------------------

                Expected= "self.driver.find_element_by_css_selector('.someclass a').get_attribute('href')"
           base:Baseline= 'browser.find_element_by_css_selector(href, parent=someClass)'
           base:+Canonic= "browser.find_element_by_id('href', parent=someclass)"
           body:Baseline= "self.driver.find_element_by_class_name('someclass')"
              body:-Code= "Child.find_element_by_css_selector('someclass')"
          mined:Baseline= "href = child.page.get('someclass')"
             mined:+Body= "print(target.get_attribute('css=a@href')"
        mined:+Body, -NL= "target.get_attribute('css=a@href')"
      mined:+Body, -Code= "print(link.get('a', href=re.compile('#/word/1'))"

================================================================================

QUESTION: idx=107    id=13793321
-------------------------------------INPUTS-------------------------------------

tags: pandas
score: 9
slot_map: {'key': ['var_0', 'var_1', 'str_0'], 'quote': ['`', '`', "'"], 'type': ['var', 'var', 'str'], 'value': ['df1', 'df2', 'Date_Time']}
intent: joining data from dataframe `df1` with data from dataframe `df2` based on matching values of column 'date_time' in both dataframes
body(Some added characters for better readability):
	I have two DataFrames:
	
	start_block
	df1 = ['Date_Time',
	    'Temp_1',
	    'Latitude',
	    'N_S',
	    'Longitude',
	    'E_W']
	df2 = ['Date_Time',
	    'Year',
	    'Month',
	    'Day',
	    'Hour',
	    'Minute',
	    'Seconds']
	
	<p>As You can see both DataFrames have 
	`Date_Time`
	 as a common column. I want to Join these two DataFrames by matching 
	`Date_Time`.
	
	<p>My current code is: 
	`df.join(df2, on='Date_Time')`, but this is giving an error.


-------------------------------------OUTPUT-------------------------------------

                Expected= "df1.merge(df2, on='Date_Time')"
           base:Baseline= "pd.merge(df1, df2, how='date_time')"
           base:+Canonic= "pd.merge(var_0, pd.DataFrame(['str_0','str_1'])"
           body:Baseline= "df1.join(df2, on='Date_Time')"
              body:-Code= "pd.merge(df1, df2, how='date_time')"
          mined:Baseline= "df1.merge(df2, on='Date_Time')"
             mined:+Body= "pd.merge(df1, df2, on='Date_Time')"
        mined:+Body, -NL= 'pd.concat([df1, df2], axis=1)'
      mined:+Body, -Code= "df1.merge(df2, how='left', on='date_time')"

================================================================================

QUESTION: idx=108    id=3367288
-------------------------------------INPUTS-------------------------------------

tags: 
score: 14
slot_map: {'key': ['str_0', 'var_0'], 'quote': ['`', '`'], 'type': ['str', 'var'], 'value': ['%s', 'str1']}
intent: use `%s` operator to print variable values `str1` inside a string
body(Some added characters for better readability):
	
	<p>I want to introduce a variable 
	`[i]` into a string in Python.
	
	<p>For example look at the following script. I just want to be able to give a name to the image, for example 
	`geo[0].tif`
	 
	...to 
	`geo[i].tif`, or if you use an accountant as I can replace a portion of the value chain to generate a counter.
	
	start_block
	data = self.cmd("r.out.gdal in=rdata out=geo.tif")
	self.dataOutTIF.setValue("geo.tif")


-------------------------------------OUTPUT-------------------------------------

                Expected= "'first string is: %s, second one is: %s' % (str1, 'geo.tif')"
           base:Baseline= '"""""".join(str1, str1))'
           base:+Canonic= "print('%s'.format(str1))"
           body:Baseline= '"""{0:.2f}""".format(str1)'
              body:-Code= "print('%s', str1)"
          mined:Baseline= "print('%s %s' % str1)"
             mined:+Body= '"""""".join(str1)'
        mined:+Body, -NL= "print('\\n'.join(str1))"
      mined:+Body, -Code= '"""""".join(str1)'

================================================================================

QUESTION: idx=109    id=3475251
-------------------------------------INPUTS-------------------------------------

tags: string, list, split
score: 209
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: split a string by a delimiter in python
body(Some added characters for better readability):
	
	<p>How to split this string where 
	`__` is the delimiter
	
	start_block
	MATCHES__STRING
	
	<p>To get an output of 
	`['MATCHES', 'STRING']`?


-------------------------------------OUTPUT-------------------------------------

                Expected= "[x.strip() for x in '2.MATCHES $$TEXT$$ STRING'.split('$$TEXT$$')]"
           base:Baseline= '""" """.join(str(x) for x in s.split(\',\')'
           base:+Canonic= "re.split('\\\\w+', '', delimiter=',')"
           body:Baseline= '"""MATCHES__STRING""".split())'
              body:-Code= "re.split('\\n', '', str)"
          mined:Baseline= '""" """.join(map(str, s.split(\',\'))'
             mined:+Body= '"""MATCHES__STRING""".split(\',\')'
        mined:+Body, -NL= '"""MATCHES__STRING""".split()'
      mined:+Body, -Code= "s.split(' ', 1)[1]"

================================================================================

QUESTION: idx=110    id=273192
-------------------------------------INPUTS-------------------------------------

tags: exception, path, directory, operating-system
score: 4616
slot_map: {'key': ['str_0'], 'quote': ['`'], 'type': ['str'], 'value': ['directory']}
intent: check if directory `directory ` exists and create it if necessary
body(Some added characters for better readability):
	What is the most elegant way to check if the directory a file is going to be written to exists, and if not, create the directory using Python? Here is what I tried:
	
	start_block
	import os
	file_path = "/my/directory/filename.txt"
	directory = os.path.dirname(file_path)
	try:
	    os.stat(directory)
	except:
	    os.mkdir(directory)       
	f = file(filename)
	
	<p>Somehow, I missed 
	`os.path.exists` (thanks kanja, Blair, and Douglas). This is what I have now:
	
	start_block
	def ensure_dir(file_path):
	    directory = os.path.dirname(file_path)
	    if not os.path.exists(directory):
	        os.makedirs(directory)
	Is there a flag for "open", that makes this happen automatically?


-------------------------------------OUTPUT-------------------------------------

                Expected= 'if not os.path.exists(directory):\n    os.makedirs(directory)'
           base:Baseline= "os.system('directory ` exists')"
           base:+Canonic= "print(os.path.exists('directory'))"
           body:Baseline= 'os.path.exists(directory)'
              body:-Code= 'os.path.exists(directory)'
          mined:Baseline= 'os.path.isfile(directory)'
             mined:+Body= 'os.path.exists(directory)'
        mined:+Body, -NL= 'os.path.exists(directory)'
      mined:+Body, -Code= 'os.path.exists(directory)'

================================================================================

QUESTION: idx=111    id=273192
-------------------------------------INPUTS-------------------------------------

tags: exception, path, directory, operating-system
score: 4616
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['path']}
intent: check if a directory `path` exists and create it if necessary
body(Some added characters for better readability):
	What is the most elegant way to check if the directory a file is going to be written to exists, and if not, create the directory using Python? Here is what I tried:
	
	start_block
	import os
	file_path = "/my/directory/filename.txt"
	directory = os.path.dirname(file_path)
	try:
	    os.stat(directory)
	except:
	    os.mkdir(directory)       
	f = file(filename)
	
	<p>Somehow, I missed 
	`os.path.exists` (thanks kanja, Blair, and Douglas). This is what I have now:
	
	start_block
	def ensure_dir(file_path):
	    directory = os.path.dirname(file_path)
	    if not os.path.exists(directory):
	        os.makedirs(directory)
	Is there a flag for "open", that makes this happen automatically?


-------------------------------------OUTPUT-------------------------------------

                Expected= 'try:\n    os.makedirs(path)\nexcept OSError:\n    if not os.path.isdir(path):\n        raise'
           base:Baseline= 'os.path.exception(path)'
           base:+Canonic= 'print(os.path.exists(path))'
           body:Baseline= 'os.path.exists(path)'
              body:-Code= 'os.path.exists(path)'
          mined:Baseline= 'os.path.exists(path)'
             mined:+Body= 'os.path.exists(path)'
        mined:+Body, -NL= 'os.path.exists(path)'
      mined:+Body, -Code= 'print(os.path.dirname(path))'

================================================================================

QUESTION: idx=112    id=273192
-------------------------------------INPUTS-------------------------------------

tags: exception, path, directory, operating-system
score: 4616
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['path']}
intent: check if a directory `path` exists and create it if necessary
body(Some added characters for better readability):
	What is the most elegant way to check if the directory a file is going to be written to exists, and if not, create the directory using Python? Here is what I tried:
	
	start_block
	import os
	file_path = "/my/directory/filename.txt"
	directory = os.path.dirname(file_path)
	try:
	    os.stat(directory)
	except:
	    os.mkdir(directory)       
	f = file(filename)
	
	<p>Somehow, I missed 
	`os.path.exists` (thanks kanja, Blair, and Douglas). This is what I have now:
	
	start_block
	def ensure_dir(file_path):
	    directory = os.path.dirname(file_path)
	    if not os.path.exists(directory):
	        os.makedirs(directory)
	Is there a flag for "open", that makes this happen automatically?


-------------------------------------OUTPUT-------------------------------------

                Expected= 'distutils.dir_util.mkpath(path)'
           base:Baseline= 'os.path.exception(path)'
           base:+Canonic= 'print(os.path.exists(path))'
           body:Baseline= 'os.path.exists(path)'
              body:-Code= 'os.path.exists(path)'
          mined:Baseline= 'os.path.exists(path)'
             mined:+Body= 'os.path.exists(path)'
        mined:+Body, -NL= 'os.path.exists(path)'
      mined:+Body, -Code= 'print(os.path.dirname(path))'

================================================================================

QUESTION: idx=113    id=273192
-------------------------------------INPUTS-------------------------------------

tags: exception, path, directory, operating-system
score: 4616
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['path']}
intent: check if a directory `path` exists and create it if necessary
body(Some added characters for better readability):
	What is the most elegant way to check if the directory a file is going to be written to exists, and if not, create the directory using Python? Here is what I tried:
	
	start_block
	import os
	file_path = "/my/directory/filename.txt"
	directory = os.path.dirname(file_path)
	try:
	    os.stat(directory)
	except:
	    os.mkdir(directory)       
	f = file(filename)
	
	<p>Somehow, I missed 
	`os.path.exists` (thanks kanja, Blair, and Douglas). This is what I have now:
	
	start_block
	def ensure_dir(file_path):
	    directory = os.path.dirname(file_path)
	    if not os.path.exists(directory):
	        os.makedirs(directory)
	Is there a flag for "open", that makes this happen automatically?


-------------------------------------OUTPUT-------------------------------------

                Expected= 'try:\n    os.makedirs(path)\nexcept OSError as exception:\n    if exception.errno != errno.EEXIST:\n        raise'
           base:Baseline= 'os.path.exception(path)'
           base:+Canonic= 'print(os.path.exists(path))'
           body:Baseline= 'os.path.exists(path)'
              body:-Code= 'os.path.exists(path)'
          mined:Baseline= 'os.path.exists(path)'
             mined:+Body= 'os.path.exists(path)'
        mined:+Body, -NL= 'os.path.exists(path)'
      mined:+Body, -Code= 'print(os.path.dirname(path))'

================================================================================

QUESTION: idx=114    id=18785032
-------------------------------------INPUTS-------------------------------------

tags: string, replace
score: 4
slot_map: {'key': ['str_0', 'str_1', 'str_2'], 'quote': ["'", "'", "'"], 'type': ['str', 'str', 'str'], 'value': ['H3', 'H1', 'text']}
intent: replace a separate word 'h3' by 'h1' in a string 'text'
body(Some added characters for better readability):
	I am trying to replace a string i.e. "H3" in a file with "H1" but I want only "H3" to get replaced and not "mmmoleculeH3" to become "mmmoleculeH1". I tried re but my limited knowledge in python didn't get me anywhere. If there is any other method than that would be great.script that i am using now is:
	
	start_block
	#!/usr/bin/python
	import fileinput
	import sys
	def replaceAll(file,searchExp,replaceExp):
	    for line in fileinput.input(file, inplace=1):
	        if searchExp in line:
	            line = line.replace(searchExp,replaceExp)
	        sys.stdout.write(line)
	replaceAll("boxFile.cof","H3","H1")
	If there is any way i can do it with this itself without using re then that would be great.Thanks in advance.


-------------------------------------OUTPUT-------------------------------------

                Expected= "re.sub('\\\\bH3\\\\b', 'H1', text)"
           base:Baseline= "text = 'h3'.replace('h1', 'h1')"
           base:+Canonic= '"""text""".replace(\'H3\', \'H1\')'
           body:Baseline= "text = re.sub('boxFile.cof', 'H3', text)"
              body:-Code= "re.sub('(?=H1)', 'H3', text)"
          mined:Baseline= "text = re.sub('(\\\\w+)', '\\\\1', text)"
             mined:+Body= "re.sub('((\\\\w+)', '\\\\1', text)"
        mined:+Body, -NL= "line = line.replace('h3', '')"
      mined:+Body, -Code= "text = re.sub('(\\\\w+)', '\\\\1', text)"

================================================================================

QUESTION: idx=115    id=1450897
-------------------------------------INPUTS-------------------------------------

tags: string
score: 148
slot_map: {'key': ['str_0', 'str_1'], 'quote': ["'", "'"], 'type': ['str', 'str'], 'value': ['aas30dsa20', '']}
intent: substitute ascii letters in string 'aas30dsa20' with empty string ''
body(Some added characters for better readability):
	How can I remove all characters except numbers from string?


-------------------------------------OUTPUT-------------------------------------

                Expected= "re.sub('\\\\D', '', 'aas30dsa20')"
           base:Baseline= '"""""".join((\'aas30dsA20\', \'\'))'
           base:+Canonic= '"""aas30dsa20""".replace(\'\')'
           body:Baseline= '"""aas30dsa20""".replace(\'\', \'\')'
              body:-Code= '"""Aas30dsA20""".replace(\'\', \'\')'
          mined:Baseline= '"""aas30dsa20""".replace(\'\', \'\')'
             mined:+Body= '"""aas30dsa20""".replace(\' \', \'\')'
        mined:+Body, -NL= '"""aas30dsa20""".encode(\'ascii\')'
      mined:+Body, -Code= '"""aas30dsa20""".replace(\' \', \'\')'

================================================================================

QUESTION: idx=116    id=1450897
-------------------------------------INPUTS-------------------------------------

tags: string
score: 148
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['aas30dsa20']}
intent: get digits only from a string `aas30dsa20` using lambda function
body(Some added characters for better readability):
	How can I remove all characters except numbers from string?


-------------------------------------OUTPUT-------------------------------------

                Expected= '"""""".join([x for x in \'aas30dsa20\' if x.isdigit()])'
           base:Baseline= '"""""".join(lambda x: x[0] for x in aas30dsa20))'
           base:+Canonic= '"""""".join(lambda x: int(x.split()) for x in aas30dsa20)'
           body:Baseline= '"""""".join(str(aas30dsa20))'
              body:-Code= "re.sub('\\\\d+', 'aas30dsA20')"
          mined:Baseline= '"""aas30dsa20""".decode(\'utf-8\')'
             mined:+Body= '"""""".join(str(aas30dsa20))'
        mined:+Body, -NL= '"""""".join(str(aas30dsa20))'
      mined:+Body, -Code= '"""""".join(c for c in a if c.isdigit())'

================================================================================

QUESTION: idx=117    id=14435268
-------------------------------------INPUTS-------------------------------------

tags: xml, beautifulsoup
score: 16
slot_map: {'key': ['str_0', 'var_0'], 'quote': ['"', '`'], 'type': ['str', 'var'], 'value': ['name', 'soup']}
intent: access a tag called "name" in beautifulsoup `soup`
body(Some added characters for better readability):
	
	<p>I want to access a tag called as 
	`"name"` such as:
	
	
	start_block
	<name>Yesugey </name> <lastName>Yesil </lastName> <phone>+90 333 9695395 </phone> </contact>
	
	<p>Since 
	`"name"`
	 is a property of a BeautifulSoup tag object, I cannot access the child tag 
	`name`:
	
	
	start_block
	>>>c1
	<name>Yesugey </name> <lastname>Yesil </lastname> <phone>+90 333 9695395 </p
	hone> </contact>
	>>>c1.name
	...'contact'
	>>>c1.lastname
	<lastname>Yesil </lastname>


-------------------------------------OUTPUT-------------------------------------

                Expected= "print(soup.find('name').string)"
           base:Baseline= "soup.find_all('name')"
           base:+Canonic= "soup.find_all('name')"
           body:Baseline= "soup.findall('name')"
              body:-Code= "soup.findChild('name')"
          mined:Baseline= "soup.findAll(attrs={'name': 'name'})"
             mined:+Body= "soup.findAll('name')"
        mined:+Body, -NL= "soup.find_all('contact', {'lastname': 'Yesil'})"
      mined:+Body, -Code= "soup.findAll('name')"

================================================================================

QUESTION: idx=118    id=4928274
-------------------------------------INPUTS-------------------------------------

tags: mongodb, pymongo
score: 13
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['records', 'cursor']}
intent: get a dictionary `records` of key-value pairs in pymongo cursor `cursor`
body(Some added characters for better readability):
	
	<p>Is it possible to iterate over a pymongo 
	`Cursor`
	 as a key-value pair like a 
	`dict`? I'm using python 2.6 and pymongo 1.9.
	I've tried this:
	
	start_block
	import pymongo
	mongo = pymongo.Connection('localhost')
	mongo_db = mongo['my_database']
	mongo_coll = mongo_db['my_collection']
	cursor = mongo_coll.find()
	records = dict([(record_id, record) for record_id, record in mongo_cursor])
	But I get the error:
	
	start_block
	ValueError: too many values to unpack


-------------------------------------OUTPUT-------------------------------------

                Expected= "records = dict((record['_id'], record) for record in cursor)"
           base:Baseline= '[(k, v) for k, v in pymongo.cursor.items()]'
           base:+Canonic= 'records = pymongo.dict((k, v) for k, v in cursor.items())'
           body:Baseline= 'records = dict((key, value) for key, value in cursor)'
              body:-Code= 'records = pymongo.dict((k, v) for k, v in cursor.items())'
          mined:Baseline= "db.cursor.setdefault(cursor, {'key1': 1, 'key2': 1})"
             mined:+Body= 'records = dict([(record_id, record) for record_id in mongo_cursor])'
        mined:+Body, -NL= 'cursor = mongo_coll.find_all(list(d.keys()))'
      mined:+Body, -Code= 'cursor.setdefault(key, []).append(records)'

================================================================================

QUESTION: idx=119    id=20180210
-------------------------------------INPUTS-------------------------------------

tags: numpy, matrix
score: 28
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: create new matrix object  by concatenating data from matrix a and matrix b
body(Some added characters for better readability):
	new to Python, struggling in numpy, hope someone can help me, thank you!
	
	start_block
	from numpy  import *   
	A = matrix('1.0 2.0; 3.0 4.0')    
	B = matrix('5.0 6.0')
	C = matrix('1.0 2.0; 3.0 4.0; 5.0 6.0')
	print "A=",A
	print "B=",B
	print "C=",C
	results:
	
	start_block
	A= [[ 1.  2.]
	   [ 3.  4.]]
	B= [[ 5.  6.]]
	C= [[ 1.  2.]
	   [ 3.  4.]
	   [ 5.  6.]]
	
	<p>Question: how to use A and B to generate C, like in matlab 
	`C=[A;B]`?


-------------------------------------OUTPUT-------------------------------------

                Expected= 'np.concatenate((A, B))'
           base:Baseline= 'np.concatenate(a, b)'
           base:+Canonic= 'numpy.concat([(a, b), (c, d), (d, e)])'
           body:Baseline= 'np.concat([A, B], axis=1)'
              body:-Code= 'np.concat([A, B], axis=1)'
          mined:Baseline= 'matrix.from_iterable(a, b)'
             mined:+Body= 'C = np.concatenate(A, B)'
        mined:+Body, -NL= 'np.concatenate((A, B))'
      mined:+Body, -Code= 'C = np.concatenate((A, B), axis=1)'

================================================================================

QUESTION: idx=120    id=20180210
-------------------------------------INPUTS-------------------------------------

tags: numpy, matrix
score: 28
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['A', 'B']}
intent: concat two matrices `a` and `b` in numpy
body(Some added characters for better readability):
	new to Python, struggling in numpy, hope someone can help me, thank you!
	
	start_block
	from numpy  import *   
	A = matrix('1.0 2.0; 3.0 4.0')    
	B = matrix('5.0 6.0')
	C = matrix('1.0 2.0; 3.0 4.0; 5.0 6.0')
	print "A=",A
	print "B=",B
	print "C=",C
	results:
	
	start_block
	A= [[ 1.  2.]
	   [ 3.  4.]]
	B= [[ 5.  6.]]
	C= [[ 1.  2.]
	   [ 3.  4.]
	   [ 5.  6.]]
	
	<p>Question: how to use A and B to generate C, like in matlab 
	`C=[A;B]`?


-------------------------------------OUTPUT-------------------------------------

                Expected= 'np.vstack((A, B))'
           base:Baseline= 'np.concat([a, b])'
           base:+Canonic= 'numpy.concat([A, B])'
           body:Baseline= 'np.concat([A, B], axis=1)'
              body:-Code= 'numpy.concat([a, b])'
          mined:Baseline= 'np.concatenate((a, b), axis=1)'
             mined:+Body= 'np.concatenate(A, B)'
        mined:+Body, -NL= 'np.concatenate((A, B), axis=1)'
      mined:+Body, -Code= 'np.concatenate(a, b, axis=1)'

================================================================================

QUESTION: idx=121    id=2011048
-------------------------------------INPUTS-------------------------------------

tags: size, character
score: 6
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['filepath']}
intent: get the characters count in a file `filepath`
body(Some added characters for better readability):
	I have a python code which reads many files.
	but some files are extremely large due to which i have errors coming in other codes.
	i want a way in which i can check for the character count of the files so that i avoid reading those extremely large files.
	Thanks.


-------------------------------------OUTPUT-------------------------------------

                Expected= 'os.stat(filepath).st_size'
           base:Baseline= 'print(os.path.get(filepath))'
           base:+Canonic= 'print(filepath.count())'
           body:Baseline= 'print(os.path.count(filepath))'
              body:-Code= 'print(os.path.count(filepath))'
          mined:Baseline= 'count = sum(len(filepath))'
             mined:+Body= "len(open('filepath').read())"
        mined:+Body, -NL= 'print(len(os.path.join(filepath, filepath)))'
      mined:+Body, -Code= 'len(filepath) == len(filePath)'

================================================================================

QUESTION: idx=122    id=2600191
-------------------------------------INPUTS-------------------------------------

tags: list, count
score: 1706
slot_map: {'key': ['str_0', 'var_0'], 'quote': ['"', '`'], 'type': ['str', 'var'], 'value': ['a', 'l']}
intent: count the occurrences of item "a" in list `l`
body(Some added characters for better readability):
	Given an item, how can I count its occurrences in a list in Python?


-------------------------------------OUTPUT-------------------------------------

                Expected= "l.count('a')"
           base:Baseline= "sum(x['a'] for x in L)"
           base:+Canonic= "count('a', l)"
           body:Baseline= 'str(l) for l in L)'
              body:-Code= "sum(item for item in L if item == 'a')"
          mined:Baseline= "sum(1 for x in l if x == 'A')"
             mined:+Body= "Counter({'a': a, 'b': a})"
        mined:+Body, -NL= 'len(L) - len(L))'
      mined:+Body, -Code= "sum(1 for item in L if item == 'A')"

================================================================================

QUESTION: idx=123    id=2600191
-------------------------------------INPUTS-------------------------------------

tags: list, count
score: 1706
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['l']}
intent: count the occurrences of items in list `l`
body(Some added characters for better readability):
	Given an item, how can I count its occurrences in a list in Python?


-------------------------------------OUTPUT-------------------------------------

                Expected= 'Counter(l)'
           base:Baseline= 'count(x) for x in L)'
           base:+Canonic= 'sum(x for x in l)'
           body:Baseline= 'count(x for x in L)'
              body:-Code= 'sum(x for x in l)'
          mined:Baseline= 'sum(1 for i in l)'
             mined:+Body= 'Counter({x for x in l if x % 2 == 0}'
        mined:+Body, -NL= 'Counter(L, key=lambda x: x[1])'
      mined:+Body, -Code= 'sum(1 for item in L)'

================================================================================

QUESTION: idx=124    id=2600191
-------------------------------------INPUTS-------------------------------------

tags: list, count
score: 1706
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['l']}
intent: count the occurrences of items in list `l`
body(Some added characters for better readability):
	Given an item, how can I count its occurrences in a list in Python?


-------------------------------------OUTPUT-------------------------------------

                Expected= '[[x, l.count(x)] for x in set(l)]'
           base:Baseline= 'count(x) for x in L)'
           base:+Canonic= 'sum(x for x in l)'
           body:Baseline= 'count(x for x in L)'
              body:-Code= 'sum(x for x in l)'
          mined:Baseline= 'sum(1 for i in l)'
             mined:+Body= 'Counter({x for x in l if x % 2 == 0}'
        mined:+Body, -NL= 'Counter(L, key=lambda x: x[1])'
      mined:+Body, -Code= 'sum(1 for item in L)'

================================================================================

QUESTION: idx=125    id=2600191
-------------------------------------INPUTS-------------------------------------

tags: list, count
score: 1706
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['l']}
intent: count the occurrences of items in list `l`
body(Some added characters for better readability):
	Given an item, how can I count its occurrences in a list in Python?


-------------------------------------OUTPUT-------------------------------------

                Expected= 'dict((x, l.count(x)) for x in set(l))'
           base:Baseline= 'count(x) for x in L)'
           base:+Canonic= 'sum(x for x in l)'
           body:Baseline= 'count(x for x in L)'
              body:-Code= 'sum(x for x in l)'
          mined:Baseline= 'sum(1 for i in l)'
             mined:+Body= 'Counter({x for x in l if x % 2 == 0}'
        mined:+Body, -NL= 'Counter(L, key=lambda x: x[1])'
      mined:+Body, -Code= 'sum(1 for item in L)'

================================================================================

QUESTION: idx=126    id=2600191
-------------------------------------INPUTS-------------------------------------

tags: list, count
score: 1706
slot_map: {'key': ['str_0', 'var_0'], 'quote': ['"', '`'], 'type': ['str', 'var'], 'value': ['b', 'l']}
intent: count the occurrences of item "b" in list `l`
body(Some added characters for better readability):
	Given an item, how can I count its occurrences in a list in Python?


-------------------------------------OUTPUT-------------------------------------

                Expected= "l.count('b')"
           base:Baseline= "sum(x['b'] for x in L)"
           base:+Canonic= "count('b', l)"
           body:Baseline= "x for x in L if 'b' in x]"
              body:-Code= "sum(x for x in l if 'b' in x)"
          mined:Baseline= "sum(1 for x in l if x == 'b')"
             mined:+Body= "sum(1 for item in L if item == 'b')"
        mined:+Body, -NL= 'len(L) - len(L))'
      mined:+Body, -Code= "sum(1 for item in L if item == 'b')"

================================================================================

QUESTION: idx=127    id=12842997
-------------------------------------INPUTS-------------------------------------

tags: file, directory, copy
score: 55
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['srcfile', 'dstdir']}
intent: copy file `srcfile` to directory `dstdir`
body(Some added characters for better readability):
	First thing I have to mention here, I'm new to python.
	Now I have a file located in:
	
	start_block
	a/long/long/path/to/file.py
	I want to copy to my home directory with a new folder created:
	
	start_block
	/home/myhome/new_folder
	My expected result is:
	
	start_block
	/home/myhome/new_folder/a/long/long/path/to/file.py
	Is there any existing library to do that? If no, how can I achieve that?


-------------------------------------OUTPUT-------------------------------------

                Expected= 'shutil.copy(srcfile, dstdir)'
           base:Baseline= 'os.copy(srcfile, dstdir)'
           base:+Canonic= 'copy(srcfile, dstdir)'
           body:Baseline= 'os.path.dirname(srcfile, dstdir)'
              body:-Code= 'os.copy(srcfile, dstdir)'
          mined:Baseline= 'os.copy(srcfile, dstdir)'
             mined:+Body= 'os.path.dirname(srcfile)'
        mined:+Body, -NL= 'os.path.dirname(srcfile)'
      mined:+Body, -Code= 'dstdir = os.path.join(srcfile, dstdir)'

================================================================================

QUESTION: idx=128    id=1555968
-------------------------------------INPUTS-------------------------------------

tags: dictionary
score: 7
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['x']}
intent: find the key associated with the largest value in dictionary `x` whilst key is non-zero value
body(Some added characters for better readability):
	I'm new Python and trying to implement code in a more Pythonic and efficient fashion.
	Given a dictionary with numeric keys and values, what is the best way to find the largest key with a non-zero value?
	Thanks


-------------------------------------OUTPUT-------------------------------------

                Expected= 'max(k for k, v in x.items() if v != 0)'
           base:Baseline= '[k for k, v in list(x.items() if k == 0]'
           base:+Canonic= 'print(key == key for key, value in list(x.items()))'
           body:Baseline= 'max(x, key=lambda x: x[0])'
              body:-Code= 'max(x, key=operator.itemgetter(x))'
          mined:Baseline= 'max(x, key=operator.itemgetter(1))'
             mined:+Body= 'max(x, key=lambda x: x[1])'
        mined:+Body, -NL= 'max(x, key=lambda x: x[1])'
      mined:+Body, -Code= 'max(x, key=lambda x: x if x!= 0)'

================================================================================

QUESTION: idx=129    id=1555968
-------------------------------------INPUTS-------------------------------------

tags: dictionary
score: 7
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['x']}
intent: get the largest key whose not associated with value of 0 in dictionary `x`
body(Some added characters for better readability):
	I'm new Python and trying to implement code in a more Pythonic and efficient fashion.
	Given a dictionary with numeric keys and values, what is the best way to find the largest key with a non-zero value?
	Thanks


-------------------------------------OUTPUT-------------------------------------

                Expected= '(k for k, v in x.items() if v != 0)'
           base:Baseline= 'max(x, key=lambda x: (x[0])'
           base:+Canonic= 'max(key=lambda x: x[0])'
           body:Baseline= 'max(x, key=lambda x: x[0])'
              body:-Code= 'max(x, key=lambda x: x[0])'
          mined:Baseline= 'max(x, key=lambda x: x[0])'
             mined:+Body= 'max(x, key=lambda x: x[0])'
        mined:+Body, -NL= 'max(x, key=lambda x: x[0])'
      mined:+Body, -Code= 'max(x, key=lambda x: x if x!= 0)'

================================================================================

QUESTION: idx=130    id=1555968
-------------------------------------INPUTS-------------------------------------

tags: dictionary
score: 7
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['x']}
intent: get the largest key in a dictionary `x` with non-zero value
body(Some added characters for better readability):
	I'm new Python and trying to implement code in a more Pythonic and efficient fashion.
	Given a dictionary with numeric keys and values, what is the best way to find the largest key with a non-zero value?
	Thanks


-------------------------------------OUTPUT-------------------------------------

                Expected= 'max(k for k, v in x.items() if v != 0)'
           base:Baseline= 'max(x, key=lambda x: sum(x[0])'
           base:+Canonic= 'len(v) for v in var_0.items()'
           body:Baseline= 'max(x, key=lambda x: x[0])'
              body:-Code= 'max(x, key=operator.itemgetter(0))'
          mined:Baseline= 'max(x, key=lambda x: x != 0, reverse=True)'
             mined:+Body= 'max(x, key=lambda x: x[1])'
        mined:+Body, -NL= 'max(x, key=lambda x: x[0])'
      mined:+Body, -Code= 'max(x, key=lambda x: x if x!= 0)'

================================================================================

QUESTION: idx=131    id=17021863
-------------------------------------INPUTS-------------------------------------

tags: file, testing
score: 19
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: put the curser at beginning of the file
body(Some added characters for better readability):
	I have a script that reads a file and then completes tests based on that file however I am running into a problem because the file reloads after one hour and I cannot get the script to re-read the file after or at that point in time.
	So:
	GETS NEW FILE TO READ
	Reads file
	performs tests on file
	GET NEW FILE TO READ (with same name - but that can change if it is part of a solution)
	Reads new file
	perform same tests on new file
	Can anyone suggest a way to get Python to re-read the file?


-------------------------------------OUTPUT-------------------------------------

                Expected= 'file.seek(0)'
           base:Baseline= 'print(os.path.dirname(__file__))'
           base:+Canonic= "os.curser.startswith('\\n')"
           body:Baseline= 'print(os.path.getcwd(0, 1))'
              body:-Code= 'os.chmod(curser)'
          mined:Baseline= 'curser.add_file(file_name, file_name)'
             mined:+Body= 'print(os.path.join(dirname, file))'
        mined:+Body, -NL= 'os.startswith(file_name)'
      mined:+Body, -Code= "print(open('test.txt', 'rb').read())"

================================================================================

QUESTION: idx=132    id=38152389
-------------------------------------INPUTS-------------------------------------

tags: pandas, numpy, dataframe
score: 62
slot_map: {'key': ['str_0', 'str_1', 'var_0', 'str_2', 'var_1'], 'quote': ["'", "'", '`', "'", '`'], 'type': ['str', 'str', 'var', 'str', 'var'], 'value': ['b', 'a', 'df', 'c', 'df']}
intent: combine values from column 'b' and column 'a' of dataframe `df`  into column 'c' of datafram `df`
body(Some added characters for better readability):
	I'm looking for a method that behaves similarly to coalesce in T-SQL. I have 2 columns (column A and B) that are sparsely populated in a pandas dataframe. I'd like to create a new column using the following rules:
	
	<li>If the value in column A 
	is not null , use that value for the new column C
	
	<li>If the value in column A 
	is null , use the value in column B for the new column C
	Like I mentioned, this can be accomplished in MS SQL Server via the coalesce function. I haven't found a good pythonic method for this; does one exist?


-------------------------------------OUTPUT-------------------------------------

                Expected= "df['c'] = np.where(df['a'].isnull, df['b'], df['a'])"
           base:Baseline= "df['C'] = df['A'] + df['C'].apply(lambda x: x[1])"
           base:+Canonic= "df['c'].groupby('b', 'a')"
           body:Baseline= "df['B', 'A'].merge(['C']))"
              body:-Code= "df['C'] = df['A'].merge(['B', 'A'], axis=1)"
          mined:Baseline= "df['b'].combine(df['a'], df['c'])"
             mined:+Body= "df['C'] = df['A'].combine(df['B'], df['C'])"
        mined:+Body, -NL= "df['c'] = df['b'].combine(df['a'], df['c'])"
      mined:+Body, -Code= "df['c'] = df['c'].coalesce(df['A'], axis=1)"

================================================================================

QUESTION: idx=133    id=4175686
-------------------------------------INPUTS-------------------------------------

tags: 
score: 4
slot_map: {'key': ['str_0', 'var_0'], 'quote': ["'", '`'], 'type': ['str', 'var'], 'value': ['ele', 'd']}
intent: remove key 'ele' from dictionary `d`
body(Some added characters for better readability):
	I use this way to remove an emelment from a dict:
	
	start_block
	    d["ele"] = data
	<console_out>
	    d["ele"] = None
	I think by this I can remove the reference on the original element so that the removed data can be freed, no memory leak.
	Is it the right way to do this?


-------------------------------------OUTPUT-------------------------------------

                Expected= "del d['ele']"
           base:Baseline= "d['ele'].remove(key=lambda x: x[1])"
           base:+Canonic= "d.remove('ele')"
           body:Baseline= 'd = dict((k, v) for k, v in d.items())'
              body:-Code= "d = dict.remove('ele')"
          mined:Baseline= "d = {k: v for k, v in d.items() if 'ele' in k}"
             mined:+Body= 'd = dict((k, e) for k, e in d.items())'
        mined:+Body, -NL= "d['ele'] = 'None'"
      mined:+Body, -Code= "d = dict(x.replace('ele', '') for x in d)"

================================================================================

QUESTION: idx=134    id=5871168
-------------------------------------INPUTS-------------------------------------

tags: django, datetime, django-database
score: 48
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['MyModel', 'timestamp']}
intent: update datetime field in `mymodel` to be the existing `timestamp` plus 100 years
body(Some added characters for better readability):
	
	<p>How can I subtract or add 100 years to a 
	`datetime` field in the database in Django?
	The date is in database, I just want to directly update the field without retrieving it out to calculate and then insert.


-------------------------------------OUTPUT-------------------------------------

                Expected= "MyModel.objects.update(timestamp=F('timestamp') + timedelta(days=36524.25))"
           base:Baseline= 'MyModel.update({timestamp: 100, datetime: 100})'
           base:+Canonic= 'MyModel.update_date(timestamp + 100)'
           body:Baseline= "myModel.update('timestamp', 100)"
              body:-Code= "myModel.update({'timestamp': 100, 'year': 100})"
          mined:Baseline= "myModel.update({'timestamp': 100}).astype(int)"
             mined:+Body= 'myModel.update(date=today + datetime.timedelta(100) + 100)'
        mined:+Body, -NL= 'myModel.dt.to_timestamp()'
      mined:+Body, -Code= "MyModel.update({'timestamp': 100, 'date': 100})"

================================================================================

QUESTION: idx=135    id=11574195
-------------------------------------INPUTS-------------------------------------

tags: list, join, merge
score: 153
slot_map: {'key': ['str_0', 'str_1', 'str_2', '[str_0]', '[str_1]', '[str_2]'], 'quote': ['`', '`', '`', '`', '`', '`'], 'type': ['str', 'str', 'str', 'str', 'str', 'str'], 'value': ["['it']", "['was']", "['annoying']", "['it']", "['was']", "['annoying']"]}
intent: merge list `['it']` and list `['was']` and list `['annoying']` into one list
body(Some added characters for better readability):
	Possible Duplicate:
	Making a flat list out of list of lists in Python
	Join a list of lists together into one list in Python
	I have many lists which looks like 
	
	start_block
	['it']
	['was']
	['annoying']
	I want the above to look like 
	
	start_block
	['it', 'was', 'annoying']
	How do I achieve that?


-------------------------------------OUTPUT-------------------------------------

                Expected= "['it'] + ['was'] + ['annoying']"
           base:Baseline= "[(['it'], ['was']], ['annoying']]"
           base:+Canonic= '[str_0, [str_1]] for str_2 in str_0]'
           body:Baseline= "[list(['it'] and list(['was']]) for _ in range(0, len(['annoying'])]"
              body:-Code= "[(x, y) for x, y in zip(['it', 'was'], 'annoying']]"
          mined:Baseline= "[list(g) for g in itertools.groupby(['it', 'was']])]"
             mined:+Body= "[['it', 'was', 'annoying'] for _ in range(10)]"
        mined:+Body, -NL= "[['it', 'was', 'annoying'] for _ in range(0, len(s)], s)]"
      mined:+Body, -Code= "[(x + y) for x, y in zip(['it', 'was'], ['annoying']]"

================================================================================

QUESTION: idx=136    id=587647
-------------------------------------INPUTS-------------------------------------

tags: 
score: 11
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['x']}
intent: increment a value with leading zeroes in a number `x`
body(Some added characters for better readability):
	What would be the best way to increment a value that contains leading zeroes?  For example, I'd like to increment "00000001".  However, it should be noted that the number of leading zeroes will not exceed 30.  So there may be cases like "0000012", "00000000000000099", or "000000000000045".
	I can think of a couple ways, but I want to see if someone comes up with something slick.


-------------------------------------OUTPUT-------------------------------------

                Expected= 'str(int(x) + 1).zfill(len(x))'
           base:Baseline= 'max(x, key=lambda x: x[1])'
           base:+Canonic= 'len(v) for v in var_0)'
           body:Baseline= 'x = int(x.strip())'
              body:-Code= 'max(x, key=lambda x: x[0]'
          mined:Baseline= 'x[-1 / -1]'
             mined:+Body= ' increment((x[1:]) for x in range(30))'
        mined:+Body, -NL= 'x = zeroes.multivariate_normal(x, axis=1)'
      mined:+Body, -Code= 'x = [int(x) if x > 30]'

================================================================================

QUESTION: idx=137    id=17315881
-------------------------------------INPUTS-------------------------------------

tags: pandas
score: 35
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['df']}
intent: check if a pandas dataframe `df`'s index is sorted
body(Some added characters for better readability):
	I have a vanilla pandas dataframe with an index. I need to check if the index is sorted. Preferably without sorting it again.
	e.g. I can test an index to see if it is unique by index.is_unique() is there a similar way for testing sorted?


-------------------------------------OUTPUT-------------------------------------

                Expected= 'all(df.index[:-1] <= df.index[1:])'
           base:Baseline= 'df.sort(key=lambda x: x[1])'
           base:+Canonic= 'df.sort(key=lambda x: x[1])'
           body:Baseline= 'df.index.is_unique()'
              body:-Code= 'if df.is_unique:\n    pass'
          mined:Baseline= 'df.index.sort(inplace=True)'
             mined:+Body= 'df.index.sort(key=lambda x: x.is_unique())'
        mined:+Body, -NL= 'df.index.sort(key=lambda x: x[1])'
      mined:+Body, -Code= 'df.index.is_unique()'

================================================================================

QUESTION: idx=138    id=16296643
-------------------------------------INPUTS-------------------------------------

tags: list, tuples
score: 231
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['t']}
intent: convert tuple `t` to list
body(Some added characters for better readability):
	I'm currently working on a map editor for a game in pygame, using tile maps.
	The level is built up out of blocks in the following structure (though much larger):
	
	start_block
	level1 = (
	         (1,1,1,1,1,1)
	         (1,0,0,0,0,1)
	         (1,0,0,0,0,1)
	         (1,0,0,0,0,1)
	         (1,0,0,0,0,1)
	         (1,1,1,1,1,1))
	where "1" is a block that's a wall and "0" is a block that's empty air.
	The following code is basically the one handling the change of block type:
	
	start_block
	clicked = pygame.mouse.get_pressed()
	if clicked[0] == 1:
	    currLevel[((mousey+cameraY)/60)][((mousex+cameraX)/60)] = 1
	But since the level is stored in a tuple, I'm unable to change the values of the different blocks. How do I go about changing the different values in the level in an easy manner?


-------------------------------------OUTPUT-------------------------------------

                Expected= 'list(t)'
           base:Baseline= '[t for t in zip(t, t)]'
           base:+Canonic= 't = [x for x in t]'
           body:Baseline= 't = map(t, key=lambda t: t[0]))'
              body:-Code= 't = map(t.reshape())'
          mined:Baseline= 't = [t[i] for i in t]'
             mined:+Body= 't = map(t, level1)'
        mined:+Body, -NL= 'currLevel[(x + y) for x in t]'
      mined:+Body, -Code= 't = map(t, list)'

================================================================================

QUESTION: idx=139    id=16296643
-------------------------------------INPUTS-------------------------------------

tags: list, tuples
score: 231
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['t']}
intent: convert list `t` to tuple
body(Some added characters for better readability):
	I'm currently working on a map editor for a game in pygame, using tile maps.
	The level is built up out of blocks in the following structure (though much larger):
	
	start_block
	level1 = (
	         (1,1,1,1,1,1)
	         (1,0,0,0,0,1)
	         (1,0,0,0,0,1)
	         (1,0,0,0,0,1)
	         (1,0,0,0,0,1)
	         (1,1,1,1,1,1))
	where "1" is a block that's a wall and "0" is a block that's empty air.
	The following code is basically the one handling the change of block type:
	
	start_block
	clicked = pygame.mouse.get_pressed()
	if clicked[0] == 1:
	    currLevel[((mousey+cameraY)/60)][((mousex+cameraX)/60)] = 1
	But since the level is stored in a tuple, I'm unable to change the values of the different blocks. How do I go about changing the different values in the level in an easy manner?


-------------------------------------OUTPUT-------------------------------------

                Expected= 'tuple(l)'
           base:Baseline= 't = tuple(t, t)'
           base:+Canonic= 'tuple(t, t)'
           body:Baseline= 't = tuple[0] for t in pygame]'
              body:-Code= 't = map(list(t.items()))'
          mined:Baseline= 'tuple(map(t, t))'
             mined:+Body= 'tuple(map(tuple, level1))'
        mined:+Body, -NL= 'tuple(x[0] for x in t)'
      mined:+Body, -Code= 'tuple(map(t, iter(t))'

================================================================================

QUESTION: idx=140    id=16296643
-------------------------------------INPUTS-------------------------------------

tags: list, tuples
score: 231
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['level1']}
intent: convert tuple `level1` to list
body(Some added characters for better readability):
	I'm currently working on a map editor for a game in pygame, using tile maps.
	The level is built up out of blocks in the following structure (though much larger):
	
	start_block
	level1 = (
	         (1,1,1,1,1,1)
	         (1,0,0,0,0,1)
	         (1,0,0,0,0,1)
	         (1,0,0,0,0,1)
	         (1,0,0,0,0,1)
	         (1,1,1,1,1,1))
	where "1" is a block that's a wall and "0" is a block that's empty air.
	The following code is basically the one handling the change of block type:
	
	start_block
	clicked = pygame.mouse.get_pressed()
	if clicked[0] == 1:
	    currLevel[((mousey+cameraY)/60)][((mousex+cameraX)/60)] = 1
	But since the level is stored in a tuple, I'm unable to change the values of the different blocks. How do I go about changing the different values in the level in an easy manner?


-------------------------------------OUTPUT-------------------------------------

                Expected= 'level1 = map(list, level1)'
           base:Baseline= 'list(level1, key=lambda tup: tup[1])'
           base:+Canonic= 'level1 = [x for x in level1]'
           body:Baseline= 'list(level1.items()))'
              body:-Code= 'list(level1, key=lambda tup: tup[0])'
          mined:Baseline= '[tuple(level1) for tuple in l]'
             mined:+Body= 'pygame.tile(level1, 0)'
        mined:+Body, -NL= 'currLevel[(x + y) for x, y in zip(level1, levelX)]'
      mined:+Body, -Code= 'Level1 = map(list(level1.items())'

================================================================================

QUESTION: idx=141    id=3880399
-------------------------------------INPUTS-------------------------------------

tags: logging
score: 58
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['dataobject', 'logFile']}
intent: send the output of pprint object `dataobject` to file `logfile`
body(Some added characters for better readability):
	I have the following code:
	
	start_block
	logFile=open('c:\\temp\\mylogfile'+'.txt', 'w')
	pprint.pprint(dataobject)
	how can i send the contents of dataobject to the log file on the pretty print format ?


-------------------------------------OUTPUT-------------------------------------

                Expected= 'pprint.pprint(dataobject, logFile)'
           base:Baseline= "logfile.send('logfile')"
           base:+Canonic= "print(dataobject.open('logFile').read())"
           body:Baseline= 'pprint.pprint(dataobject, output=logfile)'
              body:-Code= 'logfile = pd.read().close()'
          mined:Baseline= "logging.info('dataobject.txt')"
             mined:+Body= 'pprint.pprint(dataobject)'
        mined:+Body, -NL= 'pprint.pprint(dataobject)'
      mined:+Body, -Code= "logfile.write('\\n'.join(dataobject))"

================================================================================

QUESTION: idx=142    id=21800169
-------------------------------------INPUTS-------------------------------------

tags: indexing, pandas
score: 336
slot_map: {'key': ['str_0'], 'quote': ["'"], 'type': ['str'], 'value': ['BoolCol']}
intent: get index of rows in column 'boolcol'
body(Some added characters for better readability):
	Given a DataFrame with a column "BoolCol", we want to find the indexes of the DataFrame in which the values for "BoolCol" == True
	I currently have the iterating way to do it, which works perfectly:
	
	start_block
	for i in range(100,3000):
	    if df.iloc[i]['BoolCol']== True:
	         print i,df.iloc[i]['BoolCol']
	But this is not the correct panda's way to do it.
	After some research, I am currently using this code:
	
	start_block
	df[df['BoolCol'] == True].index.tolist()
	This one gives me a list of indexes, but they dont match, when I check them by doing:
	
	start_block
	df.iloc[i]['BoolCol']
	The result is actually False!!
	Which would be the correct Pandas way to do this?


-------------------------------------OUTPUT-------------------------------------

                Expected= "df.loc[df['BoolCol']]"
           base:Baseline= "df['boolCol'] = df['boolcol']"
           base:+Canonic= 'index = [[BoolCol] for str in l]'
           body:Baseline= "df[df['BoolCol'] == True].index.tolist()"
              body:-Code= "df['boolCol'] = df['BoolCol']"
          mined:Baseline= "df.index(['boolcol'])"
             mined:+Body= "df[df['BoolCol'] == True]"
        mined:+Body, -NL= "df[df['BoolCol'] == True].index.tolist()"
      mined:+Body, -Code= "df.index(['BoolCol'])"

================================================================================

QUESTION: idx=143    id=21800169
-------------------------------------INPUTS-------------------------------------

tags: indexing, pandas
score: 336
slot_map: {'key': ['str_0', 'var_0'], 'quote': ["'", '`'], 'type': ['str', 'var'], 'value': ['BoolCol', 'df']}
intent: create a list containing the indexes of rows where the value of column 'boolcol' in dataframe `df` are equal to true
body(Some added characters for better readability):
	Given a DataFrame with a column "BoolCol", we want to find the indexes of the DataFrame in which the values for "BoolCol" == True
	I currently have the iterating way to do it, which works perfectly:
	
	start_block
	for i in range(100,3000):
	    if df.iloc[i]['BoolCol']== True:
	         print i,df.iloc[i]['BoolCol']
	But this is not the correct panda's way to do it.
	After some research, I am currently using this code:
	
	start_block
	df[df['BoolCol'] == True].index.tolist()
	This one gives me a list of indexes, but they dont match, when I check them by doing:
	
	start_block
	df.iloc[i]['BoolCol']
	The result is actually False!!
	Which would be the correct Pandas way to do this?


-------------------------------------OUTPUT-------------------------------------

                Expected= "df.iloc[np.flatnonzero(df['BoolCol'])]"
           base:Baseline= "df.index(['boolcol'] == True).sum()"
           base:+Canonic= "df.groupby(['BoolCol'], axis=1).sum()"
           body:Baseline= "[df[df['BoolCol'] == True].index.tolist()"
              body:-Code= "[x for x in df if ('boolCol' == True]"
          mined:Baseline= "[(df['boolcol'] == True) for df in df]"
             mined:+Body= "df[df['BoolCol'] == True].index.tolist()"
        mined:+Body, -NL= "df[df['BoolCol'] == True].index.tolist()"
      mined:+Body, -Code= '[i for i, v in df.index.values() if v == True]'

================================================================================

QUESTION: idx=144    id=21800169
-------------------------------------INPUTS-------------------------------------

tags: indexing, pandas
score: 336
slot_map: {'key': ['str_0'], 'quote': ["'"], 'type': ['str'], 'value': ['BoolCol']}
intent: get list of indexes of rows where column 'boolcol' values match true
body(Some added characters for better readability):
	Given a DataFrame with a column "BoolCol", we want to find the indexes of the DataFrame in which the values for "BoolCol" == True
	I currently have the iterating way to do it, which works perfectly:
	
	start_block
	for i in range(100,3000):
	    if df.iloc[i]['BoolCol']== True:
	         print i,df.iloc[i]['BoolCol']
	But this is not the correct panda's way to do it.
	After some research, I am currently using this code:
	
	start_block
	df[df['BoolCol'] == True].index.tolist()
	This one gives me a list of indexes, but they dont match, when I check them by doing:
	
	start_block
	df.iloc[i]['BoolCol']
	The result is actually False!!
	Which would be the correct Pandas way to do this?


-------------------------------------OUTPUT-------------------------------------

                Expected= "df[df['BoolCol'] == True].index.tolist()"
           base:Baseline= "[(df['boolcol'] == True]"
           base:+Canonic= '[i for i, j in enumerate(BoolCol, BoolCol)]'
           body:Baseline= "df[df['BoolCol'] == True].index.tolist()"
              body:-Code= "[i for i, j in enumerate(df['BoolCol'] if j == True]"
          mined:Baseline= "[i[0] for i in rows if 'boolcol' in row]"
             mined:+Body= "df[df['BoolCol'] == True]"
        mined:+Body, -NL= "df[df['BoolCol'] == True].index.tolist()"
      mined:+Body, -Code= '[i for i, v in enumerate(df.values()) if v == True]'

================================================================================

QUESTION: idx=145    id=21800169
-------------------------------------INPUTS-------------------------------------

tags: indexing, pandas
score: 336
slot_map: {'key': ['var_0', 'str_0'], 'quote': ['`', "'"], 'type': ['var', 'str'], 'value': ['df', 'BoolCol']}
intent: get index of rows in dataframe `df` which column 'boolcol' matches value true
body(Some added characters for better readability):
	Given a DataFrame with a column "BoolCol", we want to find the indexes of the DataFrame in which the values for "BoolCol" == True
	I currently have the iterating way to do it, which works perfectly:
	
	start_block
	for i in range(100,3000):
	    if df.iloc[i]['BoolCol']== True:
	         print i,df.iloc[i]['BoolCol']
	But this is not the correct panda's way to do it.
	After some research, I am currently using this code:
	
	start_block
	df[df['BoolCol'] == True].index.tolist()
	This one gives me a list of indexes, but they dont match, when I check them by doing:
	
	start_block
	df.iloc[i]['BoolCol']
	The result is actually False!!
	Which would be the correct Pandas way to do this?


-------------------------------------OUTPUT-------------------------------------

                Expected= "df[df['BoolCol']].index.tolist()"
           base:Baseline= "df.groupby('boolcol').index()"
           base:+Canonic= "df.loc[np.arange(['BoolCol'], axis=1)]"
           body:Baseline= "df[df['BoolCol'] == True].index.tolist()"
              body:-Code= "df.index['boolCol'] == True"
          mined:Baseline= "df[df['boolcol'] == True]"
             mined:+Body= "df[df['BoolCol'] == True].index.tolist()"
        mined:+Body, -NL= "df[df['BoolCol'] == True].index.tolist()"
      mined:+Body, -Code= "df.index(['BoolCol'])"

================================================================================

QUESTION: idx=146    id=299446
-------------------------------------INPUTS-------------------------------------

tags: 
score: 29
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['owd']}
intent: change working directory to the directory `owd`
body(Some added characters for better readability):
	I have a function that resembles the one below. I'm not sure how to use the os module to get back to my original working directory at the conclusion of the jar's execution. 
	
	start_block
	def run(): 
	    owd = os.getcwd()
	    #first change dir to build_dir path
	    os.chdir(testDir)
	    #run jar from test directory
	    os.system(cmd)
	    #change dir back to original working directory (owd)
	note: I think my code formatting is off - not sure why. My apologies in advance


-------------------------------------OUTPUT-------------------------------------

                Expected= 'os.chdir(owd)'
           base:Baseline= 'os.chdir(owd)'
           base:+Canonic= "os.chdir('owd')"
           body:Baseline= 'os.chdir(testDir)'
              body:-Code= "os.chdir('owd')"
          mined:Baseline= "os.chdir('owd')"
             mined:+Body= 'os.chdir(testDir)'
        mined:+Body, -NL= 'os.chdir(os.path.dirname(__file__))'
      mined:+Body, -Code= 'os.chdir(os.path.dirname(owd))'

================================================================================

QUESTION: idx=147    id=14695134
-------------------------------------INPUTS-------------------------------------

tags: mysql, sql, database, sqlite
score: 9
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['testfield', 'c']}
intent: insert data from a string `testfield` to sqlite db `c`
body(Some added characters for better readability):
	
	<p>I'm trying to insert strings read from a file into an 
	`sqlite` database in Python. The strings have whitespace (newline, tab characters, and spaces) and also have appearances of single or double quotes.  Here's how I try to do it:
	
	start_block
	import sqlite3
	conn = sqlite3.connect('example.db')
	c = conn.cursor()
	# Create table
	c.execute('''CREATE TABLE test
	             (a text, b text)''')
	f = open("foo", "w")
	f.write("hello\n\'world\'\n")
	f.close()
	testfield = open("foo").read()
	# Insert a row of data
	c.execute("INSERT INTO test VALUES ('%s', 'bar')" %(testfield))
	# Save (commit) the changes
	conn.commit()
	I find that this fails with the error: 
	
	start_block
	    c.execute("INSERT INTO test VALUES ('%s', 'bar')" %(testfield))
	sqlite3.OperationalError: near "world": syntax error
	How can I achieve this? Do the strings need to be escaped before insertion in the db, and if so how? thanks.


-------------------------------------OUTPUT-------------------------------------

                Expected= 'c.execute("INSERT INTO test VALUES (?, \'bar\')", (testfield,))'
           base:Baseline= 'c = db.query(c)'
           base:+Canonic= "db.query(testfield, 'c')"
           body:Baseline= 'c.execute(\'INSERT INTO test VALUES (\'%s\', \'bar\')")'
              body:-Code= "c.execute('INSERT INTO table VALUES (%s, %s)', testfield)"
          mined:Baseline= "cursor.execute('INSERT INTO testfield VALUES (%s)', (testfield,))"
             mined:+Body= "c.execute('INSERT INTO test VALUES ('%s', 'bar')' % (testfield))"
        mined:+Body, -NL= "c.execute('INSERT INTO test VALUES ('%s', 'bar')' % (testfield))"
      mined:+Body, -Code= "cursor.execute('INSERT INTO testfield VALUES (%s)', (testfield,))"

================================================================================

QUESTION: idx=148    id=24242433
-------------------------------------INPUTS-------------------------------------

tags: string, rawstring
score: 22
slot_map: {'key': ['str_0'], 'quote': ['"'], 'type': ['str'], 'value': ['\\x89\\n']}
intent: decode string "\\x89\\n" into a normal string
body(Some added characters for better readability):
	In Python, I have a string like this:
	
	start_block
	'\\x89\\n'
	How can I decode it into a normal string like:
	
	start_block
	'\x89\n'


-------------------------------------OUTPUT-------------------------------------

                Expected= '"""\\\\x89\\\\n""".decode(\'string_escape\')'
           base:Baseline= '"""\\\\x89\\\\n""".decode(\'normal\')'
           base:+Canonic= '"""\\\\x89\\\\n""".decode(\'normal\')'
           body:Baseline= '"""\\\\x89\\\\n""".decode(\'normal\')'
              body:-Code= '"""\\\\x89\\\\n""".decode(\'normal\')'
          mined:Baseline= '"""\\\\x89\\\\n""".decode(\'utf-8\')'
             mined:+Body= '"""""".decode(\'\\\\x89\\\\n\')'
        mined:+Body, -NL= '"""\\\\x89\\\\n""".decode(\'unicode-escape\')'
      mined:+Body, -Code= '"""\\\\x89\\\\n""".decode(\'unicode_escape\')'

================================================================================

QUESTION: idx=149    id=24242433
-------------------------------------INPUTS-------------------------------------

tags: string, rawstring
score: 22
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['raw_string']}
intent: convert a raw string `raw_string` into a normal string
body(Some added characters for better readability):
	In Python, I have a string like this:
	
	start_block
	'\\x89\\n'
	How can I decode it into a normal string like:
	
	start_block
	'\x89\n'


-------------------------------------OUTPUT-------------------------------------

                Expected= "raw_string.decode('string_escape')"
           base:Baseline= "raw_string.split(',')"
           base:+Canonic= '"""""".join(raw_string.split())'
           body:Baseline= "raw_string.decode('normal')"
              body:-Code= "raw_string.decode('normal')"
          mined:Baseline= "raw_string = 'normal string'"
             mined:+Body= '"""""".join(raw_string)'
        mined:+Body, -NL= "raw_string.split('\\x89\\\\n')"
      mined:+Body, -Code= "raw_string.decode('string_escape')"

================================================================================

QUESTION: idx=150    id=24242433
-------------------------------------INPUTS-------------------------------------

tags: string, rawstring
score: 22
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['raw_byte_string']}
intent: convert a raw string `raw_byte_string` into a normal string
body(Some added characters for better readability):
	In Python, I have a string like this:
	
	start_block
	'\\x89\\n'
	How can I decode it into a normal string like:
	
	start_block
	'\x89\n'


-------------------------------------OUTPUT-------------------------------------

                Expected= "raw_byte_string.decode('unicode_escape')"
           base:Baseline= 'raw_byte_string.split()'
           base:+Canonic= '"""""".join(raw_byte_string.split())'
           body:Baseline= "raw_byte_string.decode('normal')"
              body:-Code= "raw_byte_string.decode('normal')"
          mined:Baseline= '"""raw_byte_string""".decode(\'utf-8\')'
             mined:+Body= '"""""".join(raw_byte_string)'
        mined:+Body, -NL= '"""""".join(raw_byte_string.split(\',\'))'
      mined:+Body, -Code= '"""""".join(raw_byte_string)'

================================================================================

QUESTION: idx=151    id=22882922
-------------------------------------INPUTS-------------------------------------

tags: regex, string
score: 20
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['s']}
intent: split a string `s` with into all strings of repeated characters
body(Some added characters for better readability):
	
	<p>I am not well experienced with Regex but I have been reading a lot about it. Assume there's a string 
	`s = '111234'`
	 I want a list with the string split into 
	`L = ['111', '2', '3', '4']`. My approach was to make a group checking if it's a digit or not and then check for a repetition of the group. Something like this 
	
	start_block
	L = re.findall('\d[\1+]', s)
	
	<p>I think that 
	`\d[\1+]` will basically check for either "digit" or "digit +" the same repetitions. I think this might do what I want. 


-------------------------------------OUTPUT-------------------------------------

                Expected= "[m.group(0) for m in re.finditer('(\\\\d)\\\\1*', s)]"
           base:Baseline= "re.split('(\\\\w+)', s)"
           base:+Canonic= "re.split('\\\\d+', s)"
           body:Baseline= "re.findall('\\\\d[\\\\1+]', s)"
              body:-Code= "re.findall('\\\\d+', s)"
          mined:Baseline= "re.split('\\\\s+', s)"
             mined:+Body= "L = re.findall('\\\\d[\\\\1+]', s)"
        mined:+Body, -NL= "re.findall('\\\\d[\\\\1+]', s)"
      mined:+Body, -Code= "re.findall('\\\\d+', s)"

================================================================================

QUESTION: idx=152    id=4143502
-------------------------------------INPUTS-------------------------------------

tags: matplotlib, geometry, scatter-plot, scatter
score: 192
slot_map: {'key': ['str_0'], 'quote': ['`'], 'type': ['str'], 'value': ['np.random.randn(100)']}
intent: scatter a plot with x, y position of `np.random.randn(100)` and face color equal to none
body(Some added characters for better readability):
	
	<p>In Python, with Matplotlib, how can a scatter plot with 
	empty 
	 circles be plotted?  The goal is to draw empty circles around 
	some 
	 of the colored disks already plotted by 
	`scatter()`, so as to highlight them, ideally without having to redraw the colored circles.
	
	<p>I tried 
	`facecolors=None`, to no avail.


-------------------------------------OUTPUT-------------------------------------

                Expected= "plt.scatter(np.random.randn(100), np.random.randn(100), facecolors='none')"
           base:Baseline= "plt.scatter('np.random.randn(100)')"
           base:+Canonic= 'plt.scatter(x, y, np.random.randn(100), color=None)'
           body:Baseline= 'scatter(np.random.randn(100))'
              body:-Code= 'plt.scatter(np.random.randn(100))'
          mined:Baseline= 'plt.scatter(x, y, color=np.random.randn(100))'
             mined:+Body= 'plt.plot(x, y, na.random.randn(100))'
        mined:+Body, -NL= 'plt.plot(x, y, np.random.randn(100))'
      mined:+Body, -Code= 'plt.scatter(x, y, marker=np.random.randn(100))'

================================================================================

QUESTION: idx=153    id=4143502
-------------------------------------INPUTS-------------------------------------

tags: matplotlib, geometry, scatter-plot, scatter
score: 192
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: do a scatter plot with empty circles
body(Some added characters for better readability):
	
	<p>In Python, with Matplotlib, how can a scatter plot with 
	empty 
	 circles be plotted?  The goal is to draw empty circles around 
	some 
	 of the colored disks already plotted by 
	`scatter()`, so as to highlight them, ideally without having to redraw the colored circles.
	
	<p>I tried 
	`facecolors=None`, to no avail.


-------------------------------------OUTPUT-------------------------------------

                Expected= "plt.plot(np.random.randn(100), np.random.randn(100), 'o', mfc='none')"
           base:Baseline= 'plt.scatter(axis=1, scatter=False)'
           base:+Canonic= "plt.scatter('\\n')"
           body:Baseline= 'scatter(map(int, scatter(background=False))'
              body:-Code= "plt.rstrip('\\n')"
          mined:Baseline= "plt.plot(x, y, label='circle')"
             mined:+Body= "ax.spines['left'].set_visible(False)"
        mined:+Body, -NL= "plt.plot(x, y, 'bo')"
      mined:+Body, -Code= 'plt.scatter(x, y)'

================================================================================

QUESTION: idx=154    id=32063985
-------------------------------------INPUTS-------------------------------------

tags: beautifulsoup
score: 37
slot_map: {'key': ['str_0'], 'quote': ['`'], 'type': ['str'], 'value': ['main-content']}
intent: remove a div with a id `main-content` using beautifulsoup
body(Some added characters for better readability):
	
	<p>I want to delete the specific 
	`div`
	 from 
	`soup` object. 
	
	<p>I am using 
	`python 2.7`
	 and 
	`bs4`. 
	
	<p>According to documentation we can use 
	`div.decompose()`. 
	
	<p>But that would delete all the 
	`div`
	. How can I delete a 
	`div` with specific class?


-------------------------------------OUTPUT-------------------------------------

                Expected= "soup.find('div', id='main-content').decompose()"
           base:Baseline= 'soup.remove(div, id=None)'
           base:+Canonic= "beautifulsoup.div('main-content')"
           body:Baseline= 'soup.delete(div, id=main - content)'
              body:-Code= "soup.removeClass(name='main-content')"
          mined:Baseline= 'div = soup.findAll(id=main_content)'
             mined:+Body= "soup.pop('main-content', None)"
        mined:+Body, -NL= "soup.pop('div', None)"
      mined:+Body, -Code= 'soup.body.remove(div, id=main - content)'

================================================================================

QUESTION: idx=155    id=27975069
-------------------------------------INPUTS-------------------------------------

tags: pandas, dataframe
score: 189
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['ball', 'ids']}
intent: filter rows containing key word `ball` in column `ids`
body(Some added characters for better readability):
	Assume we have a data frame in Python Pandas that looks like this:
	
	start_block
	df = pd.DataFrame({'vals': [1, 2, 3, 4], 'ids': [u'aball', u'bball', u'cnut', u'fball']})
	Or, in table form:
	
	start_block
	ids    vals
	aball   1
	bball   2
	cnut    3
	fball   4
	How do I filter rows which contain the key word "ball?" For example, the output should be:
	
	start_block
	ids    vals
	aball   1
	bball   2
	fball   4


-------------------------------------OUTPUT-------------------------------------

                Expected= "df[df['ids'].str.contains('ball')]"
           base:Baseline= "ids.filter(key=lambda x: x['ball']))"
           base:+Canonic= 'ids = [[ball] for ball in ids]'
           body:Baseline= "df.filter(ids, key=lambda x: x['ball']))"
              body:-Code= "ids.filter(key=lambda x: x['ball']))"
          mined:Baseline= "ids.filter(key=lambda x: x['ball'])"
             mined:+Body= "df['ids'] = df['ball'].apply(lambda x: x.groupby('ball'))"
        mined:+Body, -NL= "df.loc[df['ids'] == 'bball']"
      mined:+Body, -Code= "df[df.Key().str.contains('ball')]"

================================================================================

QUESTION: idx=156    id=20461165
-------------------------------------INPUTS-------------------------------------

tags: pandas, dataframe, indexing, series
score: 557
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['df']}
intent: convert index at level 0 into a column in dataframe `df`
body(Some added characters for better readability):
	This seems rather obvious, but I can't seem to figure out how to convert an index of data frame to a column?
	For example:
	
	start_block
	df=
	        gi       ptt_loc
	 0  384444683      593  
	 1  384444684      594 
	 2  384444686      596  
	To,
	
	start_block
	df=
	    index1    gi       ptt_loc
	 0  0     384444683      593  
	 1  1     384444684      594 
	 2  2     384444686      596  


-------------------------------------OUTPUT-------------------------------------

                Expected= 'df.reset_index(level=0, inplace=True)'
           base:Baseline= 'df.columns = df.index(level=0)'
           base:+Canonic= "df['index'] = df.columns[0]"
           body:Baseline= 'df.columns[0].index(level=0]'
              body:-Code= "df.index.strftime('0')"
          mined:Baseline= 'df.set_index(level=0)'
             mined:+Body= "df.columns = ['index1', 'gi', 'ptt_loc']"
        mined:+Body, -NL= "df.columns = ['index1', 'index2']"
      mined:+Body, -Code= 'df.set_index(level=0)'

================================================================================

QUESTION: idx=157    id=20461165
-------------------------------------INPUTS-------------------------------------

tags: pandas, dataframe, indexing, series
score: 557
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['df', 'index1']}
intent: add indexes in a data frame `df` to a column `index1`
body(Some added characters for better readability):
	This seems rather obvious, but I can't seem to figure out how to convert an index of data frame to a column?
	For example:
	
	start_block
	df=
	        gi       ptt_loc
	 0  384444683      593  
	 1  384444684      594 
	 2  384444686      596  
	To,
	
	start_block
	df=
	    index1    gi       ptt_loc
	 0  0     384444683      593  
	 1  1     384444684      594 
	 2  2     384444686      596  


-------------------------------------OUTPUT-------------------------------------

                Expected= "df['index1'] = df.index"
           base:Baseline= "df.index1 = df['index1']"
           base:+Canonic= "df['index1'] = index1.index"
           body:Baseline= 'df.index1[index1].columns'
              body:-Code= 'df.index1 = df.columns'
          mined:Baseline= "df.set_index('index1')"
             mined:+Body= "df['index1'] = df['ptt_loc']"
        mined:+Body, -NL= "df['index1'] = df.index.get_level_values(0)"
      mined:+Body, -Code= "df.set_index(['index1', 'index2'])"

================================================================================

QUESTION: idx=158    id=20461165
-------------------------------------INPUTS-------------------------------------

tags: pandas, dataframe, indexing, series
score: 557
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: convert pandas index in a dataframe to columns
body(Some added characters for better readability):
	This seems rather obvious, but I can't seem to figure out how to convert an index of data frame to a column?
	For example:
	
	start_block
	df=
	        gi       ptt_loc
	 0  384444683      593  
	 1  384444684      594 
	 2  384444686      596  
	To,
	
	start_block
	df=
	    index1    gi       ptt_loc
	 0  0     384444683      593  
	 1  1     384444684      594 
	 2  2     384444686      596  


-------------------------------------OUTPUT-------------------------------------

                Expected= "df.reset_index(level=['tick', 'obs'])"
           base:Baseline= "df['index'] = df['index'].columns"
           base:+Canonic= "df.groupby(['df', 'df'], axis=1)"
           body:Baseline= 'df.columns = df.index'
              body:-Code= "df['index'] = df['columns']"
          mined:Baseline= 'pd.concat([df1, df2], axis=1)'
             mined:+Body= "df.columns = ['index1', 'gi', 'ptt_loc']"
        mined:+Body, -NL= "df.columns = ['index1', 'index2']"
      mined:+Body, -Code= "df.to_column('index')"

================================================================================

QUESTION: idx=159    id=4685571
-------------------------------------INPUTS-------------------------------------

tags: sequences
score: 4
slot_map: {'key': ['str_0'], 'quote': ["'"], 'type': ['str'], 'value': ['b']}
intent: get reverse of list items from list 'b' using extended slicing
body(Some added characters for better readability):
	
	
	start_block
	>>>b=[('spam',0), ('eggs',1)]
	>>>[reversed(x) for x in b]
	...[ <reversed object at 0x7fbf07de7090>, <reversed object at 0x7fbf07de70d0>]
	Bummer. I expected to get a list of reversed tuples!
	Sure I can do:
	
	
	start_block
	>>>[tuple(reversed(x)) for x in b]
	...[(0, 'spam'), (1, 'eggs')]
	But I hoped for something generic? Smth that when being handed over a list of tuples, returns a list of reversed tuples, and when handed over a list of lists, returns a list of reversed lists.
	Sure, an ugly hack with isinstance() is always available but I kind of hoped avoiding going that route.


-------------------------------------OUTPUT-------------------------------------

                Expected= '[x[::-1] for x in b]'
           base:Baseline= '[(x, y) for x, y in b]'
           base:+Canonic= 'reversed([b])'
           body:Baseline= '[tuple(reversed(x)) for x in b]'
              body:-Code= '[item[0] for item in b]'
          mined:Baseline= '[x[::-1] for x in a]'
             mined:+Body= '[tuple(x) for x in b for y in reversed(x)]'
        mined:+Body, -NL= '[tuple(x) for x in b]'
      mined:+Body, -Code= '[x[::-1] for x in sorted(b)]'

================================================================================

QUESTION: idx=160    id=17960441
-------------------------------------INPUTS-------------------------------------

tags: arrays, numpy, zip
score: 34
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['a', 'b']}
intent: join each element in array `a` with element at the same index in array `b` as a tuple
body(Some added characters for better readability):
	For example I have 2 arrays
	
	start_block
	a = array([[0, 1, 2, 3],
	           [4, 5, 6, 7]])
	b = array([[0, 1, 2, 3],
	           [4, 5, 6, 7]])
	
	<p>How can I `zip`
	
	`a`
	 and 
	`b` so I get
	
	start_block
	c = array([[(0,0), (1,1), (2,2), (3,3)],
	           [(4,4), (5,5), (6,6), (7,7)]])
	?


-------------------------------------OUTPUT-------------------------------------

                Expected= 'np.array([zip(x, y) for x, y in zip(a, b)])'
           base:Baseline= 'numpy.zip(a, b)'
           base:+Canonic= '[(x + y) for x, y in zip(a, b)]'
           body:Baseline= '[(x, y) for x, y in zip(a, b)]'
              body:-Code= '[(x, y) for x, y in zip(a, b)]'
          mined:Baseline= '[(x + y) for x, y in zip(A, B)]'
             mined:+Body= 'c = zip(*a, b)'
        mined:+Body, -NL= 'a[np.arange(b)] = zip(*a)'
      mined:+Body, -Code= '[(x + y) for x, y in zip(A, B)]'

================================================================================

QUESTION: idx=161    id=17960441
-------------------------------------INPUTS-------------------------------------

tags: arrays, numpy, zip
score: 34
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['a', 'b']}
intent: zip two 2-d arrays `a` and `b`
body(Some added characters for better readability):
	For example I have 2 arrays
	
	start_block
	a = array([[0, 1, 2, 3],
	           [4, 5, 6, 7]])
	b = array([[0, 1, 2, 3],
	           [4, 5, 6, 7]])
	
	<p>How can I `zip`
	
	`a`
	 and 
	`b` so I get
	
	start_block
	c = array([[(0,0), (1,1), (2,2), (3,3)],
	           [(4,4), (5,5), (6,6), (7,7)]])
	?


-------------------------------------OUTPUT-------------------------------------

                Expected= "np.array(zip(a.ravel(), b.ravel()), dtype='i4,i4').reshape(a.shape)"
           base:Baseline= 'np.zip(a, b)'
           base:+Canonic= 'zip(a, b)'
           body:Baseline= 'zip(a, b, c)'
              body:-Code= 'zip(zip(a, b))'
          mined:Baseline= 'zip(a, b, c)'
             mined:+Body= 'zip(zip(a, b), reverse=True)'
        mined:+Body, -NL= 'zip([0, 0), (1, 1), (2, 2), (3, 3)],'
      mined:+Body, -Code= 'zip([[1, 2], [3, 4], [5, 6]])'

================================================================================

QUESTION: idx=162    id=438684
-------------------------------------INPUTS-------------------------------------

tags: 
score: 28
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['list_of_ints']}
intent: convert list `list_of_ints` into a comma separated string
body(Some added characters for better readability):
	I'm new to python, and have a list of longs which I want to join together into a comma separated string.
	In PHP I'd do something like this:
	
	start_block
	$output = implode(",", $array)
	In Python, I'm not sure how to do this. I've tried using join, but this doesn't work since the elements are the wrong type (i.e., not strings). Do I need to create a copy of the list and convert each element in the copy from a long into a string? Or is there a simpler way to do it?


-------------------------------------OUTPUT-------------------------------------

                Expected= '""",""".join([str(i) for i in list_of_ints])'
           base:Baseline= '"""""".join(map(list_of_ints))'
           base:+Canonic= '"""""".join(var_0))'
           body:Baseline= '"""""".join(list_of_ints)'
              body:-Code= '"""""".join(list_of_ints)'
          mined:Baseline= '""" """.join(map(str, list_of_ints))'
             mined:+Body= '"""""".join(list_of_ints)'
        mined:+Body, -NL= '""" """.join(map(str, list_of_ints))'
      mined:+Body, -Code= '"""""".join(list_of_ints)'

================================================================================

QUESTION: idx=163    id=8519922
-------------------------------------INPUTS-------------------------------------

tags: post, curl, urllib2, pycurl
score: 9
slot_map: {'key': ['var_0', 'var_1', 'var_2'], 'quote': ['`', '`', '`'], 'type': ['var', 'var', 'var'], 'value': ['DATA', 'username', 'password']}
intent: send a post request with raw data `data` and basic authentication with `username` and `password`
body(Some added characters for better readability):
	
	<p>I'm playing around with the Google Checkout API and I want to pull it into a Django app. I need to post data to Google using basic http authentication. I've been testing this with 
	`curl` like this:
	
	start_block
	curl -d "$(cat mytest.xml)" -u username:password https://url
	And that posts the content of my test XML file to Google. And it works fine!
	But I'm having problems porting that simple line to Python. I've managed several different ways (httplib2, urllib2, pycurl) of connecting with a password and posting something but the respose is always 400 BAD REQUEST.
	Is there a python equivalent for posting block of text to a HTTP Basic auth server? I'm running out of walls to bang my head against.
	
	<p>Apologies for not adding any code. Here are some of my greatest hits. In each, 
	`DATA`
	 is an XML string. 
	`URL`
	, 
	`USERNAME`
	 and 
	`PASSWORD` are constant.
	
	start_block
	req = urllib2.Request(URL)
	req.add_header("Authorization", "Basic %s" % base64.encodestring('%s:%s'%(USERNAME, PASSWORD)))
	u = urllib2.urlopen(req, DATA)
	
	<p>Gives me a lovely `HTTP Error 400: Bad Request`
	
	start_block
	passman = urllib2.HTTPPasswordMgrWithDefaultRealm()
	passman.add_password(None, URL, USERNAME, PASSWORD)
	authhandler = urllib2.HTTPBasicAuthHandler(passman)
	opener = urllib2.build_opener(authhandler)
	urllib2.install_opener(opener)
	pagehandle = urllib2.urlopen(URL, DATA)
	
	<p>Gives `HTTP Error 401: Unauthorized`
	
	start_block
	pycurl.global_init(pycurl.GLOBAL_DEFAULT)
	c = pycurl.Curl()
	c.setopt(pycurl.URL, URL)
	c.setopt(pycurl.USERPWD, "%s:%s" % (USERNAME,PASSWORD))
	c.setopt(pycurl.POST, 1)
	c.setopt(pycurl.HTTPHEADER, ["Content-type: text/xml"])
	c.setopt(pycurl.POSTFIELDS, DATA)
	b = StringIO.StringIO()
	c.setopt(pycurl.WRITEFUNCTION, b.write)
	c.perform()
	
	<p>Seems to struggle with passing the 
	`DATA`
	 string as a POSTFIELD. I've tried 
	`urllib.urlencode()`ing DATA in several different ways but 
	
	start_block
	h = httplib2.Http()
	h.add_credentials(USERNAME, PASSWORD)
	print = h.request(URL, "POST", body=base64.encodestring(DATA))
	The credentials don't seem to do anything - I get an unauthorised message back from Google.
	There are more but they're all based on these.


-------------------------------------OUTPUT-------------------------------------

                Expected= 'requests.post(url, data=DATA, headers=HEADERS_DICT, auth=(username, password))'
           base:Baseline= "requests.post('data', headers={'username': 'password': 'username'})"
           base:+Canonic= "r = requests.post(['DATA', 'password'])"
           body:Baseline= "urllib2.send_request(raw_data, headers={'username': 'password'})"
              body:-Code= "response = requests.post(data, auth={'username': 'password'})"
          mined:Baseline= "r = requests.post(url, data=data, auth=('username', 'password'))"
             mined:+Body= 'r = requests.post(url, data=data)'
        mined:+Body, -NL= 'r = requests.post(url, data=data)'
      mined:+Body, -Code= 'r = requests.post(url, data=data, headers=headers, content=content)'

================================================================================

QUESTION: idx=164    id=26443308
-------------------------------------INPUTS-------------------------------------

tags: 
score: 34
slot_map: {'key': ['str_0', 'str_1'], 'quote': ["'", '"'], 'type': ['str', 'str'], 'value': ['}', 'abcd}def}']}
intent: find last occurrence of character '}' in string "abcd}def}"
body(Some added characters for better readability):
	How would I find the last occurrence of a character in a string?
	
	start_block
	string = "abcd}def}"
	string = string.find('}',last) # Want something like this


-------------------------------------OUTPUT-------------------------------------

                Expected= '"""abcd}def}""".rfind(\'}\')'
           base:Baseline= '"""{:.5f}""".format(abcd}def}"'
           base:+Canonic= "re.findall('}', 'abcd}def}')"
           body:Baseline= "string = string.find('}', last)"
              body:-Code= '\'}\'.last(abcd}def}"'
          mined:Baseline= '"""abcd}def""".rsplit(\'}\')'
             mined:+Body= "string = string.find('{}', 1)"
        mined:+Body, -NL= "string = string.find('}', last)"
      mined:+Body, -Code= '"""""".join(c for c in \'abcd}def}"'

================================================================================

QUESTION: idx=165    id=22365172
-------------------------------------INPUTS-------------------------------------

tags: for-loop, syntax
score: 4
slot_map: {'key': ['str_0', '[str_0]'], 'quote': ['`', '`'], 'type': ['str', 'str'], 'value': ['[1, 2, 3]', '[1, 2, 3]']}
intent: iterate ove list `[1, 2, 3]` using list comprehension
body(Some added characters for better readability):
	I am experiencing a bit of confusion with how to place a for loop at the end of a line in python, for instance 
	
	start_block
	for i in x:
	    print i
	produces the expected result but if I run
	
	start_block
	print i for i in x
	I get a syntax error. Could someone explain a little more about how one goes about putting your for loops at the end of a line like this. 


-------------------------------------OUTPUT-------------------------------------

                Expected= 'print([item for item in [1, 2, 3]])'
           base:Baseline= 'for (k, v) in [1, 2, 3])'
           base:+Canonic= 'list(itertools.chain.from_iterable([1, 2, 3]))'
           body:Baseline= 'for i in [1, 2, 3])'
              body:-Code= 'for i in [1, 2, 3]'
          mined:Baseline= '[(1, 2, 3), (3, 4, 5), (4, 5, 6)]'
             mined:+Body= 'for i in [1, 2, 3]]'
        mined:+Body, -NL= 'for i in x:\n    pass'
      mined:+Body, -Code= '[(1, 2, 3)]'

================================================================================

QUESTION: idx=166    id=12300912
-------------------------------------INPUTS-------------------------------------

tags: optimization, dictionary
score: 7
slot_map: {'key': ['str_0', 'str_1', 'var_0'], 'quote': ["'", "'", '`'], 'type': ['str', 'str', 'var'], 'value': ['x', 'y', 'd']}
intent: extract all the values with keys 'x' and 'y' from a list of dictionaries `d` to list of tuples
body(Some added characters for better readability):
	I have a list of dictionaries like this:
	
	start_block
	 data = [{'x': 1, 'y': 10},
	         {'x': 3, 'y': 15},
	         {'x': 2, 'y': 1},
	...]
	
	<p>I have a function (for example 
	`matplotlib.axis.plot`
	) which needs lists of 
	`x`
	 and 
	`y` values. So I have to "transpose" the dictionary".
	First question: what do you call this operation? Is "transpose" the correct term?
	
	<p>I've tried this, but I'm searching for an efficient way (maybe there are some special 
	`numpy` function):
	
	start_block
	x = range(100)
	y = reversed(range(100))
	d = [dict((('x',xx), ('y', yy))) for (xx, yy) in zip(x,y)]
	...]
	timeit.Timer("[dd['x'] for dd in d]", "from __main__ import d").timeit()
	# 6.803985118865967
	from operator import itemgetter
	timeit.Timer("map(itemgetter('x'), d)", "from __main__ import d, itemgetter").timeit()
	# 7.322326898574829
	timeit.Timer("map(f, d)", "from __main__ import d, itemgetter; f=itemgetter('x')").timeit()
	# 7.098556041717529
	# quite dangerous
	timeit.Timer("[dd.values()[1] for dd in d]", "from __main__ import d").timeit()
	# 19.358459949493408
	
	<p>Is there a better solution? My doubt is: in these cases the hash of the string 
	`'x'`is recomputed every time?


-------------------------------------OUTPUT-------------------------------------

                Expected= "[(x['x'], x['y']) for x in d]"
           base:Baseline= '[(x, y) for x, y in d.items()]'
           base:+Canonic= "[(k, v) for k, v in d.items() if 'x' in k]"
           body:Baseline= "d = [dict((('x', 'y') for d in zip(x, y)]"
              body:-Code= "[d['x'] for d in zip(d.items())]"
          mined:Baseline= "[(d['x'], d['y']) for d in d]"
             mined:+Body= '[dict((x, y) for x, y in zip(zip(x, Y))) for y in data]'
        mined:+Body, -NL= "[d['x'] for d in zip(x, y)]"
      mined:+Body, -Code= '[(k, v) for k, v in d.items()]'

================================================================================

QUESTION: idx=167    id=678236
-------------------------------------INPUTS-------------------------------------

tags: string, path
score: 1172
slot_map: {'key': ['str_0'], 'quote': ["'"], 'type': ['str'], 'value': ['hemanth.txt']}
intent: get the filename without the extension from file 'hemanth.txt'
body(Some added characters for better readability):
	How to get the filename without the extension from a path in Python?
	
	<p>For instance, if I had 
	`"/path/to/some/file.txt"`
	, I would want 
	`"file"`.


-------------------------------------OUTPUT-------------------------------------

                Expected= "print(os.path.splitext(os.path.basename('hemanth.txt'))[0])"
           base:Baseline= "os.path.join(open('hemanth.txt')"
           base:+Canonic= "os.path.isfile('hemanth.txt')"
           body:Baseline= "f = os.path.isfile('hemanth.txt')"
              body:-Code= "os.path.isfile('hemanth.txt')"
          mined:Baseline= "os.path.splitext('hemanth.txt')"
             mined:+Body= "os.path.splitext('hemanth.txt')"
        mined:+Body, -NL= "os.path.expanduser('hemanth.txt')"
      mined:+Body, -Code= "print(os.path.splitext('hemanth.txt').extract())"

================================================================================

QUESTION: idx=168    id=2597166
-------------------------------------INPUTS-------------------------------------

tags: list, dictionary
score: 28
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['x']}
intent: create a dictionary by adding each two adjacent elements in tuple `x` as key/value pair to it
body(Some added characters for better readability):
	I need to transform a list into dictionary as follows.
	The odd elements has the key, and even number elements has the value.
	
	`x = (1,'a',2,'b',3,'c')`
	 -> `{1: 'a', 2: 'b', 3: 'c'}`
	
	start_block
	def set(self, val_): 
	    i = 0 
	    for val in val_: 
	        if i == 0: 
	            i = 1 
	            key = val 
	        else: 
	            i = 0 
	            self.dict[key] = val 
	A better way to get the same results?
	ADDED
	
	start_block
	i = iter(k)
	print dict(zip(i,i))
	seems to be working


-------------------------------------OUTPUT-------------------------------------

                Expected= 'dict(x[i:i + 2] for i in range(0, len(x), 2))'
           base:Baseline= 'dict((k, v) for k, v in list(x.items()))'
           base:+Canonic= 'dict((k, v) for k, v in zip(x, x))'
           body:Baseline= 'dict(zip(i, j) for i, j in x)'
              body:-Code= 'dict((k, v) for k, v in x.items())'
          mined:Baseline= 'dict((k, v) for k, v in zip(x, y))'
             mined:+Body= 'dict(zip(i, j) for i, j in zip(x, j))'
        mined:+Body, -NL= 'dict((k, v) for k, v in x.items() if v == 0)'
      mined:+Body, -Code= 'dict(zip(x, y))'

================================================================================

QUESTION: idx=169    id=7895449
-------------------------------------INPUTS-------------------------------------

tags: list, merge, list-comprehension, itertools
score: 6
slot_map: {'key': ['str_0', '[str_0]'], 'quote': ['`', '`'], 'type': ['str', 'str'], 'value': ["[['A', 'B', 'C'], ['D', 'E', 'F'], ['G', 'H', 'I']]", "[['A', 'B', 'C'], ['D', 'E', 'F'], ['G', 'H', 'I']]"]}
intent: create a list containing flattened list `[['a', 'b', 'c'], ['d', 'e', 'f'], ['g', 'h', 'i']]`
body(Some added characters for better readability):
	How do I merge a list of lists?
	
	start_block
	[['A', 'B', 'C'], ['D', 'E', 'F'], ['G', 'H', 'I']]
	into
	
	start_block
	['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I']
	Even better if I can add a value on the beginning and end of each item before merging the lists, like html tags.
	i.e., the end result would be:
	
	start_block
	[' <tr>A </tr>', ' <tr>B </tr>', ' <tr>C </tr>', ' <tr>D </tr>', ' <tr>E </tr>', ' <tr>F </tr>', ' <tr>G </tr>', ' <tr>H </tr>', ' <tr>I </tr>']


-------------------------------------OUTPUT-------------------------------------

                Expected= "values = sum([['A', 'B', 'C'], ['D', 'E', 'F'], ['G', 'H', 'I']], [])"
           base:Baseline= "[['a', 'b', 'c', ['d', 'e', 'f'], ['g', 'h', 'i']]]"
           base:+Canonic= 'list(itertools.product([str_0])'
           body:Baseline= "[['A', 'B', 'C', 'D', 'E', 'F'], ['G', 'H', 'I']]"
              body:-Code= "[[['a', 'b', 'c'], ['d', 'e', 'f'])], ['g', 'h', 'i']]]"
          mined:Baseline= "[['a', 'b', 'c', 'd', 'e', 'f'], ['g', 'h', 'i']]"
             mined:+Body= "[['A', 'B', 'C'], ['D', 'E', 'F', 'G', 'H', 'I']]"
        mined:+Body, -NL= "[['A', 'B', 'C'], ['D', 'E', 'F'], 'G', 'H', 'I']]"
      mined:+Body, -Code= "[['A', 'B', 'C', 'D', 'E', 'f'], ['g', 'h', 'i']]"

================================================================================

QUESTION: idx=170    id=31617845
-------------------------------------INPUTS-------------------------------------

tags: pandas
score: 109
slot_map: {'key': ['var_0', 'str_0'], 'quote': ['`', "'"], 'type': ['var', 'str'], 'value': ['df', 'closing_price']}
intent: select rows in a dataframe `df` column 'closing_price' between two values 99 and 101
body(Some added characters for better readability):
	
	<p>I am trying to modify a DataFrame 
	`df`
	 to only contain rows for which the values in the column 
	`closing_price` are between 99 and 101 and trying to do this with the code below. 
	However, I get the error 
	ValueError: The truth value of a Series is ambiguous. Use a.empty, a.bool(), a.item(), a.any() or a.all()
	and I am wondering if there is a way to do this without using loops.
	
	start_block
	df = df[(99 <= df['closing_price'] <= 101)]


-------------------------------------OUTPUT-------------------------------------

                Expected= "df = df[(df['closing_price'] >= 99) & (df['closing_price'] <= 101)]"
           base:Baseline= "df.loc[df['closing_price'] == 99]"
           base:+Canonic= "df['closing_price'].loc[0, 1]"
           body:Baseline= "df[99 <= df['closing_price'] <= 101]"
              body:-Code= "df.loc[df['closing_price'] == 99]"
          mined:Baseline= "df.loc[df['closing_price'] > 99]"
             mined:+Body= "df[df['closing_price'] > 99]"
        mined:+Body, -NL= "df[df['closing_price'] > 99]"
      mined:+Body, -Code= "df.loc[df.closing_price(['99', '101'])]"

================================================================================

QUESTION: idx=171    id=25698710
-------------------------------------INPUTS-------------------------------------

tags: replace, pandas, dataframe
score: 51
slot_map: {'key': ['str_0', 'str_1', 'var_0'], 'quote': ['`', '`', '`'], 'type': ['str', 'str', 'var'], 'value': ['\n', '<br>', 'df']}
intent: replace all occurences of newlines `\n` with `<br>` in dataframe `df`
body(Some added characters for better readability):
	I have a pandas dataframe with about 20 columns.
	It is possible to replace all occurrences of a string (here a newline) by manually writing all column names:
	
	start_block
	df['columnname1'] = df['columnname1'].str.replace("\n"," <br>")
	df['columnname2'] = df['columnname2'].str.replace("\n"," <br>")
	df['columnname3'] = df['columnname3'].str.replace("\n"," <br>")
	<console_out>
	df['columnname20'] = df['columnname20'].str.replace("\n"," <br>")
	This unfortunately does not work:
	
	start_block
	df = df.replace("\n"," <br>")
	Is there any other, more elegant solution?


-------------------------------------OUTPUT-------------------------------------

                Expected= "df.replace({'\\n': '<br>'}, regex=True)"
           base:Baseline= "df = df.replace(['\\n', '<br>')"
           base:+Canonic= "df.replace('\\n', '<br>')"
           body:Baseline= "df.replace('\\n', '<br>')"
              body:-Code= "df.replace('\\n', '<br>')"
          mined:Baseline= "df.replace('\\n', '<br>')"
             mined:+Body= "df['columnname1'].str.replace('\\\\n', '<br>')"
        mined:+Body, -NL= "df['columnname1'].str.replace('\\n', '<br>')"
      mined:+Body, -Code= "df.replace('\\n', '<br>', '\\n')"

================================================================================

QUESTION: idx=172    id=25698710
-------------------------------------INPUTS-------------------------------------

tags: replace, pandas, dataframe
score: 51
slot_map: {'key': ['str_0', 'str_1', 'var_0'], 'quote': ['`', '`', '`'], 'type': ['str', 'str', 'var'], 'value': ['\n', '<br>', 'df']}
intent: replace all occurrences of a string `\n` by string `<br>` in a pandas data frame `df`
body(Some added characters for better readability):
	I have a pandas dataframe with about 20 columns.
	It is possible to replace all occurrences of a string (here a newline) by manually writing all column names:
	
	start_block
	df['columnname1'] = df['columnname1'].str.replace("\n"," <br>")
	df['columnname2'] = df['columnname2'].str.replace("\n"," <br>")
	df['columnname3'] = df['columnname3'].str.replace("\n"," <br>")
	<console_out>
	df['columnname20'] = df['columnname20'].str.replace("\n"," <br>")
	This unfortunately does not work:
	
	start_block
	df = df.replace("\n"," <br>")
	Is there any other, more elegant solution?


-------------------------------------OUTPUT-------------------------------------

                Expected= "df.replace({'\\n': '<br>'}, regex=True)"
           base:Baseline= "df['\\n'] = df['<br>']"
           base:+Canonic= "df.replace('\\n', '<br>')"
           body:Baseline= "df.replace('\\n', '<br>')"
              body:-Code= "df.replace('\\n', '<br>')"
          mined:Baseline= "df.replace('\\n', '<br>')"
             mined:+Body= "df['columnname1'].str.replace('\\\\n', '<br>')"
        mined:+Body, -NL= "df['columnname1'].str.replace('\\\\n', '<br>')"
      mined:+Body, -Code= "df.replace('\\n', '<br>', inplace=True)"

================================================================================

QUESTION: idx=173    id=41923858
-------------------------------------INPUTS-------------------------------------

tags: map-function
score: 3
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['word']}
intent: create a list containing each two adjacent letters in string `word` as its elements
body(Some added characters for better readability):
	I have a for loop that iterates through a string and returns pairs of each character and the next following one:
	
	
	start_block
	>>>word = 'abcdef'
	>>>for i in range(len(word)-1):
	...    print word[i:i+2]
	<console_out>
	ab
	bc
	cd
	de
	ef
	
	<p>Is it possible to write this using a map/filter combination instead? I'm having a problem figuring out how to get the next character instead of using 
	`i+2`.
	I've tried to pass the word twice to map them together like this:
	
	
	start_block
	>>>word = 'abcdef'
	>>>map(lambda x, y: x+y, word, word[1:])
	...
	But I'm unsure how to avoid the concatenation error with a str and None:
	
	
	start_block
	>>>map(lambda x, y: x+y, word, word[1:])
	...Traceback (most recent call last):
	  File " <stdin>", line 1, in <module>
	  File " <stdin>", line 1, in <lambda>
	TypeError: cannot concatenate 'str' and 'NoneType' objects


-------------------------------------OUTPUT-------------------------------------

                Expected= '[(x + y) for x, y in zip(word, word[1:])]'
           base:Baseline= '[(x + y) for x, y in word]'
           base:+Canonic= 'list(itertools.chain.from_iterable(word))'
           body:Baseline= '[(x + y) for x, y in word]'
              body:-Code= "list(word.split(',')"
          mined:Baseline= '[(x + y) for x, y in word.split()]'
             mined:+Body= 'map(lambda x, y: x + y, word, word[1:])'
        mined:+Body, -NL= 'map(lambda x, y: x + y, word, word[1:])'
      mined:+Body, -Code= '[word[i:i + 2] for i in range(len(word), 2)]'

================================================================================

QUESTION: idx=174    id=41923858
-------------------------------------INPUTS-------------------------------------

tags: map-function
score: 3
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['word']}
intent: get a list of pairs from a string `word` using lambda function
body(Some added characters for better readability):
	I have a for loop that iterates through a string and returns pairs of each character and the next following one:
	
	
	start_block
	>>>word = 'abcdef'
	>>>for i in range(len(word)-1):
	...    print word[i:i+2]
	<console_out>
	ab
	bc
	cd
	de
	ef
	
	<p>Is it possible to write this using a map/filter combination instead? I'm having a problem figuring out how to get the next character instead of using 
	`i+2`.
	I've tried to pass the word twice to map them together like this:
	
	
	start_block
	>>>word = 'abcdef'
	>>>map(lambda x, y: x+y, word, word[1:])
	...
	But I'm unsure how to avoid the concatenation error with a str and None:
	
	
	start_block
	>>>map(lambda x, y: x+y, word, word[1:])
	...Traceback (most recent call last):
	  File " <stdin>", line 1, in <module>
	  File " <stdin>", line 1, in <lambda>
	TypeError: cannot concatenate 'str' and 'NoneType' objects


-------------------------------------OUTPUT-------------------------------------

                Expected= 'list(map(lambda x, y: x + y, word[:-1], word[1:]))'
           base:Baseline= '[(k, v) for k, v in word.items()]'
           base:+Canonic= '[k for k, v in word.split()]'
           body:Baseline= 'print(word[i:i + 2])'
              body:-Code= '[k for k, v in word.split()]'
          mined:Baseline= '[(x, y) for x, y in word.split()]'
             mined:+Body= 'map(lambda x, y: x + y, word, word[1:])'
        mined:+Body, -NL= 'map(lambda x, y: x + y, word, word[1:])'
      mined:+Body, -Code= '[(k, v) for k, v in word.items()]'

================================================================================

QUESTION: idx=175    id=9760588
-------------------------------------INPUTS-------------------------------------

tags: string, url, extract
score: 13
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['myString']}
intent: extract a url from a string `mystring`
body(Some added characters for better readability):
	For example: 
	
	start_block
	string = "This is a link http://www.google.com"
	How could I extract 'http://www.google.com' ? 
	(Each link will be of the same format i.e 'http://')


-------------------------------------OUTPUT-------------------------------------

                Expected= "print(re.findall('(https?://[^\\\\s]+)', myString))"
           base:Baseline= 'urllib.parse.quote(myString)'
           base:+Canonic= 'urllib.parse.unquote(var_0))'
           body:Baseline= '"""This is a link http://www.google.com""".join(mystring))'
              body:-Code= "myString.rfind('http://www.google.com')"
          mined:Baseline= 'urllib.parse.quote(myString)'
             mined:+Body= "urllib.parse.urlretrieve('http://www.google.com', myString)"
        mined:+Body, -NL= "urllib.request.urlretrieve('http://www.google.com', myString)"
      mined:+Body, -Code= "urllib.parse.urlencode('http://www.google.com')"

================================================================================

QUESTION: idx=176    id=9760588
-------------------------------------INPUTS-------------------------------------

tags: string, url, extract
score: 13
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['myString']}
intent: extract a url from a string `mystring`
body(Some added characters for better readability):
	For example: 
	
	start_block
	string = "This is a link http://www.google.com"
	How could I extract 'http://www.google.com' ? 
	(Each link will be of the same format i.e 'http://')


-------------------------------------OUTPUT-------------------------------------

                Expected= "print(re.search('(?P<url>https?://[^\\\\s]+)', myString).group('url'))"
           base:Baseline= 'urllib.parse.quote(myString)'
           base:+Canonic= 'urllib.parse.unquote(var_0))'
           body:Baseline= '"""This is a link http://www.google.com""".join(mystring))'
              body:-Code= "myString.rfind('http://www.google.com')"
          mined:Baseline= 'urllib.parse.quote(myString)'
             mined:+Body= "urllib.parse.urlretrieve('http://www.google.com', myString)"
        mined:+Body, -NL= "urllib.request.urlretrieve('http://www.google.com', myString)"
      mined:+Body, -Code= "urllib.parse.urlencode('http://www.google.com')"

================================================================================

QUESTION: idx=177    id=5843518
-------------------------------------INPUTS-------------------------------------

tags: regex, string
score: 280
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['mystring']}
intent: remove all special characters, punctuation and spaces from a string `mystring` using regex
body(Some added characters for better readability):
	I need to remove all special characters, punctuation and spaces from a string so that I only have letters and numbers.


-------------------------------------OUTPUT-------------------------------------

                Expected= "re.sub('[^A-Za-z0-9]+', '', mystring)"
           base:Baseline= "re.sub('(\\\\w+)', myString)"
           base:+Canonic= "re.sub('\\\\w+\\\\w', mystring)"
           body:Baseline= "re.sub('[^a-z]', mystring)"
              body:-Code= "re.sub('\\\\w+', myString)"
          mined:Baseline= "re.sub('[^a-zA-Z]', '', myString)"
             mined:+Body= "re.sub('\\\\s+', '', mystring)"
        mined:+Body, -NL= "re.sub('[^a-zA-Z]', '', mystring)"
      mined:+Body, -Code= "re.sub('[^a-zA-Z]', '', myString)"

================================================================================

QUESTION: idx=178    id=36674519
-------------------------------------INPUTS-------------------------------------

tags: datetime, pandas, indexing
score: 4
slot_map: {'key': ['str_0'], 'quote': ["'"], 'type': ['str'], 'value': ['2016-01-01']}
intent: create a datetimeindex containing 13 periods of the second friday of each month starting from date '2016-01-01'
body(Some added characters for better readability):
	I need to get the 2nd Friday of each month in Python.
	
	<p>I have written the function below that demonstrates what I need. However, I am wondering if there is a more elegant way to do it using Pandas' 
	`date_range` function and appropriate offsets.
	
	start_block
	def second_friday_of_month_date_range( start, end ):
	    dr = pd.date_range( start, end, freq='MS' )
	    first_weekday_of_month_to_2nd_friday_of_month = np.array( [ 12, 11, 10, 9, 8, 14, 13 ], dtype=int )
	    wd                                            = first_weekday_of_month_to_2nd_friday_of_month[ dr.weekday ]
	    offsets                                       = [ datetime.timedelta( days=int(x)-1 ) for x in wd ]
	    dts                                           = [d+o for d, o in zip( dr, offsets)]
	    return pd.DatetimeIndex( dts )
	import pandas as pd
	import datetime
	d0 = datetime.datetime(2016,1,1)
	d1 = datetime.datetime(2017,1,1)
	dr = second_friday_of_month_date_range( d0, d1 )
	print( dr )
	>> DatetimeIndex(['2016-01-08', '2016-02-12', '2016-03-11', '2016-04-08',
	               '2016-05-13', '2016-06-10', '2016-07-08', '2016-08-12',
	               '2016-09-09', '2016-10-14', '2016-11-11', '2016-12-09',
	               '2017-01-13'],
	              dtype='datetime64[ns]', freq=None, tz=None)


-------------------------------------OUTPUT-------------------------------------

                Expected= "pd.date_range('2016-01-01', freq='WOM-2FRI', periods=13)"
           base:Baseline= "datetime.strptime('January 2, 2019', '%Y-%m-%d-%Y').date()"
           base:+Canonic= "datetime.strptime('2016-01-01', 13)"
           body:Baseline= "datetimeindex.date_range(13, '2016-01-01', freq='MS')"
              body:-Code= "pd.datetime.strptime('2016-01-01', '%Y-%m-%d%H:%M')"
          mined:Baseline= 'datetimeindex.get_datetime(datetime.timedelta(days=1, periods=12))'
             mined:+Body= 'pd.to_datetime(pd.Timedelta(1970, 1, 1))'
        mined:+Body, -NL= 'pd.to_datetime(pd.Timedelta(days=int(x) for x in wd, dts)'
      mined:+Body, -Code= "pd.to_datetime(pd.TimeGrouper('2016-01-01', how='sum')"

================================================================================

QUESTION: idx=179    id=508657
-------------------------------------INPUTS-------------------------------------

tags: java, arrays
score: 8
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['matrix']}
intent: create multidimensional array `matrix` with 3 rows and 2 columns in python
body(Some added characters for better readability):
	I have a little Java problem I want to translate to Python. Therefor I need a multidimensional array. In Java it looks like:
	
	start_block
	double dArray[][][] = new double[x.length()+1][y.length()+1][x.length()+y.length()+3];
	dArray[0][0][0] = 0;
	dArray[0][0][1] = POSITIVE_INFINITY;
	Further values will be created bei loops and written into the array.
	How do I instantiate the array?
	PS: There is no matrix multiplication involved...


-------------------------------------OUTPUT-------------------------------------

                Expected= 'matrix = [[a, b], [c, d], [e, f]]'
           base:Baseline= 'matrix.shape(3, 2)'
           base:+Canonic= 'matrix = np.array([3, 2], axis=1)'
           body:Baseline= 'matrix = np.array([3, 2], axis=1)'
              body:-Code= 'matrix = np.array([3, 2], axis=1)'
          mined:Baseline= 'matrix = [[(1, 2), (3, 4), (5, 6)] for i in range(0, len(matrix), 3)]'
             mined:+Body= 'matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]'
        mined:+Body, -NL= 'matrix = [[1, 2, 3], [4, 5, 6]]'
      mined:+Body, -Code= 'matrix = [[(i * j) for i in range(0, len(matrix)), (i + j)], (i - j)]'

================================================================================

QUESTION: idx=180    id=1007481
-------------------------------------INPUTS-------------------------------------

tags: regex, django
score: 244
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: replace spaces with underscore
body(Some added characters for better readability):
	I want to replace whitespace with underscore in a string to create nice URLs. So that for example:
	
	start_block
	"This should be connected" becomes "This_should_be_connected" 
	I am using Python with Django. Can this be solved using regular expressions?  


-------------------------------------OUTPUT-------------------------------------

                Expected= "mystring.replace(' ', '_')"
           base:Baseline= "re.sub('([^a-z])', '', re.DOTABASE)"
           base:+Canonic= "re.sub('[^a-zA-Z]', '', '\\\\d+', '')"
           body:Baseline= '"""This_should_be_connected""".replace(\'\', \'\')'
              body:-Code= "re.sub('\\\\w+', '', '')"
          mined:Baseline= "re.sub('(?<=.)(?=.)', '\\\\1', s)"
             mined:+Body= '"""This_should_be_connected""".replace(\' \', \'\')'
        mined:+Body, -NL= "re.sub('(\\\\w+)', '\\\\1', 'This_should_be_connected')"
      mined:+Body, -Code= "re.sub('(?<=.)(?=.)', '\\\\1', s)"

================================================================================

QUESTION: idx=181    id=51520
-------------------------------------INPUTS-------------------------------------

tags: path, relative-path, absolute-path
score: 823
slot_map: {'key': ['str_0'], 'quote': ["'"], 'type': ['str'], 'value': ['mydir/myfile.txt']}
intent: get an absolute file path of file 'mydir/myfile.txt'
body(Some added characters for better readability):
	
	<p>Given a path such as 
	`"mydir/myfile.txt"`, how do I find the file's absolute path relative to the current working directory in Python? E.g. on Windows, I might end up with:
	
	start_block
	"C:/example/cwd/mydir/myfile.txt"


-------------------------------------OUTPUT-------------------------------------

                Expected= "os.path.abspath('mydir/myfile.txt')"
           base:Baseline= "os.path.abspath('mydir/myfile.txt')"
           base:+Canonic= "os.path.abspath('mydir/myfile.txt')"
           body:Baseline= "os.path.realpath('mydir/myfile.txt')"
              body:-Code= "os.path.abspath('mydir/myfile.txt')"
          mined:Baseline= "os.path.abspath('mydir/myfile.txt')"
             mined:+Body= "os.path.abspath('mydir/myfile.txt')"
        mined:+Body, -NL= "os.path.abspath('mydir/myfile.txt')"
      mined:+Body, -Code= "os.path.abspath('mydir/myfile.txt')"

================================================================================

QUESTION: idx=182    id=1249786
-------------------------------------INPUTS-------------------------------------

tags: string, line-breaks
score: 4
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['my_string']}
intent: split string `my_string` on white spaces
body(Some added characters for better readability):
	Is there a cross-platform library function that would collapse a multiline string into a single-line string with no repeating spaces?
	I've come up with some snip below, but I wonder if there is a standard function which I could just import which is perhaps even optimized in C?
	
	start_block
	def collapse(input):
	    import re
	    rn = re.compile(r'(\r\n)+')
	    r = re.compile(r'\r+')
	    n = re.compile(r'\n+')
	    s = re.compile(r'\ +')
	    return s.sub(' ',n.sub(' ',r.sub(' ',rn.sub(' ',input))))
	
	<p>P.S. Thanks for good observations. 
	`' '.join(input.split())`
	 seems to be the winner as it actually runs faster about twice in my case compared to search-replace with a precompiled 
	`r'\s+'` regex.


-------------------------------------OUTPUT-------------------------------------

                Expected= '""" """.join(my_string.split())'
           base:Baseline= "my_string.split('\\n')"
           base:+Canonic= "re.split('\\n', my_string)"
           body:Baseline= "re.sub(' '.join(input.split())"
              body:-Code= "re.sub('\\\\w+', my_string)"
          mined:Baseline= "re.split('\\\\s+', my_string)"
             mined:+Body= "re.compile('\\\\s+', my_string)"
        mined:+Body, -NL= "re.sub('\\\\s+', my_string)"
      mined:+Body, -Code= "my_string.split(' ', 1)"

================================================================================

QUESTION: idx=183    id=4444923
-------------------------------------INPUTS-------------------------------------

tags: regex
score: 91
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['filename']}
intent: get filename without extension from file `filename`
body(Some added characters for better readability):
	If I have a filename like one of these:
	
	start_block
	1.1.1.1.1.jpg
	1.1.jpg
	1.jpg
	How could I get only the filename, without the extension? Would a regex be appropriate?


-------------------------------------OUTPUT-------------------------------------

                Expected= 'os.path.splitext(filename)[0]'
           base:Baseline= "re.sub('(filename)', '', filename)"
           base:+Canonic= 'print(os.path.join(filename))'
           body:Baseline= 'filename.rsplit(filename)'
              body:-Code= 'print(os.path.isfile(filename))'
          mined:Baseline= 'print(os.path.join(filename, filename))'
             mined:+Body= "print(re.compile('\\\\.join(filename) for filename in filename))"
        mined:+Body, -NL= "os.path.expanduser('filename', filename)"
      mined:+Body, -Code= 'print(os.path.splitext(filename))'

================================================================================

QUESTION: idx=184    id=13728486
-------------------------------------INPUTS-------------------------------------

tags: functional-programming
score: 5
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['i', 'l']}
intent: get a list containing the sum of each element `i` in list `l` plus the previous elements
body(Some added characters for better readability):
	I am trying to write a function which maps elements of a list to get sum of the element and the previous elements in the list in a functional style using python e.g. :     
	
	start_block
	func([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) = [0, 1, 3, 6, 10, 15, 21, 28, 36, 45]
	
	<p>I have tried using recursion, but get 
	`RuntimeError: maximum recursion depth exceeded` with a long list.:
	
	start_block
	def recursion_way(inlist, accu, summ):
	    if len(inlist) == 0:
	         return accu
	    else:
	        return recursion_way(inlist[1:], accu + [summ + inlist[0]], summ + inlist[0])


-------------------------------------OUTPUT-------------------------------------

                Expected= '[sum(l[:i]) for i, _ in enumerate(l)]'
           base:Baseline= '[sum(i) for i in L]'
           base:+Canonic= '[sum(x + y) for x, y in zip(l, i)]'
           body:Baseline= '[sum(i) for i, j in L]'
              body:-Code= '[sum(i) for i in L]'
          mined:Baseline= '[sum(i) for i in L]'
             mined:+Body= '[sum(x) for x in L if x[0] == 0]'
        mined:+Body, -NL= '[sum(i) for i in zip(*L)]'
      mined:+Body, -Code= '[sum(i) for i in l]'

================================================================================

QUESTION: idx=185    id=9743134
-------------------------------------INPUTS-------------------------------------

tags: regex
score: 7
slot_map: {'key': ['str_0', 'str_1', 'str_2'], 'quote': ['`', '`', '`'], 'type': ['str', 'str', 'str'], 'value': ['Docs/src/Scripts/temp', '/', '/']}
intent: split a string `docs/src/scripts/temp` by `/` keeping `/` in the result
body(Some added characters for better readability):
	Easiest way to explain this is an example:
	I have this string: 'Docs/src/Scripts/temp'
	Which I know how to split two different ways:
	
	start_block
	re.split('/', 'Docs/src/Scripts/temp') -> ['Docs', 'src', 'Scripts', 'temp']
	re.split('(/)', 'Docs/src/Scripts/temp') -> ['Docs', '/', 'src', '/', 'Scripts', '/', 'temp']
	Is there a way to split by the forward slash, but keep the slash part of the words?
	For example, I want the above string to look like this:
	
	start_block
	['Docs/', '/src/', '/Scripts/', '/temp']
	Any help would be appreciated!


-------------------------------------OUTPUT-------------------------------------

                Expected= '"""Docs/src/Scripts/temp""".replace(\'/\', \'/\\x00/\').split(\'\\x00\')'
           base:Baseline= "re.split('//', 'docs/src/scripts/temp')"
           base:+Canonic= '"""Docs/src/Scripts/temp""".split(\'/\')'
           body:Baseline= "re.split('Docs/src/Scripts/temp')"
              body:-Code= '"""Docs/src/scripts/temp""".split(\',/\', \'/\')'
          mined:Baseline= "result = re.split('/', '/')"
             mined:+Body= "re.split('/', 'Docs/src/Scripts/temp')"
        mined:+Body, -NL= "re.split('/', 'Docs/src/scripts/temp')"
      mined:+Body, -Code= '"""Doc/src/scripts/temp""".split(\',/\')'

================================================================================

QUESTION: idx=186    id=20546419
-------------------------------------INPUTS-------------------------------------

tags: arrays, numpy
score: 21
slot_map: {'key': ['str_0'], 'quote': ["'"], 'type': ['str'], 'value': ['r']}
intent: shuffle columns of an numpy array 'r'
body(Some added characters for better readability):
	
	<p>Let's say I have an array 
	`r`
	 of dimension 
	`(n, m)`. I would like to shuffle the columns of that array.
	
	<p>If I use 
	`numpy.random.shuffle(r)` it shuffles the lines. How can I only shuffle the columns? So that the first column become the second one and the third the first, etc, randomly.
	Example:
	input:
	
	start_block
	array([[  1,  20, 100],
	       [  2,  31, 401],
	       [  8,  11, 108]])
	output:
	
	start_block
	array([[  20, 1, 100],
	       [  31, 2, 401],
	       [  11,  8, 108]])


-------------------------------------OUTPUT-------------------------------------

                Expected= 'np.random.shuffle(np.transpose(r))'
           base:Baseline= 'np. shuffle(np.reshape(r, axis=0)'
           base:+Canonic= 'np.shuffle([r])'
           body:Baseline= 'np.shuffle(np.arange(axis=0), reverse=True)'
              body:-Code= 'np.shuffle(r, axis=1)'
          mined:Baseline= 'np.random.shuffle(r, axis=1)'
             mined:+Body= 'np.random.shuffle(r, axis=1)'
        mined:+Body, -NL= 'np.random.shuffle(r, axis=1)'
      mined:+Body, -Code= 'np.random.shuffle(r, axis=1)'

================================================================================

QUESTION: idx=187    id=32675861
-------------------------------------INPUTS-------------------------------------

tags: pandas
score: 59
slot_map: {'key': ['str_0', 'str_1', 'str_2'], 'quote': ["'", "'", "'"], 'type': ['str', 'str', 'str'], 'value': ['B', 'D', 'df']}
intent: copy all values in a column 'b' to a new column 'd' in a pandas data frame 'df'
body(Some added characters for better readability):
	This is a very basic question, I just can not seem to find an answer.
	I have a dataframe like this, called df:
	
	start_block
	  A     B     C
	 a.1   b.1   c.1
	 a.2   b.2   c.2
	 a.3   b.3   c.3
	Then I extract all the rows from df, where column 'B' has a value of 'b.2'.  I assign these results to df_2.  
	
	start_block
	df_2 = df[df['B'] == 'b.2']
	df_2 becomes:
	
	start_block
	  A     B     C
	 a.2   b.2   c.2
	Then, I copy all the values in column 'B' to a new column named 'D'. Causing df_2 to become: 
	
	start_block
	  A     B     C     D
	 a.2   b.2   c.2   b.2
	When I preform an assignment like this:
	
	start_block
	df_2['D'] = df_2['B']
	I get the following warning:
	A value is trying to be set on a copy of a slice from a DataFrame. Try
	  using .loc[row_indexer,col_indexer] = value instead
	See the the caveats in the documentation:
	http://pandas.pydata.org/pandas-docs/stable/indexing.html#indexing-view-versus-copy
	I have also tried using .loc when creating df_2 like this:
	
	start_block
	df_2 = df.loc[df['B'] == 'b.2']
	However, I still get the warning. 
	Any help is greatly appreciated.


-------------------------------------OUTPUT-------------------------------------

                Expected= "df['D'] = df['B']"
           base:Baseline= "df['b'] = df['d']"
           base:+Canonic= "pd.concat([str_2['str_0'].str_1]].apply(lambda x: x.values())"
           body:Baseline= "df.loc[df['B'] == 'B.2']"
              body:-Code= "df.copy(['B', 'D'], axis=1)"
          mined:Baseline= "df['b'] = df['d'].astype(int)"
             mined:+Body= "df.loc[df['B'] == 'b.2']"
        mined:+Body, -NL= "df.loc[df['B'] == 'b.2']"
      mined:+Body, -Code= "df_2 = df.loc[row_indexer == 'B' for row in df.values]"

================================================================================

QUESTION: idx=188    id=14227561
-------------------------------------INPUTS-------------------------------------

tags: dictionary, nested
score: 13
slot_map: {'key': ['str_0', 'str_1'], 'quote': ["'", "'"], 'type': ['str', 'str'], 'value': ['data', 'B']}
intent: find a value within nested json 'data' where the key inside another key 'b' is unknown.
body(Some added characters for better readability):
	
	<p>From the following json, in python, I'd like to extract the value "TEXT". All the keys are constant except for unknown. Unknown could be any string like "a6784t66" or "hobvp*nfe". 
	The value of unknown is not known , only that it will be in that position in each json response.
	
	start_block
	{
	  "A": {
	    "B": {
	      "unknown": {
	        "1": "F",
	        "maindata": [
	          {
	            "Info": "TEXT"
	          }
	        ]
	      }
	    }
	  }
	}
	one line json
	
	start_block
	'{"A":{"B":{"unknown":{"1":"F","maindata":[{"Info":"TEXT"}]}}}}'
	How would you get the value of "Text"? (I know how to load the json with json.loads)..but I'm not sure how to get the value of "Text". Thanks.
	(I'm not sure what the best title is.)


-------------------------------------OUTPUT-------------------------------------

                Expected= "list(data['A']['B'].values())[0]['maindata'][0]['Info']"
           base:Baseline= "[k for k, v in data.items() if 'b' in k]"
           base:+Canonic= "json.dumps({'data': 'B'})"
           body:Baseline= "json.loads(['A', 'B', 'Info'])"
              body:-Code= "json.loads('data', key=operator.itemgetter('b'))"
          mined:Baseline= "[(k, v) for k, v in data.items() if 'b' in k]"
             mined:+Body= "{k: v for k, v in data.items() if k != 'TEXT'}"
        mined:+Body, -NL= "{k: v for k, v in data.items() if 'A' in k}"
      mined:+Body, -Code= "TEXT = json.loads('data', ensure_ascii=False)"

================================================================================

QUESTION: idx=189    id=14858916
-------------------------------------INPUTS-------------------------------------

tags: 
score: 5
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['string', 'predicate']}
intent: check characters of string `string` are true predication of function `predicate`
body(Some added characters for better readability):
	In Python 3, what's the shortest way to check whether a predicate is true for all characters of a string?


-------------------------------------OUTPUT-------------------------------------

                Expected= 'all(predicate(x) for x in string)'
           base:Baseline= '"""""".join(str(predicate))'
           base:+Canonic= '"""string""".encode(\'predicate\')'
           body:Baseline= 'print(predicate.False).issubset(string)'
              body:-Code= 'print(predicate.__dict__ for _ in string)'
          mined:Baseline= '"""""".join(predicate(string))'
             mined:+Body= 'print(predicate(s) for s in string.values())'
        mined:+Body, -NL= "print(re.sub('(?<predicate)', '', string))"
      mined:+Body, -Code= 'all(predicate(string) for _ in string)'

================================================================================

QUESTION: idx=190    id=574236
-------------------------------------INPUTS-------------------------------------

tags: macos, filesystems, hard-drive
score: 5
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: determine number of files on a drive with python
body(Some added characters for better readability):
	I have been trying to figure out how to retrieve (quickly) the number of files on a given HFS+ drive with python.
	I have been playing with os.statvfs and such, but can't quite get anything (that seems helpful to me).
	Any ideas?
	
	<strong>Edit:  Let me be a bit more specific. =]
	
	<p>I am writing a timemachine-like wrapper around rsync for various reasons, and would like a very fast estimate (does not have to be perfect) of the number of files on the drive rsync is going to scan. This way I can watch the progress from rsync (if you call it like 
	`rsync -ax --progress`
	, or with the 
	`-P` option) as it builds its initial file list, and report a percentage and/or ETA back to the user.
	This is completely separate from the actual backup, which is no problem tracking progress. But with the drives I am working on with several million files, it means the user is watching a counter of the number of files go up with no upper bound for a few minutes.
	I have tried playing with os.statvfs with exactly the method described in one of the answers so far, but the results do not make sense to me.
	
	
	start_block
	>>>import os
	>>>os.statvfs('/').f_files - os.statvfs('/').f_ffree
	...64171205L
	The more portable way gives me around 1.1 million on this machine, which is the same as every other indicator I have seen on this machine, including rsync running its preparations:
	
	
	start_block
	>>>sum(len(filenames) for path, dirnames, filenames in os.walk("/"))
	...1084224
	Note that the first method is instantaneous, while the second one made me come back 15 minutes later to update because it took just that long to run.
	Does anyone know of a similar way to get this number, or what is wrong with how I am treating/interpreting the os.statvfs numbers?


-------------------------------------OUTPUT-------------------------------------

                Expected= "os.statvfs('/').f_files - os.statvfs('/').f_ffree"
           base:Baseline= "print(os.path.join(open('file_count', 'txt_count'))"
           base:+Canonic= 'sys.path.to_my_file(1)'
           body:Baseline= "sum(len(os.statvfs('/').f_files)"
              body:-Code= 'sys.statvfs.count()'
          mined:Baseline= 'sum(1 for i in os.listdir(file_name))'
             mined:+Body= "sum(f_files - os.statvfs('/').f_ffree)"
        mined:+Body, -NL= "os.statvfs('/').f_files"
      mined:+Body, -Code= 'return sum(os.statvfs(f) / len(f))'

================================================================================

QUESTION: idx=191    id=7011291
-------------------------------------INPUTS-------------------------------------

tags: sql, sqlite
score: 34
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: how to get a single result from a sqlite query in python?
body(Some added characters for better readability):
	Is there an elegant way of getting a single result from an SQLite SELECT query when using python 2.7?
	for example:
	
	start_block
	conn = sqlite3.connect('db_path.db')
	cursor=conn.cursor()
	cursor.execute("SELECT MAX(value) FROM table")
	for row in cursor:
	    for elem in row:
	        maxVal = elem
	
	<p>is there a way to avoid those nested 
	`for`s and get the value directly? I've tried
	
	start_block
	maxVal = cursor[0][0]
	without any success.


-------------------------------------OUTPUT-------------------------------------

                Expected= 'cursor.fetchone()[0]'
           base:Baseline= 'results = sqlite.query(lambda x: x[1])'
           base:+Canonic= 'cursor.query(lambda x: x[1])'
           body:Baseline= "cursor.execute('SELECT MAX(value) FROM table')"
              body:-Code= 'result = query.query.result()'
          mined:Baseline= "cursor.execute('SELECT * FROM table WHERE index = %s', (result, result))"
             mined:+Body= "cursor.execute('SELECT MAX(value) FROM table')"
        mined:+Body, -NL= "cursor.execute('SELECT MAX(value) FROM table')"
      mined:+Body, -Code= "cursor.execute('SELECT * FROM table VALUES (%s)', (1, 2, 3))"

================================================================================

QUESTION: idx=192    id=6378889
-------------------------------------INPUTS-------------------------------------

tags: string, list, int
score: 10
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['user_input', 'user_list']}
intent: convert string `user_input` into a list of integers `user_list`
body(Some added characters for better readability):
	In my python Script I have:
	
	start_block
	user = nuke.getInput("Frames Turned On")
	userLst = [user]
	print userLst
	Result: 
	
	start_block
	['12,33,223']
	
	<p>I was wondering How I would remove the 
	`'` in the list, or somehow convert it into int?


-------------------------------------OUTPUT-------------------------------------

                Expected= "user_list = [int(number) for number in user_input.split(',')]"
           base:Baseline= 'user_input = [int(x) for x in user_list]'
           base:+Canonic= '[int(x) for x in user_list]'
           body:Baseline= 'user_list = [int(x) for x in user_list]'
              body:-Code= 'user_list = [int(x) for x in user_list]'
          mined:Baseline= '[int(user_input) for user in user_list]'
             mined:+Body= "nuke.getInput('Frames Turned On')"
        mined:+Body, -NL= "nuke.getInput('Frames Turned On')"
      mined:+Body, -Code= 'user_list = [int(i) for i in input]'

================================================================================

QUESTION: idx=193    id=6378889
-------------------------------------INPUTS-------------------------------------

tags: string, list, int
score: 10
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['user']}
intent: get a list of integers by splitting  a string `user` with comma
body(Some added characters for better readability):
	In my python Script I have:
	
	start_block
	user = nuke.getInput("Frames Turned On")
	userLst = [user]
	print userLst
	Result: 
	
	start_block
	['12,33,223']
	
	<p>I was wondering How I would remove the 
	`'` in the list, or somehow convert it into int?


-------------------------------------OUTPUT-------------------------------------

                Expected= "[int(s) for s in user.split(',')]"
           base:Baseline= "[int(x) for x in user.split(',')]"
           base:+Canonic= '[int(x) for x in user.split()]'
           body:Baseline= "user = nuke.split(',')"
              body:-Code= '[int(x) for x in user.split()]'
          mined:Baseline= '[int(x) for x in user.split()]'
             mined:+Body= "nuke.getInput('Frames Turned On')"
        mined:+Body, -NL= '[int(x) for x in user.split()]'
      mined:+Body, -Code= '[int(i) for i in user.split()]'

================================================================================

QUESTION: idx=194    id=5212870
-------------------------------------INPUTS-------------------------------------

tags: sorting
score: 195
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: sorting a python list by two criteria
body(Some added characters for better readability):
	I have the following list created from a sorted csv
	
	start_block
	list1 = sorted(csv1, key=operator.itemgetter(1))
	I would actually like to sort the list by two criteria: first by the value in field 1 and then by the value in field 2. How do I do this?


-------------------------------------OUTPUT-------------------------------------

                Expected= 'sorted(list, key=lambda x: (x[0], -x[1]))'
           base:Baseline= 'sorted(list(itertools.chain.from_iterable(2)))'
           base:+Canonic= 'sorted(key=lambda x: x[2])'
           body:Baseline= 'sorted(csv1, key=operator.itemgetter(1))'
              body:-Code= 'sorted(list(keys=lambda x: x[1])'
          mined:Baseline= 'sorted(lst, key=lambda x: x[1])'
             mined:+Body= 'sorted(csv1, key=operator.itemgetter(1))'
        mined:+Body, -NL= 'sorted(csv1, key=operator.itemgetter(1))'
      mined:+Body, -Code= 'sorted(my_list, key=lambda x: x[1])'

================================================================================

QUESTION: idx=195    id=403421
-------------------------------------INPUTS-------------------------------------

tags: list, sorting, oop, count
score: 909
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['ut', 'cmpfun']}
intent: sort a list of objects `ut`, based on a function `cmpfun` in descending order
body(Some added characters for better readability):
	I've got a list of Python objects that I'd like to sort by an attribute of the objects themselves.  The list looks like:
	
	
	start_block
	>>>ut
	...[ <Tag: 128>, <Tag: 2008>, <Tag: <>, <Tag: actionscript>, <Tag: addresses>,
	 <Tag: aes>, <Tag: ajax> <console_out>]
	Each object has a count:
	
	
	start_block
	>>>ut[1].count
	...1L
	I need to sort the list by number of counts descending.
	I've seen several methods for this, but I'm looking for best practice in Python.


-------------------------------------OUTPUT-------------------------------------

                Expected= 'ut.sort(key=cmpfun, reverse=True)'
           base:Baseline= 'ut.sort(key=lambda x: x[1])'
           base:+Canonic= 'sorted(ut, key=lambda x: x[1])'
           body:Baseline= 'ut.sort(key=lambda x: x[1])'
              body:-Code= 'sorted(ut, key=lambda x: int(x.count(cmpfun)))'
          mined:Baseline= "sorted(ut, key=operator.attrgetter('cmpfun'))"
             mined:+Body= "sorted(ut, key=lambda x: int(x['count']))"
        mined:+Body, -NL= 'ut.sort(key=lambda x: int(x[1].count()), reverse=True)'
      mined:+Body, -Code= 'sorted(ut, key=cmpfun, reverse=True)'

================================================================================

QUESTION: idx=196    id=403421
-------------------------------------INPUTS-------------------------------------

tags: list, sorting, oop, count
score: 909
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['ut', 'count']}
intent: reverse list `ut` based on the `count` attribute of each object
body(Some added characters for better readability):
	I've got a list of Python objects that I'd like to sort by an attribute of the objects themselves.  The list looks like:
	
	
	start_block
	>>>ut
	...[ <Tag: 128>, <Tag: 2008>, <Tag: <>, <Tag: actionscript>, <Tag: addresses>,
	 <Tag: aes>, <Tag: ajax> <console_out>]
	Each object has a count:
	
	
	start_block
	>>>ut[1].count
	...1L
	I need to sort the list by number of counts descending.
	I've seen several methods for this, but I'm looking for best practice in Python.


-------------------------------------OUTPUT-------------------------------------

                Expected= 'ut.sort(key=lambda x: x.count, reverse=True)'
           base:Baseline= 'ut.sort(key=lambda x: x[1])'
           base:+Canonic= 'ut = reverse_list(count, ut)'
           body:Baseline= 'ut.sort(key=lambda x: x[1].count()'
              body:-Code= 'sorted(ut, key=lambda x: x[1])'
          mined:Baseline= 'ut.sort(key=lambda x: x[1])'
             mined:+Body= 'sorted(ut, key=lambda x: int(x.count()))'
        mined:+Body, -NL= 'ut.reverse(1, 1)'
      mined:+Body, -Code= 'sorted(ut, reverse=True)'

================================================================================

QUESTION: idx=197    id=403421
-------------------------------------INPUTS-------------------------------------

tags: list, sorting, oop, count
score: 909
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['ut', 'count']}
intent: sort a list of objects `ut` in reverse order by their `count` property
body(Some added characters for better readability):
	I've got a list of Python objects that I'd like to sort by an attribute of the objects themselves.  The list looks like:
	
	
	start_block
	>>>ut
	...[ <Tag: 128>, <Tag: 2008>, <Tag: <>, <Tag: actionscript>, <Tag: addresses>,
	 <Tag: aes>, <Tag: ajax> <console_out>]
	Each object has a count:
	
	
	start_block
	>>>ut[1].count
	...1L
	I need to sort the list by number of counts descending.
	I've seen several methods for this, but I'm looking for best practice in Python.


-------------------------------------OUTPUT-------------------------------------

                Expected= 'ut.sort(key=lambda x: x.count, reverse=True)'
           base:Baseline= 'ut.sort(key=lambda x: x[1])'
           base:+Canonic= 'sorted(ut, key=lambda x: x[1])'
           body:Baseline= 'ut.sort(key=lambda x: x[1].count)'
              body:-Code= 'sorted(ut, key=lambda x: x.count)'
          mined:Baseline= 'sorted(ut, key=lambda x: x.count)'
             mined:+Body= 'sorted(ut, reverse=True)'
        mined:+Body, -NL= 'sorted(ut, reverse=True)'
      mined:+Body, -Code= 'sorted(ut, reverse=True)'

================================================================================

QUESTION: idx=198    id=19601086
-------------------------------------INPUTS-------------------------------------

tags: selenium, button, click, href
score: 19
slot_map: {'key': ['str_0'], 'quote': ["'"], 'type': ['str'], 'value': ['Send']}
intent: click a href button 'send' with selenium
body(Some added characters for better readability):
	I have one button from one LinkedIn page with this code:
	
	start_block
	<div class="primary-action-button"> <a class="primary-action label" href="/requestList?displayProposal=&amp;destID=39959446&amp;creationType=DC&amp;authToken=Yr4_&amp;authType=OUT_OF_NETWORK&amp;trk=vsrp_people_res_pri_act&amp;trkInfo=VSRPsearchId%3A2998448551382744275729%2CVSRPtargetId%3A39959446%2CVSRPcmpt%3Aprimary">Send InMail </a> </div>
	Is there any way to click on an element just by its href link? Thanks


-------------------------------------OUTPUT-------------------------------------

                Expected= "driver.find_element_by_partial_link_text('Send').click()"
           base:Baseline= "browser.find_element_by_css_selector('send').click()"
           base:+Canonic= "driver.find_element_by_css_selector('Send').click()"
           body:Baseline= "click('send', selenium)"
              body:-Code= "driver.find_element_by_css_selector('send')"
          mined:Baseline= "driver.find_element_by_css_selector('send')"
             mined:+Body= "button.click('send', 1)"
        mined:+Body, -NL= "driver.find_element_by_class_name('send')"
      mined:+Body, -Code= "driver.find_element_by_href('send')"

================================================================================

QUESTION: idx=199    id=19601086
-------------------------------------INPUTS-------------------------------------

tags: selenium, button, click, href
score: 19
slot_map: {'key': ['str_0'], 'quote': ['`'], 'type': ['str'], 'value': ['Send InMail']}
intent: click a href button having text `send inmail` with selenium
body(Some added characters for better readability):
	I have one button from one LinkedIn page with this code:
	
	start_block
	<div class="primary-action-button"> <a class="primary-action label" href="/requestList?displayProposal=&amp;destID=39959446&amp;creationType=DC&amp;authToken=Yr4_&amp;authType=OUT_OF_NETWORK&amp;trk=vsrp_people_res_pri_act&amp;trkInfo=VSRPsearchId%3A2998448551382744275729%2CVSRPtargetId%3A39959446%2CVSRPcmpt%3Aprimary">Send InMail </a> </div>
	Is there any way to click on an element just by its href link? Thanks


-------------------------------------OUTPUT-------------------------------------

                Expected= "driver.findElement(By.linkText('Send InMail')).click()"
           base:Baseline= "browser.find_element_by_css_selector('send inmail').click()"
           base:+Canonic= "driver.find_element_by_css_selector('Send InMail').click()"
           body:Baseline= "click('send InMail', selenium)"
              body:-Code= "driver.find_element_by_css_selector('send inmail')"
          mined:Baseline= 'driver.find_element_by_css_selector(\'.//a[@href="a\'))'
             mined:+Body= "link = selenium.Link('Send InMail')"
        mined:+Body, -NL= "driver.find_element_by_class_name('send inmail')"
      mined:+Body, -Code= "driver.find_element_by_href('send inmail')"

================================================================================

QUESTION: idx=200    id=19601086
-------------------------------------INPUTS-------------------------------------

tags: selenium, button, click, href
score: 19
slot_map: {'key': ['str_0'], 'quote': ["'"], 'type': ['str'], 'value': ['Send InMail']}
intent: click a href button with text 'send inmail' with selenium
body(Some added characters for better readability):
	I have one button from one LinkedIn page with this code:
	
	start_block
	<div class="primary-action-button"> <a class="primary-action label" href="/requestList?displayProposal=&amp;destID=39959446&amp;creationType=DC&amp;authToken=Yr4_&amp;authType=OUT_OF_NETWORK&amp;trk=vsrp_people_res_pri_act&amp;trkInfo=VSRPsearchId%3A2998448551382744275729%2CVSRPtargetId%3A39959446%2CVSRPcmpt%3Aprimary">Send InMail </a> </div>
	Is there any way to click on an element just by its href link? Thanks


-------------------------------------OUTPUT-------------------------------------

                Expected= "driver.find_element_by_link_text('Send InMail').click()"
           base:Baseline= "browser.find_element_by_css_selector('send inmail').click()"
           base:+Canonic= "driver.find_element_by_css_selector('Send InMail')"
           body:Baseline= "click('send InMail', selenium)"
              body:-Code= "driver.find_element_by_css_selector('send inmail')"
          mined:Baseline= "driver.find_element_by_css_selector('send_mail').click()"
             mined:+Body= "link = selenium.Link('Send InMail')"
        mined:+Body, -NL= "driver.find_element_by_class_name('send inmail')"
      mined:+Body, -Code= "driver.find_element_by_href('send inmail')"

================================================================================

QUESTION: idx=201    id=3944876
-------------------------------------INPUTS-------------------------------------

tags: string, integer, concatenation
score: 53
slot_map: {'key': ['var_0', 'str_0'], 'quote': ['`', "'"], 'type': ['var', 'str'], 'value': ['i', 'ME']}
intent: cast an int `i` to a string and concat to string 'me'
body(Some added characters for better readability):
	I want to be able to generate a number of text files with the names fileX.txt where X is some integer:
	
	start_block
	for i in range(key):
	    filename = "ME" + i + ".txt" //Error here! Can't concat a string and int
	    filenum = filename
	    filenum = open(filename , 'w')  
	Does anyone else know how to do the filename = "ME" + i  part so I get a list of files with the names: "ME0.txt" , "ME1.txt" , "ME2.txt" , and etc


-------------------------------------OUTPUT-------------------------------------

                Expected= "'ME' + str(i)"
           base:Baseline= '"""""".join(str(i))'
           base:+Canonic= "print('ME'.join(i))"
           body:Baseline= '"""ME""".join(str(i))'
              body:-Code= '""".join(open(\'ME0.txt\', \'ME1.txt\'))'
          mined:Baseline= "i = int('I', 'I')"
             mined:+Body= "filename = 'ME' + i + '.txt'"
        mined:+Body, -NL= "filenum = open(filename, 'w').read()"
      mined:+Body, -Code= '"""ME0.txt""".decode(\'utf8\')'

================================================================================

QUESTION: idx=202    id=40903174
-------------------------------------INPUTS-------------------------------------

tags: pandas
score: 4
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: sorting data in dataframe pandas
body(Some added characters for better readability):
	I obtained the following DataFrame:
	
	start_block
	    Dis        System_num  Energy
	0   0.9           1       -2.3108
	1   0.7           1       11.8735
	2   1.2           1       -2.3408
	3   2.0           1       -0.3485
	4   2.0           2       -0.9379
	5   0.7           2       7.4776
	6   1.5           2       -2.2877
	7   0.9           2       -4.1789
	8   2.0           3       -3.6596
	9   1.0           3       -18.4582
	10  0.9           3       -16.2202
	11  0.7           3       16.6290
	I want to sort values (ascending) in the Dis column for each number in System_num, I mean:
	
	start_block
	0   0.7           1       11.8735
	1   0.9           1       -2.3108
	2   1.2           1       -2.3408
	3   2.0           1       -0.3485
	4   0.7           2       7.4776
	5   0.9           2       -4.1789
	6   1.5           2       -2.2877
	7   2.0           2       -0.9379
	8   0.7           3       16.6290
	8   0.9           3       -16.2202
	10  1.0           3       -18.4582
	11  2.0           3       -3.6596


-------------------------------------OUTPUT-------------------------------------

                Expected= "df.sort_values(['System_num', 'Dis'])"
           base:Baseline= 'df.sort(key=lambda x: x[1])'
           base:+Canonic= 'df.sorted(df.values())'
           body:Baseline= "df.sort_values(['Dis'], axis=0)"
              body:-Code= "df.sort_values('ascending')"
          mined:Baseline= 'df.sort(key=lambda x: x.index)'
             mined:+Body= 'df.sort(key=lambda x: x.astype(int) for x in System_num)'
        mined:+Body, -NL= 'df.sort(key=lambda x: x[1])'
      mined:+Body, -Code= "df.sort(['Number', 'Dis'])"

================================================================================

QUESTION: idx=203    id=4454298
-------------------------------------INPUTS-------------------------------------

tags: prepend
score: 73
slot_map: {'key': ['str_0', 'str_1', 'str_2'], 'quote': ["'", "'", "'"], 'type': ['str', 'str', 'str'], 'value': ['#test firstline\n', 'infile', 'outfile']}
intent: prepend the line '#test firstline\n' to the contents of file 'infile' and save as the file 'outfile'
body(Some added characters for better readability):
	I need to add a single line to the first line of a text file and it looks like the only options available to me are more lines of code than I would expect from python. Something like this:
	
	start_block
	f = open('filename','r')
	temp = f.read()
	f.close()
	f = open('filename', 'w')
	f.write("#testfirstline")
	f.write(temp)
	f.close()
	Is there no easier way? Additionally, I see this two-handle example more often than opening a single handle for reading and writing ('r+') - why is that?


-------------------------------------OUTPUT-------------------------------------

                Expected= "open('outfile', 'w').write('#test firstline\\n' + open('infile').read())"
           base:Baseline= "os.system('#test firstline\\n')"
           base:+Canonic= "open('infile', 'outfile', 'rb')"
           body:Baseline= "f = open('#test firstline\\n', 'outfile')"
              body:-Code= "os.chmod('#test firstline\\n')"
          mined:Baseline= "outfile.write('#test firstline\\n')"
             mined:+Body= "f.write('#test firstline\\n')"
        mined:+Body, -NL= "f.write('#test firstline\\n')"
      mined:+Body, -Code= "outfile.write('#test firstline\\n')"

================================================================================

QUESTION: idx=204    id=19729928
-------------------------------------INPUTS-------------------------------------

tags: sorting, tuples
score: 11
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['l']}
intent: sort a list `l` by length of value in tuple
body(Some added characters for better readability):
	I am having difficulty sorting a list of tuples. I would like to sort by the length of a string in the list.
	For example:
	
	start_block
	l = [(99,'bbc', 121),(33,'abcd', 231),(44,'zb', 148), (23,'abcde',221)]
	if I sort by element 1:
	
	start_block
	l.sort(key=itemgetter(1), reverse=True)
	This will sort on the alphabetical ranking of the strings, not the length. I would prefer to sort in-place and reverse sort, with longest string first.
	I can use a lambda and cmp, 
	
	start_block
	l.sort(lambda x,y: cmp(len(x[1]), len(y[1])), reverse=True)
	but is there a more elegant, or pythonic way using key and/or itemgetter?


-------------------------------------OUTPUT-------------------------------------

                Expected= 'l.sort(key=lambda t: len(t[1]), reverse=True)'
           base:Baseline= 'sorted(L, key=lambda x: x[1])'
           base:+Canonic= 'sorted(var_0, key=len))'
           body:Baseline= 'l.sort(key=itemgetter(1), reverse=True)'
              body:-Code= 'sorted(l, key=lambda x: len(x[1]))'
          mined:Baseline= 'sorted(l, key=len)'
             mined:+Body= 'l.sort(key=itemgetter(1), reverse=True)'
        mined:+Body, -NL= 'l.sort(key=lambda x, y: cmp(len(x[1]), len(y[1]))'
      mined:+Body, -Code= 'sorted(L, key=lambda x: (len(x), 1))'

================================================================================

QUESTION: idx=205    id=31371879
-------------------------------------INPUTS-------------------------------------

tags: regex, split
score: 5
slot_map: {'key': ['var_0', 'str_0'], 'quote': ['`', "'"], 'type': ['var', 'str'], 'value': ['s', 'd']}
intent: split string `s` by words that ends with 'd'
body(Some added characters for better readability):
	
	<p>I want to split strings only by suffixes. For example, I would like to be able to split 
	`dord word`
	 to 
	`[dor,wor]`.
	
	<p>I though that 
	`\wd`
	 would search for words that end with 
	`d`. However this does not produce the expected results
	
	start_block
	import re
	re.split(r'\wd',"dord word")
	['do', ' wo', '']
	How can I split by suffixes?


-------------------------------------OUTPUT-------------------------------------

                Expected= "re.findall('\\\\b(\\\\w+)d\\\\b', s)"
           base:Baseline= "re.split('\\\\d+', s)"
           base:+Canonic= "re.split('d', s)"
           body:Baseline= "re.findall('\\\\wd', s)"
              body:-Code= "s.split(',', 'd')"
          mined:Baseline= "re.split('\\\\d+', s)"
             mined:+Body= "re.findall('\\\\w', s)"
        mined:+Body, -NL= "re.findall('\\\\d', s)"
      mined:+Body, -Code= "re.split('\\\\d+', s)"

================================================================================

QUESTION: idx=206    id=9012008
-------------------------------------INPUTS-------------------------------------

tags: regex
score: 114
slot_map: {'key': ['var_0', 'var_1', 'str_0'], 'quote': ['`', '`', '`'], 'type': ['var', 'var', 'str'], 'value': ['True', 'foobarrrr', 'ba[rzd]']}
intent: return `true` if string `foobarrrr` contains regex `ba[rzd]`
body(Some added characters for better readability):
	I have a regular expression like this:
	
	start_block
	regexp = u'ba[r|z|d]'
	
	<p>Function must return True if word contains 
	bar 
	, 
	baz 
	 or 
	bad .
	In short, I need regexp analog for Python's
	
	start_block
	'any-string' in 'text'
	How can I realize it? Thanks!


-------------------------------------OUTPUT-------------------------------------

                Expected= "bool(re.search('ba[rzd]', 'foobarrrr'))"
           base:Baseline= "re.findall('([a-z])', 'foobarrrr')"
           base:+Canonic= "return var_0 if'str_0' in var_1]"
           body:Baseline= "re.sub('(?=?)(?=?)', 'foobarrrr', 'ba[rzd]')"
              body:-Code= "return True if re.sub('(?\\\\d+\\\\b\\\\d+)', 'foobarrrr', 'ba[rzd]')"
          mined:Baseline= "print('foobarrrr')"
             mined:+Body= "re.search('\\\\bba[r|z|d]', 'foobarrrr')"
        mined:+Body, -NL= '"""ba[r|z|d]""".encode(\'utf8\')'
      mined:+Body, -Code= '"""foobarrrr""".endswith(bar[rzd])'

================================================================================

QUESTION: idx=207    id=7961363
-------------------------------------INPUTS-------------------------------------

tags: algorithm, list, duplicates, intersection
score: 1128
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['t']}
intent: removing duplicates in list `t`
body(Some added characters for better readability):
	Pretty much I need to write a program that checks if a list has any duplicates and if it does it removes them and returns a new list with the items that weren't duplicated/removed. This is what I have tried but honestly I don't know what to do.
	
	start_block
	def remove_duplicates():
	    t = ['a', 'b', 'c', 'd']
	    t2 = ['a', 'c', 'd']
	    for t in t2:
	        t.append(t.remove())
	    return t


-------------------------------------OUTPUT-------------------------------------

                Expected= 'list(set(t))'
           base:Baseline= 'list(itertools.chain(*t))'
           base:+Canonic= 'del t[::-1]'
           body:Baseline= 't = [x for x in t]'
              body:-Code= 'del t[::-1] for sublist in t]'
          mined:Baseline= '[(x, y) for x, y in list(t.items())]'
             mined:+Body= 't2 = [x for x in t if x not in list(t)]'
        mined:+Body, -NL= 't2 = [t for t in t2 if t.duplicated()]'
      mined:+Body, -Code= '[list(t) for t in list(t.items())]'

================================================================================

QUESTION: idx=208    id=7961363
-------------------------------------INPUTS-------------------------------------

tags: algorithm, list, duplicates, intersection
score: 1128
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['source_list']}
intent: removing duplicates in list `source_list`
body(Some added characters for better readability):
	Pretty much I need to write a program that checks if a list has any duplicates and if it does it removes them and returns a new list with the items that weren't duplicated/removed. This is what I have tried but honestly I don't know what to do.
	
	start_block
	def remove_duplicates():
	    t = ['a', 'b', 'c', 'd']
	    t2 = ['a', 'c', 'd']
	    for t in t2:
	        t.append(t.remove())
	    return t


-------------------------------------OUTPUT-------------------------------------

                Expected= 'list(set(source_list))'
           base:Baseline= '[(x, y) for x, y insource_list]'
           base:+Canonic= 'del source_list[::-1]'
           body:Baseline= '[x for x in source_list]'
              body:-Code= 'del solex for solex insource_list'
          mined:Baseline= '[list(source_list) for _ in range(10)]'
             mined:+Body= 'source_list.sort(key=lambda x: abs(x))'
        mined:+Body, -NL= 't = list(source_list)'
      mined:+Body, -Code= 'print(list(source_list))'

================================================================================

QUESTION: idx=209    id=7961363
-------------------------------------INPUTS-------------------------------------

tags: algorithm, list, duplicates, intersection
score: 1128
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['abracadabra']}
intent: removing duplicates in list `abracadabra`
body(Some added characters for better readability):
	Pretty much I need to write a program that checks if a list has any duplicates and if it does it removes them and returns a new list with the items that weren't duplicated/removed. This is what I have tried but honestly I don't know what to do.
	
	start_block
	def remove_duplicates():
	    t = ['a', 'b', 'c', 'd']
	    t2 = ['a', 'c', 'd']
	    for t in t2:
	        t.append(t.remove())
	    return t


-------------------------------------OUTPUT-------------------------------------

                Expected= "list(OrderedDict.fromkeys('abracadabra'))"
           base:Baseline= 'map(list(abracadabra.items()))'
           base:+Canonic= 'del abracadabra[::-1]'
           body:Baseline= '[x for x in abracadabra]'
              body:-Code= 'del duplicates in list(abracadabra)'
          mined:Baseline= 'list(abracadabra.values())'
             mined:+Body= 'list(abracadabra.items())'
        mined:+Body, -NL= 't = list(abracadabra.values())'
      mined:+Body, -Code= 'return list(set(abracadabra))'

================================================================================

QUESTION: idx=210    id=5183533
-------------------------------------INPUTS-------------------------------------

tags: list, matrix, numpy
score: 40
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['a']}
intent: convert array `a` into a list
body(Some added characters for better readability):
	I using the dot() function from numpy to multiply a matrix of 3x3 with a numpy.array of 1x3. The output is for example this:
	[[ 0.16666667  0.66666667  0.16666667]]
	which is of type:
	
	start_block
	<class 'numpy.matrixlib.defmatrix.matrix'>
	how can I convert this to a list. Because I know the result will always be a matrix of 1x3 so it should be coverted to a list because I need to be able to loop through it later for calculation the pearson distance of two of those lists.
	So to summarize: how can I make a list from this matrix?


-------------------------------------OUTPUT-------------------------------------

                Expected= 'numpy.array(a).reshape(-1).tolist()'
           base:Baseline= 'list(a, key=lambda x: x[1])'
           base:+Canonic= 'list(a, key=lambda x: x[1])'
           body:Baseline= 'list(itertools.from_iterable(a))'
              body:-Code= 'list(a.reshape(1))'
          mined:Baseline= 'list(itertools.chain(*a))'
             mined:+Body= 'list(map(int, a.split())'
        mined:+Body, -NL= 'numpy.matrixlib.concatenate((a, a))'
      mined:+Body, -Code= 'a = numpy.dot(a, [1, 2, 3])'

================================================================================

QUESTION: idx=211    id=5183533
-------------------------------------INPUTS-------------------------------------

tags: list, matrix, numpy
score: 40
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['a']}
intent: convert the first row of numpy matrix `a` to a list
body(Some added characters for better readability):
	I using the dot() function from numpy to multiply a matrix of 3x3 with a numpy.array of 1x3. The output is for example this:
	[[ 0.16666667  0.66666667  0.16666667]]
	which is of type:
	
	start_block
	<class 'numpy.matrixlib.defmatrix.matrix'>
	how can I convert this to a list. Because I know the result will always be a matrix of 1x3 so it should be coverted to a list because I need to be able to loop through it later for calculation the pearson distance of two of those lists.
	So to summarize: how can I make a list from this matrix?


-------------------------------------OUTPUT-------------------------------------

                Expected= 'numpy.array(a)[0].tolist()'
           base:Baseline= 'list(a, axis=0)'
           base:+Canonic= 'a.shape[0]'
           body:Baseline= 'list(a.shape[0]'
              body:-Code= 'list(a.shape[0]'
          mined:Baseline= 'a = a[:, (1)]'
             mined:+Body= 'numpy.dot(a, 1)'
        mined:+Body, -NL= 'numpy.matrixlib.concatenate((a, a))'
      mined:+Body, -Code= 'a = numpy.dot(a, [1, 2, 3])'

================================================================================

QUESTION: idx=212    id=5999747
-------------------------------------INPUTS-------------------------------------

tags: beautifulsoup
score: 47
slot_map: {'key': ['var_0', 'var_1', 'str_0'], 'quote': ['`', '`', '`'], 'type': ['var', 'var', 'str'], 'value': ['soup', 'td', 'Address:']}
intent: in `soup`, get the content of the sibling of the `td`  tag with text content `address:`
body(Some added characters for better readability):
	I'm trying to get the content "My home address" using the following but got the AttributeError:
	
	start_block
	address = soup.find(text="Address:")
	print address.nextSibling
	This is my HTML:
	
	
	start_block
	<b>Address: </b> </td>
	<td>My home address </td>
	
	<p>What is a good way to navigate down 
	`td` tag and pull the content?


-------------------------------------OUTPUT-------------------------------------

                Expected= "print(soup.find(text='Address:').findNext('td').contents[0])"
           base:Baseline= "soup.find_element_by_xpath('address:')"
           base:+Canonic= "print(soup.get('Address:', 'str_1'))"
           body:Baseline= "soup.find(text='Address:')"
              body:-Code= "soup.find_element_by_css_name('My Home Address')"
          mined:Baseline= 'soup.findAll(text=True)'
             mined:+Body= "address = soup.find(text='Address:')"
        mined:+Body, -NL= "soup.find(text='Address:')"
      mined:+Body, -Code= 'soup.findAll(text=True)'

================================================================================

QUESTION: idx=213    id=4284648
-------------------------------------INPUTS-------------------------------------

tags: string, list, tuples
score: 14
slot_map: {'key': ['var_0', 'str_0'], 'quote': ['`', '`'], 'type': ['var', 'str'], 'value': ['l', '@']}
intent: convert elements of each tuple in list `l` into a string  separated by character `@`
body(Some added characters for better readability):
	I've written a function in python that returns a list, for example
	
	start_block
	[(1,1),(2,2),(3,3)] 
	But i want the output as a string so i can replace the comma with another char so the output would be 
	
	start_block
	'1@1' '2@2' '3@3' 
	Any easy way around this?:)
	Thanks for any tips in advance


-------------------------------------OUTPUT-------------------------------------

                Expected= '""" """.join([(\'%d@%d\' % t) for t in l])'
           base:Baseline= '"""""".join(zip(*L))'
           base:+Canonic= '"""""".join(str(x) for x in l)'
           body:Baseline= '"""""".join(str(x) for x in L)'
              body:-Code= '"""""".join(str(x) for x in L)'
          mined:Baseline= '"""""".join(str(i) for i in L)'
             mined:+Body= '"""""".join(map(str, L))'
        mined:+Body, -NL= '"""""".join(map(lambda x: x.split(\'@\'), L))'
      mined:+Body, -Code= '"""""".join(map(str, L))'

================================================================================

QUESTION: idx=214    id=4284648
-------------------------------------INPUTS-------------------------------------

tags: string, list, tuples
score: 14
slot_map: {'key': ['var_0', 'str_0'], 'quote': ['`', "'"], 'type': ['var', 'str'], 'value': ['l', '@']}
intent: convert each tuple in list `l` to a string with '@' separating the tuples' elements
body(Some added characters for better readability):
	I've written a function in python that returns a list, for example
	
	start_block
	[(1,1),(2,2),(3,3)] 
	But i want the output as a string so i can replace the comma with another char so the output would be 
	
	start_block
	'1@1' '2@2' '3@3' 
	Any easy way around this?:)
	Thanks for any tips in advance


-------------------------------------OUTPUT-------------------------------------

                Expected= '""" """.join([(\'%d@%d\' % (t[0], t[1])) for t in l])'
           base:Baseline= '"""""".join(zip(l))'
           base:+Canonic= "str_0 = ''.join(var_0, var_0))"
           body:Baseline= '"""""".join(str(x) for x in L)'
              body:-Code= '"""""".join(str(x) for x in L)'
          mined:Baseline= '"""""".join(str(x) for x in L)'
             mined:+Body= '"""""".join(map(str, L))'
        mined:+Body, -NL= '"""""".join(map(lambda x: x.split(\'@\'), l))'
      mined:+Body, -Code= '"""""".join(map(str, l))'

================================================================================

QUESTION: idx=215    id=26809954
-------------------------------------INPUTS-------------------------------------

tags: html, selenium, web-crawler, splinter
score: 7
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: get the html from the current web page of a selenium driver
body(Some added characters for better readability):
	
	<p>I'm trying to crawl the website " 
	http://everydayhealth.com ". However, I found that the page will dynamically rendered. So, when I click the button "More", some new news will be shown. However, using splinter to click the button doesn't let "browser.html" automatically changes to the current html content. Is there a way to let it get newest html source, using either splinter or selenium? My code in splinter is as follows:
	
	start_block
	import requests
	from bs4 import BeautifulSoup
	from splinter import Browser
	browser = Browser()
	browser.visit('http://everydayhealth.com')
	browser.click_link_by_text("More")
	print(browser.html)
	Based on @Louis's answer, I rewrote the program as follows:
	
	start_block
	from selenium import webdriver
	from selenium.webdriver.support.ui import WebDriverWait
	driver = webdriver.Firefox()
	driver.get("http://www.everydayhealth.com")
	more_xpath = '//a[@class="btn-more"]'
	more_btn = WebDriverWait(driver, 10).until(lambda driver: driver.find_element_by_xpath(more_xpath))
	more_btn.click()
	more_news_xpath = '(//a[@href="http://www.everydayhealth.com/recipe-rehab/5-herbs-and-spices-to-intensify-flavor.aspx"])[2]'
	WebDriverWait(driver, 5).until(lambda driver: driver.find_element_by_xpath(more_news_xpath))
	print(driver.execute_script("return document.documentElement.outerHTML;"))
	driver.quit()
	However, in the output text, I still couldn't find the text in the updated page. For example, when I search "Is Milk Your Friend or Foe?", it still returns nothing. What's the problem?


-------------------------------------OUTPUT-------------------------------------

                Expected= "driver.execute_script('return document.documentElement.outerHTML;')"
           base:Baseline= 'driver.find_element_by_css_selector(html)'
           base:+Canonic= "driver.find_element_by_id('html')"
           body:Baseline= "driver.get('http://www.everydayhealth.com  '.html)"
              body:-Code= "driver.find_element_by_css_selector('browser.html')"
          mined:Baseline= "driver.get('http://stackoverflow.com')"
             mined:+Body= 'driver.execute_script("return document.documentElement.outerHTML;\')'
        mined:+Body, -NL= "driver.execute_script('return document.documentElement.outerHTML;')"
      mined:+Body, -Code= 'driver.find_element_by_css_selector("http://everydayhealth.com\')'

================================================================================

QUESTION: idx=216    id=29696641
-------------------------------------INPUTS-------------------------------------

tags: regex, string, list
score: 4
slot_map: {'key': ['str_0', 'var_0'], 'quote': ['`', '`'], 'type': ['str', 'var'], 'value': ['\\d+[xX]', 'teststr']}
intent: get all matches with regex pattern `\\d+[xx]` in list of string `teststr`
body(Some added characters for better readability):
	So I have this list of strings:
	
	start_block
	teststr = ['1 FirstString', '2x Sec String', '3rd String', 'x forString', '5X fifth']
	What I need to do, is to get all the elements from this list that contain:
	
	start_block
	number + "x" 
	or 
	
	start_block
	number + "X"
	For example if I have the function
	
	start_block
	def SomeFunc(string):
	    #do something
	I would like to get an output like this:
	
	start_block
	2x Sec String
	5X fifth
	I found somewhere here in StackOverflow this function:
	
	start_block
	def CheckIfContainsNumber(inputString):
	    return any(char.isdigit() for char in inputString)
	But this returns each string that has a number.
	How can I expand the functions to get the desired output?


-------------------------------------OUTPUT-------------------------------------

                Expected= "[i for i in teststr if re.search('\\\\d+[xX]', i)]"
           base:Baseline= "re.findall('\\\\d+[xx]', teststr)"
           base:+Canonic= "re.match('\\\\d+[xX]', teststr)"
           body:Baseline= "re.match('\\\\d+[xx]', teststr)"
              body:-Code= "re.findall('\\\\d+[xx]', teststr)"
          mined:Baseline= "re.findall('\\\\d+[xx]', teststr)"
             mined:+Body= "[match for match in re.findall('\\\\d+[xx]', teststr)]"
        mined:+Body, -NL= "re.findall('\\\\d+[xx]', teststr)"
      mined:+Body, -Code= "[match for match in re.findall('\\\\d+[xx]', testStr)]"

================================================================================

QUESTION: idx=217    id=15315452
-------------------------------------INPUTS-------------------------------------

tags: pandas
score: 261
slot_map: {'key': ['str_0', 'str_1', 'str_2', 'var_0'], 'quote': ["'", "'", "'", '`'], 'type': ['str', 'str', 'str', 'var'], 'value': ['A', 'B', 'C', 'df']}
intent: select values from column 'a' for which corresponding values in column 'b' will be greater than 50, and in column 'c' - equal 900 in dataframe `df`
body(Some added characters for better readability):
	For example I have simple DF:
	
	start_block
	import pandas as pd
	from random import randint
	df = pd.DataFrame({'A': [randint(1, 9) for x in xrange(10)],
	                   'B': [randint(1, 9)*10 for x in xrange(10)],
	                   'C': [randint(1, 9)*100 for x in xrange(10)]})
	Can I select values from 'A' for which corresponding values for 'B' will be greater than 50, and for 'C' - not equal 900, using methods and idioms of Pandas?


-------------------------------------OUTPUT-------------------------------------

                Expected= "df['A'][(df['B'] > 50) & (df['C'] == 900)]"
           base:Baseline= "df['a'] = df['c'] + 900"
           base:+Canonic= "df.groupby(['B', 'C'], [A] > 900)"
           body:Baseline= "df.loc[df['A']!= 50, 'C']!= 900]"
              body:-Code= "df['A'] = df['C']"
          mined:Baseline= "df.loc[df['A'].isin(['B', 'C'])]"
             mined:+Body= "df.loc[df['A'].isin(['B', 'C'])]"
        mined:+Body, -NL= "df.loc[df['A'].isin(['B', 'C'])]"
      mined:+Body, -Code= "df.loc[df['B'] > 50, 'C']"

================================================================================

QUESTION: idx=218    id=4642501
-------------------------------------INPUTS-------------------------------------

tags: sorting, dictionary
score: 21
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['o']}
intent: sort dictionary `o` in ascending order based on its keys and items
body(Some added characters for better readability):
	Can anyone tell me how I can sort this:
	
	start_block
	{'a': [1, 2, 3], 'c': ['one', 'two'], 'b': ['blah', 'bhasdf', 'asdf'], 'd': ['asdf', 'wer', 'asdf', 'zxcv']}
	into
	
	start_block
	{'a': [1, 2, 3], 'b': ['blah', 'bhasdf', 'asdf'], 'c': ['one', 'two'],'d': ['asdf', 'wer', 'asdf', 'zxcv']}
	?
	Thanks!
	UPDATE 1, code sample:
	So I am doing linguistics. One article is broken down to words that are stored in a database and have all kinds of properties including para ID and sentence ID. The task: trying to rebuild the original text.
	Get 500 consecutive words from DB
	
	start_block
	words = Words.objects.all()[wordId:wordId+500]
	# I first create paragraphs, through which I can loop later in my django template,
	# and in each para will be a list of words (also dictionaries). 
	# So i am trying to get a dictionary with values that are lists of dictionaries. 
	# 'pp' i make just for shorthanding a long-named variable.
	paras={}
	para_high = para_low =  words[0].belongs_to_paragraph
	for w in words:
	    last_word = w
	    pp = w.belongs_to_paragraph
	    if pp >para_high:
	        para_high = pp
	    if pp < para_low:
	        para_low = pp
	    if pp in paras:
	        paras[pp].append(w)
	    else:
	        list = [w]
	        paras[pp] = list
	# Since there are blank lines between paragraphs, in rebuilding the text as it 
	    #  looked originally, I need to insert blank lines. 
	    # Since i have the ID's of the paragraphs and they go somewhat like that: 1,3,4,8,9 
	    #(the gaps between 1 & 3 and 4 & 8 i have to fill in with something else, 
	    # which is why i had para_low and para_high to loop the range. 
	isbr = True
	for i in range(para_low, para_high+1):
	    if i in paras:
	        isbr = True
	    else:
	        if isbr:
	            paras[i]=['break']
	            isbr = False
	        else:
	            paras[i]=[]
	At this point, however, if I try to loop the dict and rebuild the text, some later id'd paragraphs come before previous ones, and that just doesn't do it.
	UPDATE 2, loop code:
	
	start_block
	        {% for k,v in wording.iteritems()  %}
	        {% if v[0] == 'break' %}
	        <br/>
	        {% else %}
	        </div> <div class="p">{% for word in v %}{% if word.special==0%} {% endif %} <span class="word {% if word.special == 0%}clickable{% endif%}" wid="{{word.id}}" special="{{word.special}}" somethingElse={{word.somethingElse}}>{{ word.word }} </span>{% endfor %}
	        {% endif %}
	    {% endfor %}


-------------------------------------OUTPUT-------------------------------------

                Expected= 'sorted(o.items())'
           base:Baseline= 'sorted(list(o.items()), key=lambda x: x[1])'
           base:+Canonic= 'sorted(var_0.items()), key=lambda x: x[1])'
           body:Baseline= 'sorted(o, key=lambda x: x[1])'
              body:-Code= 'sorted(list(o.items()), key=lambda x: x[1])'
          mined:Baseline= 'sorted(list(o.items()), key=operator.itemgetter(1))'
             mined:+Body= 'sorted(o, key=itemgetter(1), reverse=True)'
        mined:+Body, -NL= 'sorted(list(o.items()), key=lambda x: x[1])'
      mined:+Body, -Code= 'sorted(o, key=itemgetter(1), reverse=True)'

================================================================================

QUESTION: idx=219    id=4642501
-------------------------------------INPUTS-------------------------------------

tags: sorting, dictionary
score: 21
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['d']}
intent: get sorted list of keys of dict `d`
body(Some added characters for better readability):
	Can anyone tell me how I can sort this:
	
	start_block
	{'a': [1, 2, 3], 'c': ['one', 'two'], 'b': ['blah', 'bhasdf', 'asdf'], 'd': ['asdf', 'wer', 'asdf', 'zxcv']}
	into
	
	start_block
	{'a': [1, 2, 3], 'b': ['blah', 'bhasdf', 'asdf'], 'c': ['one', 'two'],'d': ['asdf', 'wer', 'asdf', 'zxcv']}
	?
	Thanks!
	UPDATE 1, code sample:
	So I am doing linguistics. One article is broken down to words that are stored in a database and have all kinds of properties including para ID and sentence ID. The task: trying to rebuild the original text.
	Get 500 consecutive words from DB
	
	start_block
	words = Words.objects.all()[wordId:wordId+500]
	# I first create paragraphs, through which I can loop later in my django template,
	# and in each para will be a list of words (also dictionaries). 
	# So i am trying to get a dictionary with values that are lists of dictionaries. 
	# 'pp' i make just for shorthanding a long-named variable.
	paras={}
	para_high = para_low =  words[0].belongs_to_paragraph
	for w in words:
	    last_word = w
	    pp = w.belongs_to_paragraph
	    if pp >para_high:
	        para_high = pp
	    if pp < para_low:
	        para_low = pp
	    if pp in paras:
	        paras[pp].append(w)
	    else:
	        list = [w]
	        paras[pp] = list
	# Since there are blank lines between paragraphs, in rebuilding the text as it 
	    #  looked originally, I need to insert blank lines. 
	    # Since i have the ID's of the paragraphs and they go somewhat like that: 1,3,4,8,9 
	    #(the gaps between 1 & 3 and 4 & 8 i have to fill in with something else, 
	    # which is why i had para_low and para_high to loop the range. 
	isbr = True
	for i in range(para_low, para_high+1):
	    if i in paras:
	        isbr = True
	    else:
	        if isbr:
	            paras[i]=['break']
	            isbr = False
	        else:
	            paras[i]=[]
	At this point, however, if I try to loop the dict and rebuild the text, some later id'd paragraphs come before previous ones, and that just doesn't do it.
	UPDATE 2, loop code:
	
	start_block
	        {% for k,v in wording.iteritems()  %}
	        {% if v[0] == 'break' %}
	        <br/>
	        {% else %}
	        </div> <div class="p">{% for word in v %}{% if word.special==0%} {% endif %} <span class="word {% if word.special == 0%}clickable{% endif%}" wid="{{word.id}}" special="{{word.special}}" somethingElse={{word.somethingElse}}>{{ word.word }} </span>{% endfor %}
	        {% endif %}
	    {% endfor %}


-------------------------------------OUTPUT-------------------------------------

                Expected= 'sorted(d)'
           base:Baseline= 'sorted(list(d.items()), key=lambda x: x[1])'
           base:+Canonic= 'sorted(d, key=lambda x: x[1])'
           body:Baseline= 'sorted(list(d.keys()), key=lambda x: x[1])'
              body:-Code= 'sorted(list(d.items()), key=lambda x: x[1])'
          mined:Baseline= 'sorted(d, key=d.get)'
             mined:+Body= 'sorted(list(d.items()), key=lambda x: x[1])'
        mined:+Body, -NL= 'sorted(list(d.items()), key=lambda x: x[1])'
      mined:+Body, -Code= 'sorted(list(d.items()), key=lambda x: x[1])'

================================================================================

QUESTION: idx=220    id=4642501
-------------------------------------INPUTS-------------------------------------

tags: sorting, dictionary
score: 21
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: how to sort dictionaries by keys in python
body(Some added characters for better readability):
	Can anyone tell me how I can sort this:
	
	start_block
	{'a': [1, 2, 3], 'c': ['one', 'two'], 'b': ['blah', 'bhasdf', 'asdf'], 'd': ['asdf', 'wer', 'asdf', 'zxcv']}
	into
	
	start_block
	{'a': [1, 2, 3], 'b': ['blah', 'bhasdf', 'asdf'], 'c': ['one', 'two'],'d': ['asdf', 'wer', 'asdf', 'zxcv']}
	?
	Thanks!
	UPDATE 1, code sample:
	So I am doing linguistics. One article is broken down to words that are stored in a database and have all kinds of properties including para ID and sentence ID. The task: trying to rebuild the original text.
	Get 500 consecutive words from DB
	
	start_block
	words = Words.objects.all()[wordId:wordId+500]
	# I first create paragraphs, through which I can loop later in my django template,
	# and in each para will be a list of words (also dictionaries). 
	# So i am trying to get a dictionary with values that are lists of dictionaries. 
	# 'pp' i make just for shorthanding a long-named variable.
	paras={}
	para_high = para_low =  words[0].belongs_to_paragraph
	for w in words:
	    last_word = w
	    pp = w.belongs_to_paragraph
	    if pp >para_high:
	        para_high = pp
	    if pp < para_low:
	        para_low = pp
	    if pp in paras:
	        paras[pp].append(w)
	    else:
	        list = [w]
	        paras[pp] = list
	# Since there are blank lines between paragraphs, in rebuilding the text as it 
	    #  looked originally, I need to insert blank lines. 
	    # Since i have the ID's of the paragraphs and they go somewhat like that: 1,3,4,8,9 
	    #(the gaps between 1 & 3 and 4 & 8 i have to fill in with something else, 
	    # which is why i had para_low and para_high to loop the range. 
	isbr = True
	for i in range(para_low, para_high+1):
	    if i in paras:
	        isbr = True
	    else:
	        if isbr:
	            paras[i]=['break']
	            isbr = False
	        else:
	            paras[i]=[]
	At this point, however, if I try to loop the dict and rebuild the text, some later id'd paragraphs come before previous ones, and that just doesn't do it.
	UPDATE 2, loop code:
	
	start_block
	        {% for k,v in wording.iteritems()  %}
	        {% if v[0] == 'break' %}
	        <br/>
	        {% else %}
	        </div> <div class="p">{% for word in v %}{% if word.special==0%} {% endif %} <span class="word {% if word.special == 0%}clickable{% endif%}" wid="{{word.id}}" special="{{word.special}}" somethingElse={{word.somethingElse}}>{{ word.word }} </span>{% endfor %}
	        {% endif %}
	    {% endfor %}


-------------------------------------OUTPUT-------------------------------------

                Expected= 'sorted(d.items())'
           base:Baseline= 'sorted(list(d.items()), key=lambda x: x[1])'
           base:+Canonic= 'sorted(d.keys()), key=lambda d: d.keys())'
           body:Baseline= 'sorted(list(d.items()), key=lambda x: x[1])'
              body:-Code= 'sorted(list(d.items()), key=lambda x: x[1])'
          mined:Baseline= 'sorted(list(d.keys()), key=lambda x: x[1])'
             mined:+Body= 'sorted(list(d.items()), key=lambda x: x[1])'
        mined:+Body, -NL= "['a', 'b', 'c', 'd', 'asdf', 'zxcv']"
      mined:+Body, -Code= 'sorted(list(d.items()), key=lambda x: x[1])'

================================================================================

QUESTION: idx=221    id=642154
-------------------------------------INPUTS-------------------------------------

tags: string, integer
score: 444
slot_map: {'key': ['str_0'], 'quote': ['"'], 'type': ['str'], 'value': ['1']}
intent: convert string "1" into integer
body(Some added characters for better readability):
	I have a tuple of tuples from a MySQL query like this:
	
	start_block
	T1 = (('13', '17', '18', '21', '32'),
	      ('07', '11', '13', '14', '28'),
	      ('01', '05', '06', '08', '15', '16'))
	I'd like to convert all the string elements into integers and put them back into a list of lists:
	
	start_block
	T2 = [[13, 17, 18, 21, 32], [7, 11, 13, 14, 28], [1, 5, 6, 8, 15, 16]]
	
	<p>I tried to achieve it with 
	`eval` but didn't get any decent result yet.


-------------------------------------OUTPUT-------------------------------------

                Expected= "int('1')"
           base:Baseline= "int('1', 1)[::-1]"
           base:+Canonic= "int('1', 16)"
           body:Baseline= '[int(x) for x in list(1.items())]'
              body:-Code= 'int(map(int, x) for x in zip(1, 2))'
          mined:Baseline= "int('1' + str(int(s))"
             mined:+Body= '[int(x) for x in T2]'
        mined:+Body, -NL= 'ast.literal_eval("1"")'
      mined:+Body, -Code= "map(int, ['1', '2', '3'])"

================================================================================

QUESTION: idx=222    id=642154
-------------------------------------INPUTS-------------------------------------

tags: string, integer
score: 444
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: function to convert strings into integers
body(Some added characters for better readability):
	I have a tuple of tuples from a MySQL query like this:
	
	start_block
	T1 = (('13', '17', '18', '21', '32'),
	      ('07', '11', '13', '14', '28'),
	      ('01', '05', '06', '08', '15', '16'))
	I'd like to convert all the string elements into integers and put them back into a list of lists:
	
	start_block
	T2 = [[13, 17, 18, 21, 32], [7, 11, 13, 14, 28], [1, 5, 6, 8, 15, 16]]
	
	<p>I tried to achieve it with 
	`eval` but didn't get any decent result yet.


-------------------------------------OUTPUT-------------------------------------

                Expected= 'int()'
           base:Baseline= 'int(map(int, x))'
           base:+Canonic= "int(s) for s in re.findall('\\\\d+', '', s))"
           body:Baseline= 'map(int, zip(*tuple))'
              body:-Code= 'map(int, sublist, zip(*map(map(lambda x: x.split())))'
          mined:Baseline= 'map(int, x.split())'
             mined:+Body= 'map(int, T2.split())'
        mined:+Body, -NL= "map(int, ['13', '17', '18', '21', '32'])"
      mined:+Body, -Code= '[map(int, x.split()[0]) for x in rows]'

================================================================================

QUESTION: idx=223    id=642154
-------------------------------------INPUTS-------------------------------------

tags: string, integer
score: 444
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['T1']}
intent: convert items in `t1` to integers
body(Some added characters for better readability):
	I have a tuple of tuples from a MySQL query like this:
	
	start_block
	T1 = (('13', '17', '18', '21', '32'),
	      ('07', '11', '13', '14', '28'),
	      ('01', '05', '06', '08', '15', '16'))
	I'd like to convert all the string elements into integers and put them back into a list of lists:
	
	start_block
	T2 = [[13, 17, 18, 21, 32], [7, 11, 13, 14, 28], [1, 5, 6, 8, 15, 16]]
	
	<p>I tried to achieve it with 
	`eval` but didn't get any decent result yet.


-------------------------------------OUTPUT-------------------------------------

                Expected= 'T2 = [map(int, x) for x in T1]'
           base:Baseline= 'int(x, y) for x, y in t1[::(-1)]'
           base:+Canonic= 'int(x) for x in var_0)'
           body:Baseline= 'map(int, zip(*t1))'
              body:-Code= 'map(int, tuple(t1))'
          mined:Baseline= 'map(int, t1.split())'
             mined:+Body= '[int(x) for x in T1]'
        mined:+Body, -NL= 'ast.literal_eval(t1)'
      mined:+Body, -Code= 'map(int, zip(*t1))'

================================================================================

QUESTION: idx=224    id=3777301
-------------------------------------INPUTS-------------------------------------

tags: shell
score: 237
slot_map: {'key': ['str_0'], 'quote': ['`'], 'type': ['str'], 'value': ['./test.sh']}
intent: call a shell script `./test.sh` using subprocess
body(Some added characters for better readability):
	How to call a shell script from python code?


-------------------------------------OUTPUT-------------------------------------

                Expected= "subprocess.call(['./test.sh'])"
           base:Baseline= "subprocess.call('./test.sh', shell=True)"
           base:+Canonic= "subprocess.call('./test.sh', shell=True)"
           body:Baseline= "subprocess.call('./test.sh', shell=True)"
              body:-Code= "subprocess.call('./test.sh', shell=True)"
          mined:Baseline= "subprocess.call('./test.sh', shell=True)"
             mined:+Body= "subprocess.call('./test.sh', shell=True)"
        mined:+Body, -NL= "subprocess.call(['./test.sh', shell=True)"
      mined:+Body, -Code= "subprocess.call('./test.sh', shell=True)"

================================================================================

QUESTION: idx=225    id=3777301
-------------------------------------INPUTS-------------------------------------

tags: shell
score: 237
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['notepad']}
intent: call a shell script `notepad` using subprocess
body(Some added characters for better readability):
	How to call a shell script from python code?


-------------------------------------OUTPUT-------------------------------------

                Expected= "subprocess.call(['notepad'])"
           base:Baseline= 'subprocess.call(notepad, shell=True)'
           base:+Canonic= "subprocess.call('notepad', shell=True)"
           body:Baseline= "subprocess.call('notepad', shell=True)"
              body:-Code= "subprocess.call('notepad', shell=True)"
          mined:Baseline= "subprocess.call('notepad', shell=True)"
             mined:+Body= "subprocess.call(['notepad', 'notepad'])"
        mined:+Body, -NL= "subprocess.call(['notepad', 'notepad'])"
      mined:+Body, -Code= "subprocess.call(['notepad', shell=True)"

================================================================================

QUESTION: idx=226    id=7946798
-------------------------------------INPUTS-------------------------------------

tags: list
score: 90
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['l1', 'l2']}
intent: combine lists `l1` and `l2`  by alternating their elements
body(Some added characters for better readability):
	In Python, is there a good way to interleave two lists of the same length?
	
	<p>Say I'm given 
	`[1,2,3]`
	 and 
	`[10,20,30]`
	. I'd like to transform those into 
	`[1,10,2,20,3,30]`.


-------------------------------------OUTPUT-------------------------------------

                Expected= '[val for pair in zip(l1, l2) for val in pair]'
           base:Baseline= '[(x + y) for x, y in zip(l1, l2)]'
           base:+Canonic= '[(i, j) for i, j in zip(l1, l2) for j in i]'
           body:Baseline= '[l1[i] for i in l2]'
              body:-Code= '[i for i, j in zip(l1, l2)]'
          mined:Baseline= '[(x / y) for x, y in zip(l1, l2)]'
             mined:+Body= '[(x + y) for x, y in zip(l1, l2)]'
        mined:+Body, -NL= 'from functools import reduce\nreduce(lambda x, y: x + y, l1, l2)'
      mined:+Body, -Code= '[(x + y) for x, y in zip(l1, l2)]'

================================================================================

QUESTION: idx=227    id=8908287
-------------------------------------INPUTS-------------------------------------

tags: base64
score: 279
slot_map: {'key': ['str_0'], 'quote': ["'"], 'type': ['str'], 'value': ['data to be encoded']}
intent: encode string 'data to be encoded'
body(Some added characters for better readability):
	
	<p>Following this 
	python example , I encode a string as Base64 with:
	
	
	start_block
	>>>import base64
	>>>encoded = base64.b64encode(b'data to be encoded')
	>>>encoded
	...b'ZGF0YSB0byBiZSBlbmNvZGVk'
	
	<p>But, if I leave out the leading 
	`b`:
	
	
	start_block
	>>>encoded = base64.b64encode('data to be encoded')
	...
	I get the following error:
	
	start_block
	Traceback (most recent call last):
	  File " <stdin>", line 1, in <module>
	  File "C:\Python32\lib\base64.py", line 56, in b64encode
	   raise TypeError("expected bytes, not %s" % s.__class__.__name__)
	   TypeError: expected bytes, not str
	Why is this?


-------------------------------------OUTPUT-------------------------------------

                Expected= "encoded = base64.b64encode('data to be encoded')"
           base:Baseline= "struct.encode('data to be encoded')"
           base:+Canonic= "print('str_0'.encode('utf-8')"
           body:Baseline= "struct.encode('data to be encoded')"
              body:-Code= "struct.encode('data to be encoded')"
          mined:Baseline= "data.encode('utf-8')"
             mined:+Body= "encoded = base64.b64encode('data to be encoded')"
        mined:+Body, -NL= "base64.b64encode('data to be encoded')"
      mined:+Body, -Code= '"""data to be encoded""".encode(\'base64\')'

================================================================================

QUESTION: idx=228    id=8908287
-------------------------------------INPUTS-------------------------------------

tags: base64
score: 279
slot_map: {'key': ['str_0', 'var_0'], 'quote': ['`', '`'], 'type': ['str', 'var'], 'value': ['data to be encoded', 'ascii']}
intent: encode a string `data to be encoded` to `ascii` encoding
body(Some added characters for better readability):
	
	<p>Following this 
	python example , I encode a string as Base64 with:
	
	
	start_block
	>>>import base64
	>>>encoded = base64.b64encode(b'data to be encoded')
	>>>encoded
	...b'ZGF0YSB0byBiZSBlbmNvZGVk'
	
	<p>But, if I leave out the leading 
	`b`:
	
	
	start_block
	>>>encoded = base64.b64encode('data to be encoded')
	...
	I get the following error:
	
	start_block
	Traceback (most recent call last):
	  File " <stdin>", line 1, in <module>
	  File "C:\Python32\lib\base64.py", line 56, in b64encode
	   raise TypeError("expected bytes, not %s" % s.__class__.__name__)
	   TypeError: expected bytes, not str
	Why is this?


-------------------------------------OUTPUT-------------------------------------

                Expected= "encoded = 'data to be encoded'.encode('ascii')"
           base:Baseline= "ascii.encode('utf-8')"
           base:+Canonic= "urllib.parse.unquote('data to be encoded', ascii)"
           body:Baseline= "struct.encode('data to be encoded')"
              body:-Code= "ascii.encode('data to be encoded')"
          mined:Baseline= "urllib.parse.unquote(data).encode('ascii', 'ignore')"
             mined:+Body= "encoded = base64.b64encode('data to be encoded')"
        mined:+Body, -NL= "base64.b64encode('data to be encoded')"
      mined:+Body, -Code= '"""data to be encoded""".encode(\'ascii\')'

================================================================================

QUESTION: idx=229    id=7856296
-------------------------------------INPUTS-------------------------------------

tags: parsing, csv, dictionary
score: 32
slot_map: {'key': ['str_0'], 'quote': ["'"], 'type': ['str'], 'value': ['text.txt']}
intent: parse tab-delimited csv file 'text.txt' into a list
body(Some added characters for better readability):
	I currently have a CSV file which, when opened in Excel, has a total of 5 columns. Only columns A and C are of any significance to me and the data in the remaining columns is irrelevant.
	Starting on line 8 and then working in multiples of 7 (ie. lines 8, 15, 22, 29, 36 etc...), I am looking to create a dictionary with Python 2.7 with the information from these fields. The data in column A will be the key (a 6-digit integer) and the data in column C being the respective value for the key. I've tried to highlight this below but the formatting isn't the best:-
	
	start_block
	    A        B      C          D
	1                           CDCDCDCD  
	2                           VDDBDDB
	3
	4
	5
	6
	7  DDEFEEF                   FEFEFEFE
	8  123456         JONES
	9
	10
	11
	12
	13
	14
	15 293849         SMITH
	As per the above, I am looking to extract the value from A7 (DDEFEEF) as a key in my dictionary and "FEFEFEFE" being the respective data and then add another entry to my dictionary, jumping to line 15 with "2938495" being my key and "Smith" being the respective value.
	Any suggestions? The source file is a .txt file with entries being tab-delimited.
	Thanks
	Clarification:
	Just to clarify, so far, I have tried the below:-
	
	start_block
	import csv
	mydict = {:}
	f = open("myfile", 'rt')
	reader = csv.reader(f)
	    for row in reader:
	        print row
	The above simply prints out all content though a row at a time. I did try "for row(7) in reader" but this returned an error. I then researched it and had a go at the below but it didn't work neither:
	
	start_block
	import csv
	from itertools import islice
	entries = csv.reader(open("myfile", 'rb'))
	mydict = {'key' : 'value'}
	for i in xrange(6):
	    mydict['i(0)] = 'I(2)    # integers representing columns
	    range = islice(entries,6)
	    for entry in range:
	        mydict[entries(0) = entries(2)] # integers representing columns


-------------------------------------OUTPUT-------------------------------------

                Expected= "lol = list(csv.reader(open('text.txt', 'rb'), delimiter='\\t'))"
           base:Baseline= "list('text.txt', delimiter=',')"
           base:+Canonic= "list('text.txt', delimiter=',')"
           body:Baseline= "df = open('text.txt', 'rb').read()"
              body:-Code= "df = open('text.txt', delimiter=None)"
          mined:Baseline= "[item for sublist in open('text.txt').read()]"
             mined:+Body= '[row[0] for row in reader]'
        mined:+Body, -NL= "list(open('myfile', 'rb'))"
      mined:+Body, -Code= "list(open('text.txt', 'rb').read().split())"

================================================================================

QUESTION: idx=230    id=9035479
-------------------------------------INPUTS-------------------------------------

tags: object, dictionary
score: 10
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['my_str', 'my_object']}
intent: get attribute `my_str` of object `my_object`
body(Some added characters for better readability):
	
	
	start_block
	>>>my_object.name = 'stuff'
	>>>my_str = 'name'
	>>>my_object[my_str] # won't work because it's not a dictionary :)
	...
	
	<p>How can I access to the fields of 
	`my_object`
	 defined on 
	`my_str` ?


-------------------------------------OUTPUT-------------------------------------

                Expected= 'getattr(my_object, my_str)'
           base:Baseline= 'my_object.getattr(my_str)'
           base:+Canonic= 'my_object.getattr(my_str)'
           body:Baseline= 'my_object.getattr(my_str)'
              body:-Code= 'my_object.getattr(my_str)'
          mined:Baseline= 'my_object.getattr(my_str)'
             mined:+Body= 'getattr(my_object, my_str)'
        mined:+Body, -NL= 'my_object.getattr(my_str)'
      mined:+Body, -Code= 'getattr(my_object, my_str)'

================================================================================

QUESTION: idx=231    id=5558418
-------------------------------------INPUTS-------------------------------------

tags: list, dictionary
score: 81
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['LD']}
intent: group a list of dicts `ld` into one dict by key
body(Some added characters for better readability):
	I am looking to change back and forth between a dictionary of lists (all of the same length):
	
	start_block
	DL = {'a': [0, 1], 'b': [2, 3]}
	and a list of dictionaries:
	
	start_block
	LD = [{'a': 0, 'b': 2}, {'a': 1, 'b': 3}]
	I am looking for the cleanest way to switch between the two forms.


-------------------------------------OUTPUT-------------------------------------

                Expected= 'print(dict(zip(LD[0], zip(*[list(d.values()) for d in LD]))))'
           base:Baseline= 'dict((k, v) for k, v in list(ld.items()))'
           base:+Canonic= 'dict((k, v) for k, v in LD.items())'
           body:Baseline= "[d['a'] for d in zip(DL, LD)]"
              body:-Code= 'dict((k, v) for k, v in list(ld.items()))'
          mined:Baseline= 'dict((k, v) for k, v in list(ld.items()))'
             mined:+Body= '[dict(zip(DL, LD)) for x in LD]'
        mined:+Body, -NL= '[dict(zip(DL, LD)) for x in LD]'
      mined:+Body, -Code= 'dict((k, v) for k, v in list(ld.items()) for k in k)'

================================================================================

QUESTION: idx=232    id=638048
-------------------------------------INPUTS-------------------------------------

tags: list, tuples
score: 31
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: how do i sum the first value in each tuple in a list of tuples in python?
body(Some added characters for better readability):
	I have a list of tuples (always pairs) like this:
	
	start_block
	[(0, 1), (2, 3), (5, 7), (2, 1)]
	I'd like to find the sum of the first items in each pair, i.e.:
	
	start_block
	0 + 2 + 5 + 2
	How can I do this in Python? At the moment I'm iterating through the list: 
	
	start_block
	sum = 0
	for pair in list_of_pairs:
	   sum += pair[0]
	I have a feeling there must be a more Pythonic way.


-------------------------------------OUTPUT-------------------------------------

                Expected= 'sum([pair[0] for pair in list_of_pairs])'
           base:Baseline= 'sum(x[0] for x in zip(*zip(my_list, my_list))'
           base:+Canonic= 'sum(x[0] for x in zip(*var(x)))'
           body:Baseline= 'sum(x[0] for x in zip(*list_of_pairs)]'
              body:-Code= 'sum(x[0] for x in zip(*my_list)'
          mined:Baseline= '[x[0] for x in a]'
             mined:+Body= 'sum(x[0] for x in list_of_pairs)'
        mined:+Body, -NL= 'sum(x[0] for x in list_of_pairs)'
      mined:+Body, -Code= 'sum(x[0] for x in l)'

================================================================================

QUESTION: idx=233    id=14950260
-------------------------------------INPUTS-------------------------------------

tags: unicode, dictionary
score: 52
slot_map: {'key': ['str_0', '{str_0}'], 'quote': ['"', '"'], 'type': ['str', 'str'], 'value': ["{'code1':1,'code2':1}", "{'code1':1,'code2':1}"]}
intent: convert unicode string u"{'code1':1,'code2':1}" into dictionary
body(Some added characters for better readability):
	
	<p>I have unicode 
	`u"{'code1':1,'code2':1}"` and I want it in dictionary format.
	
	<p>I want it in 
	`{'code1':1,'code2':1}` format.
	
	<p>I tried 
	`unicodedata.normalize('NFKD', my_data).encode('ascii','ignore')` but it returns string not dictionary.
	Can anyone help me?


-------------------------------------OUTPUT-------------------------------------

                Expected= 'd = ast.literal_eval("{\'code1\':1,\'code2\':1}")'
           base:Baseline= "dict((k, v) for k, v in u.split(',code1': 1,'code2': 1})"
           base:+Canonic= 'dict((k, ustr_0))'
           body:Baseline= "dict((k, v) for k, v in unicodedata.normalize('NFKD', {'code1': 1, 'code2': 1})\n    )"
              body:-Code= "dict((k, v) for k, v in {'code1': 1, 'code2': 1})"
          mined:Baseline= "dict(chr(ord(c)) for c in u.decode('utf8'))"
             mined:+Body= "{'code1': 1, 'code2': 1}"
        mined:+Body, -NL= "'{'code1': 1,'code2': 1}'.encode('ascii', 'ignore')"
      mined:+Body, -Code= "{'code1': 1, 'code2': 1}"

================================================================================

QUESTION: idx=234    id=11416772
-------------------------------------INPUTS-------------------------------------

tags: regex, dollar-sign
score: 12
slot_map: {'key': ['var_0', 'str_0'], 'quote': ['`', '`'], 'type': ['var', 'str'], 'value': ['mystring', '$']}
intent: find all words in a string `mystring` that start with the `$` sign
body(Some added characters for better readability):
	How can I extract all words in a string that start with the $ sign? For example in the string
	
	start_block
	This $string is an $example
	
	<p>I want to extract the words 
	`$string`
	 and 
	`$example`.
	
	<p>I tried with this regex 
	`\b[$]\S*` but it works fine only if I use a normal character rather than dollar.


-------------------------------------OUTPUT-------------------------------------

                Expected= "[word for word in mystring.split() if word.startswith('$')]"
           base:Baseline= "re.findall('\\\\d+$', mystring)"
           base:+Canonic= "re.findall('\\\\w+', mystring)"
           body:Baseline= "re.findall('\\\\b[$]\\\\S*', mystring)"
              body:-Code= "re.findall('\\\\w+)', myString)"
          mined:Baseline= "re.findall('\\\\w+', myString)"
             mined:+Body= "re.findall('\\\\b[$]\\\\S*', mystring)"
        mined:+Body, -NL= "re.findall('\\\\b[$]', mystring)"
      mined:+Body, -Code= "re.findall('[^\\\\$]', myString)"

================================================================================

QUESTION: idx=235    id=11331982
-------------------------------------INPUTS-------------------------------------

tags: regex, url, replace
score: 48
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['text']}
intent: remove any url within string `text`
body(Some added characters for better readability):
	I want to remove all URLs inside a string (replace them with "")
	I searched around but couldn't really find what I want.
	Example:
	
	start_block
	text1
	text2
	http://url.com/bla1/blah1/
	text3
	text4
	http://url.com/bla2/blah2/
	text5
	text6
	http://url.com/bla3/blah3/
	I want the result to be:
	
	start_block
	text1
	text2
	text3
	text4
	text5
	text6


-------------------------------------OUTPUT-------------------------------------

                Expected= "text = re.sub('^https?:\\\\/\\\\/.*[\\\\r\\\\n]*', '', text, flags=re.MULTILINE)"
           base:Baseline= "re.sub('(\\\\w+)', text)"
           base:+Canonic= 'urllib.parse.unquote(var_0))'
           body:Baseline= "text = re.sub('/', '', text)"
              body:-Code= "re.sub('(?<?\\\\w+)', '', text)"
          mined:Baseline= "text = re.sub('(\\\\w+)', '\\\\1\\\\1', text)"
             mined:+Body= "text = re.sub('(.*?\\\\)', '\\\\1', text)"
        mined:+Body, -NL= "text = url.replace('/', '')"
      mined:+Body, -Code= 're.sub(\'[^"]*\', \'\', text)'

================================================================================

QUESTION: idx=236    id=34945274
-------------------------------------INPUTS-------------------------------------

tags: arrays, performance, numpy, vectorization
score: 4
slot_map: {'key': ['var_0', 'str_0', '[str_0]'], 'quote': ['`', '`', '`'], 'type': ['var', 'str', 'str'], 'value': ['A', '[1, 3, 4]', '[1, 3, 4]']}
intent: replace all elements in array `a` that are not present in array `[1, 3, 4]` with zeros
body(Some added characters for better readability):
	I have a 2-dimensional NumPy array, for example:
	
	start_block
	array([[1, 1, 0, 2, 2],
	       [1, 1, 0, 2, 0],
	       [0, 0, 0, 0, 0],
	       [3, 3, 0, 4, 4],
	       [3, 3, 0, 4, 4]])
	I would like to get all elements from that array which are in a certain list, for example (1, 3, 4). The desired result in the example case would be:
	
	start_block
	array([[1, 1, 0, 0, 0],
	       [1, 1, 0, 0, 0],
	       [0, 0, 0, 0, 0],
	       [3, 3, 0, 4, 4],
	       [3, 3, 0, 4, 4]])
	
	<p>I know that I can just do (as recommended here 
	Numpy: find elements within range ):
	
	start_block
	np.logical_or(
	    np.logical_or(cc_labeled == 1, cc_labeled == 3),
	    cc_labeled == 4
	)
	, but this will be only reasonably effective in the example case. In reality iteratively using for loop and numpy.logical_or turned out to be really slow since the list of possible values is in thousands (and numpy array has approximately the dimension of 1000 x 1000).


-------------------------------------OUTPUT-------------------------------------

                Expected= 'np.where(np.in1d(A, [1, 3, 4]).reshape(A.shape), A, 0)'
           base:Baseline= 'a = np.array([1, 3, 4])'
           base:+Canonic= "A = A.replace('[1, 3, 4]', 'zeros')"
           body:Baseline= 'np.all(a != [1, 3, 4])'
              body:-Code= 'numpy.replace([1, 3, 4], a)'
          mined:Baseline= 'a = [1, 3, 4]'
             mined:+Body= '[x for x in a if x not in [1, 3, 4]]'
        mined:+Body, -NL= 'np.logical_or(a, [1, 3, 4], axis=1)'
      mined:+Body, -Code= 'np.all(a != [1, 3, 4])'

================================================================================

QUESTION: idx=237    id=15819980
-------------------------------------INPUTS-------------------------------------

tags: arrays, multidimensional-array, numpy, mean
score: 85
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['a']}
intent: calculate mean across dimension in a 2d array `a`
body(Some added characters for better readability):
	
	<p>I have an array 
	`a` like this:
	
	start_block
	a = [[40, 10], [50, 11]]
	I need to calculate the mean for each dimension separately, the result should be this:
	
	start_block
	[45, 10.5]
	
	`45`
	 being the mean of 
	`a[*][0]`
	 and 
	`10.5`
	 the mean of 
	`a[*][1]`.
	What is the most elegant way of solving this without using a loop?


-------------------------------------OUTPUT-------------------------------------

                Expected= 'np.mean(a, axis=1)'
           base:Baseline= 'np.mean(a, axis=0)'
           base:+Canonic= 'np.mean(a, axis=0)'
           body:Baseline= 'mean(np.arange(a), axis=1)'
              body:-Code= 'np.mean(a, axis=1)'
          mined:Baseline= 'np.mean(a, axis=1)'
             mined:+Body= 'a.mean(axis=1)'
        mined:+Body, -NL= 'np.mean(a, axis=1)'
      mined:+Body, -Code= 'mean(np.mean(a, axis=1))'

================================================================================

QUESTION: idx=238    id=19894365
-------------------------------------INPUTS-------------------------------------

tags: r
score: 46
slot_map: {'key': ['str_0'], 'quote': ["'"], 'type': ['str'], 'value': ['/pathto/MyrScript.r']}
intent: running r script '/pathto/myrscript.r' from python
body(Some added characters for better readability):
	I searched for this question and found some answers on this, but none of them seem to work. This is the script that I'm using in python to run my R script.
	
	start_block
	import subprocess
	retcode = subprocess.call("/usr/bin/Rscript --vanilla -e 'source(\"/pathto/MyrScript.r\")'", shell=True)
	and I get this error:
	
	start_block
	Error in read.table(file = file, header = header, sep = sep, quote = quote,  : 
	  no lines available in input
	...withVisible -> eval -> eval -> read.csv -> read.table
	Execution halted
	and here is the content of my R script (pretty simple!)
	
	start_block
	data = read.csv('features.csv')
	data1 = read.csv("BagofWords.csv")
	merged = merge(data,data1)
	write.table(merged, "merged.csv",quote=FALSE,sep=",",row.names=FALSE)
	for (i in 1:length(merged$fileName))
	{
	        fileConn <-file(paste("output/",toString(merged$fileName[i]),".txt",sep=""))
	        writeLines((toString(merged$BagofWord[i])),fileConn)
	        close(fileConn)
	}
	
	<p>The r script is working fine, when I use 
	`source('MyrScript.r')`
	 in r commandline. Moreover, when I try to use the exact command which I pass to the 
	`subprocess.call`
	 function (i.e., 
	`/usr/bin/Rscript --vanilla -e 'source("/pathto/MyrScript.r")'`) in my commandline it works find, I don't really get what's the problem.


-------------------------------------OUTPUT-------------------------------------

                Expected= "subprocess.call(['/usr/bin/Rscript', '--vanilla', '/pathto/MyrScript.r'])"
           base:Baseline= "os.system('/pathTo/myrscript.r')"
           base:+Canonic= "os.system('/pathto/MyrScript.r')"
           body:Baseline= "subprocess.call('/pathto/myrscript.r')"
              body:-Code= "os.system('/pathto/myrscript.r')"
          mined:Baseline= "os.system('/pathto/myrscript.r')"
             mined:+Body= "subprocess.call('/pathto/myrscript.r', shell=True)"
        mined:+Body, -NL= "subprocess.call('/pathto/myrscript.r')"
      mined:+Body, -Code= "subprocess.call('path/to/myrscript.r', shell=True)"

================================================================================

QUESTION: idx=239    id=19894365
-------------------------------------INPUTS-------------------------------------

tags: r
score: 46
slot_map: {'key': ['str_0'], 'quote': ["'"], 'type': ['str'], 'value': ['/usr/bin/Rscript --vanilla /pathto/MyrScript.r']}
intent: run r script '/usr/bin/rscript --vanilla /pathto/myrscript.r'
body(Some added characters for better readability):
	I searched for this question and found some answers on this, but none of them seem to work. This is the script that I'm using in python to run my R script.
	
	start_block
	import subprocess
	retcode = subprocess.call("/usr/bin/Rscript --vanilla -e 'source(\"/pathto/MyrScript.r\")'", shell=True)
	and I get this error:
	
	start_block
	Error in read.table(file = file, header = header, sep = sep, quote = quote,  : 
	  no lines available in input
	...withVisible -> eval -> eval -> read.csv -> read.table
	Execution halted
	and here is the content of my R script (pretty simple!)
	
	start_block
	data = read.csv('features.csv')
	data1 = read.csv("BagofWords.csv")
	merged = merge(data,data1)
	write.table(merged, "merged.csv",quote=FALSE,sep=",",row.names=FALSE)
	for (i in 1:length(merged$fileName))
	{
	        fileConn <-file(paste("output/",toString(merged$fileName[i]),".txt",sep=""))
	        writeLines((toString(merged$BagofWord[i])),fileConn)
	        close(fileConn)
	}
	
	<p>The r script is working fine, when I use 
	`source('MyrScript.r')`
	 in r commandline. Moreover, when I try to use the exact command which I pass to the 
	`subprocess.call`
	 function (i.e., 
	`/usr/bin/Rscript --vanilla -e 'source("/pathto/MyrScript.r")'`) in my commandline it works find, I don't really get what's the problem.


-------------------------------------OUTPUT-------------------------------------

                Expected= "subprocess.call('/usr/bin/Rscript --vanilla /pathto/MyrScript.r', shell=True)"
           base:Baseline= "os.system('/usr/bin/rscript --vanilla /pathTo/myrscript.r')"
           base:+Canonic= "subprocess.call('/usr/bin/Rscript --vanilla /pathto/MyrScript.r', shell=True)"
           body:Baseline= "subprocess.call('/usr/bin/Rscript --vanilla /pathto/MyrScript.r')"
              body:-Code= "os.system('/usr/bin/rscript --vanilla /pathto/myrscript.r')"
          mined:Baseline= "os.system('/usr/bin/rscript --vanilla /pathto/myrscript.r')"
             mined:+Body= "subprocess.call('/usr/bin/Rscript --vanilla -e'source('/pathto/MyrScript.r')', shell=True)"
        mined:+Body, -NL= "subprocess.call('/usr/bin/Rscript --vanilla -e'source('/pathto/MyrScript.r')', shell=True)"
      mined:+Body, -Code= "subprocess.call('/usr/bin/rscript --vanilla /pathto/myrscript.r')"

================================================================================

QUESTION: idx=240    id=15907200
-------------------------------------INPUTS-------------------------------------

tags: csv
score: 12
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: add a header to a csv file
body(Some added characters for better readability):
	I've tried many solutions to add a header to my csv file, but nothing's working properly. Here they are :
	I used the writerow method, but my data are overwriting the first row.
	I used the DictWriter method, but I don't know how to fill it correctly. Here is my code:
	
	start_block
	csv = csv.DictWriter(open(directory +'/csv.csv', 'wt'), fieldnames = ["stuff1", "stuff2", "stuff3"], delimiter = ';')
	csv.writeheader(["stuff1", "stuff2", "stuff3"])
	I got a "2 arguments instead of one" error and I really don't know why.
	Any advice?


-------------------------------------OUTPUT-------------------------------------

                Expected= 'writer.writeheader()'
           base:Baseline= 'csv = os.path.dirname(__file__))'
           base:+Canonic= 'csv = csv.headers()'
           body:Baseline= "csv.writeheader(['stuff1', 'stuff2'])"
              body:-Code= "writerow.write('header', header=False)"
          mined:Baseline= 'writer.writerows(header=None)'
             mined:+Body= "csv.writeheader(['{}_{}'.format(x) for x in data])"
        mined:+Body, -NL= 'csv.writeheader([\'stuff1\',\'stuff2\', "stuff3\'])'
      mined:+Body, -Code= 'writerow.writeheader(data)'

================================================================================

QUESTION: idx=241    id=33058590
-------------------------------------INPUTS-------------------------------------

tags: pandas, dataframe, missing-data
score: 24
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['df']}
intent: replacing nan in the dataframe `df` with row average
body(Some added characters for better readability):
	
	<p>I am  trying to learn pandas but i have been puzzled with the following please. I want to replace NaNs is a dataframe with the row average. Hence something like 
	`df.fillna(df.mean(axis=1))`
	 should work but for some reason it fails for me. Am I missing anything please, something I'm doing wrong? Is is because its not implemented; see link here
	
	start_block
	import pandas as pd
	import numpy as np
	pd.__version__
	<console_out>
	'0.15.2'
	<console_in>
	...df = pd.DataFrame()
	df['c1'] = [1, 2, 3]
	df['c2'] = [4, 5, 6]
	df['c3'] = [7, np.nan, 9]
	df
	<console_out>
	    c1  c2  c3
	0   1   4   7
	1   2   5   NaN
	2   3   6   9
	>>> 
	...df.fillna(df.mean(axis=1)) 
	<console_out>
	    c1  c2  c3
	0   1   4   7
	1   2   5   NaN
	2   3   6   9
	However something like this looks to work fine
	
	start_block
	df.fillna(df.mean(axis=0)) 
	<console_out>
	    c1  c2  c3
	0   1   4   7
	1   2   5   8
	2   3   6   9


-------------------------------------OUTPUT-------------------------------------

                Expected= 'df.fillna(df.mean(axis=1), axis=1)'
           base:Baseline= 'df.fillna(axis=1).mean()'
           base:+Canonic= 'df.fillna(axis=1).mean()'
           body:Baseline= 'df.fillna(df.mean(axis=1))'
              body:-Code= 'df.fillna(axis=1)'
          mined:Baseline= 'df.fillna(axis=1)'
             mined:+Body= 'df.fillna(df.mean(axis=1)'
        mined:+Body, -NL= 'df.fillna(df.mean(axis=1)'
      mined:+Body, -Code= 'df.fillna(axis=1).mean()'

================================================================================

QUESTION: idx=242    id=12400256
-------------------------------------INPUTS-------------------------------------

tags: 
score: 346
slot_map: {'key': ['str_0', 'str_1'], 'quote': ["'", "'"], 'type': ['str', 'str'], 'value': ['1347517370', '%Y-%m-%d %H:%M:%S']}
intent: convert unix timestamp '1347517370' to formatted string '%y-%m-%d %h:%m:%s'
body(Some added characters for better readability):
	I am getting a response from the rest is an Epoch time format like
	
	start_block
	start_time = 1234566
	end_time = 1234578
	I want to convert that epoch seconds in MySQL format time so that I could store the differences in my MySQL database.
	I tried:
	
	
	start_block
	>>>import time
	>>>time.gmtime(123456)
	...time.struct_time(tm_year=1970, tm_mon=1, tm_mday=2, tm_hour=10, tm_min=17, tm_sec=36, tm_wday=4, tm_yday=2, tm_isdst=0)
	The above result is not what I am expecting. I want it be like 
	
	start_block
	2012-09-12 21:00:00
	Please suggest how can I achieve this?
	Also,
	
	`TypeError: a float is required` for
	
	
	start_block
	>>>getbbb_class.end_time = 1347516459425
	>>>mend = time.gmtime(getbbb_class.end_time).tm_hour
	...Traceback (most recent call last):
	  <console_out>
	TypeError: a float is required


-------------------------------------OUTPUT-------------------------------------

                Expected= "time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(1347517370))"
           base:Baseline= "datetime.strptime('1347517370', '%Y-%m-%d %H:%M:%S')"
           base:+Canonic= "datetime.strptime('1347517370', '%Y-%m-%d %H:%M:%S')"
           body:Baseline= "time.gmtime(1347517370, '%Y-%m-%d %H:%M:%S')"
              body:-Code= "timestamp('1347517370', '%Y-%m-%d %H:%M:%S')"
          mined:Baseline= "struct.unpack('%Y-%m-%d %H:%M:%S')"
             mined:+Body= "time.strftime('%Y-%m-%d %H:%M:%S')"
        mined:+Body, -NL= "struct.unpack('1347517370', '%Y-%m-%d %H:%M:%S')"
      mined:+Body, -Code= "time.strptime('1347517370', '%Y-%m-%d %H:%M:%S')"

================================================================================

QUESTION: idx=243    id=1269217
-------------------------------------INPUTS-------------------------------------

tags: class, overriding, class-method
score: 112
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['do', 'Derived']}
intent: call a base class's class method `do` from derived class `derived`
body(Some added characters for better readability):
	Consider the following code:
	
	start_block
	class Base(object):
	    @classmethod
	    def do(cls, a):
	        print cls, a
	class Derived(Base):
	    @classmethod
	    def do(cls, a):
	        print 'In derived!'
	        # Base.do(cls, a) -- can't pass `cls`
	        Base.do(a)
	if __name__ == '__main__':
	    d = Derived()
	    d.do('hello')
	> $ python play.py  
	> In derived! 
	> <class '__main__.Base'> msg
	
	<p>From 
	`Derived.do`
	, how do I call 
	`Base.do`? 
	
	<p>I would normally use 
	`super` or even the base class name directly if this is a normal object method, but apparently I can't find a way to call the classmethod in the base class. 
	
	<p>In the above example, 
	`Base.do(a)`
	 prints 
	`Base`
	 class instead of 
	`Derived` class.


-------------------------------------OUTPUT-------------------------------------

                Expected= 'super(Derived, cls).do(a)'
           base:Baseline= 'print(super(name, self).__init__(*name))'
           base:+Canonic= 'do = base(Derived, Derived)'
           body:Baseline= 'Base.__class__.__do__'
              body:-Code= 'print(do.__class__).__name__'
          mined:Baseline= 'super(Do, self).__init__(*args, **kwargs)'
             mined:+Body= 'super(Base, self).__class__.__do__'
        mined:+Body, -NL= 'do_list = Base.__init__(*args, **kwargs)'
      mined:+Body, -Code= 'super(Foo, self).__init__(*args, **kwargs)'

================================================================================

QUESTION: idx=244    id=23359886
-------------------------------------INPUTS-------------------------------------

tags: numpy, multidimensional-array
score: 21
slot_map: {'key': ['str_0'], 'quote': ["'"], 'type': ['str'], 'value': ['a']}
intent: selecting rows in numpy ndarray 'a', where the value in the first column is 0 and value in the second column is 1
body(Some added characters for better readability):
	
	<p>I have a big 
	`np.ndarray (3600000,3)`
	, the 
	`HUE`
	, the 
	`VALUE`
	, and an associated 
	`CLASS`
	 number. For each pairs of 
	`HUE`
	 and 
	`VALUE`
	 I would like to find, using this array the corresponding 
	`Class` number. I'm a very beginner in Python and have a hard time doing it. Do you know a way to do it? 
	Thank you in advance!


-------------------------------------OUTPUT-------------------------------------

                Expected= 'a[np.where((a[:, (0)] == 0) * (a[:, (1)] == 1))]'
           base:Baseline= 'numpy.choice(a, key=lambda x: x[1])'
           base:+Canonic= 'a.sort(key=lambda x: x[1])'
           body:Baseline= 'np.ndarray(a, key=lambda x: x[1])'
              body:-Code= 'numpy.select(a, key=lambda x: -1, reverse=True)'
          mined:Baseline= 'a[np.arange(a.shape[0], axis=1)]'
             mined:+Body= 'numpy.where(a == 0, a == 1, axis=1)'
        mined:+Body, -NL= 'a[np.arange(len(a)) == 1]'
      mined:+Body, -Code= 'np.where(a == 0, axis=1)'

================================================================================

QUESTION: idx=245    id=4383082
-------------------------------------INPUTS-------------------------------------

tags: regex, string, list
score: 7
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: separate words delimited by one or more spaces into a list
body(Some added characters for better readability):
	If I have a string = "hello world sample text"
	I want to be able to convert it to a list = ["hello", "world", "sample", "text"]
	How can I do that with regular expressions? (other methods not using re are acceptable)


-------------------------------------OUTPUT-------------------------------------

                Expected= "re.split(' +', 'hello world sample text')"
           base:Baseline= "[item for item in re.findall('\\\\w+|\\\\d+\\\\W+|', '', item)"
           base:+Canonic= "[x for x in re.findall('\\\\d+', '', delimiter=',')]"
           body:Baseline= "list(re.split('\\\\w+', '', 'hello world sample text')"
              body:-Code= "list(re.search('hello world sample text', 'text')"
          mined:Baseline= '[word.split() for word in words]'
             mined:+Body= "['hello', 'world', 'sample', 'text']"
        mined:+Body, -NL= "list(re.findall('\\\\w+', s))"
      mined:+Body, -Code= "['world', 'sample', 'text'].split()"

================================================================================

QUESTION: idx=246    id=14637696
-------------------------------------INPUTS-------------------------------------

tags: string, performance, list, coding-style
score: 7
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['words']}
intent: length of longest element in list `words`
body(Some added characters for better readability):
	What is the more pythonic way of getting the length of the longest word:
	`len(max(words, key=len))`
	Or:
	`max(len(w) for w in words)`
	
	<p>Or.. something else?   
	`words` is a list of strings. 
	
	`len` being called twice seems not to matter - does more happen in C code in this form?).  


-------------------------------------OUTPUT-------------------------------------

                Expected= 'len(max(words, key=len))'
           base:Baseline= 'len(words.min(len(word))'
           base:+Canonic= 'length(len(words))'
           body:Baseline= 'len(words, key=len))'
              body:-Code= 'print(len(word) for word in words)'
          mined:Baseline= '[len(word) for word in words]'
             mined:+Body= 'len(words, key=lambda x: len(x))'
        mined:+Body, -NL= 'len(words, key=lambda x: len(x))'
      mined:+Body, -Code= '[len(word) for word in words]'

================================================================================

QUESTION: idx=247    id=3933478
-------------------------------------INPUTS-------------------------------------

tags: dictionary
score: 5
slot_map: {'key': ['str_0', 'var_0'], 'quote': ["'", '`'], 'type': ['str', 'var'], 'value': ['from_user', 'result']}
intent: get the value associated with unicode key 'from_user' of first dictionary in list `result`
body(Some added characters for better readability):
	I am writing code that will search twitter for key words and store them in a python dictionary:
	
	start_block
	        base_url = 'http://search.twitter.com/search.json?rpp=100&q=4sq.com/'
	        query = '7bOHRP'
	        url_string = base_url + query
	        logging.info("url string = " + url_string)
	        json_text = fetch(url_string)
	        json_response = simplejson.loads(json_text.content)                                              
	        result = json_response['results']
	        print "Contents"
	        print result
	The resulting dictionary is :
	
	start_block
	Contents[{
	    u 'iso_language_code': u 'en',
	    u 'text': u "I'm at Cafe en Seine (40 Dawson Street, Dublin) w/ 2 others. http://4sq.com/7bOHRP",
	    u 'created_at': u 'Wed, 06 Oct 2010 23:37:02 +0000',
	    u 'profile_image_url': u 'http://a1.twimg.com/profile_images/573130785/twitterProfilePhoto_normal.jpg',
	    u 'source': u '&lt;a href=&quot;http://foursquare.com&quot; rel=&quot;nofollow&quot;&gt;foursquare&lt;/a&gt;',
	    u 'place': {
	        u 'type': u 'neighborhood',
	        u 'id': u '898cf727ca504e96',
	        u 'full_name': u 'Mansion House B, Dublin'
	    },
	    u 'from_user': u 'pkerssemakers',
	    u 'from_user_id': 60241195,
	    u 'to_user_id': None,
	    u 'geo': None,
	    u 'id': 26597357992,
	    u 'metadata': {
	        u 'result_type': u 'recent'
	    }
	}]
	Status: 200 OK
	Content - Type: text / html;charset = utf - 8
	Cache - Control: no - cache
	Expires: Fri, 01 Jan 1990 00: 00: 00 GMT
	Content - Length: 0
	How can I access the 'from_user' and what is the 'u' before the key and value?


-------------------------------------OUTPUT-------------------------------------

                Expected= "result[0]['from_user']"
           base:Baseline= "result['from_user'].encode('unicode_escape')"
           base:+Canonic= "print(result['from_user'].encode('unicode_escape'))"
           body:Baseline= "result['from_user'] = json.get('utf-8')"
              body:-Code= "result['from_user'] = result[0]"
          mined:Baseline= "[d['from_user'] for d inresult]"
             mined:+Body= "result = json_response['results'].encode('utf8')"
        mined:+Body, -NL= "result = json_response['results'].encode('utf8')"
      mined:+Body, -Code= "result = {'from_user': [k.encode('utf-8')) for k in result}"

================================================================================

QUESTION: idx=248    id=39112645
-------------------------------------INPUTS-------------------------------------

tags: 
score: 4
slot_map: {'key': ['str_0'], 'quote': ["'"], 'type': ['str'], 'value': ['File.txt']}
intent: retrieve each line from a file 'file.txt' as a list
body(Some added characters for better readability):
	
	start_block
	file = input('Name: ')
	with open(file) as infile:
	    for line in infile:
	        for name in infile:
	            name
	            print(name[line])
	So if a user were to pass a file of vertical list of sentences, how would I save each sentence to its own list?
	Sample input:
	
	start_block
	'hi'
	'hello'
	'cat'
	'dog'
	Output:
	
	start_block
	['hi']
	['hello']
	and so on...


-------------------------------------OUTPUT-------------------------------------

                Expected= "[line.split() for line in open('File.txt')]"
           base:Baseline= "[x for x in open('file.txt', 'r')]"
           base:+Canonic= "with open('File.txt', 'rb') as f:\n    pass"
           body:Baseline= 'with open(file.txt):\n    pass'
              body:-Code= "[line for line in open('file.txt').split()]"
          mined:Baseline= "[line for line in open('file.txt') if line.strip()]"
             mined:+Body= "[line for line in open('file.txt').read()]"
        mined:+Body, -NL= "[line for line in open(file) if 'hi' in line]"
      mined:+Body, -Code= "[line.split() for line in open('file.txt')]"

================================================================================

QUESTION: idx=249    id=1031851
-------------------------------------INPUTS-------------------------------------

tags: dictionary
score: 109
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['a']}
intent: swap keys with values in a dictionary `a`
body(Some added characters for better readability):
	I receive a dictionary as input, and would like to to return a dictionary whose keys will be the input's values and whose value will be the corresponding input keys. Values are unique.
	For example, say my input is:
	
	start_block
	a = dict()
	a['one']=1
	a['two']=2
	I would like my output to be:
	
	start_block
	{1: 'one', 2: 'two'}
	To clarify I would like my result to be the equivalent of the following:
	
	start_block
	res = dict()
	res[1] = 'one'
	res[2] = 'two'
	Any neat Pythonic way to achieve this?


-------------------------------------OUTPUT-------------------------------------

                Expected= 'res = dict((v, k) for k, v in a.items())'
           base:Baseline= '{k: v for k, v in a.items()}'
           base:+Canonic= 'dict((k, v) for k, v in a.items())'
           body:Baseline= 'dict((k, v) for k, v in a.items())'
              body:-Code= 'dict((k, v) for k, v in a.items())'
          mined:Baseline= '[key for key, value in a.items() if value == 1]'
             mined:+Body= '{k: v for k, v in list(a.items())}'
        mined:+Body, -NL= 'dict((k, v) for k, v in a.items() if v == 2)'
      mined:+Body, -Code= 'dict((k, v) for k, v in a.items())'

================================================================================

QUESTION: idx=250    id=8577137
-------------------------------------INPUTS-------------------------------------

tags: 
score: 72
slot_map: {'key': ['str_0'], 'quote': ['`'], 'type': ['str'], 'value': ['path/to/FILE_NAME.ext']}
intent: open a file `path/to/file_name.ext` in write mode
body(Some added characters for better readability):
	I have this function that references the path of a file:
	
	start_block
	some_obj.file_name(FILE_PATH)
	
	<p>where FILE_PATH is a string of the path of a file, i.e. `H:/path/FILE_NAME.ext`
	I want to create a file FILE_NAME.ext inside my python script with the content of a string:
	
	start_block
	some_string = 'this is some content'
	How to go about this? The Python script will be placed inside a Linux box.


-------------------------------------OUTPUT-------------------------------------

                Expected= "new_file = open('path/to/FILE_NAME.ext', 'w')"
           base:Baseline= 'write(path / to / file_name.ext)'
           base:+Canonic= "open('path/to/FILE_NAME.ext', 'write')"
           body:Baseline= "os.path.write('/path/to/file_name.ext')"
              body:-Code= "os.path.open('path/to/file_name.ext')"
          mined:Baseline= "f = open('path/to/file_name.ext')"
             mined:+Body= 'some_obj.file_name(FILE_PATH)'
        mined:+Body, -NL= "open('path/to/file_name.ext', some_string)"
      mined:+Body, -Code= "f.write('path/to/file_name.ext')"

================================================================================

QUESTION: idx=251    id=17926273
-------------------------------------INPUTS-------------------------------------

tags: group-by, pandas
score: 23
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: how to count distinct values in a column of a pandas group by object?
body(Some added characters for better readability):
	
	<p>I have a pandas data frame and group it by two columns (for example 
	`col1`
	 and 
	`col2`
	). For fixed values of 
	`col1`
	 and 
	`col2`
	 (i.e. for a group) I can have several different values in the 
	`col3`. I would like to count the number of distinct values from the third columns.
	For example, If I have this as my input:
	
	start_block
	1  1  1
	1  1  1
	1  1  2
	1  2  3
	1  2  3
	1  2  3
	2  1  1
	2  1  2
	2  1  3
	2  2  3
	2  2  3
	2  2  3
	I would like to have this table (data frame) as the output:
	
	start_block
	1  1  2
	1  2  1
	2  1  3
	2  2  1


-------------------------------------OUTPUT-------------------------------------

                Expected= "df.groupby(['col1', 'col2'])['col3'].nunique().reset_index()"
           base:Baseline= 'df.groupby(lambda x: x[1])'
           base:+Canonic= 'df.groupby(lambda x: x[1])'
           body:Baseline= 'df = pd.groupby(df, axis=1).sum()'
              body:-Code= 'df.groupby(lambda x: x[1])'
          mined:Baseline= "df.groupby(['A', 'B'])['C'].size().reset_index()"
             mined:+Body= "df.groupby(['col1', 'col2'], axis=1).sum()"
        mined:+Body, -NL= "df.groupby(['col1', 'col2'], ascending=[True, False], inplace=True)"
      mined:+Body, -Code= "df.groupby(['a', 'b'])['c'].sum()"

================================================================================

QUESTION: idx=252    id=3735814
-------------------------------------INPUTS-------------------------------------

tags: dictionary
score: 7
slot_map: {'key': ['var_0', 'str_0'], 'quote': ['`', '`'], 'type': ['var', 'str'], 'value': ['dict1', 'EMP$$']}
intent: check if any key in the dictionary `dict1` starts with the string `emp$$`
body(Some added characters for better readability):
	
	start_block
	    dict1=({"EMP$$1":1,"EMP$$2":2,"EMP$$3":3})
	How to check if EMP exists in the dictionary using python
	
	start_block
	   dict1.get("EMP##") ??


-------------------------------------OUTPUT-------------------------------------

                Expected= "any(key.startswith('EMP$$') for key in dict1)"
           base:Baseline= "any(x in dict1 if x.startswith('emp$$')"
           base:+Canonic= "any(x in var_0.items() for x in'str_0'))"
           body:Baseline= "any(dict1.isdigit() == 'emp$$')"
              body:-Code= "any(dict1.isdigit() == 'emp$$')"
          mined:Baseline= 'any(item in dict1 for item in list(dict1.items()))'
             mined:+Body= "any(x.startswith('emp$$') for x in dict1)"
        mined:+Body, -NL= "any(d.startswith('emp$$') for d in dict1)"
      mined:+Body, -Code= 'any(key in dict1 for key in list(emp$$.keys()))'

================================================================================

QUESTION: idx=253    id=3735814
-------------------------------------INPUTS-------------------------------------

tags: dictionary
score: 7
slot_map: {'key': ['var_0', 'str_0'], 'quote': ['`', "'"], 'type': ['var', 'str'], 'value': ['dict1', 'EMP$$']}
intent: create list of values from dictionary `dict1` that have a key that starts with 'emp$$'
body(Some added characters for better readability):
	
	start_block
	    dict1=({"EMP$$1":1,"EMP$$2":2,"EMP$$3":3})
	How to check if EMP exists in the dictionary using python
	
	start_block
	   dict1.get("EMP##") ??


-------------------------------------OUTPUT-------------------------------------

                Expected= "[value for key, value in list(dict1.items()) if key.startswith('EMP$$')]"
           base:Baseline= "[x for x in dict1 if 'emp$$' in x]"
           base:+Canonic= "[k for k, v in list(dict1.items()) if 'EMP$$' in k]"
           body:Baseline= 'dict1 = dict1.items()'
              body:-Code= "list(dict1.items() if 'emp$$' in key)"
          mined:Baseline= "[key for key, value in list(dict1.items()) if 'emp$$')]"
             mined:+Body= "{k: v for k, v in list(dict1.items()) if 'emp$$' in k}"
        mined:+Body, -NL= "{k: v for k, v in dict1.items() if 'emp$$' in k}"
      mined:+Body, -Code= "[key for key, value in list(dict1.items()) if 'emp$$' in key]"

================================================================================

QUESTION: idx=254    id=26097916
-------------------------------------INPUTS-------------------------------------

tags: pandas, dataframe, series
score: 97
slot_map: {'key': ['var_0', 'var_1', 'var_2', 'var_3'], 'quote': ['`', '`', '`', '`'], 'type': ['var', 'var', 'var', 'var'], 'value': ['sf', 'df', 'email', 'list']}
intent: convert a pandas series `sf` into a pandas dataframe `df` with columns `email` and `list`
body(Some added characters for better readability):
	I have a Pandas series sf:
	
	start_block
	email
	email1@email.com    [1.0, 0.0, 0.0]
	email2@email.com    [2.0, 0.0, 0.0]
	email3@email.com    [1.0, 0.0, 0.0]
	email4@email.com    [4.0, 0.0, 0.0]
	email5@email.com    [1.0, 0.0, 3.0]
	email6@email.com    [1.0, 5.0, 0.0]
	And I would like to transform it to the following DataFrame:
	
	start_block
	index | email             | list
	_____________________________________________
	0     | email1@email.com  | [1.0, 0.0, 0.0]
	1     | email2@email.com  | [2.0, 0.0, 0.0]
	2     | email3@email.com  | [1.0, 0.0, 0.0]
	3     | email4@email.com  | [4.0, 0.0, 0.0]
	4     | email5@email.com  | [1.0, 0.0, 3.0]
	5     | email6@email.com  | [1.0, 5.0, 0.0]
	I found a way to do it, but I doubt it's the more efficient one:
	
	start_block
	df1 = pd.DataFrame(data=sf.index, columns=['email'])
	df2 = pd.DataFrame(data=sf.values, columns=['list'])
	df = pd.merge(df1, df2, left_index=True, right_index=True)


-------------------------------------OUTPUT-------------------------------------

                Expected= "pd.DataFrame({'email': sf.index, 'list': sf.values})"
           base:Baseline= "df.to_df(['email', 'list'])"
           base:+Canonic= 'df.concat([email, list])'
           body:Baseline= "pd.merge(df, columns=['email', 'list'])"
              body:-Code= "df.concat([df.columns, 'email', 'list'])"
          mined:Baseline= "df.set_index(['email', 'list'])"
             mined:+Body= "df.pivot_table(index='email', columns=['list'])"
        mined:+Body, -NL= "pd.merge(df1, df2, left_index=True, right_index='list', how='inner')"
      mined:+Body, -Code= "df.set_index(['email', 'list'])"

================================================================================

QUESTION: idx=255    id=4048964
-------------------------------------INPUTS-------------------------------------

tags: printing
score: 31
slot_map: {'key': ['var_0', 'str_0'], 'quote': ['`', '`'], 'type': ['var', 'str'], 'value': ['list', '\t']}
intent: print elements of list `list` seperated by tabs `\t`
body(Some added characters for better readability):
	Here's my current code:
	
	start_block
	print(list[0], list[1], list[2], list[3], list[4], sep = '\t')
	I'd like to write it better. But
	
	start_block
	print('\t'.join(list))
	
	<p>won't work because list elements may numbers, other lists, etc., so 
	`join` would complain.


-------------------------------------OUTPUT-------------------------------------

                Expected= "print('\\t'.join(map(str, list)))"
           base:Baseline= "print(list.split('\\t')))"
           base:+Canonic= "print(' '.join(set(list, '\\t')))"
           body:Baseline= "print('\\t'.join(list))"
              body:-Code= "print('\\t'.join(list))"
          mined:Baseline= "print('\\t\\t'.join(list))"
             mined:+Body= "print('\\t'.join(list))"
        mined:+Body, -NL= 'print(list(itertools.chain.from_iterable(list)))'
      mined:+Body, -Code= "print(list.replace('\\t', ''))"

================================================================================

QUESTION: idx=256    id=3182716
-------------------------------------INPUTS-------------------------------------

tags: unicode
score: 7
slot_map: {'key': ['str_0'], 'quote': ["'"], 'type': ['str'], 'value': ['\x80']}
intent: print unicode string '\xd0\xbf\xd1\x80\xd0\xb8' with utf-8
body(Some added characters for better readability):
	I'm getting back from a library what looks to be an incorrect unicode string:
	
	
	start_block
	>>>title
	...u'Sopet\xc3\xb3n'
	Now, those two hex escapes there are the UTF-8 encoding for U+00F3 LATIN SMALL LETTER O WITH ACUTE.  So far as I understand, a unicode string in Python should have the actual character, not the the UTF-8 encoding for the character, so I think this is incorrect and presumably a bug either in the library or in my input, right?
	The question is, how do I (a) recognize that I have UTF-8 encoded text in my unicode string, and (b) convert this to a proper unicode string?
	
	<p>I'm stumped on (a), as there's nothing wrong, encoding-wise, about that original string (i.e, both are valid characters in their own right, 
	`u'\xc3\xb3'` == A3, but they're not what's supposed to be there)
	It looks like I can achieve (b) by eval()ing that repr() output minus the "u" in front to get a str and then decoding the str with UTF-8:
	
	
	start_block
	>>>eval(repr(title)[1:]).decode("utf-8")
	...u'Sopet\xf3n'
	>>>print eval(repr(title)[1:]).decode("utf-8")
	...Sopeton
	But that seems a bit kludgy.  Is there an officially-sanctioned way to get the raw data out of a unicode string and treat that as a regular string?


-------------------------------------OUTPUT-------------------------------------

                Expected= "print('\\x80'.encode('raw_unicode_escape'))"
           base:Baseline= "print('\\xd0\\xbf\\xd1\\x80\\xd 0\\xb8'.encode('utf8')"
           base:+Canonic= "print('\\x80', 'utf8')"
           body:Baseline= "print(repr(title)[1:]).decode('utf-8')"
              body:-Code= "print('\\xd0\\xbf\\xd1\\x80\\xd00\\xb8'.encode('utf-8')"
          mined:Baseline= "print('\\xd0\\xbf\\xd1\\x80\\xd2\\xb8'.encode('utf8')"
             mined:+Body= "print(repr(title)[1:]).decode('utf-8')"
        mined:+Body, -NL= 'print(repr(title)[1:])'
      mined:+Body, -Code= "print(s.decode('utf-8'))"

================================================================================

QUESTION: idx=257    id=3182716
-------------------------------------INPUTS-------------------------------------

tags: unicode
score: 7
slot_map: {'key': ['str_0'], 'quote': ['`'], 'type': ['str'], 'value': ['Sopetn']}
intent: encode a latin character in string `sopet\xc3\xb3n` properly
body(Some added characters for better readability):
	I'm getting back from a library what looks to be an incorrect unicode string:
	
	
	start_block
	>>>title
	...u'Sopet\xc3\xb3n'
	Now, those two hex escapes there are the UTF-8 encoding for U+00F3 LATIN SMALL LETTER O WITH ACUTE.  So far as I understand, a unicode string in Python should have the actual character, not the the UTF-8 encoding for the character, so I think this is incorrect and presumably a bug either in the library or in my input, right?
	The question is, how do I (a) recognize that I have UTF-8 encoded text in my unicode string, and (b) convert this to a proper unicode string?
	
	<p>I'm stumped on (a), as there's nothing wrong, encoding-wise, about that original string (i.e, both are valid characters in their own right, 
	`u'\xc3\xb3'` == A3, but they're not what's supposed to be there)
	It looks like I can achieve (b) by eval()ing that repr() output minus the "u" in front to get a str and then decoding the str with UTF-8:
	
	
	start_block
	>>>eval(repr(title)[1:]).decode("utf-8")
	...u'Sopet\xf3n'
	>>>print eval(repr(title)[1:]).decode("utf-8")
	...Sopeton
	But that seems a bit kludgy.  Is there an officially-sanctioned way to get the raw data out of a unicode string and treat that as a regular string?


-------------------------------------OUTPUT-------------------------------------

                Expected= '"""Sopetn""".encode(\'latin-1\').decode(\'utf-8\')'
           base:Baseline= '"""{0:.2f}""".format(sopet\\xc3\\xb3n))'
           base:+Canonic= '"""Sopetn""".encode(\'utf-8\')'
           body:Baseline= "print(repr(title)[1:]).decode('utf-8')"
              body:-Code= "sopet\\xc3\\xb3n.encode('utf-8')"
          mined:Baseline= "print(sopet\\xc3\\xb3n).encode('utf-8')"
             mined:+Body= "eval(repr(title)[1:]).decode('utf-8')"
        mined:+Body, -NL= '"""Sopet\\\\xc3n""".encode(\'utf8\')'
      mined:+Body, -Code= '"""Sopetn""".encode(\'utf-8\')'

================================================================================

QUESTION: idx=258    id=1405602
-------------------------------------INPUTS-------------------------------------

tags: 
score: 58
slot_map: {'key': ['var_0', 'str_0', 'var_1', '(str_0)'], 'quote': ['`', '`', '`', '`'], 'type': ['var', 'str', 'var', 'str'], 'value': ['image', '(x, y)', 'ANTIALIAS', '(x, y)']}
intent: resized image `image` to width, height of `(x, y)` with filter of `antialias`
body(Some added characters for better readability):
	I am working on PIL and need to know if the image quality can be adjusted while resizing or thumbnailing an image. From what I have known is the default quality is set to 85. Can this parameter be tweaked during resizing?
	I am currently using the following code:
	
	start_block
	image = Image.open(filename)
	image.thumbnail((x, y), img.ANTIALIAS)
	
	<p>The 
	`ANTIALIAS` parameter presumably gives the best quality. I need to know if we can get more granularity on the quality option.


-------------------------------------OUTPUT-------------------------------------

                Expected= 'image = image.resize((x, y), Image.ANTIALIAS)'
           base:Baseline= 'image.resize(x, y)'
           base:+Canonic= "image.resize('(x, y)', ANTIALIAS=True)"
           body:Baseline= 'image.reshape(frame.frame.image.thumbnail((x, y), img.ANTIALIAS)'
              body:-Code= 'image.resize(x, y)'
          mined:Baseline= "imagedata.resize(image, interpolation='nearest')"
             mined:+Body= 'image.resize(image.thumbnail((x, y), img.ANTIALIAS)'
        mined:+Body, -NL= 'image.resize(x, y)'
      mined:+Body, -Code= 'imagedata.resize(image, (x, y))'

================================================================================

QUESTION: idx=259    id=35622945
-------------------------------------INPUTS-------------------------------------

tags: regex
score: 5
slot_map: {'key': ['str_0', 'var_0'], 'quote': ['"', '`'], 'type': ['str', 'var'], 'value': ['n', 's']}
intent: regex, find "n"s only in the middle of string `s`
body(Some added characters for better readability):
	
	<p>I am using python 2.6 and trying to find a bunch of repeating characters in a string, let's say a bunch of 
	`n`
	's, e.g. 
	`nnnnnnnABCnnnnnnnnnDEF`
	. In any place of the string the number of 
	`n`'s can be variable.
	If I construct a regex like this:
	
	`re.findall(r'^(((?i)n)\2{2,})', s)`,
	
	<p>I can find occurences of case-insensitive 
	`n`'s only in the beginning of the string, which is fine. If I do it like this: 
	
	`re.findall(r'(((?i)n)\2{2,}$)', s)`,
	I can detect the ones only in the end of the sequence. But what about just in the middle?
	
	<p>At first, I thought of using 
	`re.findall(r'(((?i)n)\2{2,})', s)`
	 and the two previous regex(-ices?) to check the length of the returned list and the presence of 
	`n`'s either in the beginning or end of the string and make logical tests, but it became an ugly if-else mess very quickly.
	
	<p>Then, I tried 
	`re.findall(r'(?!^)(((?i)n)\2{2,})', s)`
	, which seems to exlude the beginning just fine but 
	`(?!$)`
	 or 
	`(?!\z)`
	 at the end of the regex only excludes the last 
	`n`
	 in 
	`ABCnnnn`
	. Finally, I tried 
	`re.findall(r'(?!^)(((?i)n)\2{2,})\w+', s)` which seems to work sometimes, but I get weird results at others. It feels like I need a lookahead or lookbehind, but I can't wrap my head around them.


-------------------------------------OUTPUT-------------------------------------

                Expected= "re.findall('n(?<=[^n]n)n+(?=[^n])(?i)', s)"
           base:Baseline= "re.findall('\\\\n+', s)"
           base:+Canonic= "re.findall('n', s)"
           body:Baseline= "re.findall('((?i)n)\\x02{2,})\\\\w+', s)"
              body:-Code= "re.findall('\\\\n', s)"
          mined:Baseline= "re.findall('\\\\n', s)"
             mined:+Body= "re.findall('(?!^)(((?i)n)\\\\2{2,}$)', s)"
        mined:+Body, -NL= "re.findall('(?!^)(((?i)n)\\\\2{2,}$)', s)"
      mined:+Body, -Code= "re.findall('\\\\b', s)"

================================================================================

QUESTION: idx=260    id=5306756
-------------------------------------INPUTS-------------------------------------

tags: 
score: 204
slot_map: {'key': ['str_0'], 'quote': ['`'], 'type': ['str'], 'value': ['1/3*100']}
intent: display the float `1/3*100` as a percentage
body(Some added characters for better readability):
	this is my code:
	
	start_block
	print str(float(1/3))+'%'
	and it shows:
	
	start_block
	0.0%
	
	<p>but I want to get `33%`
	What can I do?


-------------------------------------OUTPUT-------------------------------------

                Expected= "print('{0:.0f}%'.format(1.0 / 3 * 100))"
           base:Baseline= 'print(float(1 / 3 * 100))'
           base:+Canonic= "print(float('str_0', %s)"
           body:Baseline= 'print(str(float(1/3*100))'
              body:-Code= 'float(1/3*100))'
          mined:Baseline= '"""{:.3f}""".format(1 / 3 * 100)'
             mined:+Body= 'print(float(1 / 3 * 100))'
        mined:+Body, -NL= 'print(float(1 / 3 * 100))'
      mined:+Body, -Code= '"""{:.3f}""".format(1 / 3 * 100)'

================================================================================

QUESTION: idx=261    id=2878084
-------------------------------------INPUTS-------------------------------------

tags: sorting, dictionary
score: 17
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['mylist', 'title']}
intent: sort a list of dictionary `mylist` by the key `title`
body(Some added characters for better readability):
	I have a list of dictionaries:
	
	start_block
	[{'title':'New York Times', 'title_url':'New_York_Times','id':4},
	 {'title':'USA Today','title_url':'USA_Today','id':6},
	 {'title':'Apple News','title_url':'Apple_News','id':2}]
	I'd like to sort it by the title, so elements with A go before Z:
	
	start_block
	[{'title':'Apple News','title_url':'Apple_News','id':2},
	 {'title':'New York Times', 'title_url':'New_York_Times','id':4},
	 {'title':'USA Today','title_url':'USA_Today','id':6}]
	What's the best way to do this?
	Also, is there a way to ensure the order of each dictionary key stays constant, e.g., always title, title_url, then id?


-------------------------------------OUTPUT-------------------------------------

                Expected= "mylist.sort(key=lambda x: x['title'])"
           base:Baseline= 'sorted(myList, key=lambda x: x[1])'
           base:+Canonic= 'sorted(mylist, key=title)'
           body:Baseline= 'sorted(mylist, key=lambda x: x[1])'
              body:-Code= 'sorted(list(mylist.items()), key=lambda x: x[1])'
          mined:Baseline= 'mylist.sort(key=operator.itemgetter(1))'
             mined:+Body= "sorted(mylist, key=lambda x: x['title'], reverse=True)"
        mined:+Body, -NL= "mylist.sort(key=lambda x: x[1]['title'], reverse=True)"
      mined:+Body, -Code= 'mylist.sort(key=lambda x: x.title, reverse=True)'

================================================================================

QUESTION: idx=262    id=2878084
-------------------------------------INPUTS-------------------------------------

tags: sorting, dictionary
score: 17
slot_map: {'key': ['var_0', 'str_0'], 'quote': ['`', "'"], 'type': ['var', 'str'], 'value': ['l', 'title']}
intent: sort a list `l` of dicts by dict value 'title'
body(Some added characters for better readability):
	I have a list of dictionaries:
	
	start_block
	[{'title':'New York Times', 'title_url':'New_York_Times','id':4},
	 {'title':'USA Today','title_url':'USA_Today','id':6},
	 {'title':'Apple News','title_url':'Apple_News','id':2}]
	I'd like to sort it by the title, so elements with A go before Z:
	
	start_block
	[{'title':'Apple News','title_url':'Apple_News','id':2},
	 {'title':'New York Times', 'title_url':'New_York_Times','id':4},
	 {'title':'USA Today','title_url':'USA_Today','id':6}]
	What's the best way to do this?
	Also, is there a way to ensure the order of each dictionary key stays constant, e.g., always title, title_url, then id?


-------------------------------------OUTPUT-------------------------------------

                Expected= "l.sort(key=lambda x: x['title'])"
           base:Baseline= "sorted(l, key=lambda x: x['title']))"
           base:+Canonic= "sorted(l, key=lambda d: d['title'])"
           body:Baseline= "sorted(l, key=dict.get('title')"
              body:-Code= "sorted(l, key=dict.get('title')"
          mined:Baseline= "sorted(l, key=lambda d: d['title'])"
             mined:+Body= "sorted(l, key=lambda x: x['title'], reverse=True)"
        mined:+Body, -NL= "sorted(l, key=lambda d: d['title'], reverse=True)"
      mined:+Body, -Code= 'sorted(l, key=lambda x: x.title, reverse=True)'

================================================================================

QUESTION: idx=263    id=2878084
-------------------------------------INPUTS-------------------------------------

tags: sorting, dictionary
score: 17
slot_map: {'key': ['str_0', 'str_1', 'str_2'], 'quote': ["'", "'", "'"], 'type': ['str', 'str', 'str'], 'value': ['title', 'title_url', 'id']}
intent: sort a list of dictionaries by the value of keys 'title', 'title_url', 'id' in ascending order.
body(Some added characters for better readability):
	I have a list of dictionaries:
	
	start_block
	[{'title':'New York Times', 'title_url':'New_York_Times','id':4},
	 {'title':'USA Today','title_url':'USA_Today','id':6},
	 {'title':'Apple News','title_url':'Apple_News','id':2}]
	I'd like to sort it by the title, so elements with A go before Z:
	
	start_block
	[{'title':'Apple News','title_url':'Apple_News','id':2},
	 {'title':'New York Times', 'title_url':'New_York_Times','id':4},
	 {'title':'USA Today','title_url':'USA_Today','id':6}]
	What's the best way to do this?
	Also, is there a way to ensure the order of each dictionary key stays constant, e.g., always title, title_url, then id?


-------------------------------------OUTPUT-------------------------------------

                Expected= "l.sort(key=lambda x: (x['title'], x['title_url'], x['id']))"
           base:Baseline= "sorted(list(d.items()), key=lambda x: x['title', 'title_url', 'id'])"
           base:+Canonic= "sorted(list(d.keys()), key=lambda d: (d['str_0','str_1', str_2])"
           body:Baseline= "sorted(list(d.items()), key=lambda x: x['title', 'title_url', 'id'])"
              body:-Code= "sorted(list(d.items()), key=lambda x: x['title', 'title_url', 'id'])"
          mined:Baseline= "sorted(list(d.items()), key=lambda x: x['title', 'title_url', 'id'])"
             mined:+Body= "sorted(d, key=lambda x: x['title'], reverse=True)"
        mined:+Body, -NL= "sorted(dic, key=lambda x: x['title'], reverse=True)"
      mined:+Body, -Code= "sorted(lst, key=lambda d: d['title', 'title_url', 'id'])"

================================================================================

QUESTION: idx=264    id=9323159
-------------------------------------INPUTS-------------------------------------

tags: algorithm, data-structures, ordereddictionary
score: 5
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['l1', 'l2']}
intent: find 10 largest differences between each respective elements of list `l1` and list `l2`
body(Some added characters for better readability):
	
	<p>I have two lists 
	`old`
	 and 
	`new`, with the same number of elements.
	
	<p>I'm trying to write an efficient function that takes 
	`n`
	 as a parameter, compares the elements of two lists at the same locations (by index), finds 
	`n`
	 largest differences, and returns the indices of those 
	`n` elements.
	
	<p>I was thinking this would be best solved by a value-sorted dictionary, but one 
	isn't available  in Python (and I'm not aware of any libraries that offer it). Perhaps there's a better solution? 


-------------------------------------OUTPUT-------------------------------------

                Expected= 'heapq.nlargest(10, range(len(l1)), key=lambda i: abs(l1[i] - l2[i]))'
           base:Baseline= '[(i, j) for i, j in zip(l1, l2)]'
           base:+Canonic= 'sum(len(l1, l2))'
           body:Baseline= 'sum(len(l1, l2))'
              body:-Code= '[i for i, j in zip(l1, l2)]'
          mined:Baseline= '[(x / y) for x, y in zip(l1, l2)]'
             mined:+Body= '[i for i, j in zip(l1, l2)]'
        mined:+Body, -NL= 'max(l1, l2)'
      mined:+Body, -Code= '[(x / y) for x, y in zip(l1, l2)]'

================================================================================

QUESTION: idx=265    id=29877663
-------------------------------------INPUTS-------------------------------------

tags: beautifulsoup
score: 9
slot_map: {'key': ['str_0', 'var_0', 'str_1'], 'quote': ["'", '`', "'"], 'type': ['str', 'var', 'str'], 'value': ['span', 'soup', 'starGryB sp']}
intent: beautifulsoup find all 'span' elements in html string `soup` with class of 'stargryb sp'
body(Some added characters for better readability):
	There are two values that i am looking to scrape from a website. These are present in the following tags:
	
	start_block
	<span class="sp starBig">4.1 </span>
	<span class="sp starGryB">2.9 </span>
	I need the values sp starBig, sp starGryB.
	The findAll expression that i am using is - 
	
	start_block
	soup.findAll('span', {'class': ['sp starGryB', 'sp starBig']}):
	The code gets executed without any errors yet no results get displayed.


-------------------------------------OUTPUT-------------------------------------

                Expected= "soup.find_all('span', {'class': 'starGryB sp'})"
           base:Baseline= "soup.findAll('span', class='stargryb sp')"
           base:+Canonic= "var_0.findAll('str_0', class='str_1')"
           body:Baseline= "soup.findAll('span', {'class': ['sp starGryB','sp starBig'})"
              body:-Code= "soup.findAll('span')"
          mined:Baseline= "soup.findAll('span', class='stargryb sp')"
             mined:+Body= "soup.findAll('span', {'class': ['sp starGryB','sp starBig']}"
        mined:+Body, -NL= "soup.find_all('span', {'class': ['sp starGryB', 'sp starBig']})"
      mined:+Body, -Code= "soup.findAll('span', class='stargryb sp')"

================================================================================

QUESTION: idx=266    id=24189150
-------------------------------------INPUTS-------------------------------------

tags: sql, postgresql, pandas, sqlalchemy
score: 17
slot_map: {'key': ['var_0', 'str_0', 'str_1'], 'quote': ['`', "'", "'"], 'type': ['var', 'str', 'str'], 'value': ['df', 'test', 'a_schema']}
intent: write records in dataframe `df` to table 'test' in schema 'a_schema'
body(Some added characters for better readability):
	I am trying to write a pandas DataFrame to a PostgreSQL database,
	using a schema-qualified table.
	I use the following code:
	
	start_block
	import pandas.io.sql as psql
	from sqlalchemy import create_engine
	engine = create_engine(r'postgresql://some:user@host/db')
	c = engine.connect()
	conn = c.connection
	df = psql.read_sql("SELECT * FROM xxx", con=conn)    
	df.to_sql('a_schema.test', engine)
	conn.close()
	What happens is that pandas writes in schema "public", in a table named 'a_schema.test',
	instead of writing in the "test" table in the "a_schema" schema.
	How can I instruct pandas to use a schema different than public?
	Thanks


-------------------------------------OUTPUT-------------------------------------

                Expected= "df.to_sql('test', engine, schema='a_schema')"
           base:Baseline= "df.to_table('test')"
           base:+Canonic= "df.to_csv('a_schema', 'test')"
           body:Baseline= "df.to_sql('a_schema.test')"
              body:-Code= "df.set_index('test')"
          mined:Baseline= "df.to_sql('test', inplace=True)"
             mined:+Body= "df.to_sql('a_schema.test', engine)"
        mined:+Body, -NL= "df.to_sql('a_schema.test', engine)"
      mined:+Body, -Code= "df.set_index('test')"

================================================================================

QUESTION: idx=267    id=30766151
-------------------------------------INPUTS-------------------------------------

tags: regex
score: 5
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['s']}
intent: extract brackets from string `s`
body(Some added characters for better readability):
	I have a string which has multiple brackets. Let says
	
	start_block
	s="(a(vdwvndw){}]"
	I want to extract all the brackets as a separate string. 
	I tried this: 
	
	
	start_block
	>>>brackets=re.search(r"[(){}[]]+",s)
	>>>brackets.group()
	...
	But it is only giving me last two brackets. 
	
	start_block
	'}]'
	Why is that? Shouldn't it fetch one or more of any of the brackets in the character set?


-------------------------------------OUTPUT-------------------------------------

                Expected= "brackets = re.sub('[^(){}[\\\\]]', '', s)"
           base:Baseline= "re.sub('([^a-z])', s)"
           base:+Canonic= "re.sub('\\\\w+', s)"
           body:Baseline= "s = re.search('(\\\\wvndw){}]', s)"
              body:-Code= "re.findall('\\\\d+', s)"
          mined:Baseline= "re.findall('\\\\b\\\\d+\\\\b', s)"
             mined:+Body= "re.findall('\\\\s+', s)"
        mined:+Body, -NL= "re.search('(a(vdwvndw){}', s)"
      mined:+Body, -Code= "re.findall('\\\\[(.*?)\\\\]', s)"

================================================================================

QUESTION: idx=268    id=1143379
-------------------------------------INPUTS-------------------------------------

tags: list
score: 13
slot_map: {'key': ['str_0'], 'quote': ["'"], 'type': ['str'], 'value': ['L']}
intent: remove duplicate elements from list 'l'
body(Some added characters for better readability):
	Can anyone suggest a good solution to remove duplicates from nested lists if wanting to evaluate duplicates based on first element of each nested list?
	The main list looks like this:
	
	start_block
	L = [['14', '65', 76], ['2', '5', 6], ['7', '12', 33], ['14', '22', 46]]
	
	<p>If there is another list with the same element at first position 
	`[k][0]` that had already occurred, then I'd like to remove that list and get this result:
	
	start_block
	L = [['14', '65', 76], ['2', '5', 6], ['7', '12', 33]]
	Can you suggest an algorithm to achieve this goal?


-------------------------------------OUTPUT-------------------------------------

                Expected= 'list(dict((x[0], x) for x in L).values())'
           base:Baseline= "[x for x in l if x != 'l']"
           base:+Canonic= 'list(itertools.chain.from_iterable(L))'
           body:Baseline= 'l = [x[0] for x in L]'
              body:-Code= '[k for k, v in l if v[0] == 1]'
          mined:Baseline= '[item for item in l if item[1] == 1]'
             mined:+Body= '[x for x in L if x[0]]'
        mined:+Body, -NL= '[x for x in L if x not in l]'
      mined:+Body, -Code= 'l = list(set(l))'

================================================================================

QUESTION: idx=269    id=12330522
-------------------------------------INPUTS-------------------------------------

tags: line-breaks, readlines
score: 448
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['file']}
intent: read a file `file` without newlines
body(Some added characters for better readability):
	In Python, calling
	
	start_block
	temp = open(filename,'r').readlines()
	
	<p>results in a list in which each element is a line in the file. It's a little stupid but still: 
	`readlines()` also writes newline character to each element, something I do not wish to happen. 
	How can I avoid it? 


-------------------------------------OUTPUT-------------------------------------

                Expected= "[line.rstrip('\\n') for line in file]"
           base:Baseline= 'for line in open(file):\n    pass'
           base:+Canonic= "with open('file', 'rb') as f:\n    pass"
           body:Baseline= "Temp = open(filename, 'r').readlines()"
              body:-Code= 'print(os.path.isfile(file))'
          mined:Baseline= "file = open('file', 'w').read()"
             mined:+Body= "temp = open(filename, 'r').readlines()"
        mined:+Body, -NL= "temp = open(filename, 'r').readlines()"
      mined:+Body, -Code= 'for line in open(file):\n    pass'

================================================================================

QUESTION: idx=270    id=364621
-------------------------------------INPUTS-------------------------------------

tags: list
score: 177
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['testlist']}
intent: get the position of item 1 in `testlist`
body(Some added characters for better readability):
	I am iterating over a list and I want to print out the index of the item if it meets a certain condition. How would I do this?
	Example:  
	
	start_block
	testlist = [1,2,3,5,3,1,2,1,6]
	for item in testlist:
	    if item == 1:
	        print position


-------------------------------------OUTPUT-------------------------------------

                Expected= '[i for i, x in enumerate(testlist) if x == 1]'
           base:Baseline= 'testlist.pop(1)[1:]'
           base:+Canonic= 'testlist.position(1)'
           body:Baseline= 'print(len(1) for item in testlist)'
              body:-Code= 'print(item[1] for item in testlist)'
          mined:Baseline= 'len(testlist) - 1 + 1'
             mined:+Body= 'next((1) if item == 1)'
        mined:+Body, -NL= 'len(testlist) - 1 - testlist[1]'
      mined:+Body, -Code= 'len(testlist) == 1 - 1'

================================================================================

QUESTION: idx=271    id=364621
-------------------------------------INPUTS-------------------------------------

tags: list
score: 177
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['testlist']}
intent: get the position of item 1 in `testlist`
body(Some added characters for better readability):
	I am iterating over a list and I want to print out the index of the item if it meets a certain condition. How would I do this?
	Example:  
	
	start_block
	testlist = [1,2,3,5,3,1,2,1,6]
	for item in testlist:
	    if item == 1:
	        print position


-------------------------------------OUTPUT-------------------------------------

                Expected= '[i for i, x in enumerate(testlist) if x == 1]'
           base:Baseline= 'testlist.pop(1)[1:]'
           base:+Canonic= 'testlist.position(1)'
           body:Baseline= 'print(len(1) for item in testlist)'
              body:-Code= 'print(item[1] for item in testlist)'
          mined:Baseline= 'len(testlist) - 1 + 1'
             mined:+Body= 'next((1) if item == 1)'
        mined:+Body, -NL= 'len(testlist) - 1 - testlist[1]'
      mined:+Body, -Code= 'len(testlist) == 1 - 1'

================================================================================

QUESTION: idx=272    id=364621
-------------------------------------INPUTS-------------------------------------

tags: list
score: 177
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['testlist']}
intent: get the position of item 1 in `testlist`
body(Some added characters for better readability):
	I am iterating over a list and I want to print out the index of the item if it meets a certain condition. How would I do this?
	Example:  
	
	start_block
	testlist = [1,2,3,5,3,1,2,1,6]
	for item in testlist:
	    if item == 1:
	        print position


-------------------------------------OUTPUT-------------------------------------

                Expected= 'for i in [i for i, x in enumerate(testlist) if x == 1]:\n    pass'
           base:Baseline= 'testlist.pop(1)[1:]'
           base:+Canonic= 'testlist.position(1)'
           body:Baseline= 'print(len(1) for item in testlist)'
              body:-Code= 'print(item[1] for item in testlist)'
          mined:Baseline= 'len(testlist) - 1 + 1'
             mined:+Body= 'next((1) if item == 1)'
        mined:+Body, -NL= 'len(testlist) - 1 - testlist[1]'
      mined:+Body, -Code= 'len(testlist) == 1 - 1'

================================================================================

QUESTION: idx=273    id=364621
-------------------------------------INPUTS-------------------------------------

tags: list
score: 177
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['testlist']}
intent: get the position of item 1 in `testlist`
body(Some added characters for better readability):
	I am iterating over a list and I want to print out the index of the item if it meets a certain condition. How would I do this?
	Example:  
	
	start_block
	testlist = [1,2,3,5,3,1,2,1,6]
	for item in testlist:
	    if item == 1:
	        print position


-------------------------------------OUTPUT-------------------------------------

                Expected= 'for i in (i for i, x in enumerate(testlist) if x == 1):\n    pass'
           base:Baseline= 'testlist.pop(1)[1:]'
           base:+Canonic= 'testlist.position(1)'
           body:Baseline= 'print(len(1) for item in testlist)'
              body:-Code= 'print(item[1] for item in testlist)'
          mined:Baseline= 'len(testlist) - 1 + 1'
             mined:+Body= 'next((1) if item == 1)'
        mined:+Body, -NL= 'len(testlist) - 1 - testlist[1]'
      mined:+Body, -Code= 'len(testlist) == 1 - 1'

================================================================================

QUESTION: idx=274    id=364621
-------------------------------------INPUTS-------------------------------------

tags: list
score: 177
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['testlist']}
intent: get the position of item 1 in `testlist`
body(Some added characters for better readability):
	I am iterating over a list and I want to print out the index of the item if it meets a certain condition. How would I do this?
	Example:  
	
	start_block
	testlist = [1,2,3,5,3,1,2,1,6]
	for item in testlist:
	    if item == 1:
	        print position


-------------------------------------OUTPUT-------------------------------------

                Expected= 'gen = (i for i, x in enumerate(testlist) if x == 1)\nfor i in gen:\n    pass'
           base:Baseline= 'testlist.pop(1)[1:]'
           base:+Canonic= 'testlist.position(1)'
           body:Baseline= 'print(len(1) for item in testlist)'
              body:-Code= 'print(item[1] for item in testlist)'
          mined:Baseline= 'len(testlist) - 1 + 1'
             mined:+Body= 'next((1) if item == 1)'
        mined:+Body, -NL= 'len(testlist) - 1 - testlist[1]'
      mined:+Body, -Code= 'len(testlist) == 1 - 1'

================================================================================

QUESTION: idx=275    id=364621
-------------------------------------INPUTS-------------------------------------

tags: list
score: 177
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['element', 'testlist']}
intent: get the position of item `element` in list `testlist`
body(Some added characters for better readability):
	I am iterating over a list and I want to print out the index of the item if it meets a certain condition. How would I do this?
	Example:  
	
	start_block
	testlist = [1,2,3,5,3,1,2,1,6]
	for item in testlist:
	    if item == 1:
	        print position


-------------------------------------OUTPUT-------------------------------------

                Expected= 'print(testlist.index(element))'
           base:Baseline= 'testlist.pop(element).Position(element)'
           base:+Canonic= 'len(element, testlist)'
           body:Baseline= 'print(element[0] for item in testlist)'
              body:-Code= 'print(element in testlist, position=element)'
          mined:Baseline= '[len(element) for element in testlist]'
             mined:+Body= 'next((i, j) for i, j in testlist)'
        mined:+Body, -NL= '[item for item in testlist if item == 1]'
      mined:+Body, -Code= 'element.index(len(testlist))'

================================================================================

QUESTION: idx=276    id=364621
-------------------------------------INPUTS-------------------------------------

tags: list
score: 177
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['element', 'testlist']}
intent: get the position of item `element` in list `testlist`
body(Some added characters for better readability):
	I am iterating over a list and I want to print out the index of the item if it meets a certain condition. How would I do this?
	Example:  
	
	start_block
	testlist = [1,2,3,5,3,1,2,1,6]
	for item in testlist:
	    if item == 1:
	        print position


-------------------------------------OUTPUT-------------------------------------

                Expected= 'try:\n    print(testlist.index(element))\nexcept ValueError:\n    pass'
           base:Baseline= 'testlist.pop(element).Position(element)'
           base:+Canonic= 'len(element, testlist)'
           body:Baseline= 'print(element[0] for item in testlist)'
              body:-Code= 'print(element in testlist, position=element)'
          mined:Baseline= '[len(element) for element in testlist]'
             mined:+Body= 'next((i, j) for i, j in testlist)'
        mined:+Body, -NL= '[item for item in testlist if item == 1]'
      mined:+Body, -Code= 'element.index(len(testlist))'

================================================================================

QUESTION: idx=277    id=13145368
-------------------------------------INPUTS-------------------------------------

tags: list, tuples
score: 95
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['lis']}
intent: find the first element of the tuple with the maximum second element in a list of tuples `lis`
body(Some added characters for better readability):
	Possible Duplicate:
	Sorting or Finding Max Value by the second element in a nested list. Python
	I have a list with ~10^6 tuples in it like this:
	
	start_block
	[(101, 153), (255, 827), (361, 961), <console_out>]
	  ^     ^
	  X     Y
	I want to find the maximum value of the Ys in this list, but also want to know the X that it is bound to.
	How do I do this?


-------------------------------------OUTPUT-------------------------------------

                Expected= 'max(lis, key=lambda item: item[1])[0]'
           base:Baseline= '[x[1] for x inlis]'
           base:+Canonic= 'max(lis, key=lambda x: x[1])'
           body:Baseline= '[x[1] for x inlis]'
              body:-Code= 'max(zip(lis, key=lambda x: x[1])'
          mined:Baseline= 'max(lis, key=lambda x: x[1])'
             mined:+Body= 'max(lis, key=lambda x: x[1])'
        mined:+Body, -NL= '[x[0] for x in lst]'
      mined:+Body, -Code= 'max(lis, key=lambda x: x[1])'

================================================================================

QUESTION: idx=278    id=13145368
-------------------------------------INPUTS-------------------------------------

tags: list, tuples
score: 95
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['lis']}
intent: get the item at index 0 from the tuple that has maximum value at index 1 in list `lis`
body(Some added characters for better readability):
	Possible Duplicate:
	Sorting or Finding Max Value by the second element in a nested list. Python
	I have a list with ~10^6 tuples in it like this:
	
	start_block
	[(101, 153), (255, 827), (361, 961), <console_out>]
	  ^     ^
	  X     Y
	I want to find the maximum value of the Ys in this list, but also want to know the X that it is bound to.
	How do I do this?


-------------------------------------OUTPUT-------------------------------------

                Expected= 'max(lis, key=itemgetter(1))[0]'
           base:Baseline= '[max(x) for x inlis]'
           base:+Canonic= 'max(var_0, key=lambda x: len(x[1]) for x in var_0)'
           body:Baseline= '[max(x, y) for x, y inlis]'
              body:-Code= 'max(zip(lis, key=lambda x: x[1])'
          mined:Baseline= 'max(lis, key=lambda x: x[1])'
             mined:+Body= 'max(lis, key=lambda x: x[1])'
        mined:+Body, -NL= 'max(lis, key=lambda x: x[1])'
      mined:+Body, -Code= 'max(lis, key=lambda x: x[1])'

================================================================================

QUESTION: idx=279    id=2689189
-------------------------------------INPUTS-------------------------------------

tags: command-line
score: 5
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: make a delay of 1 second
body(Some added characters for better readability):
	My Python program does a series of things and prints some diagnostic output. I would also like to have a progress counter like this:
	
	start_block
	Percentage done: 25%
	where the number increases "in place". If I use only string statements I can write separate numbers, but that would clutter the screen. Is there some way to achieve this, for example using some escape char for backspace in order to clear a number and write the next one?
	Thanks


-------------------------------------OUTPUT-------------------------------------

                Expected= 'time.sleep(1)'
           base:Baseline= "time.strftime('1 second')"
           base:+Canonic= 'time.sleep(1) + 1'
           body:Baseline= 'sys.exit(1)\n\n    pass'
              body:-Code= 'time.sleep(1)\nexcept Exception:\n    pass'
          mined:Baseline= 'time.sleep(1.1)'
             mined:+Body= 'sys.stdout.flush()[0]'
        mined:+Body, -NL= 'sys.stdout.flush()[0]'
      mined:+Body, -Code= 'time.sleep(0.1)'

================================================================================

QUESTION: idx=280    id=12485244
-------------------------------------INPUTS-------------------------------------

tags: 
score: 4
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['L']}
intent: convert list of tuples `l` to a string
body(Some added characters for better readability):
	I have the following list:
	
	start_block
	[('Steve Buscemi', 'Mr. Pink'), ('Chris Penn', 'Nice Guy Eddie'), <console_out>]
	I need to convert it to a string in the following format:
	
	start_block
	"(Steve Buscemi, Mr. Pink), (Chris Penn, Nice Guy Eddit), <console_out>"
	I tried doing 
	
	start_block
	str = ', '.join(item for item in items)
	but run into the following error:
	
	start_block
	TypeError: sequence item 0: expected string, tuple found
	How would I do the above formatting?


-------------------------------------OUTPUT-------------------------------------

                Expected= '""", """.join(\'(\' + \', \'.join(i) + \')\' for i in L)'
           base:Baseline= '"""""".join(str(x) for x in l))'
           base:+Canonic= '"""""".join(map(L))'
           body:Baseline= "str = ', '.join(item for item in L))"
              body:-Code= '"""""".join(str(x) for x in L)'
          mined:Baseline= '"""""".join(str(l))'
             mined:+Body= "str = ', '.join(item for item in items)"
        mined:+Body, -NL= '"""(Steve Buscemi, Mr. Pink), (Chris Penn, Nice Guy Eddit), """.join(l)'
      mined:+Body, -Code= '"""""".join(map(str, l))'

================================================================================

QUESTION: idx=281    id=755857
-------------------------------------INPUTS-------------------------------------

tags: django, django-models, django-admin
score: 104
slot_map: {'key': ['var_0', 'str_0'], 'quote': ['`', "'"], 'type': ['var', 'str'], 'value': ['b', '0000000']}
intent: django set default value of field `b` equal to '0000000'
body(Some added characters for better readability):
	Suppose I have a model:
	
	start_block
	class SomeModel(models.Model):
	    id = models.AutoField(primary_key=True)
	    a = models.CharField(max_length=10)
	    b = models.CharField(max_length=7)
	Currently I am using the default admin to create/edit objects of this type.
	
	`b`
	 from the admin so that each object 
	cannot 
	 be created with a value, and rather will receive a default value of 
	`0000000`?


-------------------------------------OUTPUT-------------------------------------

                Expected= "b = models.CharField(max_length=7, default='0000000', editable=False)"
           base:Baseline= "Model.objects.setdefault_value(b, '0000000')"
           base:+Canonic= "b = '0000000'"
           body:Baseline= 'someModel.objects.default_value(b)'
              body:-Code= "b = admin.objects.default('0000000')"
          mined:Baseline= 'super(Person, self).save(*args, **kwargs)'
             mined:+Body= "SomeModel.objects.default_value('b')"
        mined:+Body, -NL= 'SomeModel.objects.extra(**kwargs)'
      mined:+Body, -Code= 'super(B, self).save(*args, **kwargs)'

================================================================================

QUESTION: idx=282    id=16193578
-------------------------------------INPUTS-------------------------------------

tags: 
score: 29
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['list5']}
intent: sort lis `list5` in ascending order based on the degrees value of its elements
body(Some added characters for better readability):
	
	<p>If i have a list of numbers 
	`[4,2,5,1,3]`
	
	`f`
	 and then for numbers with the same value of 
	`f` i want it to be sorted by the magnitude of the number.
	This code does not seem to be working.
	
	start_block
	list5 = sorted(list5)
	list5 = sorted(list5, key = lambda vertex: degree(vertex)) 
	Secondary sorting first: list5 is sorted based on magnitude.
	Primary sorting next: list5 is sorted based on some function of the numbers.  


-------------------------------------OUTPUT-------------------------------------

                Expected= 'sorted(list5, lambda x: (degree(x), x))'
           base:Baseline= 'sorted(list5, key=lambda x: x[1])'
           base:+Canonic= 'sorted(list5, key=lambda x: x[1])'
           body:Baseline= 'list5 = sorted(list5, key=lambda x: x[1])'
              body:-Code= 'sorted(list5, key=lambda x: x[1])'
          mined:Baseline= 'list5.sort(key=operator.itemgetter(1))'
             mined:+Body= 'sorted(list5, key=lambda v: (v[1], v[2]))'
        mined:+Body, -NL= 'sorted(list5, key=lambda x: (x[0], x[1]))'
      mined:+Body, -Code= 'sorted(list5, key=lambda x: magnitude(x))'

================================================================================

QUESTION: idx=283    id=16193578
-------------------------------------INPUTS-------------------------------------

tags: 
score: 29
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: how do i perform secondary sorting in python?
body(Some added characters for better readability):
	
	<p>If i have a list of numbers 
	`[4,2,5,1,3]`
	
	`f`
	 and then for numbers with the same value of 
	`f` i want it to be sorted by the magnitude of the number.
	This code does not seem to be working.
	
	start_block
	list5 = sorted(list5)
	list5 = sorted(list5, key = lambda vertex: degree(vertex)) 
	Secondary sorting first: list5 is sorted based on magnitude.
	Primary sorting next: list5 is sorted based on some function of the numbers.  


-------------------------------------OUTPUT-------------------------------------

                Expected= 'sorted(list5, key=lambda vertex: (degree(vertex), vertex))'
           base:Baseline= 'my_list.sort(key=lambda x: x[1])'
           base:+Canonic= 'sorted(key=lambda x: x[1])'
           body:Baseline= 'sorted(list5, key=lambda x: x[4, 2, 5, 1, 3])'
              body:-Code= 'sorted(list5, key=lambda x: x[1])'
          mined:Baseline= 'sorted(list(range(10)), key=lambda x: x[1])'
             mined:+Body= 'sorted(list5, key=lambda v: (v[1], v[2]))'
        mined:+Body, -NL= '[4, 2, 5, 1, 3]'
      mined:+Body, -Code= 'sorted(list5, key=lambda x: magnitude(x))'

================================================================================

QUESTION: idx=284    id=16041405
-------------------------------------INPUTS-------------------------------------

tags: 
score: 37
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: convert a list  into a generator object
body(Some added characters for better readability):
	Say I have a list
	
	start_block
	data = []
	data.append("A")
	data.append("B")
	data.append("C")
	data.append("D")
	How do I convert this to a generator?
	Any help with sample code would be highly appreciated...
	
	<p>Found a URL: http://eli.thegreenplace.net/2012/04/05/implementing-a-generatoryield-in-a-python-c-extension/
	Is this what I want to do?


-------------------------------------OUTPUT-------------------------------------

                Expected= '(n for n in [1, 2, 3, 5])'
           base:Baseline= ' generator.from_iterable(map(lambda x: x[1])'
           base:+Canonic= ' generator.from_iterable(key=lambda x: x[1])'
           body:Baseline= 'data = [list(data.items()))'
              body:-Code= '[item for item in enumerate(list(itertools.product()))]'
          mined:Baseline= '[(i, j) for i, j in enumerate(lst) if i == j]'
             mined:+Body= 'print(list(itertools.chain.from_iterable(data)))'
        mined:+Body, -NL= 'list(itertools.chain(*data))'
      mined:+Body, -Code= 'from functools import reduce\nreduce(lambda x, y: x + y, l)'

================================================================================

QUESTION: idx=285    id=18837607
-------------------------------------INPUTS-------------------------------------

tags: list
score: 15
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['oldlist', 'removelist']}
intent: remove elements from list `oldlist` that have an index number mentioned in list `removelist`
body(Some added characters for better readability):
	
	<p>So, for example, I got a list: 
	`myList=["asdf","ghjk","qwer","tyui"]`
	
	`removeIndexList=[1,3]` (I want to remove items 1 and 3 from the list above)
	What would be the best way to do this?


-------------------------------------OUTPUT-------------------------------------

                Expected= 'newlist = [v for i, v in enumerate(oldlist) if i not in removelist]'
           base:Baseline= 'oldlist = [x for x in list(removelist)]'
           base:+Canonic= 'oldlist = [x for x in removelist if x == oldlist]'
           body:Baseline= 'oldlist = [x for x in oldlist if x not in x]'
              body:-Code= 'newlist = [x for x in oldlist if x not inremovelist]'
          mined:Baseline= "[x for x in oldlist if x != 'Removelist']"
             mined:+Body= "[x for x in oldlist if x.index == 'removelist']"
        mined:+Body, -NL= 'removelist = [x for x in oldlist if x not in indexList]'
      mined:+Body, -Code= 'oldlist = [x for x in oldlist if x.index()]'

================================================================================

QUESTION: idx=286    id=4710067
-------------------------------------INPUTS-------------------------------------

tags: file, input
score: 165
slot_map: {'key': ['str_0'], 'quote': ['`'], 'type': ['str'], 'value': ['yourfile.txt']}
intent: open a file `yourfile.txt` in write mode
body(Some added characters for better readability):
	Let's say I have a text file full of nicknames. How can I delete a specific nickname from this file, using Python?


-------------------------------------OUTPUT-------------------------------------

                Expected= "f = open('yourfile.txt', 'w')"
           base:Baseline= "print(open('yourfile.txt','shutdown')"
           base:+Canonic= "open('yourfile.txt', 'write')"
           body:Baseline= "open('yourfile.txt', 'write')"
              body:-Code= "open('yourfile.txt', 'write')"
          mined:Baseline= "f = open('yourfile.txt', 'r')"
             mined:+Body= "open('yourfile.txt', 'wb')"
        mined:+Body, -NL= "f = open('yourfile.txt', 'rb')"
      mined:+Body, -Code= "f = open('yourfile.txt', 'wb')"

================================================================================

QUESTION: idx=287    id=7373219
-------------------------------------INPUTS-------------------------------------

tags: 
score: 5
slot_map: {'key': ['str_0', 'var_0'], 'quote': ["'", '`'], 'type': ['str', 'var'], 'value': ['attr', 'obj']}
intent: get attribute 'attr' from object `obj`
body(Some added characters for better readability):
	I vaguely remember learning about some sort of built-in function that would do the equivalent of
	
	start_block
	f = lambda x: x.attr
	Am I just imagining this or does such a thing exist? 


-------------------------------------OUTPUT-------------------------------------

                Expected= "getattr(obj, 'attr')"
           base:Baseline= "obj['attr'] = obj.attr"
           base:+Canonic= "obj.getattr('attr')"
           body:Baseline= "obj = obj.attribute('attr')"
              body:-Code= "obj.getattr('attr', obj)"
          mined:Baseline= "getattr(obj, 'attr')"
             mined:+Body= 'f = obj.getattr(obj)'
        mined:+Body, -NL= 'obj = obj.getattr(obj)'
      mined:+Body, -Code= "getattr(obj, 'attr')"

================================================================================

QUESTION: idx=288    id=8171751
-------------------------------------INPUTS-------------------------------------

tags: list, cursor, tuples
score: 5
slot_map: {'key': ['str_0', '(str_0)'], 'quote': ['`', '`'], 'type': ['str', 'str'], 'value': ["(('aa',), ('bb',), ('cc',))", "(('aa',), ('bb',), ('cc',))"]}
intent: convert tuple of tuples `(('aa',), ('bb',), ('cc',))` to tuple
body(Some added characters for better readability):
	
	start_block
	query = 'select mydata from mytable'
	cursor.execute(query)
	myoutput = cursor.fetchall() 
	print myoutput
	(('aa',), ('bb',), ('cc',))
	Why is it (cursor.fetchall) returning a tuple of tuples instead of a tuple since my query is asking for only one column of data?
	
	<p>What is the best way of converting it to 
	`['aa', 'bb', 'cc']` ?
	I can do something like this :
	
	start_block
	mylist = []
	myoutput = list(myoutput)
	for each in myoutput:
	   mylist.append(each[0])
	I am sure this isn't the best way of doing it. Please enlighten me!


-------------------------------------OUTPUT-------------------------------------

                Expected= "from functools import reduce\nreduce(lambda a, b: a + b, (('aa',), ('bb',), ('cc',)))"
           base:Baseline= "tuple(('aa', ( ('bb',), ('cc',)))"
           base:+Canonic= 'tuple("((\'aa\',), (\'bb\',), (\'cc\',))", \'tuple\')'
           body:Baseline= 'cursor.execute(query, tuple)'
              body:-Code= "cursor.fetchall([(('aa',), ('bb',), (cc',))])"
          mined:Baseline= "tuple(map(tuple, ('aa', ('bb',), ('cc',))"
             mined:+Body= 'myoutput = tuple(map(lambda t: t[0]))'
        mined:+Body, -NL= 'myoutput = tuple(map(lambda t: t[0]), cursor.fetchall())'
      mined:+Body, -Code= "tuple(map(lambda t: t[1], ('bb',), ('cc',))"

================================================================================

QUESTION: idx=289    id=8171751
-------------------------------------INPUTS-------------------------------------

tags: list, cursor, tuples
score: 5
slot_map: {'key': ['str_0', '(str_0)'], 'quote': ['`', '`'], 'type': ['str', 'str'], 'value': ["(('aa',), ('bb',), ('cc',))", "(('aa',), ('bb',), ('cc',))"]}
intent: convert tuple of tuples `(('aa',), ('bb',), ('cc',))` to list in one line
body(Some added characters for better readability):
	
	start_block
	query = 'select mydata from mytable'
	cursor.execute(query)
	myoutput = cursor.fetchall() 
	print myoutput
	(('aa',), ('bb',), ('cc',))
	Why is it (cursor.fetchall) returning a tuple of tuples instead of a tuple since my query is asking for only one column of data?
	
	<p>What is the best way of converting it to 
	`['aa', 'bb', 'cc']` ?
	I can do something like this :
	
	start_block
	mylist = []
	myoutput = list(myoutput)
	for each in myoutput:
	   mylist.append(each[0])
	I am sure this isn't the best way of doing it. Please enlighten me!


-------------------------------------OUTPUT-------------------------------------

                Expected= "map(lambda a: a[0], (('aa',), ('bb',), ('cc',)))"
           base:Baseline= "map(lambda x: (('aa', ( ('bb',), ('cc',)))"
           base:+Canonic= "[(x + y) for x in (('aa',), ('bb',), ('cc',))]"
           body:Baseline= 'mylist = list(myoutput)'
              body:-Code= "list(cursor.fetchall(('aa',), ('bb',), 'cc'))"
          mined:Baseline= 'map(lambda tup: tup[1])'
             mined:+Body= 'myoutput = list(myoutput)'
        mined:+Body, -NL= "['aa', 'bb', 'cc']"
      mined:+Body, -Code= "cursor.fetchall(('aa', ('bb',), ('cc',))"

================================================================================

QUESTION: idx=290    id=28986489
-------------------------------------INPUTS-------------------------------------

tags: replace, pandas, dataframe
score: 117
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: python pandas: how to replace a characters in a column of a dataframe?
body(Some added characters for better readability):
	I have a column in my dataframe like this:
	
	start_block
	range
	"(2,30)"
	"(50,290)"
	"(400,1000)"
	...
	
	<p>and I want to replace the 
	`,`
	 comma with 
	`-` dash. I'm currently using this method but nothing is changed.
	
	start_block
	org_info_exc['range'].replace(',', '-', inplace=True)
	Can anybody help?


-------------------------------------OUTPUT-------------------------------------

                Expected= "df['range'].replace(',', '-', inplace=True)"
           base:Baseline= "df['name'] = df['name'].replace(name)"
           base:+Canonic= "df['str'].replace('str', ''))"
           body:Baseline= "df['range'].replace(',', '-', inplace=True)"
              body:-Code= "df['index'] = df['index'].replace(' comma', 'dash')"
          mined:Baseline= "df[df.columns.replace('foo', 'bar')]"
             mined:+Body= "df['range'].replace(',', '-', inplace=True)"
        mined:+Body, -NL= "df['range'].replace(',', '-', inplace=True)"
      mined:+Body, -Code= "df['column_name'] = df.replace('', '')"

================================================================================

QUESTION: idx=291    id=19339
-------------------------------------INPUTS-------------------------------------

tags: list, matrix, transpose
score: 535
slot_map: {'key': ['str_0', '[str_0]'], 'quote': ['`', '`'], 'type': ['str', 'str'], 'value': ["[('a', 1), ('b', 2), ('c', 3), ('d', 4)]", "[('a', 1), ('b', 2), ('c', 3), ('d', 4)]"]}
intent: unzip the list `[('a', 1), ('b', 2), ('c', 3), ('d', 4)]`
body(Some added characters for better readability):
	I have a list of 2-item tuples and I'd like to convert them to 2 lists where the first contains the first item in each tuple and the second list holds the second item.
	For example:
	
	start_block
	original = [('a', 1), ('b', 2), ('c', 3), ('d', 4)]
	# and I want to become...
	result = (['a', 'b', 'c', 'd'], [1, 2, 3, 4])
	Is there a builtin function that does that?


-------------------------------------OUTPUT-------------------------------------

                Expected= "zip(*[('a', 1), ('b', 2), ('c', 3), ('d', 4)])"
           base:Baseline= "zip([('A', 1), ('B', 2), ('C', 3), ('D', 4)])"
           base:+Canonic= 'zip("[(\'a\', 1), (\'b\', 2), (\'c\', 3), (\'d\', 4)]", \'rb\')'
           body:Baseline= "result = [('a', 1), ('b', 2), ('c', 3), ('d', 4)])"
              body:-Code= "zip([('A', 1), ('B', 2), ('C', 3), ('D', 4)])"
          mined:Baseline= "zip(*((('a', 1), ('b', 2), ('c', 3), ('d', 4))"
             mined:+Body= "zip(*[('a', 1), ('b', 2), ('c', 3), ('d', 4)])"
        mined:+Body, -NL= "new = zip(*[('a', 1), ('b', 2), ('c', 3), ('d', 4)]"
      mined:+Body, -Code= "zip([('A', 1), ('B', 2), ('C', 3), ('D', 4)])"

================================================================================

QUESTION: idx=292    id=19339
-------------------------------------INPUTS-------------------------------------

tags: list, matrix, transpose
score: 535
slot_map: {'key': ['str_0', '[str_0]'], 'quote': ['`', '`'], 'type': ['str', 'str'], 'value': ["[('a', 1), ('b', 2), ('c', 3), ('d', 4)]", "[('a', 1), ('b', 2), ('c', 3), ('d', 4)]"]}
intent: unzip the list `[('a', 1), ('b', 2), ('c', 3), ('d', 4)]`
body(Some added characters for better readability):
	I have a list of 2-item tuples and I'd like to convert them to 2 lists where the first contains the first item in each tuple and the second list holds the second item.
	For example:
	
	start_block
	original = [('a', 1), ('b', 2), ('c', 3), ('d', 4)]
	# and I want to become...
	result = (['a', 'b', 'c', 'd'], [1, 2, 3, 4])
	Is there a builtin function that does that?


-------------------------------------OUTPUT-------------------------------------

                Expected= "zip(*[('a', 1), ('b', 2), ('c', 3), ('d', 4)])"
           base:Baseline= "zip([('A', 1), ('B', 2), ('C', 3), ('D', 4)])"
           base:+Canonic= 'zip("[(\'a\', 1), (\'b\', 2), (\'c\', 3), (\'d\', 4)]", \'rb\')'
           body:Baseline= "result = [('a', 1), ('b', 2), ('c', 3), ('d', 4)])"
              body:-Code= "zip([('A', 1), ('B', 2), ('C', 3), ('D', 4)])"
          mined:Baseline= "zip(*((('a', 1), ('b', 2), ('c', 3), ('d', 4))"
             mined:+Body= "zip(*[('a', 1), ('b', 2), ('c', 3), ('d', 4)])"
        mined:+Body, -NL= "new = zip(*[('a', 1), ('b', 2), ('c', 3), ('d', 4)]"
      mined:+Body, -Code= "zip([('A', 1), ('B', 2), ('C', 3), ('D', 4)])"

================================================================================

QUESTION: idx=293    id=19339
-------------------------------------INPUTS-------------------------------------

tags: list, matrix, transpose
score: 535
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['original']}
intent: unzip list `original`
body(Some added characters for better readability):
	I have a list of 2-item tuples and I'd like to convert them to 2 lists where the first contains the first item in each tuple and the second list holds the second item.
	For example:
	
	start_block
	original = [('a', 1), ('b', 2), ('c', 3), ('d', 4)]
	# and I want to become...
	result = (['a', 'b', 'c', 'd'], [1, 2, 3, 4])
	Is there a builtin function that does that?


-------------------------------------OUTPUT-------------------------------------

                Expected= 'result = [a for a, b in original], [b for a, b in original]'
           base:Baseline= 'original = [zip(original, key=lambda x: x[1])'
           base:+Canonic= 'zip(original, key=lambda x: x[1])'
           body:Baseline= 'original = [zip(key=lambda x: x[1]) for x in original]'
              body:-Code= 'original.zip(key=operator.itemgetter(1))'
          mined:Baseline= 'original = zip(*[(1, 2), (3, 4), (5, 6)]))'
             mined:+Body= 'zip(original, result[:]))'
        mined:+Body, -NL= 'result = [(x[0], x[1] for x in original]'
      mined:+Body, -Code= 'zip(*original, zip(*original))'

================================================================================

QUESTION: idx=294    id=19339
-------------------------------------INPUTS-------------------------------------

tags: list, matrix, transpose
score: 535
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['original']}
intent: unzip list `original` and return a generator
body(Some added characters for better readability):
	I have a list of 2-item tuples and I'd like to convert them to 2 lists where the first contains the first item in each tuple and the second list holds the second item.
	For example:
	
	start_block
	original = [('a', 1), ('b', 2), ('c', 3), ('d', 4)]
	# and I want to become...
	result = (['a', 'b', 'c', 'd'], [1, 2, 3, 4])
	Is there a builtin function that does that?


-------------------------------------OUTPUT-------------------------------------

                Expected= 'result = (a for a, b in original), (b for a, b in original)'
           base:Baseline= 'new = [zip(original, key=lambda x: x[1])'
           base:+Canonic= 'print(zip(var_0, key=lambda x: x[1])'
           body:Baseline= 'new = [zip(original, key=lambda x: x[1])'
              body:-Code= 'new = zip(original, key=operator.itemgetter(1))'
          mined:Baseline= 'random.sample(list(original))'
             mined:+Body= 'new = zip(*original, result)'
        mined:+Body, -NL= 'new_list = [random.sample(list(original.items())) for _ in range(0, len(\n    original), 3)]'
      mined:+Body, -Code= 'zip(original, zip(*original))'

================================================================================

QUESTION: idx=295    id=19339
-------------------------------------INPUTS-------------------------------------

tags: list, matrix, transpose
score: 535
slot_map: {'key': ['str_0', '[str_0]'], 'quote': ['`', '`'], 'type': ['str', 'str'], 'value': ["[('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e', )]", "[('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e', )]"]}
intent: unzip list `[('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e', )]`
body(Some added characters for better readability):
	I have a list of 2-item tuples and I'd like to convert them to 2 lists where the first contains the first item in each tuple and the second list holds the second item.
	For example:
	
	start_block
	original = [('a', 1), ('b', 2), ('c', 3), ('d', 4)]
	# and I want to become...
	result = (['a', 'b', 'c', 'd'], [1, 2, 3, 4])
	Is there a builtin function that does that?


-------------------------------------OUTPUT-------------------------------------

                Expected= "zip(*[('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e',)])"
           base:Baseline= "zip(* ['A', 1), ('B', 2), ('C', 3), ('D', 4), ('E', )]))"
           base:+Canonic= 'zip(*["[(\'a\', 1), (\'b\', 2), (\'c\', 3), (\'d\', 4), (\'e\', )]"])'
           body:Baseline= "new = [('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e',)]"
              body:-Code= "zip(* ['A', 1), ('B', 2), ('C', 3), ('D', 4), ('E', )])"
          mined:Baseline= "zip(*[[('A', 1), ('B', 2), ('C', 3), ('D', 4), ('E', 5), ('F', 6), ('G', 7)]))"
             mined:+Body= "zip(*[('a', 1), ('b', 2), ('c', 3), ('d', 4)])"
        mined:+Body, -NL= 'new = zip(*new)[::-1]'
      mined:+Body, -Code= "zip([('A', 1), ('B', 2), ('C', 3), ('D', 4), ('E', 5)])"

================================================================================

QUESTION: idx=296    id=19339
-------------------------------------INPUTS-------------------------------------

tags: list, matrix, transpose
score: 535
slot_map: {'key': ['str_0', '[str_0]'], 'quote': ['`', '`'], 'type': ['str', 'str'], 'value': ["[('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e', )]", "[('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e', )]"]}
intent: unzip list `[('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e', )]` and fill empty results with none
body(Some added characters for better readability):
	I have a list of 2-item tuples and I'd like to convert them to 2 lists where the first contains the first item in each tuple and the second list holds the second item.
	For example:
	
	start_block
	original = [('a', 1), ('b', 2), ('c', 3), ('d', 4)]
	# and I want to become...
	result = (['a', 'b', 'c', 'd'], [1, 2, 3, 4])
	Is there a builtin function that does that?


-------------------------------------OUTPUT-------------------------------------

                Expected= "map(None, *[('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e',)])"
           base:Baseline= "zip([('A', 1), ('B', 2), ('C', 3), ('D', 4), ('E', )]])"
           base:+Canonic= "zip([('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e', )], None)"
           body:Baseline= "result = [('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e',)]"
              body:-Code= "zip(*[[('A', 1), ('B', 2), ('C', 3), ('D', 4), ('E', )]))"
          mined:Baseline= "zip(*[[('A', 1), ('B', 2), ('C', 3), ('D', 4), ('E', 5), ('F', 6)]))"
             mined:+Body= "zip(*[('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e', 5)]"
        mined:+Body, -NL= 'new = [x for x in original if x is not None]'
      mined:+Body, -Code= "zip(*[('A', 1), ('B', 2), ('C', 3), ('D', 4), ('E', None)]"

================================================================================

QUESTION: idx=297    id=1960516
-------------------------------------INPUTS-------------------------------------

tags: json, floating-point, decimal
score: 267
slot_map: {'key': ['str_0'], 'quote': ['`'], 'type': ['str'], 'value': ["Decimal('3.9')"]}
intent: encode `decimal('3.9')` to a json string
body(Some added characters for better readability):
	
	<p>I have a 
	`Decimal('3.9')`
	 as part of an object, and wish to encode this to a JSON string which should look like 
	`{'x': 3.9}`. I don't care about precision on the client side, so a float is fine.
	
	<p>Is there a good way to serialize this? JSONDecoder doesn't accept Decimal objects, and converting to a float beforehand yields 
	`{'x': 3.8999999999999999}` which is wrong, and will be a big waste of bandwidth.


-------------------------------------OUTPUT-------------------------------------

                Expected= "json.dumps(Decimal('3.9'))"
           base:Baseline= "json.decimal('3.9')"
           base:+Canonic= 'json.encode("Decimal(\'3.9\')")'
           body:Baseline= "json.decimal('3.9')"
              body:-Code= "json.decimal('3.9')"
          mined:Baseline= "json.dumps(decimal('3.9'))"
             mined:+Body= "json.dumps(decimal('3.9')))"
        mined:+Body, -NL= "json.dumps(decimal('3.9')).encode('utf-8')"
      mined:+Body, -Code= "json.dumps(decimal('3.9'))"

================================================================================

QUESTION: idx=298    id=1024847
-------------------------------------INPUTS-------------------------------------

tags: dictionary, lookup
score: 2913
slot_map: {'key': ['str_0', 'var_0', 'str_1'], 'quote': ['"', '`', '"'], 'type': ['str', 'var', 'str'], 'value': ['mynewkey', 'd', 'mynewvalue']}
intent: add key "mynewkey" to dictionary `d` with value "mynewvalue"
body(Some added characters for better readability):
	Is it possible to add a key to a Python dictionary after it has been created?
	
	<p>It doesn't seem to have an 
	`.add()` method.


-------------------------------------OUTPUT-------------------------------------

                Expected= "d['mynewkey'] = 'mynewvalue'"
           base:Baseline= "d['mynewkey'] = d['MyNewValue']"
           base:+Canonic= "d.update({'mynewvalue': 'mynewkey'})"
           body:Baseline= "d = {'mynewkey':'mynewvalue'})"
              body:-Code= "d.update({'mynewkey': 'mynewvalue'})"
          mined:Baseline= "d['mynewkey'] = 'mynewvalue'"
             mined:+Body= "d['mynewkey'] = 'mynewvalue'"
        mined:+Body, -NL= "d.update({'mynewkey': 'mynewvalue'})"
      mined:+Body, -Code= "d.update({'mynewkey': 'mynewvalue'})"

================================================================================

QUESTION: idx=299    id=1024847
-------------------------------------INPUTS-------------------------------------

tags: dictionary, lookup
score: 2913
slot_map: {'key': ['str_0', 'var_0'], 'quote': ["'", '`'], 'type': ['str', 'var'], 'value': ['a', 'data']}
intent: add key 'a' to dictionary `data` with value 1
body(Some added characters for better readability):
	Is it possible to add a key to a Python dictionary after it has been created?
	
	<p>It doesn't seem to have an 
	`.add()` method.


-------------------------------------OUTPUT-------------------------------------

                Expected= "data.update({'a': 1})"
           base:Baseline= "data.update({'a': 1})"
           base:+Canonic= "data.update({'a': 1})"
           body:Baseline= "data.update({'a': 1})"
              body:-Code= "data.update({'a': 1})"
          mined:Baseline= "data['a'].update({'a': 1})"
             mined:+Body= "data.update({'a': 1})"
        mined:+Body, -NL= "data.update({'a': 1})"
      mined:+Body, -Code= 'data.update((k, a) for k, v in data.items())'

================================================================================

QUESTION: idx=300    id=1024847
-------------------------------------INPUTS-------------------------------------

tags: dictionary, lookup
score: 2913
slot_map: {'key': ['str_0', 'var_0'], 'quote': ["'", '`'], 'type': ['str', 'var'], 'value': ['a', 'data']}
intent: add key 'a' to dictionary `data` with value 1
body(Some added characters for better readability):
	Is it possible to add a key to a Python dictionary after it has been created?
	
	<p>It doesn't seem to have an 
	`.add()` method.


-------------------------------------OUTPUT-------------------------------------

                Expected= 'data.update(dict(a=1))'
           base:Baseline= "data.update({'a': 1})"
           base:+Canonic= "data.update({'a': 1})"
           body:Baseline= "data.update({'a': 1})"
              body:-Code= "data.update({'a': 1})"
          mined:Baseline= "data['a'].update({'a': 1})"
             mined:+Body= "data.update({'a': 1})"
        mined:+Body, -NL= "data.update({'a': 1})"
      mined:+Body, -Code= 'data.update((k, a) for k, v in data.items())'

================================================================================

QUESTION: idx=301    id=1024847
-------------------------------------INPUTS-------------------------------------

tags: dictionary, lookup
score: 2913
slot_map: {'key': ['str_0', 'var_0'], 'quote': ["'", '`'], 'type': ['str', 'var'], 'value': ['a', 'data']}
intent: add key 'a' to dictionary `data` with value 1
body(Some added characters for better readability):
	Is it possible to add a key to a Python dictionary after it has been created?
	
	<p>It doesn't seem to have an 
	`.add()` method.


-------------------------------------OUTPUT-------------------------------------

                Expected= 'data.update(a=1)'
           base:Baseline= "data.update({'a': 1})"
           base:+Canonic= "data.update({'a': 1})"
           body:Baseline= "data.update({'a': 1})"
              body:-Code= "data.update({'a': 1})"
          mined:Baseline= "data['a'].update({'a': 1})"
             mined:+Body= "data.update({'a': 1})"
        mined:+Body, -NL= "data.update({'a': 1})"
      mined:+Body, -Code= 'data.update((k, a) for k, v in data.items())'

================================================================================

QUESTION: idx=302    id=35837346
-------------------------------------INPUTS-------------------------------------

tags: for-loop, max
score: 14
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['matrix']}
intent: find maximal value in matrix `matrix`
body(Some added characters for better readability):
	To find the maximal value in a matrix of numbers, we can code 5 lines to solve the problem:
	
	start_block
	ans = matrix[0][0]
	for x in range(len(matrix)):
	    for y in range(len(matrix[0])):
	        ans = max(ans, matrix[x][y])
	return ans
	Is there a one line solution for this problem?
	The one that I came up with is pretty awkward actually:
	
	start_block
	return max(max(matrix, key=max))
	or
	
	start_block
	return max(map(max, matrix))


-------------------------------------OUTPUT-------------------------------------

                Expected= 'max([max(i) for i in matrix])'
           base:Baseline= 'max(matrix, key=lambda x: max(x[1])'
           base:+Canonic= 'max(matrix, matrix)'
           body:Baseline= 'max(matrix, key=lambda x: x[0])'
              body:-Code= 'max(matrix, key=lambda x: x[1])'
          mined:Baseline= 'max(matrix, key=matrix.get)'
             mined:+Body= 'max(abs, matrix[x][y])'
        mined:+Body, -NL= 'max(ans, matrix[x][y])'
      mined:+Body, -Code= 'np.max(matrix, axis=1)'

================================================================================

QUESTION: idx=303    id=20457038
-------------------------------------INPUTS-------------------------------------

tags: rounding
score: 340
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['answer']}
intent: round number `answer` to 2 precision after the decimal point
body(Some added characters for better readability):
	I am getting a lot of decimals in the output of this code (Fahrenheit to Celsius converter).
	My code currently looks like this:
	
	start_block
	def main():
	    printC(formeln(typeHere()))
	def typeHere():
	    global Fahrenheit
	    try:
	        Fahrenheit = int(raw_input("Hi! Enter Fahrenheit value, and get it in Celsius!\n"))
	    except ValueError:
	        print "\nYour insertion was not a digit!"
	        print "We've put your Fahrenheit value to 50!"
	        Fahrenheit = 50
	    return Fahrenheit
	def formeln(c):
	    Celsius = (Fahrenheit - 32.00) * 5.00/9.00
	    return Celsius
	def printC(answer):
	    answer = str(answer)
	    print "\nYour Celsius value is " + answer + " C.\n"
	main()
	So my question is, how do I make the program round every answer to the 2nd decimal place?


-------------------------------------OUTPUT-------------------------------------

                Expected= 'answer = str(round(answer, 2))'
           base:Baseline= 'round(answer.round(2))'
           base:+Canonic= 'round(answer, 2)'
           body:Baseline= 'print(round(answer, 2))'
              body:-Code= 'print(answer.round(2))'
          mined:Baseline= 'print(round(answer, 2))'
             mined:+Body= "print('Celsius = (Fahrenheit - 32.00) * 5.00 / 9.00')"
        mined:+Body, -NL= "print('\\n'.join(round(answer))"
      mined:+Body, -Code= 'print(round(answer, 2))'

================================================================================

QUESTION: idx=304    id=2890896
-------------------------------------INPUTS-------------------------------------

tags: regex, string
score: 27
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: extract ip address from an html string
body(Some added characters for better readability):
	I want to extract an IP address from a string (actually a one-line HTML) using Python.
	
	
	start_block
	
	>>>s = " 
	<title>Current IP Check </title> </head> <body>Current IP Address: 165.91.15.131 </body> </html>"
	...
	-- '165.91.15.131' is what I want!
	I tried using regular expressions, but so far I can only get to the first number.
	
	
	start_block
	>>>import re
	>>>ip = re.findall( r'([0-9]+)(?:\.[0-9]+){3}', s )
	>>>ip
	...['165']
	But I don't have a firm grasp on reg-expression; the above code was found and modified from elsewhere on the web.


-------------------------------------OUTPUT-------------------------------------

                Expected= "ip = re.findall('[0-9]+(?:\\\\.[0-9]+){3}', s)"
           base:Baseline= "re.sub('[^a-zA-Z]', '\\\\1', shell=True)"
           base:+Canonic= 'urllib.parse.unquote(id=0)'
           body:Baseline= "s = re.findall('([0-9]+)(?:\\\\.[0- 9]+){3}', s)"
              body:-Code= 'urllib.parse.unquote(IP address)'
          mined:Baseline= 'sock.get_ip_address()'
             mined:+Body= "s = re.findall('(?<!>[0-9]+)(?:\\\\.[0-10]+){3}', s)"
        mined:+Body, -NL= "print(s.encode('utf-8'))"
      mined:+Body, -Code= "print(s.get('168.91.15.131'))"

================================================================================

QUESTION: idx=305    id=29836836
-------------------------------------INPUTS-------------------------------------

tags: pandas, filtering, dataframe
score: 51
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['df', 'A']}
intent: filter dataframe `df` by values in column `a` that appear more than once
body(Some added characters for better readability):
	
	<p>I'm working in Python with a pandas DataFrame of video games, each with a genre. I'm trying to remove any video game with a genre that appears less than some number of times in the DataFrame, but I have no clue how to go about this. I did find 
	a StackOverflow question  that seems to be related, but I can't decipher the solution at all (possibly because I've never heard of R and my memory of functional programming is rusty at best).
	Help?


-------------------------------------OUTPUT-------------------------------------

                Expected= "df.groupby('A').filter(lambda x: len(x) > 1)"
           base:Baseline= 'df.filter(lambda x: x[1])'
           base:+Canonic= "df.filter(['A', 'var_2'], axis=1)"
           body:Baseline= "df.filter(['a'], a)"
              body:-Code= 'df.filter(df.a)'
          mined:Baseline= 'df.filter(lambda x: len(x), axis=1)'
             mined:+Body= "df.ix[df.genre.str.count('a') > 0]"
        mined:+Body, -NL= 'df.filter(df.columns, axis=1)'
      mined:+Body, -Code= 'df.ix[df.genre.str.count() > 0]'

================================================================================

QUESTION: idx=306    id=2545397
-------------------------------------INPUTS-------------------------------------

tags: 
score: 9
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['myfile']}
intent: append each line in file `myfile` into a list
body(Some added characters for better readability):
	I have a text document that contains a list of numbers and I want to convert it to a list. Right now I can only get the entire list in the 0th entry of the list, but I want each number to be an element of a list. Does anyone know of an easy way to do this in Python?
	
	start_block
	1000
	2000
	3000
	4000
	to 
	
	start_block
	['1000','2000','3000','4000']


-------------------------------------OUTPUT-------------------------------------

                Expected= "[x for x in myfile.splitlines() if x != '']"
           base:Baseline= '[x for x in myfile]'
           base:+Canonic= 'myfile = [x for x in myfile]'
           body:Baseline= '[x for x in myfile]'
              body:-Code= '[x for x in myfile]'
          mined:Baseline= "[line for line in open('myfile') if line.endswith('\\n')]"
             mined:+Body= "['1000', '2000', '3000', '4000']"
        mined:+Body, -NL= "['1000', '2000', '3000', '4000']"
      mined:+Body, -Code= "list(open('myfile').read().split())"

================================================================================

QUESTION: idx=307    id=2545397
-------------------------------------INPUTS-------------------------------------

tags: 
score: 9
slot_map: {'key': ['var_0', 'str_0'], 'quote': ['`', '`'], 'type': ['var', 'str'], 'value': ['lst', 'filename.txt']}
intent: get a list of integers `lst` from a file `filename.txt`
body(Some added characters for better readability):
	I have a text document that contains a list of numbers and I want to convert it to a list. Right now I can only get the entire list in the 0th entry of the list, but I want each number to be an element of a list. Does anyone know of an easy way to do this in Python?
	
	start_block
	1000
	2000
	3000
	4000
	to 
	
	start_block
	['1000','2000','3000','4000']


-------------------------------------OUTPUT-------------------------------------

                Expected= "lst = map(int, open('filename.txt').readlines())"
           base:Baseline= "[int(x) for x in open('filename.txt')]"
           base:+Canonic= "lst = open('filename.txt', 'rb')"
           body:Baseline= "[int(x) for x in open('filename.txt')]"
              body:-Code= "[int(x) for x in open('filename.txt')]"
          mined:Baseline= "[int(x) for x in open('filename.txt')]"
             mined:+Body= "[int(x) for x in open('filename.txt')]"
        mined:+Body, -NL= 'lst = [int(x) for x infilename.txt]'
      mined:+Body, -Code= "lst = [int(i) for i in open('filename.txt')]"

================================================================================

QUESTION: idx=308    id=35420052
-------------------------------------INPUTS-------------------------------------

tags: spectrogram
score: 10
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['mappable', 'plt']}
intent: add color bar with image `mappable` to plot `plt`
body(Some added characters for better readability):
	I'm trying to add a Colorbar to a spectrogram. I have tried every example and question thread I have found online and none have solved this issue
	Note that 'spl1' (data splice 1) is a trace from ObsPy.
	My code is:
	
	start_block
	fig = plt.figure()
	ax1 = fig.add_axes([0.1, 0.75, 0.7, 0.2]) #[left bottom width height]
	ax2 = fig.add_axes([0.1, 0.1, 0.7, 0.60], sharex=ax1)
	ax3 = fig.add_axes([0.83, 0.1, 0.03, 0.6])
	t = np.arange(spl1[0].stats.npts) / spl1[0].stats.sampling_rate
	ax1.plot(t, spl1[0].data, 'k')
	ax,spec = spectrogram(spl1[0].data,spl1[0].stats.sampling_rate, show=False, axes=ax2)
	ax2.set_ylim(0.1, 15)
	fig.colorbar(spec, cax=ax3)
	It comes out with the error:
	
	start_block
	Traceback (most recent call last):
	  File " <ipython-input-18-61226ccd2d85>", line 14, in <module>
	    ax,spec = spectrogram(spl1[0].data,spl1[0].stats.sampling_rate, show=False, axes=ax2)
	TypeError: 'Axes' object is not iterable
	Best result so far:
	Replacing the last 3 lines above with:
	
	start_block
	ax = spectrogram(spl1[0].data,spl1[0].stats.sampling_rate, show=False, axes=ax2)
	ax2.set_ylim(0.1, 15)
	fig.colorbar(ax,cax=ax3)
	Produces this:
	and this error for the colorbar:
	
	start_block
	axes object has no attribute 'autoscale_None'
	I don't seem to be able to find a way to get the colorbar on the right to work.
	Solutions?
	One of the solutions I have seen is that you need to create an 'image' of your data using imshow(), however I don't get an output for that from Spectrogram(), only 'ax'. I have seen places try with the 'ax,spec' output from spectrogram() but that is causing the TypeError.
	
	<li>Very similar code I found but didn't work 
	https://www.nicotrebbin.de/wp-content/uploads/2012/03/bachelorthesis.pdf  (ctrl+f 'colorbar')
	
	<li>Looked at code examples from a related question
	
	<li>imshow() 
	suggestions 
	 and 
	example  - can't get an output from spectrogram to turn into an image. That second link, I also can't get the mlpy module to work (it doesn't think there's a mlpy.wavelet function)
	
	<li>This problem was addressed in 
	an improvement post for obspy  but the solution he stated he found was not given
	I hope someone can give a hand with this - I've been working on this all day now!


-------------------------------------OUTPUT-------------------------------------

                Expected= 'plt.colorbar(mappable=mappable, cax=ax3)'
           base:Baseline= "plt.pop('mappable')"
           base:+Canonic= 'plt.colorbar(mappable)'
           body:Baseline= "plt.colorbar(t, spl1[0].data, 'k')"
              body:-Code= "plt.set_colorbar('mappable')"
          mined:Baseline= "plt.colorbar(im, label='mappable')"
             mined:+Body= 'plt.colorbar(mappable)'
        mined:+Body, -NL= 'plt.colorbar(ax, cax=ax3)'
      mined:+Body, -Code= "plt.imshow('mappable')"

================================================================================

QUESTION: idx=309    id=29903025
-------------------------------------INPUTS-------------------------------------

tags: pandas
score: 20
slot_map: {'key': ['str_0', 'var_0'], 'quote': ["'", '`'], 'type': ['str', 'var'], 'value': ['text', 'df']}
intent: count most frequent 100 words in column 'text' of dataframe `df`
body(Some added characters for better readability):
	I have text reviews in one column in Pandas dataframe and I want to count the N-most frequent words with their frequency counts (in whole column - NOT in single cell). One approach is Counting the words using a counter, by iterating through each row. Is there a better alternative?
	Representative data.
	
	start_block
	0    a heartening tale of small victories and endu
	1    no sophomore slump for director sam mendes  w
	2    if you are an actor who can relate to the sea
	3    it's this memory-as-identity obviation that g
	4    boyd's screenplay ( co-written with guardian


-------------------------------------OUTPUT-------------------------------------

                Expected= "Counter(' '.join(df['text']).split()).most_common(100)"
           base:Baseline= "df['text'] = df['text'].count(len(key=lambda x: x[1])"
           base:+Canonic= "df.groupby('text').most_common()"
           body:Baseline= "df['text'].count(100)"
              body:-Code= "df.count_common_words('text')"
          mined:Baseline= "df['text'] = df['text'].apply(lambda x: len(x), axis=1)"
             mined:+Body= "df.groupby(['text', 'reaction']).sum()"
        mined:+Body, -NL= "df['text'].apply(lambda x: len(x), axis=1)"
      mined:+Body, -Code= "df.reindex('Words', inplace=True)"

================================================================================

QUESTION: idx=310    id=16330838
-------------------------------------INPUTS-------------------------------------

tags: regex, string, split
score: 5
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: python split a string using regex
body(Some added characters for better readability):
	I would like to split a string by ':' and ' ' characters. However, i would like to ignore two spaces '  ' and  two colons '::'. for e.g.
	
	start_block
	text = "s:11011 i:11010 ::110011  :110010 d:11000"
	should split into
	
	start_block
	[s,11011,i,11010,:,110011, ,110010,d,11000]
	after following the Regular Expressions HOWTO on the python website, i managed to comeup with the following 
	
	start_block
	regx= re.compile('([\s:]|[^\s\s]|[^::])')
	regx.split(text)
	However this does not work as intended as it splits on the : and spaces, but it still includes the ':' and ' ' in the split. 
	
	start_block
	[s,:,11011, ,i,:,11010, ,:,:,110011, , :,110010, ,d,:,11000]
	How can I fix this?
	
	<strong>EDIT:  In case of a double space, i only want one space to appear


-------------------------------------OUTPUT-------------------------------------

                Expected= "re.findall('(.+?):(.+?)\\\\b?', text)"
           base:Baseline= "re.split('[^a-zA-Z]', '', string)"
           base:+Canonic= "re.split('\\n', '\\n')"
           body:Baseline= "re.compile('([^\\\\s\\\\s]|[^::]\\\\s', '', text)"
              body:-Code= "re.split('\\\\', '', 2)"
          mined:Baseline= "re.split('(?<=.)(?=.)', '\\\\1', s)"
             mined:+Body= "regx = re.compile('([^\\\\s\\\\s]|[^::])')"
        mined:+Body, -NL= "regx.split('s:11011 i:11010 ::110011  :110010 d:11000')"
      mined:+Body, -Code= "re.split('(?<=.)(?=.)', '', s)"

================================================================================

QUESTION: idx=311    id=7378180
-------------------------------------INPUTS-------------------------------------

tags: set, tuples, subset
score: 17
slot_map: {'key': ['str_0', '(str_0)'], 'quote': ['`', '`'], 'type': ['str', 'str'], 'value': ['(1, 2, 3)', '(1, 2, 3)']}
intent: generate all 2-element subsets of tuple `(1, 2, 3)`
body(Some added characters for better readability):
	I have a set of values and would like to create list of all subsets containing 2 elements. 
	
	<p>For example, a source set 
	`([1,2,3])` has the following 2-element subsets: 
	
	start_block
	set([1,2]), set([1,3]), set([2,3])
	Is there a way to do this in python?


-------------------------------------OUTPUT-------------------------------------

                Expected= 'list(itertools.combinations((1, 2, 3), 2))'
           base:Baseline= '[(1, 2, 3))'
           base:+Canonic= '[(x, y) for x, y in (1, 2, 3)]'
           body:Baseline= '[(1, 2, 3)]'
              body:-Code= '[(1, 2, 3) for k, v in subsets]'
          mined:Baseline= '[(1, 2, 3) for i in range(0, len(a))]'
             mined:+Body= '[(1, 2, 3)], (2, 3)]'
        mined:+Body, -NL= '[(1, 2, 3), (2, 3)]'
      mined:+Body, -Code= 'list(itertools.chain(*(1, 2, 3)))'

================================================================================

QUESTION: idx=312    id=4530069
-------------------------------------INPUTS-------------------------------------

tags: datetime, date, timezone
score: 354
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: get a value of datetime.today() in the utc time zone
body(Some added characters for better readability):
	
	<p>I am trying to subtract one date value from the value of 
	`datetime.today()` to calculate how long ago something was. But it complains:
	
	start_block
	TypeError: can't subtract offset-naive and offset-aware datetimes
	
	<p>The value 
	`datetime.today()`
	 doesn't seem to be "timezone aware", while my other date value is. How do I get a value of 
	`datetime.today()` that is timezone aware?
	
	<p>Right now, it's giving me the time in local time, which happens to be PST, i.e. UTC - 8 hours. Worst case, is there a way I can manually enter a timezone value into the 
	`datetime`
	 object returned by 
	`datetime.today()` and set it to UTC-8?
	Of course, the ideal solution would be for it to automatically know the timezone.


-------------------------------------OUTPUT-------------------------------------

                Expected= 'datetime.now(pytz.utc)'
           base:Baseline= 'datetime.today()[:-1]'
           base:+Canonic= 'datetime.today() - datetime.utcnow().date()'
           body:Baseline= "datetime.today().strftime('%Y-%m-%d %H:%M')"
              body:-Code= "datetime.today().strftime('%B')"
          mined:Baseline= 'today = datetime.datetime.utcnow().date()'
             mined:+Body= 'datetime.today() - datetime.timedelta(hours=1)'
        mined:+Body, -NL= 'dt = datetime.utcnow().date()'
      mined:+Body, -Code= 'today = datetime.datetime.utcnow().date()'

================================================================================

QUESTION: idx=313    id=4842956
-------------------------------------INPUTS-------------------------------------

tags: list
score: 78
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['list2', 'list1']}
intent: get a new list `list2`by removing empty list from a list of lists `list1`
body(Some added characters for better readability):
	I have a list with empty lists in it:
	
	start_block
	list1 = [[], [], [], [], [], 'text', 'text2', [], 'moreText']
	How can I remove the empty lists so that I get:
	
	start_block
	list2 = ['text', 'text2', 'moreText']
	I tried list.remove('') but that doesn't work.


-------------------------------------OUTPUT-------------------------------------

                Expected= 'list2 = [x for x in list1 if x != []]'
           base:Baseline= '[x for x in zip(list1, list2)]'
           base:+Canonic= 'list2 = [x for x in list1]'
           body:Baseline= 'list2 = [x for x in list1]'
              body:-Code= 'list2 = [x for x in list1]'
          mined:Baseline= 'list2 = [list1[i] for i in list1]'
             mined:+Body= "list2 = [x for x in list1 if x != '']"
        mined:+Body, -NL= "list2 = [x for x in list1 if x != 'moreText']"
      mined:+Body, -Code= "list2 = [x for x in list1 if x != '']"

================================================================================

QUESTION: idx=314    id=4842956
-------------------------------------INPUTS-------------------------------------

tags: list
score: 78
slot_map: {'key': ['var_0', 'var_1', 'var_2'], 'quote': ['`', '`', '`'], 'type': ['var', 'var', 'var'], 'value': ['list2', 'list1', 'list1']}
intent: create `list2` to contain the lists from list `list1` excluding the empty lists from `list1`
body(Some added characters for better readability):
	I have a list with empty lists in it:
	
	start_block
	list1 = [[], [], [], [], [], 'text', 'text2', [], 'moreText']
	How can I remove the empty lists so that I get:
	
	start_block
	list2 = ['text', 'text2', 'moreText']
	I tried list.remove('') but that doesn't work.


-------------------------------------OUTPUT-------------------------------------

                Expected= 'list2 = [x for x in list1 if x]'
           base:Baseline= 'list2 = [x for x in zip(list1, list2)]'
           base:+Canonic= 'list2 = [x for x in zip(list1, list1)]'
           body:Baseline= 'list2 = [[], [x for x in list1 if x not in list2]'
              body:-Code= 'list2 = [item for item in list1 if item in item1]'
          mined:Baseline= 'list2 = [[] for i in range(len(list1))]'
             mined:+Body= 'list2 = [x for x in list1 if x is not None]'
        mined:+Body, -NL= "list2 = [x for x in list1 if x != 'moreText']"
      mined:+Body, -Code= 'list2 = [x for x in list1 if x != list1]'

================================================================================

QUESTION: idx=315    id=9262278
-------------------------------------INPUTS-------------------------------------

tags: json, django, django-views
score: 83
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['data']}
intent: django response with json `data`
body(Some added characters for better readability):
	
	<p>This is related to this question: Django return json and html depending on client python
	
	<p>I have a command line Python API for a Django app. When I access the app through the API it should return JSON and with a browser it should return HTML. I can use different URLs to access the different versions but how do I render the HTML template and JSON in the 
	views.py  with just one template?
	To render the HTML I would use:
	
	start_block
	return render_to_response('sample/sample.html....')
	
	<p>But how would I do the same for JSON without putting a JSON template? (the 
	`content-type`
	 should be 
	`application/json`
	 instead of 
	`text/html`)
	What would determine the JSON and HTML outputs?
	
	<p>So in my 
	views.py :
	
	start_block
	if something:
	    return render_to_response('html_template',.....)
	else:
	    return HttpReponse(jsondata,mimetype='application/json')


-------------------------------------OUTPUT-------------------------------------

                Expected= "return HttpResponse(data, mimetype='application/json')"
           base:Baseline= 'data = json.dumps(data)'
           base:+Canonic= 'response = json.dumps(data)'
           body:Baseline= "httpReponse(data, headers=['application/json'])"
              body:-Code= 'response = json.loads(data)'
          mined:Baseline= 'return HttpResponse(json.dumps(data))'
             mined:+Body= "return HttpReponse(jsondata, mimetype='application/json')"
        mined:+Body, -NL= "return HttpReponse(jsondata, mimetype='application/json')"
      mined:+Body, -Code= 'return HttpResponse(json, content)'

================================================================================

QUESTION: idx=316    id=17284947
-------------------------------------INPUTS-------------------------------------

tags: regex
score: 9
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['example_str']}
intent: get all text that is not enclosed within square brackets in string `example_str`
body(Some added characters for better readability):
	I'm trying to grab any text outside of brackets with a regex.
	Example string
	Josie Smith [3996 COLLEGE AVENUE, SOMETOWN, MD 21003]Mugsy Dog Smith
	  [2560 OAK ST, GLENMEADE, WI 14098]
	
	<p>I'm able to get the text 
	inside  the square brackets successfully with:
	
	start_block
	addrs = re.findall(r"\[(.*?)\]", example_str)
	print addrs
	[u'3996 COLLEGE AVENUE, SOMETOWN, MD 21003',u'2560 OAK ST, GLENMEADE, WI 14098']    
	
	<p>but I'm having trouble getting anything 
	outside  of the square brackets.  I've tried something like the following:
	
	start_block
	names = re.findall(r"(.*?)\[.*\]+", example_str)
	but that only finds the first name:
	
	start_block
	print names
	[u'Josie Smith ']
	
	<p>So far I've only seen a string containing one to two 
	`name [address]` combos, but I'm assuming there could be any number of them in a string.


-------------------------------------OUTPUT-------------------------------------

                Expected= "re.findall('(.*?)\\\\[.*?\\\\]', example_str)"
           base:Baseline= "example_str = re.sub('(\\\\w+)', '', example_str)"
           base:+Canonic= "re.findall('\\\\w+\\\\w', example_str)"
           body:Baseline= "re.findall('\\\\[.*\\\\]+', example_str)"
              body:-Code= "re.findall('\\\\w+\\\\s+', example_str)"
          mined:Baseline= '"""example_str""".replace(\',\', \'\')'
             mined:+Body= "re.findall('\\\\[(.*?)\\\\]', example_str)"
        mined:+Body, -NL= "re.findall('\\\\[(.*?)\\\\]', example_str)"
      mined:+Body, -Code= "re.findall('\\\\w+', example_str)"

================================================================================

QUESTION: idx=317    id=17284947
-------------------------------------INPUTS-------------------------------------

tags: regex
score: 9
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['example_str']}
intent: use a regex to get all text in a string `example_str` that is not surrounded by square brackets
body(Some added characters for better readability):
	I'm trying to grab any text outside of brackets with a regex.
	Example string
	Josie Smith [3996 COLLEGE AVENUE, SOMETOWN, MD 21003]Mugsy Dog Smith
	  [2560 OAK ST, GLENMEADE, WI 14098]
	
	<p>I'm able to get the text 
	inside  the square brackets successfully with:
	
	start_block
	addrs = re.findall(r"\[(.*?)\]", example_str)
	print addrs
	[u'3996 COLLEGE AVENUE, SOMETOWN, MD 21003',u'2560 OAK ST, GLENMEADE, WI 14098']    
	
	<p>but I'm having trouble getting anything 
	outside  of the square brackets.  I've tried something like the following:
	
	start_block
	names = re.findall(r"(.*?)\[.*\]+", example_str)
	but that only finds the first name:
	
	start_block
	print names
	[u'Josie Smith ']
	
	<p>So far I've only seen a string containing one to two 
	`name [address]` combos, but I'm assuming there could be any number of them in a string.


-------------------------------------OUTPUT-------------------------------------

                Expected= "re.findall('(.*?)(?:\\\\[.*?\\\\]|$)', example_str)"
           base:Baseline= "re.findall('(\\\\w+)\\\\w\\\\w+\\\\W+\\\\w|\\\\W+)', example_str)"
           base:+Canonic= "re.findall('\\\\w+', example_str)"
           body:Baseline= "re.findall('\\\\[.*\\\\]+', example_str)"
              body:-Code= "re.findall('\\\\w+', example_str)"
          mined:Baseline= "re.findall('\\\\w+', example_str)"
             mined:+Body= "re.findall('\\\\[(.*?)\\\\]', example_str)"
        mined:+Body, -NL= "re.findall('\\\\[(.*?)\\\\]', example_str)"
      mined:+Body, -Code= "re.findall('\\\\w+', example_str)"

================================================================================

QUESTION: idx=318    id=14182339
-------------------------------------INPUTS-------------------------------------

tags: regex, regex-alternation
score: 12
slot_map: {'key': ['str_0'], 'quote': ["'"], 'type': ['str'], 'value': ['(zyx)bc']}
intent: get whatever is between parentheses as a single match, and any char outside as an individual match in string '(zyx)bc'
body(Some added characters for better readability):
	I ran into a small problem using Python Regex.
	Suppose this is the input:
	
	start_block
	(zyx)bc
	What I'm trying to achieve is obtain whatever is between parentheses as a single match, and any char outside as an individual match. The desired result would be along the lines of:
	
	start_block
	['zyx','b','c']
	The order of matches should be kept.
	I've tried obtaining this with Python 3.3, but can't seem to figure out the correct Regex. So far I have:
	
	start_block
	matches = findall(r'\((.*?)\)|\w', '(zyx)bc')
	
	`print(matches)` yields the following:
	
	start_block
	['zyx','','']
	Any ideas what I'm doing wrong?


-------------------------------------OUTPUT-------------------------------------

                Expected= "re.findall('\\\\(.+?\\\\)|\\\\w', '(zyx)bc')"
           base:Baseline= "re.sub('(?:\\\\w+)', '(zyx)bc')"
           base:+Canonic= "re.findall('([^a-zA-Z]', '(zyx)bc')"
           body:Baseline= "match(re.findall('\\\\((.*?)\\\\)', '(zyx)bc')"
              body:-Code= "re.findall('\\\\w+', '(zyx)bc')"
          mined:Baseline= "re.findall('(zyx)bc', 'whatever')"
             mined:+Body= "match = re.compile('\\\\((.*?)\\\\)', '(zyx)bc')"
        mined:+Body, -NL= "re.findall('\\\\((.*?)\\\\)|\\\\w', '(zyx)bc')"
      mined:+Body, -Code= "print(re.findall('\\\\([^\\\\]*)', '(zyx)bc', my_string))"

================================================================================

QUESTION: idx=319    id=14182339
-------------------------------------INPUTS-------------------------------------

tags: regex, regex-alternation
score: 12
slot_map: {'key': ['str_0', 'str_1'], 'quote': ["'", "'"], 'type': ['str', 'str'], 'value': ['\\((.*?)\\)|(\\w)', '(zyx)bc']}
intent: match regex '\\((.*?)\\)|(\\w)' with string '(zyx)bc'
body(Some added characters for better readability):
	I ran into a small problem using Python Regex.
	Suppose this is the input:
	
	start_block
	(zyx)bc
	What I'm trying to achieve is obtain whatever is between parentheses as a single match, and any char outside as an individual match. The desired result would be along the lines of:
	
	start_block
	['zyx','b','c']
	The order of matches should be kept.
	I've tried obtaining this with Python 3.3, but can't seem to figure out the correct Regex. So far I have:
	
	start_block
	matches = findall(r'\((.*?)\)|\w', '(zyx)bc')
	
	`print(matches)` yields the following:
	
	start_block
	['zyx','','']
	Any ideas what I'm doing wrong?


-------------------------------------OUTPUT-------------------------------------

                Expected= "re.findall('\\\\((.*?)\\\\)|(\\\\w)', '(zyx)bc')"
           base:Baseline= "re.compile('\\\\((.*?)\\\\)|(\\\\w)', '(zyx)bc')"
           base:+Canonic= "re.match('\\\\((.*?)\\\\)|(\\\\w)', '(zyx)bc')"
           body:Baseline= "match(re.findall('\\\\((.*?)\\\\)|(\\\\w)', '(zyx)bc')"
              body:-Code= "re.match('\\\\((.*?)\\\\)|(\\\\w)', '(zyx)bc')"
          mined:Baseline= "re.match('\\\\((.*?)\\\\)|(\\\\w)', '(zyx)bc')"
             mined:+Body= "match = re.compile('\\\\((.*?)\\\\)|(\\\\w)', '(zyx)bc')"
        mined:+Body, -NL= "match = re.match('\\\\((.*?)\\\\)|(\\\\w)', '(zyx)bc')"
      mined:+Body, -Code= "re.findall('\\\\((.*?)\\\\)|(\\\\w)', '(zyx)bc')"

================================================================================

QUESTION: idx=320    id=14182339
-------------------------------------INPUTS-------------------------------------

tags: regex, regex-alternation
score: 12
slot_map: {'key': ['str_0', 'str_1'], 'quote': ['`', '`'], 'type': ['str', 'str'], 'value': ['|', '(zyx)bc']}
intent: match multiple regex patterns with the alternation operator `|` in a string `(zyx)bc`
body(Some added characters for better readability):
	I ran into a small problem using Python Regex.
	Suppose this is the input:
	
	start_block
	(zyx)bc
	What I'm trying to achieve is obtain whatever is between parentheses as a single match, and any char outside as an individual match. The desired result would be along the lines of:
	
	start_block
	['zyx','b','c']
	The order of matches should be kept.
	I've tried obtaining this with Python 3.3, but can't seem to figure out the correct Regex. So far I have:
	
	start_block
	matches = findall(r'\((.*?)\)|\w', '(zyx)bc')
	
	`print(matches)` yields the following:
	
	start_block
	['zyx','','']
	Any ideas what I'm doing wrong?


-------------------------------------OUTPUT-------------------------------------

                Expected= "re.findall('\\\\(.*?\\\\)|\\\\w', '(zyx)bc')"
           base:Baseline= "re.sub('(zyx)bc)', '|')"
           base:+Canonic= "re.findall('(zyx)bc', '|')"
           body:Baseline= "match(re.findall('\\\\((.*?)\\\\)', '(zyx)bc')"
              body:-Code= "re.match('|', (zyx)bc)"
          mined:Baseline= "re.findall('(zyx)bc', '|')"
             mined:+Body= "match = re.compile('\\\\((.*?)\\\\)|(zyx)bc')"
        mined:+Body, -NL= "match = re.findall('\\\\((.*?)\\\\)|\\\\w', (zyx)bc)"
      mined:+Body, -Code= "re.findall('\\\\([^\\\\]*)|', '(zyx)bc')"

================================================================================

QUESTION: idx=321    id=7126916
-------------------------------------INPUTS-------------------------------------

tags: string, list
score: 62
slot_map: {'key': ['var_0', 'str_0'], 'quote': ['`', "'"], 'type': ['var', 'str'], 'value': ['elements', '%{0}%']}
intent: formate each string cin list `elements` into pattern '%{0}%'
body(Some added characters for better readability):
	
	<p>I have a list of strings in Python - 
	`elements`
	. I would like to edit each 
	`element`
	 in 
	`elements`. See the code below (it doesn't work, but you'll get the idea):
	
	start_block
	for element in elements:
	    element = "%" + element + "%"
	Is there a way to do this?


-------------------------------------OUTPUT-------------------------------------

                Expected= "elements = ['%{0}%'.format(element) for element in elements]"
           base:Baseline= '"""""".join(elements, \'%{0}%\')'
           base:+Canonic= "re.compile('%{0}%', elements)"
           body:Baseline= "print('%{0}%'.join(elements))"
              body:-Code= "pattern = re.compile('%{0}%', elelements)"
          mined:Baseline= "print('%{0}%'.format(elements))"
             mined:+Body= '"""""".join(elements)'
        mined:+Body, -NL= "print('%{0}%'.format(element))"
      mined:+Body, -Code= "'%{0}%'.format(elements))"

================================================================================

QUESTION: idx=322    id=3595685
-------------------------------------INPUTS-------------------------------------

tags: 
score: 5
slot_map: {'key': ['str_0', 'str_1'], 'quote': ["'", "'"], 'type': ['str', 'str'], 'value': ['background-process', 'arguments']}
intent: open a background process 'background-process' with arguments 'arguments'
body(Some added characters for better readability):
	My python script needs to start a background process and then continue processing to completion without waiting for a return.
	The background script will process for some time and will not generate any screen output.
	There is no inter-process data required.
	I have tried using various methods subprocess, multiprocessing but am clearly missing something.
	Does anyone have a simple example?
	TIA


-------------------------------------OUTPUT-------------------------------------

                Expected= "subprocess.Popen(['background-process', 'arguments'])"
           base:Baseline= "os.system('background-process', arguments='Arguments')"
           base:+Canonic= "background_process = open('background-process', 'arguments')"
           body:Baseline= "backgroundprocess = os.system('background-process', arguments='arguments')"
              body:-Code= "backgroundProcess.call(['Arguments'])"
          mined:Baseline= "subprocess.call(['background-process', 'arguments'])"
             mined:+Body= "subprocess.call(['background-process', 'arguments'])"
        mined:+Body, -NL= "process.call(['background-process', 'arguments'])"
      mined:+Body, -Code= "Popen(['background-process', 'arguments'])"

================================================================================

QUESTION: idx=323    id=18453566
-------------------------------------INPUTS-------------------------------------

tags: list, dictionary, key
score: 210
slot_map: {'key': ['str_0', 'str_1'], 'quote': ["'", "'"], 'type': ['str', 'str'], 'value': ['mydict', 'mykeys']}
intent: get list of values from dictionary 'mydict' w.r.t. list of keys 'mykeys'
body(Some added characters for better readability):
	Is there a built-in/quick way to use a list of keys to a dictionary to get a list of corresponding items?
	For instance I have:
	
	
	start_block
	>>>mydict = {'one': 1, 'two': 2, 'three': 3}
	>>>mykeys = ['three', 'one']
	...
	
	<p>How can I use 
	`mykeys` to get the corresponding values in the dictionary as a list?
	
	
	start_block
	>>>mydict.WHAT_GOES_HERE(mykeys)
	...[3, 1]


-------------------------------------OUTPUT-------------------------------------

                Expected= '[mydict[x] for x in mykeys]'
           base:Baseline= "[k for k, v in list(mydict.keys()) if 'mykeys' in k]"
           base:+Canonic= "[k for k, v in mydict.items() if 'mykeys' in k]"
           body:Baseline= '[k for k, v in list(mydict.values()) if v in k]'
              body:-Code= '[k for k, v in list(mydict.items()) if v in k]'
          mined:Baseline= "[key for key, value in list(mydict.items()) if 'mykeys' in key]"
             mined:+Body= '[list(mydict.keys() for _ in range(len(mykeys))]'
        mined:+Body, -NL= '{k: v for k, v in list(mydict.items()) if v}'
      mined:+Body, -Code= '[k for k, v in list(myDict.items()) for k in mykeys]'

================================================================================

QUESTION: idx=324    id=12692135
-------------------------------------INPUTS-------------------------------------

tags: 
score: 5
slot_map: {'key': ['str_0', '[str_0]'], 'quote': ['`', '`'], 'type': ['str', 'str'], 'value': ["[('Name', 'Joe'), ('Age', 22)]", "[('Name', 'Joe'), ('Age', 22)]"]}
intent: convert list `[('name', 'joe'), ('age', 22)]` into a dictionary
body(Some added characters for better readability):
	I have two lists:
	
	start_block
	header = ["Name", "Age"]
	detail = ["Joe", 22, "Dave", 43, "Herb", 32]
	And would like to create a list of dictonaries like this:
	
	start_block
	[{"Name": "Joe", "Age": 22}, {"Name": "Dave", "Age": 32}, {"Name": "Herb", "Age": 32}]
	
	<p>This method 
	zip  gets me partially there, but only adds the first set of values to the dictionary:
	
	
	start_block
	>>>dict(zip(header, detail))
	...{'Age': 22, 'Name': 'Joe'}
	
	<p>How can I output as one dictionary for all values in the 
	`detail`
	 list? I found this 
	answer 
	, but this depends on 
	`detail` containing nested lists.


-------------------------------------OUTPUT-------------------------------------

                Expected= "dict([('Name', 'Joe'), ('Age', 22)])"
           base:Baseline= "dict([('name', 'joe'), ('age', 22)]"
           base:+Canonic= "dict([('Name', 'Joe'), ('Age', 22)]).split()"
           body:Baseline= 'dict(zip(header, detail))'
              body:-Code= "dict((k, v) for k, v in ['name', 'joe'), ('age', 22)]"
          mined:Baseline= "dict(zip(('name', 'joe'), ('age', 22))"
             mined:+Body= 'dict(zip(header, detail))'
        mined:+Body, -NL= 'dict(zip(header, detail))'
      mined:+Body, -Code= "zip(*[('name', 'joe'), ('age', 22)]"

================================================================================

QUESTION: idx=325    id=14401047
-------------------------------------INPUTS-------------------------------------

tags: numpy
score: 4
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['data']}
intent: average each two columns of array `data`
body(Some added characters for better readability):
	Right now I am doing this by iterating, but there has to be a way to accomplish this task using numpy functions.  My goal is to take a 2D array and average J columns at a time, producing a new array with the same number of rows as the original, but with columns/J columns.
	So I want to take this:
	
	start_block
	J = 2 // two columns averaged at a time
	[[1 2 3 4]
	 [4 3 7 1]
	 [6 2 3 4]
	 [3 4 4 1]]
	and produce this:
	
	start_block
	[[1.5 3.5]
	 [3.5 4.0]
	 [4.0 3.5]
	 [3.5 2.5]]
	Is there a simple way to accomplish this task?  I also need a way such that if I never end up with an unaveraged remainder column.  So if, for example, I have an input array with 5 columns and J=2, I would average the first two columns, then the last three columns.
	Any help you can provide would be great.


-------------------------------------OUTPUT-------------------------------------

                Expected= 'data.reshape(-1, j).mean(axis=1).reshape(data.shape[0], -1)'
           base:Baseline= 'np.arange(data, axis=0)'
           base:+Canonic= 'np.arange(data, axis=1)'
           body:Baseline= 'np.arange(data, axis=1)'
              body:-Code= 'np.arange(data, axis=2)'
          mined:Baseline= 'data[np.mean(axis=1), axis=1)]'
             mined:+Body= 'data[:, ([1, 2])]'
        mined:+Body, -NL= 'np.mean(data, axis=1)'
      mined:+Body, -Code= 'data[:, (np.mean(axis=1))]'

================================================================================

QUESTION: idx=326    id=18886596
-------------------------------------INPUTS-------------------------------------

tags: string, replace
score: 42
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['s']}
intent: double backslash escape all double quotes in string `s`
body(Some added characters for better readability):
	Given a string in python, such as:
	
	start_block
	s = 'This sentence has some "quotes" in it\n'
	I want to create a new copy of that string with any quotes escaped (for further use in Javascript). So, for example, what I want is to produce this:
	
	start_block
	'This sentence has some \"quotes\" in it\n'
	
	<p>I tried using 
	`replace()`, such as:
	
	start_block
	s.replace('"', '\"')
	but that returns the same string. So then I tried this:
	
	start_block
	s.replace('"', '\\"')
	but that returns double-escaped quotes, such as:
	
	start_block
	'This sentence has some \\"quotes\\" in it.\n'
	
	<p>How to replace 
	`"`
	 with 
	`\"`?
	UPDATE:
	I need as output from this copyable text that shows both the quotes and the newlines as escaped.  In other words, I want to be able to copy:
	
	start_block
	'This sentence has some \"quotes\" in it.\n'
	
	<p>If I use the raw string and 
	`print`
	 the result I get the correctly escaped quote, but the escaped newline doesn't print. If I don't use 
	`print` then I get my newlines but double-escaped quotes. How can I create a string I can copy that shows both newline and quote escaped?


-------------------------------------OUTPUT-------------------------------------

                Expected= 'print(s.encode(\'unicode-escape\').replace(\'"\', \'\\\\"\'))'
           base:Baseline= "re.sub('(\\\\w+)', s)"
           base:+Canonic= "re.sub('\\\\w+', s)"
           body:Baseline= "re.sub('\\\\n\\\\s\\\\n', s)"
              body:-Code= "re.sub('\\\\w+', s)"
          mined:Baseline= '""" """.join(re.split(\'\\\\s+\', s))'
             mined:+Body= '"""This sentence has some "quotes" in it\\\\n"""'
        mined:+Body, -NL= 's.replace(\'"\', \'\\\\"\')'
      mined:+Body, -Code= "print(re.sub('[^\\\\w]+', '', s))"

================================================================================

QUESTION: idx=327    id=5932059
-------------------------------------INPUTS-------------------------------------

tags: regex, split, whitespace
score: 11
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: split a string into a list of words and whitespace
body(Some added characters for better readability):
	I need to split a string into an array on word boundaries (whitespace) while maintaining the whitespace.
	For example:
	
	start_block
	'this is  a\nsentence'
	Would become
	
	start_block
	['this', ' ', 'is', '  ', 'a' '\n', 'sentence']
	
	<p>I know about 
	str.partition 
	 and 
	re.split 
	, but neither of them quite do what I want and there is no 
	`re.partition`.
	How should I partition strings on whitespace in Python with reasonable efficiency?


-------------------------------------OUTPUT-------------------------------------

                Expected= "re.split('(\\\\W+)', s)"
           base:Baseline= "re.split('[^a-zA-Z]*', '', s)"
           base:+Canonic= "re.split('[^a-zA-Z]', '', '', '', var_name)"
           body:Baseline= "[int(x) for x in re.split('\\n')]"
              body:-Code= "re.split('\\\\w+', '', str)"
          mined:Baseline= '[word.split() for word in string]'
             mined:+Body= "['this', '', 'is', ' ', 'a\\n', 'sentence']"
        mined:+Body, -NL= "re.findall('\\\\n', s)"
      mined:+Body, -Code= '[word.split() for word in s.splitlines()]'

================================================================================

QUESTION: idx=328    id=9938130
-------------------------------------INPUTS-------------------------------------

tags: pandas
score: 5
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: plotting stacked barplots on a panda data frame
body(Some added characters for better readability):
	This is my first attempt at playing with Pandas library after attending Wesley's tutorial at pycon.
	After poking around a bit with the dataframe I am glad I was able to massage the data in the way I wanted but having trouble in plotting it. I guess it also points to my naiveness with the matplotlib library.
	What I have is pandas Series object with the following data. I would like to plot as a barplot with col 1 ('file') as the labels oriented vertically.
	
	start_block
	sample data here:
	http://pastebin.com/y2w0uJPQ 


-------------------------------------OUTPUT-------------------------------------

                Expected= "df.plot(kind='barh', stacked=True)"
           base:Baseline= 'df.plot(df.barplots, axis=1)'
           base:+Canonic= 'panda.plot(x, y, y)'
           body:Baseline= 'pandas.set_barplot(list(range(1)), axis=1)'
              body:-Code= 'pd.concat([pd.Series.barplots()], axis=1)'
          mined:Baseline= 'df.plot(list(range(10)), stacked=True)'
             mined:+Body= "df.plot(x, y, 'file')"
        mined:+Body, -NL= "df.groupby('col').size().plot(kind='bar')"
      mined:+Body, -Code= "df.plot(kind='bar', stacked=True)"

================================================================================

QUESTION: idx=329    id=35945473
-------------------------------------INPUTS-------------------------------------

tags: dictionary
score: 17
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['myDictionary']}
intent: reverse the keys and values in a dictionary `mydictionary`
body(Some added characters for better readability):
	I would like to write a function that receives a dictionary as input argument and returns a reverse of the input dictionary where the values of the original dictionary are used as keys for the returned dictionary and the keys of the original dictionary are used as value for the returned dictionary as explained below: 
	
	start_block
	dict = {'Accurate': ['exact', 'precise'], 
	        'exact': ['precise'], 
	        'astute': ['Smart', 'clever'], 
	        'smart': ['clever', 'bright', 'talented']}
	to
	
	start_block
	dict = {'precise': ['accurate', 'exact'], 
	        'clever': ['astute', 'smart'], 
	        'talented': ['smart'], 
	        'bright': ['smart'],
	        'exact': ['accurate'],
	        'smart': ['astute']}
	The list of values in the returned dictionary should be sorted in ascending order.  Capitalization does not matter. This means that all the words should be converted to lower case letters. For example the word "Accurate" is capitalized in the original dictionary but in the returned dictionary it is written with all lower case letters.
	
	start_block
	#My code is:
	from collections import defaultdict
	def reverse_dictionary(input_dict):
	   d = defaultdict(list)
	   for v,k in input_dict.items():
	       d[k].append(v)
	       return d
	But it returns this error though:
	
	start_block
	Error in evaluating function:
	TypeError at line 6
	unhashable type: 'list'


-------------------------------------OUTPUT-------------------------------------

                Expected= '{i[1]: i[0] for i in list(myDictionary.items())}'
           base:Baseline= 'dict((k, v) for k, v in list(mydictionary.items()))'
           base:+Canonic= 'dict((k, v) for k, v in myDictionary.values())'
           body:Baseline= 'dict((k, v) for k, v in mydictionary.items())'
              body:-Code= 'dict((k, v) for k, v in list(myDictionary.items()))'
          mined:Baseline= 'dict((k, v) for k, v in list(myDict.items()))'
             mined:+Body= 'dict((v, k) for v, k in list(mydictionary.items()))'
        mined:+Body, -NL= '{k: v for k, v in list(d.items()) for d in v}'
      mined:+Body, -Code= "[(v, k) for k, v in list(myDictionary.items()) if k != 'accurate']"

================================================================================

QUESTION: idx=330    id=30729735
-------------------------------------INPUTS-------------------------------------

tags: string, list
score: 6
slot_map: {'key': ['str_0', 'str_1', 'str_2'], 'quote': ["'", "'", "'"], 'type': ['str', 'str', 'str'], 'value': ['how', 'what', 'myList']}
intent: finding the index of elements containing substring 'how' and 'what' in a list of strings 'mylist'.
body(Some added characters for better readability):
	I have a list 
	
	start_block
	myList = ["what is your name", "Hi, how are you",
	          "What about you", "How about a coffee", "How are you"]
	
	<p>Now I want to search index of all occurrence of 
	`"How"`
	 and 
	`"what"`. How can I do this in Pythonic way?


-------------------------------------OUTPUT-------------------------------------

                Expected= "[i for i, j in enumerate(myList) if 'how' in j.lower() or 'what' in j.lower()]"
           base:Baseline= "[i for i, j in mylist if 'how' in j]"
           base:+Canonic= "[i for i in myList if 'how' in i]"
           body:Baseline= "myList.index('How', 'What')"
              body:-Code= "mylist.index('how', 'what')"
          mined:Baseline= "[i for i, x in enumerate(myList) if x.startswith('how')]"
             mined:+Body= "[x for x in myList if x.startswith('How')]"
        mined:+Body, -NL= "[i for i, j in enumerate(myList) if j == 'How']"
      mined:+Body, -Code= '[i for i, j in enumerate(mylist) if i == j]'

================================================================================

QUESTION: idx=331    id=1303243
-------------------------------------INPUTS-------------------------------------

tags: string, types, compatibility
score: 433
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['obj']}
intent: check if object `obj` is a string
body(Some added characters for better readability):
	How can I check if a Python object is a string (either regular or Unicode)?


-------------------------------------OUTPUT-------------------------------------

                Expected= 'isinstance(obj, str)'
           base:Baseline= 'print(obj.__dict__))'
           base:+Canonic= 'if not obj:\n    pass'
           body:Baseline= "obj.is_string().strftime('\\n')"
              body:-Code= 'if (obj.isString())):\n    pass'
          mined:Baseline= 'isinstance(obj, str, None)'
             mined:+Body= "isinstance(obj, 'string')"
        mined:+Body, -NL= 'if obj.isalpha()):\n    pass'
      mined:+Body, -Code= 'obj.str.isdigit()'

================================================================================

QUESTION: idx=332    id=1303243
-------------------------------------INPUTS-------------------------------------

tags: string, types, compatibility
score: 433
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['o']}
intent: check if object `o` is a string
body(Some added characters for better readability):
	How can I check if a Python object is a string (either regular or Unicode)?


-------------------------------------OUTPUT-------------------------------------

                Expected= 'isinstance(o, str)'
           base:Baseline= 'if (isinstance(o):\n    pass'
           base:+Canonic= 'if not o:\n    pass'
           body:Baseline= 'if o == string:\n    pass'
              body:-Code= 'if (not a string):\n    pass'
          mined:Baseline= 'if o.isdigit():\n    pass'
             mined:+Body= 'if o.isdigit():\n    pass'
        mined:+Body, -NL= 'if o.isdigit():\n    pass'
      mined:+Body, -Code= "isinstance(o, 'Hello')"

================================================================================

QUESTION: idx=333    id=1303243
-------------------------------------INPUTS-------------------------------------

tags: string, types, compatibility
score: 433
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['o']}
intent: check if object `o` is a string
body(Some added characters for better readability):
	How can I check if a Python object is a string (either regular or Unicode)?


-------------------------------------OUTPUT-------------------------------------

                Expected= 'type(o) is str'
           base:Baseline= 'if (isinstance(o):\n    pass'
           base:+Canonic= 'if not o:\n    pass'
           body:Baseline= 'if o == string:\n    pass'
              body:-Code= 'if (not a string):\n    pass'
          mined:Baseline= 'if o.isdigit():\n    pass'
             mined:+Body= 'if o.isdigit():\n    pass'
        mined:+Body, -NL= 'if o.isdigit():\n    pass'
      mined:+Body, -Code= "isinstance(o, 'Hello')"

================================================================================

QUESTION: idx=334    id=1303243
-------------------------------------INPUTS-------------------------------------

tags: string, types, compatibility
score: 433
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['o']}
intent: check if object `o` is a string
body(Some added characters for better readability):
	How can I check if a Python object is a string (either regular or Unicode)?


-------------------------------------OUTPUT-------------------------------------

                Expected= 'isinstance(o, str)'
           base:Baseline= 'if (isinstance(o):\n    pass'
           base:+Canonic= 'if not o:\n    pass'
           body:Baseline= 'if o == string:\n    pass'
              body:-Code= 'if (not a string):\n    pass'
          mined:Baseline= 'if o.isdigit():\n    pass'
             mined:+Body= 'if o.isdigit():\n    pass'
        mined:+Body, -NL= 'if o.isdigit():\n    pass'
      mined:+Body, -Code= "isinstance(o, 'Hello')"

================================================================================

QUESTION: idx=335    id=1303243
-------------------------------------INPUTS-------------------------------------

tags: string, types, compatibility
score: 433
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['obj_to_test']}
intent: check if `obj_to_test` is a string
body(Some added characters for better readability):
	How can I check if a Python object is a string (either regular or Unicode)?


-------------------------------------OUTPUT-------------------------------------

                Expected= 'isinstance(obj_to_test, str)'
           base:Baseline= 'if not obj_to_test:\n    pass'
           base:+Canonic= 'if not obj_to_test:\n    pass'
           body:Baseline= 'obj_to_test.isdigit()'
              body:-Code= 'if obj_to_test:\n    pass'
          mined:Baseline= 'obj_to_test.isdigit()'
             mined:+Body= 'obj_to_test.isdigit()'
        mined:+Body, -NL= 'obj_to_test.isdigit()'
      mined:+Body, -Code= 'obj_to_test.isdigit()'

================================================================================

QUESTION: idx=336    id=8177079
-------------------------------------INPUTS-------------------------------------

tags: list
score: 215
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['list1', 'list2']}
intent: append list `list1` to `list2`
body(Some added characters for better readability):
	I am trying to understand if it makes sense to take the content of a list and append it to another list.
	I have the first list created through a loop function, that will get specific lines out of a file and will save them in a list.
	Then a second list is used to save these lines, and start a new cycle over another file.
	My idea was to get the list once that the for cycle is done, dump it into the second list, then start a new cycle, dump the content of the first list again into the second but appending it, so the second list will be the sum of all the smaller list files created in my loop. The list has to be appended only if certain conditions met. 
	It looks like something similar to this:
	
	start_block
	# This is done for each log in my directory, i have a loop running
	for logs in mydir:
	    for line in mylog:
	        #...if the conditions are met
	        list1.append(line)
	    for item in list1:
	        if "string" in item: #if somewhere in the list1 i have a match for a string
	            list2.append(list1) # append every line in list1 to list2
	            del list1 [:] # delete the content of the list1
	            break
	        else:
	            del list1 [:] # delete the list content and start all over
	Does this makes sense or should I go for a different route?
	I need something efficient that would not take up too many cycles, since the list of logs is long and each text file is pretty big; so I thought that the lists would fit the purpose.


-------------------------------------OUTPUT-------------------------------------

                Expected= 'list2.extend(list1)'
           base:Baseline= 'list2 = [x for x in zip(list1, list2)]'
           base:+Canonic= 'list2.append(list1)'
           body:Baseline= 'list1.append(list2)'
              body:-Code= 'list1 = list2.append(list1)'
          mined:Baseline= 'list2.append(list1)'
             mined:+Body= 'list1.append(list2)'
        mined:+Body, -NL= 'list1.append(list1)'
      mined:+Body, -Code= 'list1.append(list2)'

================================================================================

QUESTION: idx=337    id=8177079
-------------------------------------INPUTS-------------------------------------

tags: list
score: 215
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['mylog', 'list1']}
intent: append list `mylog` to `list1`
body(Some added characters for better readability):
	I am trying to understand if it makes sense to take the content of a list and append it to another list.
	I have the first list created through a loop function, that will get specific lines out of a file and will save them in a list.
	Then a second list is used to save these lines, and start a new cycle over another file.
	My idea was to get the list once that the for cycle is done, dump it into the second list, then start a new cycle, dump the content of the first list again into the second but appending it, so the second list will be the sum of all the smaller list files created in my loop. The list has to be appended only if certain conditions met. 
	It looks like something similar to this:
	
	start_block
	# This is done for each log in my directory, i have a loop running
	for logs in mydir:
	    for line in mylog:
	        #...if the conditions are met
	        list1.append(line)
	    for item in list1:
	        if "string" in item: #if somewhere in the list1 i have a match for a string
	            list2.append(list1) # append every line in list1 to list2
	            del list1 [:] # delete the content of the list1
	            break
	        else:
	            del list1 [:] # delete the list content and start all over
	Does this makes sense or should I go for a different route?
	I need something efficient that would not take up too many cycles, since the list of logs is long and each text file is pretty big; so I thought that the lists would fit the purpose.


-------------------------------------OUTPUT-------------------------------------

                Expected= 'list1.extend(mylog)'
           base:Baseline= 'list1.append(mylog)'
           base:+Canonic= 'list1.append(mylog)'
           body:Baseline= 'list1.append(mylog)'
              body:-Code= 'list1.append(mylog)'
          mined:Baseline= 'list1.append(myLog)'
             mined:+Body= 'list1.append(mylog)'
        mined:+Body, -NL= 'list1.append(mylog)'
      mined:+Body, -Code= 'list1.append(mylog)'

================================================================================

QUESTION: idx=338    id=8177079
-------------------------------------INPUTS-------------------------------------

tags: list
score: 215
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['a', 'c']}
intent: append list `a` to `c`
body(Some added characters for better readability):
	I am trying to understand if it makes sense to take the content of a list and append it to another list.
	I have the first list created through a loop function, that will get specific lines out of a file and will save them in a list.
	Then a second list is used to save these lines, and start a new cycle over another file.
	My idea was to get the list once that the for cycle is done, dump it into the second list, then start a new cycle, dump the content of the first list again into the second but appending it, so the second list will be the sum of all the smaller list files created in my loop. The list has to be appended only if certain conditions met. 
	It looks like something similar to this:
	
	start_block
	# This is done for each log in my directory, i have a loop running
	for logs in mydir:
	    for line in mylog:
	        #...if the conditions are met
	        list1.append(line)
	    for item in list1:
	        if "string" in item: #if somewhere in the list1 i have a match for a string
	            list2.append(list1) # append every line in list1 to list2
	            del list1 [:] # delete the content of the list1
	            break
	        else:
	            del list1 [:] # delete the list content and start all over
	Does this makes sense or should I go for a different route?
	I need something efficient that would not take up too many cycles, since the list of logs is long and each text file is pretty big; so I thought that the lists would fit the purpose.


-------------------------------------OUTPUT-------------------------------------

                Expected= 'c.extend(a)'
           base:Baseline= 'c = c[::-1]'
           base:+Canonic= 'c.append(a)'
           body:Baseline= 'c = [a[:] for a in c]'
              body:-Code= 'c = [a.append(c))'
          mined:Baseline= 'c = c.append(a)'
             mined:+Body= 'list(a) + list(c)'
        mined:+Body, -NL= 'list1.append(a, c)'
      mined:+Body, -Code= 'c = [int(i) for i in a]'

================================================================================

QUESTION: idx=339    id=8177079
-------------------------------------INPUTS-------------------------------------

tags: list
score: 215
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['mylog', 'list1']}
intent: append items in list `mylog` to `list1`
body(Some added characters for better readability):
	I am trying to understand if it makes sense to take the content of a list and append it to another list.
	I have the first list created through a loop function, that will get specific lines out of a file and will save them in a list.
	Then a second list is used to save these lines, and start a new cycle over another file.
	My idea was to get the list once that the for cycle is done, dump it into the second list, then start a new cycle, dump the content of the first list again into the second but appending it, so the second list will be the sum of all the smaller list files created in my loop. The list has to be appended only if certain conditions met. 
	It looks like something similar to this:
	
	start_block
	# This is done for each log in my directory, i have a loop running
	for logs in mydir:
	    for line in mylog:
	        #...if the conditions are met
	        list1.append(line)
	    for item in list1:
	        if "string" in item: #if somewhere in the list1 i have a match for a string
	            list2.append(list1) # append every line in list1 to list2
	            del list1 [:] # delete the content of the list1
	            break
	        else:
	            del list1 [:] # delete the list content and start all over
	Does this makes sense or should I go for a different route?
	I need something efficient that would not take up too many cycles, since the list of logs is long and each text file is pretty big; so I thought that the lists would fit the purpose.


-------------------------------------OUTPUT-------------------------------------

                Expected= 'for line in mylog:\n    list1.append(line)'
           base:Baseline= 'list1 = [item for item in mylog if item not in list1]'
           base:+Canonic= 'list1 = [x for x in mylog if x.isdigit()]'
           body:Baseline= 'list1 = [i for i in mylog]'
              body:-Code= 'list1 = [item for item in mylog]'
          mined:Baseline= 'list1.append(myLog)'
             mined:+Body= "list1 = [line for line in mylog if 'string' in line]"
        mined:+Body, -NL= "list1 = [line for line in mylog if 'string' in line]"
      mined:+Body, -Code= 'list1.append(myLog)'

================================================================================

QUESTION: idx=340    id=4126227
-------------------------------------INPUTS-------------------------------------

tags: list, tuples
score: 5
slot_map: {'key': ['var_0', 'str_0', 'var_1', '[str_0]'], 'quote': ['`', "'", '`', "'"], 'type': ['var', 'str', 'var', 'str'], 'value': ['a', '[0][0] [0][2]', 'b', '[0][0] [0][2]']}
intent: append a tuple of elements from list `a` with indexes '[0][0] [0][2]' to list `b`
body(Some added characters for better readability):
	What's the proper syntax for adding a recomposed tuple to a list?
	For example, if I had two lists:
	
	
	start_block
	>>>a = [(1,2,3),(4,5,6)]
	>>>b = [(0,0)]
	...
	Then I would expect the following to work:
	
	
	start_block
	>>>b.append((a[0][0],a[0,2]))
	...Traceback (most recent call last):
	  File " <stdin>", line 1, in <module>
	TypeError: list indices must be integers, not tuple
	Furthermore, when it informs me that indices must be integers, how come this works?
	
	
	start_block
	>>>b.append((7,7))
	>>>b
	...[(0, 0), (7, 7)]


-------------------------------------OUTPUT-------------------------------------

                Expected= 'b.append((a[0][0], a[0][2]))'
           base:Baseline= 'b = [[0][0][0][2] for i in zip(a, b)]'
           base:+Canonic= "var_1 = [x for x in var_0 if x!='str_0'])"
           body:Baseline= 'b = [(a[0][0], (0, 2)]'
              body:-Code= 'b = [(i, j) for i, j in zip(a, b)]'
          mined:Baseline= 'b = tuple([0][0][0][2])'
             mined:+Body= 'b = [(0, 0], (7, 7)]'
        mined:+Body, -NL= 'b = [(x[0] for x in a]'
      mined:+Body, -Code= 'b = [(i + j) for i, j in zip(a, b)]'

================================================================================

QUESTION: idx=341    id=34902378
-------------------------------------INPUTS-------------------------------------

tags: flask
score: 71
slot_map: {'key': ['var_0', 'str_0'], 'quote': ['`', '`'], 'type': ['var', 'str'], 'value': ['SECRET_KEY', 'Your_secret_string']}
intent: initialize `secret_key` in flask config with `your_secret_string `
body(Some added characters for better readability):
	I am trying to set up Flask-Debugtoolbar, but I get the message "DebugToolBar requires a SECRET_KEY".  Where do I get the secret key?


-------------------------------------OUTPUT-------------------------------------

                Expected= "app.config['SECRET_KEY'] = 'Your_secret_string'"
           base:Baseline= 'your_secret_string = flask.config(key=lambda x: x[1])'
           base:+Canonic= "SECRET_KEY = flask.config('Your_secret_string')"
           body:Baseline= 'your_secret_key = config.SECRET_KEY'
              body:-Code= "your_secret_string = config.get('DebugToolBar requires a SECRET_KEY')"
          mined:Baseline= "app.config['secret_key'] = 'your_secret_string'"
             mined:+Body= 'app.run(debug=True)'
        mined:+Body, -NL= 'app.run(debug=True)'
      mined:+Body, -Code= 'app.run(debug=True)'

================================================================================

QUESTION: idx=342    id=22799300
-------------------------------------INPUTS-------------------------------------

tags: pandas
score: 36
slot_map: {'key': ['str_0', 'str_1'], 'quote': ["'", "'"], 'type': ['str', 'str'], 'value': ['out-1', 'out-2']}
intent: unpack a series of tuples in pandas into a dataframe with column names 'out-1' and 'out-2'
body(Some added characters for better readability):
	Sometimes I end up with a series of tuples/lists when using Pandas. This is common when, for example, doing a group-by and passing a function that has multiple return values:
	
	start_block
	import numpy as np
	from scipy import stats
	df = pd.DataFrame(dict(x=np.random.randn(100),
	                       y=np.repeat(list("abcd"), 25)))
	out = df.groupby("y").x.apply(stats.ttest_1samp, 0)
	print out
	y
	a       (1.3066417476, 0.203717485506)
	b    (0.0801133382517, 0.936811414675)
	c      (1.55784329113, 0.132360504653)
	d     (0.267999459642, 0.790989680709)
	dtype: object
	What is the correct way to "unpack" this structure so that I get a DataFrame with two columns?
	A related question is how I can unpack either this structure or the resulting dataframe into two Series/array objects. This almost works:
	
	start_block
	t, p = zip(*out)
	
	<p>but it 
	`t` is
	
	start_block
	 (array(1.3066417475999257),
	 array(0.08011333825171714),
	 array(1.557843291126335),
	 array(0.267999459641651))
	and one needs to take the extra step of squeezing it.


-------------------------------------OUTPUT-------------------------------------

                Expected= "pd.DataFrame(out.tolist(), columns=['out-1', 'out-2'], index=out.index)"
           base:Baseline= "df.groupby(['out-1', 'out-2'])"
           base:+Canonic= "df.groupby(['out-1', 'out-2'], axis=1)"
           body:Baseline= "df.groupby('y').apply(list('out-1', 'out-2')"
              body:-Code= "pd.concat([['out-1', 'out-2'])"
          mined:Baseline= "pd.concat([df['Out-1', 'Out-2']], axis=1)"
             mined:+Body= "df.groupby('y').apply(stats.ttest_1samp, 0)"
        mined:+Body, -NL= "df.groupby('stats').apply(stats.ttest_1samp, 0)"
      mined:+Body, -Code= 'pd.concat([df1, df2], axis=1)'

================================================================================

QUESTION: idx=343    id=1762484
-------------------------------------INPUTS-------------------------------------

tags: list
score: 20
slot_map: {'key': ['str_0', 'var_0'], 'quote': ["'", '`'], 'type': ['str', 'var'], 'value': ['MSFT', 'stocks_list']}
intent: find the index of an element 'msft' in a list `stocks_list`
body(Some added characters for better readability):
	
	start_block
	for s in stocks_list:
	    print s
	
	<p>how do I know what "position" s is in? So that I can do 
	stocks_list[4]  in the future?


-------------------------------------OUTPUT-------------------------------------

                Expected= "[x for x in range(len(stocks_list)) if stocks_list[x] == 'MSFT']"
           base:Baseline= "[x['msft'] for x instocks_list]"
           base:+Canonic= '[i for i, j in zip(stocks_list, stocks_list)]'
           body:Baseline= "print(str(x['msft'] for x in stocks_list))"
              body:-Code= "stock_list.index('msft')"
          mined:Baseline= "[i for i, j in enumerate(stocks_list) if j == 'msft']"
             mined:+Body= 'stocks_list[i:i + 1]'
        mined:+Body, -NL= 'print(s[i:i + 1] for i in stocks_list))'
      mined:+Body, -Code= " stocks_list.index('msft')"

================================================================================

QUESTION: idx=344    id=3464359
-------------------------------------INPUTS-------------------------------------

tags: django, matlab, matplotlib
score: 6
slot_map: {'key': ['var_0', 'str_0'], 'quote': ['`', '`'], 'type': ['var', 'str'], 'value': ['ax', '45']}
intent: rotate the xtick labels of matplotlib plot `ax` by `45` degrees to make long labels readable
body(Some added characters for better readability):
	Anyone know if it is possible to wrap the xtick labels in matplotlib? Right now I've got the following code (kind of messy -- been hacking at it for a while): 
	
	start_block
	def plotResults(request, question_id):
	 responses = ResponseOption.objects.filter(question__id=question_id).order_by('order').annotate(response_num=Count('response'))
	 counts = []
	 labels = [] 
	 for response in responses:
	  counts.append(response.response_num)
	  labels.append(smart_truncate('$'+response.text+'$'))
	 N = len(labels)
	 labels = tuple(labels)
	 counts = tuple(counts)
	 ind = na.array(range(N))+0.5
	 width = .35
	 fig = Figure(facecolor='white',edgecolor='white')
	 ax = fig.add_subplot(1,1,1)
	 rects1 = ax.bar(ind, counts,linewidth=0)
	 ax.set_ylabel('$Count$')
	 ax.set_title('$Response Historgram$')
	 ax.set_xticks(ind+width)
	 ax.set_xticklabels(labels)
	 print mpl.matplotlib_fname()
	 canvas = FigureCanvas(fig)
	 response = HttpResponse(content_type='image/png')
	 canvas.print_png(response)
	 return response
	That generates this plot:
	As you can see the xticks are boned. Any ideas on how to wrap them, or baring that make them readable? Thanks again!
	PS: This is part of a Django project. I return the plot as a png image -- normally call them from img tags in various views. 


-------------------------------------OUTPUT-------------------------------------

                Expected= 'ax.set_xticklabels(labels, rotation=45)'
           base:Baseline= 'ax.set_xick_label_position(45)'
           base:+Canonic= "ax.set_label('45')"
           body:Baseline= 'ax.set_xticklabels(labels)'
              body:-Code= "ax.set_xicklabels(ax.shape_by('45'))"
          mined:Baseline= 'ax.set_xticklabels(45)'
             mined:+Body= 'ax.set_xticklabels(labels)'
        mined:+Body, -NL= 'ax.set_xticklabels(labels)'
      mined:+Body, -Code= 'ax.set_xticklabels(45)'

================================================================================

QUESTION: idx=345    id=875968
-------------------------------------INPUTS-------------------------------------

tags: regex, string
score: 83
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['s']}
intent: remove symbols from a string `s`
body(Some added characters for better readability):
	I'm a beginner with both Python and RegEx, and I would like to know how to make a string that takes symbols and replaces them with spaces. Any help is great.
	For example:
	
	start_block
	how much for the maple syrup? $20.99? That's ricidulous!!!
	into:
	
	start_block
	how much for the maple syrup 20 99 That s ridiculous


-------------------------------------OUTPUT-------------------------------------

                Expected= "re.sub('[^\\\\w]', '', s)"
           base:Baseline= "re.sub('\\\\(\\\\w+)', s)"
           base:+Canonic= "s = re.sub('\\\\d+', '', s)"
           body:Baseline= "s = s.replace('', '')"
              body:-Code= "s = re.sub('\\\\w+', '', s)"
          mined:Baseline= "s = s.replace(',', '')"
             mined:+Body= "s = s.replace('\\\\s', '')"
        mined:+Body, -NL= "s = s.replace(' ', '')"
      mined:+Body, -Code= "s = s.replace(' ', '')"

================================================================================

QUESTION: idx=346    id=31258561
-------------------------------------INPUTS-------------------------------------

tags: file, getcwd
score: 36
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: get the current directory of a script
body(Some added characters for better readability):
	I know I can use this to get the full file path
	
	start_block
	os.path.dirname(os.path.realpath(__file__))
	But I want just the name of the folder, my scrip is in. SO if I have my_script.py and it is located at
	
	start_block
	/home/user/test/my_script.py
	I want to return "test" How could I do this?
	Thanks


-------------------------------------OUTPUT-------------------------------------

                Expected= 'os.path.basename(os.path.dirname(os.path.realpath(__file__)))'
           base:Baseline= 'os.path.dirname(__file__)'
           base:+Canonic= 'os.path.abspath(__file__))'
           body:Baseline= 'os.path.dirname(os.Path.realpath(__file__))'
              body:-Code= 'os.path.dirname(__file__)'
          mined:Baseline= 'os.path.realpath(__file__)'
             mined:+Body= 'os.path.dirname(os.file.realpath(__file__))'
        mined:+Body, -NL= 'os.chdir(os.path.dirname(__file__))'
      mined:+Body, -Code= 'print(os.path.dirname(__file__))'

================================================================================

QUESTION: idx=347    id=34750084
-------------------------------------INPUTS-------------------------------------

tags: regex, string, octal
score: 4
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['str']}
intent: find octal characters matches from a string `str` using regex
body(Some added characters for better readability):
	I'm attempting to write a regex that captures octal characters.
	For example, if the line I'm comparing to my regex is:
	
	start_block
	char x = '\077';
	
	<p>I want my regex to capture `'\077'`
	I attempted to do this via the re module and a regex of the form:
	
	start_block
	"'\\[0-7]{1-3}'"
	But this doesn't capture the octal character.  How can octal characters be identified using regex in Python?
	Edit:
	As an example of what I mean, consider the C code:
	
	start_block
	char x = '\077'; 
	printf("%c", x);
	
	<p>I would like to capture 
	`'\077'` from the first line.
	Edit:
	After testing some of the suggestions in this thread, I have a case that works.  I realize that after adding the octal regex to a larger regex, I needed to prefix with r for raw input, or escape each backslash, for a total of four backslashes.
	For example, both of these solve the problem:
	
	start_block
	regex = re.compile(r"\s*("                  
	                        r"'\\0[0-7]{1,2}'"          # octal
	                        "|[a-zA-Z_][a-zA-Z_\d]*"    # identifer
	                        ")")
	regex.findall(line)
	and
	
	start_block
	regex = re.compile(r"\s*("                  
	                        "'\\\\0[0-7]{1,2}'"         # octal
	                        "|[a-zA-Z_][a-zA-Z_\d]*"    # identifer
	                        ")")
	regex.findall(line)
	
	<p>Which will produce 
	`'\077'`
	 if line is: `char = '\077';`
	Thanks for the help everyone.


-------------------------------------OUTPUT-------------------------------------

                Expected= 'print(re.findall("\'\\\\\\\\[0-7]{1,3}\'", str))'
           base:Baseline= "re.findall('([a-z])', str)"
           base:+Canonic= "re.findall('([a-z])', str)"
           body:Baseline= "re.compile('\\\\[0-7]{1-3}')"
              body:-Code= "re.findall('\\\\w+', str)"
          mined:Baseline= "re.findall('(?<!\\\\w)([a-z])\\\\w+', str)"
             mined:+Body= "regex = re.compile('\\\\[0-7]{1-3}')"
        mined:+Body, -NL= "re.findall('\\\\[0-7]{1,2}', str)"
      mined:+Body, -Code= "re.findall('[a-zA-Z]*', str)"

================================================================================

QUESTION: idx=348    id=13209288
-------------------------------------INPUTS-------------------------------------

tags: regex, split
score: 125
slot_map: {'key': ['var_0', 'str_0', '[str_0)'], 'quote': ['`', "'", "'"], 'type': ['var', 'str', 'str'], 'value': ['input', '[ ](?=[A-Z]+\\b)', '[ ](?=[A-Z]+\\b)']}
intent: split string `input` based on occurrences of regex pattern '[ ](?=[a-z]+\\b)'
body(Some added characters for better readability):
	
	<p>What is the best way to split a string like 
	`"HELLO there HOW are YOU"` by upper case words (in Python)? 
	
	<p>So I'd end up with an array like such: `results = ['HELLO there', 'HOW are', 'YOU']`
	EDIT: 
	I have tried: 
	
	start_block
	p = re.compile("\b[A-Z]{2,}\b")
	print p.split(page_text)
	It doesn't seem to work, though.


-------------------------------------OUTPUT-------------------------------------

                Expected= "re.split('[ ](?=[A-Z]+\\\\b)', input)"
           base:Baseline= "re.findall('([ ](?=[A-Z]+\\\\b)', input)"
           base:+Canonic= "re.split('[ ](?=[A-Z]+\\\\b)', input)"
           body:Baseline= "re.compile('[ ](?=[A-Z]+\\\\b)', input)"
              body:-Code= "re.split('[ ](?=[A-Z]+\\\\b)', input)"
          mined:Baseline= "re.split('[ ](?=[A-Z]+\\\\b)', input)"
             mined:+Body= "results = re.compile('\\\\b[A-Z]{2,}\\x08')"
        mined:+Body, -NL= "re.compile('\\\\b[A-Z]+\\\\b', input)"
      mined:+Body, -Code= "re.split('[ ](?=[A-Z]+\\\\b)', input)"

================================================================================

QUESTION: idx=349    id=13209288
-------------------------------------INPUTS-------------------------------------

tags: regex, split
score: 125
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['input']}
intent: split string `input` at every space followed by an upper-case letter
body(Some added characters for better readability):
	
	<p>What is the best way to split a string like 
	`"HELLO there HOW are YOU"` by upper case words (in Python)? 
	
	<p>So I'd end up with an array like such: `results = ['HELLO there', 'HOW are', 'YOU']`
	EDIT: 
	I have tried: 
	
	start_block
	p = re.compile("\b[A-Z]{2,}\b")
	print p.split(page_text)
	It doesn't seem to work, though.


-------------------------------------OUTPUT-------------------------------------

                Expected= "re.split('[ ](?=[A-Z])', input)"
           base:Baseline= "re.split('(\\\\w+)', input)"
           base:+Canonic= "re.split('\\n', input)"
           body:Baseline= "results = re.compile('\\\\b[A-Z]{2,}\\x08')"
              body:-Code= "input.split(',', 1)[0]"
          mined:Baseline= "re.split('[^a-zA-Z]', input)"
             mined:+Body= "results = re.compile('\\\\b[A-Z]{2,}\\x08')"
        mined:+Body, -NL= "re.compile('\\\\b[A-Z]{2,}\\x08', input)"
      mined:+Body, -Code= "input = re.compile('\\\\w+', input)"

================================================================================

QUESTION: idx=350    id=24642040
-------------------------------------INPUTS-------------------------------------

tags: rest
score: 15
slot_map: {'key': ['var_0', 'var_1', 'var_2', 'var_3'], 'quote': ['`', '`', '`', '`'], 'type': ['var', 'var', 'var', 'var'], 'value': ['files', 'url', 'headers', 'data']}
intent: send multipart encoded file `files` to url `url` with headers `headers` and metadata `data`
body(Some added characters for better readability):
	I'm trying to POST to an API (Build using SlimPHP) which accepts an image along with additional image meta data in the form of JSON.  
	I've verified the API works correctly using a REST client tool and can successfully POST to the service. All data is stored correctly.
	I'm now trying to POST using Python - however my JSON data doesn't appear to be saving.
	My code:
	
	start_block
	    data = {'key1': 'value1', 'key2': 'value2'}
	    url = 'http://mydomain.com/api/endpoint'
	    headers = {'Authorization': 'my-api-key'}
	    files = {'file': (FILE, open(PATH, 'rb'), 'image/jpg', {'Expires': '0'})}
	    r = requests.post(url, files=files, headers=headers, data=data)
	--
	I've attempted to set additional headers,
	ie:/
	
	start_block
	headers = {'Authorization': 'unique-auth-key', 'Content-type': 'multipart/form-data'}
	or
	
	start_block
	headers = {'Authorization': 'unique-auth-key', 'Content-type': 'application/json'}
	These result in a 500 error.
	UPDATE 14/07/2014:
	Using a chrome extension (Advanced Rest Client) my POST is successful - here's what the console shows as the payload:
	
	start_block
	------WebKitFormBoundarysBpiwrA3hnGPUbMA
	Content-Disposition: form-data; name="data"
	test
	------WebKitFormBoundarysBpiwrA3hnGPUbMA
	Content-Disposition: form-data; name="file"; filename="image.jpg"
	Content-Type: image/jpeg
	------WebKitFormBoundarysBpiwrA3hnGPUbMA--
	I'm not quite sure what this signifies...


-------------------------------------OUTPUT-------------------------------------

                Expected= 'r = requests.post(url, files=files, headers=headers, data=data)'
           base:Baseline= 'urllib.request.urlretrieve(url, headers=headers, metadata=data)'
           base:+Canonic= 'urllib.request.urlretrieve(files, url, headers={headers})'
           body:Baseline= 'requests.post(url, files=files, headers=headers, data=data)'
              body:-Code= "urllib.request.urlopen('files', headers={'headers': 'data'})"
          mined:Baseline= 'urllib.request.urlretrieve(files, headers=headers, metadata=data)'
             mined:+Body= 'r = requests.post(url, files=files, headers=headers, data=data)'
        mined:+Body, -NL= 'r = requests.post(url, files=files, headers=headers, data=data)'
      mined:+Body, -Code= 'urllib.request.urlretrieve(files, headers=headers, data=data)'

================================================================================

QUESTION: idx=351    id=4290716
-------------------------------------INPUTS-------------------------------------

tags: io
score: 55
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['bytes_', 'filename']}
intent: write bytes `bytes_` to a file `filename` in python 3
body(Some added characters for better readability):
	In Python 2.x with 'file-like' object:
	
	start_block
	sys.stdout.write(bytes_)
	tempfile.TemporaryFile().write(bytes_)
	open('filename', 'wb').write(bytes_)
	StringIO().write(bytes_)
	How to do the same in Python 3?
	How to write equivalent of this Python 2.x code:
	
	start_block
	def write(file_, bytes_):
	    file_.write(bytes_)
	
	<p>Note: 
	`sys.stdout`
	 is not always semantically a text stream. It might be beneficial to consider it as a stream of bytes sometimes. For example, 
	make encrypted archive of dir/ on remote machine :
	
	start_block
	tar -c dir/ | gzip | gpg -c | ssh user@remote 'dd of=dir.tar.gz.gpg'
	There is no point to use Unicode in this case.


-------------------------------------OUTPUT-------------------------------------

                Expected= "open('filename', 'wb').write(bytes_)"
           base:Baseline= 'fd = os.write(filename, bytes_)'
           base:+Canonic= "filename.write('bytes_', bytes_)"
           body:Baseline= 'sys.stdout.write(bytes_)'
              body:-Code= 'print(filename.write(bytes_))'
          mined:Baseline= 'f.writebytes(bytes_)'
             mined:+Body= "filename = open('filename', 'wb').write(bytes_)"
        mined:+Body, -NL= "open('filename', 'wb').write(bytes_)"
      mined:+Body, -Code= "f = open('filename', 'w').read().decode('utf8')"

================================================================================

QUESTION: idx=352    id=33078554
-------------------------------------INPUTS-------------------------------------

tags: list, dictionary
score: 57
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['lst', 'dct']}
intent: get a list from a list `lst` with values mapped into a dictionary `dct`
body(Some added characters for better readability):
	Given the following dictionary:
	
	start_block
	dct = {'a':3, 'b':3,'c':5,'d':3}
	How can I apply these values to a list such as:
	
	start_block
	lst = ['c', 'd', 'a', 'b', 'd']
	in order to get something like:
	
	start_block
	lstval = [5, 3, 3, 3, 3]


-------------------------------------OUTPUT-------------------------------------

                Expected= '[dct[k] for k in lst]'
           base:Baseline= '[dct for dct in lst]'
           base:+Canonic= '[k for k, v in zip(lst, dct)]'
           body:Baseline= '[dct for dct, dct in lst]'
              body:-Code= '[dct for dct in lst]'
          mined:Baseline= 'dct = [dct[key] for key in lst]'
             mined:+Body= '[x for x in lst for y in dct]'
        mined:+Body, -NL= 'dct = dict((k, v) for k, v in lst.items())'
      mined:+Body, -Code= 'dct = [dct[k] for k in lst]'

================================================================================

QUESTION: idx=353    id=15247628
-------------------------------------INPUTS-------------------------------------

tags: group-by, pandas
score: 21
slot_map: {'key': ['str_0', 'var_0'], 'quote': ["'", '`'], 'type': ['str', 'var'], 'value': ['name', 'x']}
intent: find duplicate names in column 'name' of the dataframe `x`
body(Some added characters for better readability):
	
	<p>I have a 
	`pandas.DataFrame`
	 with a column called 
	`name` containing strings.
	I would like to get a list of the names which occur more than once in the column. How do I do that?
	I tried:
	
	start_block
	funcs_groups = funcs.groupby(funcs.name)
	funcs_groups[(funcs_groups.count().name>1)]
	But it doesn't filter out the singleton names.


-------------------------------------OUTPUT-------------------------------------

                Expected= "x.set_index('name').index.get_duplicates()"
           base:Baseline= "df['name'] = df['name'].groupby(lambda x: x[1])"
           base:+Canonic= "x.groupby(['name'], duplicate=True)"
           body:Baseline= "df['name'] = df['name'].groupby(df.name)"
              body:-Code= "x.groupby('name').filter(lambda name: name.split())"
          mined:Baseline= "x.groupby(level=1).agg(['name'])"
             mined:+Body= "df.groupby(['name', 'name'])['name'].distinct()"
        mined:+Body, -NL= "df.groupby(['name', 'name'])['name'].apply(lambda x: x.name)"
      mined:+Body, -Code= "x.groupby('name')['success'].apply(lambda x: len(x))"

================================================================================

QUESTION: idx=354    id=783897
-------------------------------------INPUTS-------------------------------------

tags: floating-point
score: 122
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: truncate float 1.923328437452 to 3 decimal places
body(Some added characters for better readability):
	I want to remove digits from a float to have a fixed number of digits after the dot, like:
	
	start_block
	1.923328437452 - 1.923
	I need to output as a string to another function, not print.
	Also I want to ignore the lost digits, not round them.


-------------------------------------OUTPUT-------------------------------------

                Expected= 'round(1.923328437452, 3)'
           base:Baseline= '"""{0:.3f}""".format(1.923328437452)'
           base:+Canonic= "print('{0:.3f}'.format(1.923328437452))"
           body:Baseline= '"""{0:.923328437452}""".format(1.923)'
              body:-Code= "print('%.3f' % 1.923328437452)"
          mined:Baseline= '"""{0:.3f}""".format(1.923328437452)'
             mined:+Body= '"""{:.3f}""".format(1.923328437452)'
        mined:+Body, -NL= '"""{0:.3f}""".format(1.923328437452 - 1.923)'
      mined:+Body, -Code= "print('{0:.3f}'.format(1.923328437452))"

================================================================================

QUESTION: idx=355    id=22859493
-------------------------------------INPUTS-------------------------------------

tags: string, sorting, datetime
score: 5
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['li', 'li']}
intent: sort list `li` in descending order based on the date value in second element of each list in list `li`
body(Some added characters for better readability):
	
	start_block
	import csv,operator
	from datetime import datetime
	li = [['name','01/03/2012','job'],
	      ['name','02/05/2013','job'],
	      ['name','03/08/2014','job']]
	Sorted Method:
	
	start_block
	sorted(li,key=lambda x:datetime.strptime(row[1],'%d/%m/%Y'), reverse=True)
	Output:
	No error, but simply not ordered
	Itemgetter Method:
	
	start_block
	for x in range(1,len(li)):
	    li[x][6]=datetime.strptime(li[x][6],'%d/%m/%Y')
	li.sort(key=operator.itemgetter(6))
	Output:
	
	start_block
	Traceback (most recent call last):
	  File "U:/rmarshall/Work For Staff/ROB/_Python/__Python Projects Code/April Signed Terms.py", line 35, in <module>
	    li.sort(key=operator.itemgetter(6))
	TypeError: unorderable types: datetime.datetime() < str()
	Could someone supply an example of ordering a the list li by date.  For educational purposes I would appreciate examples of both the sorted method and itemgetter method with a comparison of efficiency.
	Also, by the error on the itemgetter approach, is itemgetter simply not able to handle datetime objects.
	
	<p>Note:  I presume the ascending or descending order doesn't matter too much in this example as it can be simply flipped with 
	`reverse=True`.


-------------------------------------OUTPUT-------------------------------------

                Expected= "sorted(li, key=lambda x: datetime.strptime(x[1], '%d/%m/%Y'), reverse=True)"
           base:Baseline= 'li.sort(key=lambda x: x[1])'
           base:+Canonic= 'var_0.sort(key=lambda x: (x[1]) for x in var_0)'
           body:Baseline= 'li.sort(key=operator.itemgetter(6))'
              body:-Code= 'sorted(li, key=lambda x: x[1])'
          mined:Baseline= 'li.sort(key=lambda x: x[2])'
             mined:+Body= 'li.sort(key=operator.itemgetter(6))'
        mined:+Body, -NL= 'li.sort(key=operator.itemgetter(6))'
      mined:+Body, -Code= 'sorted(li, key=itemgetter(1), reverse=True)'

================================================================================

QUESTION: idx=356    id=29394552
-------------------------------------INPUTS-------------------------------------

tags: matplotlib, polar-coordinates
score: 10
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['ax']}
intent: place the radial ticks in plot `ax` at 135 degrees
body(Some added characters for better readability):
	
	<p>From 
	matplotlib examples :
	
	start_block
	import numpy as np
	import seaborn as sbs
	import matplotlib.pyplot as plt
	r = np.arange(0, 3.0, 0.01)
	theta = 2 * np.pi * r
	ax = plt.subplot(111, polar=True)
	ax.plot(theta, r, color='r', linewidth=3)
	ax.set_rmax(2.0)
	ax.grid(True)
	ax.set_title("A line plot on a polar axis", va='bottom')
	plt.show()
	How to move the radial tick labels (0.5, 1.0, 1.5, 2.0) to a different angle, say 120 deg?


-------------------------------------OUTPUT-------------------------------------

                Expected= 'ax.set_rlabel_position(135)'
           base:Baseline= 'ax.set_ticks_position(135)'
           base:+Canonic= 'var_0.set_ticks_position(135 degrees)'
           body:Baseline= 'ax.set_radigit()'
              body:-Code= 'ax.set_radigit()'
          mined:Baseline= 'ax.xaxis.set_major_locator(locator)'
             mined:+Body= "ax.plot(theta, r, color='r', linewidth=3)"
        mined:+Body, -NL= "ax.plot(theta, r, color='r', linewidth=3)"
      mined:+Body, -Code= 'ax.xaxis.set_major_locator(locator)'

================================================================================

QUESTION: idx=357    id=3320406
-------------------------------------INPUTS-------------------------------------

tags: path
score: 161
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['my_path']}
intent: check if path `my_path` is an absolute path
body(Some added characters for better readability):
	UNIX absolute path starts with '/', whereas Windows starts with alphabet 'C:' or '\'.
	Does python has a standard function to check if a path is absolute or relative? 


-------------------------------------OUTPUT-------------------------------------

                Expected= 'os.path.isabs(my_path)'
           base:Baseline= 'if not my_path:\n    pass'
           base:+Canonic= 'if not my_path:\n    pass'
           body:Baseline= 'print(os.path.abspath(my_path))'
              body:-Code= 'print(os.path.abspath(my_path))'
          mined:Baseline= 'print(os.path.abspath(my_path))'
             mined:+Body= 'print(os.path.realpath(my_path))'
        mined:+Body, -NL= 'print(os.path.abspath(my_path))'
      mined:+Body, -Code= 'print(os.path.realpath(my_path))'

================================================================================

QUESTION: idx=358    id=2212433
-------------------------------------INPUTS-------------------------------------

tags: dictionary, count, keyword
score: 263
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['yourdict']}
intent: get number of keys in dictionary `yourdict`
body(Some added characters for better readability):
	I have a list of words in a dictionary with the value = the repetition of the keyword but I only want a list of distinct words so I wanted to count the number of keywords. Is there a way to count the number of keywords or is there another way I should look for distinct words?


-------------------------------------OUTPUT-------------------------------------

                Expected= 'len(list(yourdict.keys()))'
           base:Baseline= 'sum(key for key, value in list(yourdict.items())'
           base:+Canonic= 'len(v) for v in list(var_0.items())'
           body:Baseline= 'sum(key) for key in list(yourdict.values())'
              body:-Code= 'sum(key for key, value in list(yourdict.items()) if value == repeat)'
          mined:Baseline= 'sum(1 for k, v in list(yourdict.values()))'
             mined:+Body= 'sum(1 for word in list(yourdict.items())'
        mined:+Body, -NL= 'sum(key for key, value in list(yourdict.items()))'
      mined:+Body, -Code= 'len(set(yourdict.keys()))'

================================================================================

QUESTION: idx=359    id=2212433
-------------------------------------INPUTS-------------------------------------

tags: dictionary, count, keyword
score: 263
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['yourdictfile']}
intent: count the number of keys in dictionary `yourdictfile`
body(Some added characters for better readability):
	I have a list of words in a dictionary with the value = the repetition of the keyword but I only want a list of distinct words so I wanted to count the number of keywords. Is there a way to count the number of keywords or is there another way I should look for distinct words?


-------------------------------------OUTPUT-------------------------------------

                Expected= 'len(set(open(yourdictfile).read().split()))'
           base:Baseline= 'sum(yourdictfile.keys()))'
           base:+Canonic= 'sum(len(v) for v in yourdictfile.items())'
           body:Baseline= 'sum(key) for key in list(yourdictfile.values())'
              body:-Code= 'sum(key for key, value in list(yourdictfile.items()))'
          mined:Baseline= 'sum(1 for k, v in list(yourDict.values()))'
             mined:+Body= 'sum(1 for word in list(yourdictfile.keys())'
        mined:+Body, -NL= 'sum(1 for key, value in list(yourdictfile.values()))'
      mined:+Body, -Code= 'len(yourdictfile.values())'

================================================================================

QUESTION: idx=360    id=20067636
-------------------------------------INPUTS-------------------------------------

tags: pandas, dataframe
score: 166
slot_map: {'key': ['str_0'], 'quote': ["'"], 'type': ['str'], 'value': ['id']}
intent: pandas dataframe get first row of each group by 'id'
body(Some added characters for better readability):
	
	<p>I have a pandas 
	`DataFrame` like following.
	
	start_block
	df = pd.DataFrame({'id' : [1,1,1,2,2,3,3,3,3,4,4,5,6,6,6,7,7],
	                'value'  : ["first","second","second","first",
	                            "second","first","third","fourth",
	                            "fifth","second","fifth","first",
	                            "first","second","third","fourth","fifth"]})
	I want to group this by ["id","value"] and get the first row of each group.
	
	start_block
	        id   value
	0        1   first
	1        1  second
	2        1  second
	3        2   first
	4        2  second
	5        3   first
	6        3   third
	7        3  fourth
	8        3   fifth
	9        4  second
	10       4   fifth
	11       5   first
	12       6   first
	13       6  second
	14       6   third
	15       7  fourth
	16       7   fifth
	Expected outcome
	
	start_block
	    id   value
	     1   first
	     2   first
	     3   first
	     4  second
	     5  first
	     6  first
	     7  fourth
	
	<p>I tried following which only gives the first row of the 
	`DataFrame`. Any help regarding this is appreciated.
	
	
	start_block
	>>>for index, row in df.iterrows():
	...  <console_out>.:     df2 = pd.DataFrame(df.groupby(['id','value']).reset_index().ix[0])


-------------------------------------OUTPUT-------------------------------------

                Expected= "df.groupby('id').first()"
           base:Baseline= "df.groupby('id').first()"
           base:+Canonic= "df.groupby(['id'], axis=1)"
           body:Baseline= "df.groupby('id')['value']"
              body:-Code= "df['id'] = df['value']"
          mined:Baseline= "df.groupby('id').head(1)"
             mined:+Body= "df.groupby(['id', 'value']).head(1)"
        mined:+Body, -NL= "df.groupby(['id', 'value'])['value'].first()"
      mined:+Body, -Code= "df.groupby('id').head(1)"

================================================================================

QUESTION: idx=361    id=40924332
-------------------------------------INPUTS-------------------------------------

tags: list, pandas, dataframe
score: 17
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: split a list in first column  into multiple columns keeping other columns as well in pandas data frame
body(Some added characters for better readability):
	
	<p>I have a really simple `Pandas`
	
	`dataframe`
	 where each cell contains a list. I'd like to split each element of the list into it's own column. I can do that by exporting the values and then creating a new 
	`dataframe`
	. This doesn't seem like a good way to do this especially, if my 
	`dataframe` had a column aside from the list column.
	
	start_block
	import pandas as pd
	df = pd.DataFrame(data=[[[8,10,12]],
	                        [[7,9,11]]])
	df = pd.DataFrame(data=[x[0] for x in df.values])
	Desired output:
	
	start_block
	   0   1   2
	0  8  10  12
	1  7   9  11
	Follow-up based on @Psidom answer:
	If I did have a second column:
	
	start_block
	df = pd.DataFrame(data=[[[8,10,12], 'A'],
	                        [[7,9,11], 'B']])
	How do I not loose the other column?
	Desired output:
	
	start_block
	   0   1   2  3 
	0  8  10  12  A
	1  7   9  11  B


-------------------------------------OUTPUT-------------------------------------

                Expected= 'pd.concat([df[0].apply(pd.Series), df[1]], axis=1)'
           base:Baseline= "df.groupby(['1', '2', '3', '4', '5'])"
           base:+Canonic= "df.groupby(['1', '2', '3', '4', '5', '6', '7'])"
           body:Baseline= "pd.DataFrame(['[0] for _ in df.values]])"
              body:-Code= "df.groupby(['1', '2'])"
          mined:Baseline= 'df.apply(lambda x: x.str[1:])'
             mined:+Body= "df['A'].apply(lambda x: x.apply(pd.Series).astype(int)"
        mined:+Body, -NL= 'pd.concat([df, pd.DataFrame(data=[x[0] for x in df.values])'
      mined:+Body, -Code= 'df.apply(pd.Series).apply(list, axis=1)'

================================================================================

QUESTION: idx=362    id=30759776
-------------------------------------INPUTS-------------------------------------

tags: regex
score: 5
slot_map: {'key': ['str_0', 'var_0'], 'quote': ["'", '`'], 'type': ['str', 'var'], 'value': ['src="js/([^"]*\\bjquery\\b[^"]*)"', 'data']}
intent: extract attributes 'src="js/([^"]*\\bjquery\\b[^"]*)"' from string `data`
body(Some added characters for better readability):
	
	<p>I want to get JS file names from the input content which contains 
	`jquery` as a substring by RE.
	This is my code:
	Step 1: Extract JS file from the content.
	
	
	start_block
	>>>data = """    <script type="text/javascript" src="js/jquery-1.9.1.min.js"/>
	...    <script type="text/javascript" src="js/jquery-migrate-1.2.1.min.js"/>
	...    <script type="text/javascript" src="js/jquery-ui.min.js"/>
	...    <script type="text/javascript" src="js/abc_bsub.js"/>
	...    <script type="text/javascript" src="js/abc_core.js"/>
	...    <script type="text/javascript" src="js/abc_explore.js"/>
	...    <script type="text/javascript" src="js/abc_qaa.js"/>"""
	>>>import re
	>>>re.findall('src="js/([^"]+)"', data)
	...['jquery-1.9.1.min.js', 'jquery-migrate-1.2.1.min.js', 'jquery-ui.min.js', 'abc_bsub.js', 'abc_core.js', 'abc_explore.js', 'abc_qaa.js']
	
	<p>Step 2: Get JS file which have sub string as `jquery`
	
	
	start_block
	>>>[ii for ii in re.findall('src="js/([^"]+)"', data) if "jquery" in ii]
	...['jquery-1.9.1.min.js', 'jquery-migrate-1.2.1.min.js', 'jquery-ui.min.js']
	Can I do above Step 2 in the Step 1 means RE Pattern to get result?


-------------------------------------OUTPUT-------------------------------------

                Expected= 're.findall(\'src="js/([^"]*\\\\bjquery\\\\b[^"]*)"\', data)'
           base:Baseline= 'data = re.sub(\'src="js/([^"]*\\\\bjquery\\\\b[^]*)"\')'
           base:+Canonic= 're.findall(\'src="js/([^"]*\\\\bjquery\\\\b[^"]*)"\', data)'
           body:Baseline= 'data = re.findall(\'src="js/([^"]*\\\\bjquery\\\\b[^]*)"\', data)'
              body:-Code= 'data = re.compile(\'src="js/([^"]*\\\\bjquery\\\\b[^]*)"'
          mined:Baseline= 'data.extract(\'src="js/([^"]*\\\\bjquery\\\\b[^"])*)"'
             mined:+Body= 're.findall(\'src="js/([^"]+\\\\bjquery\\\\b[^"]*)"\', data)'
        mined:+Body, -NL= '[ii for i in re.findall(\'src="js/([^"]+)"\', data) if \'jquery\' in i]'
      mined:+Body, -Code= '[\'src="js/([^"]*\\\\bjquery\\\\b[^]*)"]'

================================================================================

QUESTION: idx=363    id=25388796
-------------------------------------INPUTS-------------------------------------

tags: file-io, io
score: 4
slot_map: {'key': ['str_0', '[str_0]'], 'quote': ['`', '`'], 'type': ['str', 'str'], 'value': ["['', '3.4', '', '', '1.0']", "['', '3.4', '', '', '1.0']"]}
intent: sum integers contained in strings in list `['', '3.4', '', '', '1.0']`
body(Some added characters for better readability):
	I'm doing something like this to sum up a number of elements of a line:   
	
	start_block
	for line in open(filename, 'r'):
	   big_list = line.strip().split(delim)
	   a = sum(int(float(item)) for item in big_list[start:end] if item)  
	   # do some other stuff
	this is done line by line with a big file, where some items may be missing, i.e., equal to ''. If I use the statement above to compute a, the script becomes much slower than without it. Is there a way to speed it up? 


-------------------------------------OUTPUT-------------------------------------

                Expected= "sum(int(float(item)) for item in [_f for _f in ['', '3.4', '', '', '1.0'] if\n    _f])"
           base:Baseline= 'sum(map(int, [\'\', \'3.4\', \'\', \'", \'1.0\'])'
           base:+Canonic= "sum([int(x) for x in ['', '3.4', '', '', '1.0']])"
           body:Baseline= "sum(int(float(item)) for item in ['', '3.4', '', ',1.0'])"
              body:-Code= "sum(int(x) for x in ['', '3.4', '', ''', '1.0'])"
          mined:Baseline= 'sum(map(int, x))'
             mined:+Body= 'sum(int(float(item)) for item in big_list[start:end] if item)'
        mined:+Body, -NL= 'sum(int(float(item)) for item in big_list[start:end] if item)'
      mined:+Body, -Code= 'sum(map(sum, x))'

================================================================================

QUESTION: idx=364    id=804995
-------------------------------------INPUTS-------------------------------------

tags: subprocess
score: 22
slot_map: {'key': ['str_0'], 'quote': ['`'], 'type': ['str'], 'value': ['c:\\Program Files\\VMware\\VMware Server\\vmware-cmd.bat']}
intent: call a subprocess with arguments `c:\\program files\\vmware\\vmware server\\vmware-cmd.bat` that may contain spaces
body(Some added characters for better readability):
	I'm working on a wrapper script that will exercise a vmware executable, allowing for the automation of virtual machine startup/shutdown/register/deregister actions.  I'm trying to use subprocess to handle invoking the executable, but the spaces in the executables path and in parameters of the executable are not being handled correctly by subprocess.  Below is a code fragment:
	
	start_block
	vmrun_cmd = r"c:/Program Files/VMware/VMware Server/vmware-cmd.bat"
	def vm_start(target_vm):
	    list_arg = "start"
	    list_arg2 = "hard"
	    if vm_list(target_vm):
	            p = Popen([vmrun_cmd, target_vm, list_arg, list_arg2],   stdout=PIPE).communicate()[0]
	            print p
	    else:
	            vm_register(target_vm)
	            vm_start(target_vm)
	def vm_list2(target_vm):
	    list_arg = "-l"
	    p = Popen([vmrun_cmd, list_arg], stdout=PIPE).communicate()[0]
	    for line in p.split('\n'):
	            print line
	If I call the vm_list2 function, I get the following output:
	
	start_block
	$ ./vmware_control.py --list                                                
	C:\Virtual Machines\QAW2K3Server\Windows Server 2003 Standard Edition.vmx
	C:\Virtual Machines\ubunturouter\Ubuntu.vmx
	C:\Virtual Machines\vacc\vacc.vmx
	C:\Virtual Machines\EdgeAS-4.4.x\Other Linux 2.4.x kernel.vmx
	C:\Virtual Machines\UbuntuServer1\Ubuntu.vmx
	C:\Virtual Machines\Other Linux 2.4.x kernel\Other Linux 2.4.x kernel.vmx
	C:\Virtual Machines\QAClient\Windows XP Professional.vmx
	If I call the vm_start function, which requires a path-to-vm parameter, I get the following output:
	
	start_block
	$ ./vmware_control.py --start "C:\Virtual Machines\ubunturouter\Ubuntu.vmx"
	'c:\Program' is not recognized as an internal or external command,
	operable program or batch file.
	Apparently, the presence of a second parameter with embedded spaces is altering the way that subprocess is interpreting the first parameter.  Any suggestions on how to resolve this?
	python2.5.2/cygwin/winxp


-------------------------------------OUTPUT-------------------------------------

                Expected= "subprocess.Popen(['c:\\\\Program Files\\\\VMware\\\\VMware Server\\\\vmware-cmd.bat'])"
           base:Baseline= "subprocess.call(['c:\\\\program files\\\\vmware\\\\vmWARE server\\\\VMware-cmd.bat']\n    ).call('c')"
           base:+Canonic= "subprocess.call('c:\\\\Program Files\\\\VMware\\\\VMware Server\\\\vmware-cmd.bat',\n    shell=True)"
           body:Baseline= "subprocess.call(['c:\\\\Program Files\\\\vmware\\\\VMware Server/vmware-cmd.bat'])"
              body:-Code= "subprocess.call('c:\\\\program files\\\\vmware\\\\vmWare server\\\\vmWARE-cmd.bat',\n    shell=True)"
          mined:Baseline= "subprocess.call(['c:\\\\Program Files\\\\vmware\\\\VMware server\\\\vmWARE-cmd.bat', shell=True)"
             mined:+Body= "subprocess.call(['c:\\\\Program Files\\\\vmware\\\\VMware Server\\\\vmvmware-cmd.bat', shell=True)"
        mined:+Body, -NL= "subprocess.call(['c:\\\\Program Files\\\\vmware\\\\n', '-l', 'vmware-cmd.bat'])"
      mined:+Body, -Code= "subprocess.call(['c:\\\\program files\\\\vmware\\\\VMware server\\\\vmWARE-cmd.bat', shell=True)"

================================================================================

QUESTION: idx=365    id=26441253
-------------------------------------INPUTS-------------------------------------

tags: priority-queue
score: 8
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['q']}
intent: reverse a priority queue `q` in python without using classes
body(Some added characters for better readability):
	I am just learning the priority queues in Python, and I have made the following code:
	
	start_block
	def main():
	    q=Queue.PriorityQueue()
	    while True:
	        n=input("numbre?")
	        if n==0:
	            break
	        else:
	            q.put(n)
	            print n
	while not q.empty():
	        print q.get()
	when I input data like: 9, 1, 4, 5
	it prints 1,4,5,9 which it seems correct, but I would like to know how can I do to deque in reverse order, I mean: 9,5,4,1
	I know how to do that with a class, but in this case it seems the following extra code:
	
	start_block
	def __cmp__():
	        -cmp(q.get(),q.get())
	does not work, any help?


-------------------------------------OUTPUT-------------------------------------

                Expected= 'q.put((-n, n))'
           base:Baseline= 'requests.reverse(Q, class=None)'
           base:+Canonic= 'sorted(q, key=lambda x: x[1])'
           body:Baseline= 'queue.reverse_queue(q)'
              body:-Code= 'q.reset_priority(0)'
          mined:Baseline= 'q = queue.reverse(queue.__class__, queue.__name__)'
             mined:+Body= 'rdd.reverse(q, reverse=True)'
        mined:+Body, -NL= 'Queue.PriorityQueue(queue_name, queue_name)'
      mined:+Body, -Code= 'q.sort(key=lambda x: (x[1], x[2]))'

================================================================================

QUESTION: idx=366    id=18897261
-------------------------------------INPUTS-------------------------------------

tags: plot, pandas, bar-chart
score: 16
slot_map: {'key': ['var_0', 'var_1', 'var_2'], 'quote': ['`', '`', '`'], 'type': ['var', 'var', 'var'], 'value': ['group', 'df', 'color']}
intent: make a barplot of data in column `group` of dataframe `df` colour-coded according to list `color`
body(Some added characters for better readability):
	I would like to use pandas to plot a barplot with diffrent colors for category in column.
	Here is a simple example: (index is variable)
	
	start_block
	df:
	         value   group
	variable               
	a             10      1
	b              9      1
	c              8      1
	d              7      2
	f              6      2
	g              5      3
	h              4      3
	I would like to make a barplot with coloring on group. I would also like to specify the colors. In my original dataset I have many goups.
	Could someone help me with this?


-------------------------------------OUTPUT-------------------------------------

                Expected= "df['group'].plot(kind='bar', color=['r', 'g', 'b', 'r', 'g', 'b', 'r'])"
           base:Baseline= 'df.group.colour_coded().reset_index(axis=1)'
           base:+Canonic= "df.colour_coded(group='color', color='green')"
           body:Baseline= "df.group.colour.diffrent_color().barplot(['color'], axis=1)"
              body:-Code= "df.group.colour_by('color')"
          mined:Baseline= "df.colour.plot(kind='bar')"
             mined:+Body= "df.group.color.diffrent('greyscale')"
        mined:+Body, -NL= "df.colour.pivot(index='group', columns='color', aggfunc='value', fill_value=0)"
      mined:+Body, -Code= "df.groupby('color').size().plot(kind='bar')"

================================================================================

QUESTION: idx=367    id=373194
-------------------------------------INPUTS-------------------------------------

tags: regex, md5
score: 21
slot_map: {'key': ['str_0', 'var_0', '(str_0)'], 'quote': ["'", '`', "'"], 'type': ['str', 'var', 'str'], 'value': ['([a-fA-F\\d]{32})', 'data', '([a-fA-F\\d]{32})']}
intent: find all matches of regex pattern '([a-fa-f\\d]{32})' in string `data`
body(Some added characters for better readability):
	I've come up with:
	
	start_block
	re.findall("([a-fA-F\d]*)", data)
	but it's not very fool proof, is there a better way to grab all MD5-hash codes?


-------------------------------------OUTPUT-------------------------------------

                Expected= "re.findall('([a-fA-F\\\\d]{32})', data)"
           base:Baseline= "re.findall('([A-F\\\\d]{32})', data)"
           base:+Canonic= "re.findall('([a-fA-F\\\\d]{32})', data)"
           body:Baseline= "re.findall('([a-fa-f\\\\d]{32})', data)"
              body:-Code= "print(re.findall('([A-fa-f\\\\d]{32})', data))"
          mined:Baseline= "re.findall('([a-fa-f\\\\d]{32})', data)"
             mined:+Body= "re.findall('([a-fa-f\\\\d]{32})', data)"
        mined:+Body, -NL= "re.findall('([a-fa-f\\\\d]{32})', data)"
      mined:+Body, -Code= "print(re.findall('([A-fa-f\\\\d]{32})', data))"

================================================================================

QUESTION: idx=368    id=518021
-------------------------------------INPUTS-------------------------------------

tags: arrays, methods
score: 739
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['my_list']}
intent: get the length of list `my_list`
body(Some added characters for better readability):
	
	<p>In 
	Python , is the following the only way to get the number of elements?
	
	start_block
	arr.__len__()
	If so, why the strange syntax?


-------------------------------------OUTPUT-------------------------------------

                Expected= 'len(my_list)'
           base:Baseline= 'len(len(my_list))'
           base:+Canonic= 'len(len(my_list))'
           body:Baseline= 'length(len(my_list))'
              body:-Code= 'len(len(my_list))'
          mined:Baseline= 'len(set(my_list))'
             mined:+Body= 'len(my_list) - my_list'
        mined:+Body, -NL= '[len(my_list) for _ in range(length)]'
      mined:+Body, -Code= 'len(len(my_list)'

================================================================================

QUESTION: idx=369    id=518021
-------------------------------------INPUTS-------------------------------------

tags: arrays, methods
score: 739
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['l']}
intent: getting the length of array `l`
body(Some added characters for better readability):
	
	<p>In 
	Python , is the following the only way to get the number of elements?
	
	start_block
	arr.__len__()
	If so, why the strange syntax?


-------------------------------------OUTPUT-------------------------------------

                Expected= 'len(l)'
           base:Baseline= 'len(L) + len(len(l))'
           base:+Canonic= 'len(l, l)'
           body:Baseline= 'len(l) - L[::-1]'
              body:-Code= 'len(l) - len(len(L))'
          mined:Baseline= 'L[len(len(l))]'
             mined:+Body= 'len(L) - len(l)'
        mined:+Body, -NL= 'L[::-1].length()'
      mined:+Body, -Code= 'len(x) - len(y)'

================================================================================

QUESTION: idx=370    id=518021
-------------------------------------INPUTS-------------------------------------

tags: arrays, methods
score: 739
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['s']}
intent: getting the length of array `s`
body(Some added characters for better readability):
	
	<p>In 
	Python , is the following the only way to get the number of elements?
	
	start_block
	arr.__len__()
	If so, why the strange syntax?


-------------------------------------OUTPUT-------------------------------------

                Expected= 'len(s)'
           base:Baseline= 'len(s, len(s))'
           base:+Canonic= 'len(s, s)'
           body:Baseline= 'sum(len(s) for s in s)'
              body:-Code= 'len(s, len(s))'
          mined:Baseline= 'sum(len(s) for s in s)'
             mined:+Body= 'len([x for x in s if x not in s])'
        mined:+Body, -NL= 'arr[::-1].length()'
      mined:+Body, -Code= 'len(s) - len(s - 1'

================================================================================

QUESTION: idx=371    id=518021
-------------------------------------INPUTS-------------------------------------

tags: arrays, methods
score: 739
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['my_tuple']}
intent: getting the length of `my_tuple`
body(Some added characters for better readability):
	
	<p>In 
	Python , is the following the only way to get the number of elements?
	
	start_block
	arr.__len__()
	If so, why the strange syntax?


-------------------------------------OUTPUT-------------------------------------

                Expected= 'len(my_tuple)'
           base:Baseline= 'len(my_tuple).split()'
           base:+Canonic= 'len(len(my_tuple))'
           body:Baseline= 'len(len(my_tuple))'
              body:-Code= 'len(len(my_tuple))'
          mined:Baseline= 'len(str(my_tuple))'
             mined:+Body= 'len(len(my_tuple))'
        mined:+Body, -NL= 'len(my_tuple) - len(my-tuple))'
      mined:+Body, -Code= 'len(len(my_tuple))'

================================================================================

QUESTION: idx=372    id=518021
-------------------------------------INPUTS-------------------------------------

tags: arrays, methods
score: 739
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['my_string']}
intent: getting the length of `my_string`
body(Some added characters for better readability):
	
	<p>In 
	Python , is the following the only way to get the number of elements?
	
	start_block
	arr.__len__()
	If so, why the strange syntax?


-------------------------------------OUTPUT-------------------------------------

                Expected= 'len(my_string)'
           base:Baseline= 'print(len(my_string))'
           base:+Canonic= 'len(len(my_string))'
           body:Baseline= 'len(len(my_string))'
              body:-Code= 'len(len(my_string))'
          mined:Baseline= 'len(str(my_string))'
             mined:+Body= 'len(my_string) - my_string'
        mined:+Body, -NL= 'print(len(my_string))'
      mined:+Body, -Code= 'len(str(my_string))'

================================================================================

QUESTION: idx=373    id=40452956
-------------------------------------INPUTS-------------------------------------

tags: 
score: 7
slot_map: {'key': ['str_0'], 'quote': ['"'], 'type': ['str'], 'value': ['\\a']}
intent: remove escape character from string "\\a"
body(Some added characters for better readability):
	I would like to turn this string:
	
	start_block
	a = '\\a'
	into this one 
	
	start_block
	b = '\a'
	
	<p>It doesn't seem like there is an obvious way to do this with 
	`replace`?
	
	<p>EDIT: To be more precise, I want to change the escaping of the backslash to escape the character `a`


-------------------------------------OUTPUT-------------------------------------

                Expected= '"""\\\\a""".decode(\'string_escape\')'
           base:Baseline= '"""\\\\a""".encode(\'utf-8\')'
           base:+Canonic= '"""\\\\a""".encode(\'escape\')'
           body:Baseline= '"""\\\\a""".encode(\'escape\')'
              body:-Code= "re.sub('\\\\A', '\\\\A')"
          mined:Baseline= "re.sub('\\\\a', '', '\\\\a')"
             mined:+Body= "a.replace('\\\\a', '')"
        mined:+Body, -NL= "a.replace('\\\\a', '')"
      mined:+Body, -Code= '"""\\\\a""".replace(\'\\\\\', \'\')'

================================================================================

QUESTION: idx=374    id=8687018
-------------------------------------INPUTS-------------------------------------

tags: string
score: 37
slot_map: {'key': ['str_0', 'str_1', 'str_2', 'str_3', 'str_4'], 'quote': ["'", "'", "'", "'", "'"], 'type': ['str', 'str', 'str', 'str', 'str'], 'value': ['a', 'b', 'b', 'a', 'obama']}
intent: replace each 'a' with 'b' and each 'b' with 'a' in the string 'obama' in a single pass.
body(Some added characters for better readability):
	
	<p>Say I have a string, 
	`"ab"`.
	
	<p>I want to replace 
	`"a"`
	 with 
	`"b"`
	 and 
	`"b"`
	 with 
	`"a"` in one swoop.
	
	<p>So in the end, the string should be 
	`"ba"`
	 and not 
	`"aa"`
	 or 
	`"bb"` and not use more than one line. Is this doable?


-------------------------------------OUTPUT-------------------------------------

                Expected= '"""obama""".replace(\'a\', \'%temp%\').replace(\'b\', \'a\').replace(\'%temp%\', \'b\')'
           base:Baseline= '"""obama""".replace(\'a\', \'b\', \'a\')'
           base:+Canonic= '"""str_4""".replace(\'str_0\',\'str_1\',\'\'))'
           body:Baseline= '"""obama""".replace(\'a\', \'b\', \'a\')'
              body:-Code= '"""obama""".replace(\'a\', \'b\', \'a\')'
          mined:Baseline= '"""obama""".replace(\'a\', \'b\', \'a\')'
             mined:+Body= '"""a""".replace(\'a\', \'b\', \'a\')'
        mined:+Body, -NL= '"""ab""".replace(\'a\', \'b\', \'a\')'
      mined:+Body, -Code= '"""obama""".replace(\'a\', \'b\', \'a\')'

================================================================================

QUESTION: idx=375    id=303200
-------------------------------------INPUTS-------------------------------------

tags: file
score: 923
slot_map: {'key': ['str_0'], 'quote': ["'"], 'type': ['str'], 'value': ['/folder_name']}
intent: remove directory tree '/folder_name'
body(Some added characters for better readability):
	
	<p>I am getting an 'access is denied' error when I attempt to delete a folder that is not empty. I used the following command in my attempt: 
	`os.remove("/folder_name")`. 
	What is the most effective way of removing/deleting a folder/directory that is not empty?


-------------------------------------OUTPUT-------------------------------------

                Expected= "shutil.rmtree('/folder_name')"
           base:Baseline= "os.path.dirname('/folder_name')"
           base:+Canonic= "os.chdir('/folder_name')"
           body:Baseline= "os.remove('/folder_name')"
              body:-Code= "os.path.remove('/folder_name')"
          mined:Baseline= "os.path.remove('/folder_name')"
             mined:+Body= "os.remove('/folder_name')"
        mined:+Body, -NL= "os.path.expanduser('/folder_name')"
      mined:+Body, -Code= "os.path.join(folder, '/folder_name')"

================================================================================

QUESTION: idx=376    id=13740672
-------------------------------------INPUTS-------------------------------------

tags: pandas
score: 16
slot_map: {'key': ['var_0', 'var_1', 'var_2'], 'quote': ['`', '`', '`'], 'type': ['var', 'var', 'var'], 'value': ['weekday', 'data', 'my_dt']}
intent: create a new column `weekday` in pandas data frame `data` based on the values in column `my_dt`
body(Some added characters for better readability):
	I'd like to filter out weekend data and only look at data for weekdays (mon(0)-fri(4)).  I'm new to pandas, what's the best way to accomplish this in pandas?
	
	start_block
	import datetime
	from pandas import *
	data = read_csv("data.csv")
	data.my_dt 
	<console_out>
	0     2012-10-01 02:00:39
	1     2012-10-01 02:00:38
	2     2012-10-01 02:01:05
	3     2012-10-01 02:01:07
	4     2012-10-01 02:02:03
	5     2012-10-01 02:02:09
	6     2012-10-01 02:02:03
	7     2012-10-01 02:02:35
	8     2012-10-01 02:02:33
	9     2012-10-01 02:03:01
	10    2012-10-01 02:08:53
	11    2012-10-01 02:09:04
	12    2012-10-01 02:09:09
	13    2012-10-01 02:10:20
	14    2012-10-01 02:10:45
	<console_out>
	I'd like to do something like:
	
	start_block
	weekdays_only = data[data.my_dt.weekday() < 5]
	AttributeError: 'numpy.int64' object has no attribute 'weekday'
	but this doesn't work, I haven't quite grasped how column datetime objects are accessed.
	The eventual goal being to arrange hierarchically to weekday hour-range, something like:
	
	start_block
	monday, 0-6, 7-12, 13-18, 19-23
	tuesday, 0-6, 7-12, 13-18, 19-23


-------------------------------------OUTPUT-------------------------------------

                Expected= "data['weekday'] = data['my_dt'].apply(lambda x: x.weekday())"
           base:Baseline= "df['weekday'] = df['My_dt']"
           base:+Canonic= "pd.concat([var_1['var_2'].var_0] for var_2 in var_1]"
           body:Baseline= "df['weekday'] = df['my_dt'].strftime('%B')"
              body:-Code= "pd.concat([data['weekday'], axis=1)"
          mined:Baseline= "data.loc[~df['weekday'].isin(my_dt)]"
             mined:+Body= "df['weekday'].str[0]"
        mined:+Body, -NL= "df['weekday'].apply(lambda x: x.dt.weekday() < 5).astype(float)"
      mined:+Body, -Code= "pd.concat([df['weekday'], axis=1)"

================================================================================

QUESTION: idx=377    id=20950650
-------------------------------------INPUTS-------------------------------------

tags: sorting, collections, counter
score: 171
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['x']}
intent: reverse sort counter `x` by values
body(Some added characters for better readability):
	Other than doing list comprehensions of reversed list comprehension, is there a pythonic way to sort Counter by value? If so, it is faster than this:
	
	
	start_block
	>>>from collections import Counter
	>>>x = Counter({'a':5, 'b':3, 'c':7})
	>>>sorted(x)
	...['a', 'b', 'c']
	>>>sorted(x.items())
	...[('a', 5), ('b', 3), ('c', 7)]
	>>>[(l,k) for k,l in sorted([(j,i) for i,j in x.items()])]
	...[('b', 3), ('a', 5), ('c', 7)]
	>>>[(l,k) for k,l in sorted([(j,i) for i,j in x.items()], reverse=True)]
	...[('c', 7), ('a', 5), ('b', 3)


-------------------------------------OUTPUT-------------------------------------

                Expected= 'sorted(x, key=x.get, reverse=True)'
           base:Baseline= 'sorted(x, key=lambda x: x[1])'
           base:+Canonic= 'sorted(x, key=lambda x: x[1])'
           body:Baseline= 'sorted(x, key=lambda x: reverse=True)'
              body:-Code= 'sorted(x, key=lambda x: reverse(x.values))'
          mined:Baseline= 'sorted(x, reverse=True)'
             mined:+Body= 'sorted(x, reverse=True)'
        mined:+Body, -NL= "sorted(Counter({'a': 5, 'b': 3, 'c': 7}, reverse=True)"
      mined:+Body, -Code= 'sorted(x, key=itemgetter(1))'

================================================================================

QUESTION: idx=378    id=20950650
-------------------------------------INPUTS-------------------------------------

tags: sorting, collections, counter
score: 171
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['x']}
intent: reverse sort counter `x` by value
body(Some added characters for better readability):
	Other than doing list comprehensions of reversed list comprehension, is there a pythonic way to sort Counter by value? If so, it is faster than this:
	
	
	start_block
	>>>from collections import Counter
	>>>x = Counter({'a':5, 'b':3, 'c':7})
	>>>sorted(x)
	...['a', 'b', 'c']
	>>>sorted(x.items())
	...[('a', 5), ('b', 3), ('c', 7)]
	>>>[(l,k) for k,l in sorted([(j,i) for i,j in x.items()])]
	...[('b', 3), ('a', 5), ('c', 7)]
	>>>[(l,k) for k,l in sorted([(j,i) for i,j in x.items()], reverse=True)]
	...[('c', 7), ('a', 5), ('b', 3)


-------------------------------------OUTPUT-------------------------------------

                Expected= 'sorted(list(x.items()), key=lambda pair: pair[1], reverse=True)'
           base:Baseline= 'sorted(x, key=lambda x: x[1])'
           base:+Canonic= 'sorted(x, key=lambda x: x[1])'
           body:Baseline= 'sorted(x, reverse=True)'
              body:-Code= 'sorted(x, key=lambda x: reverse(x))'
          mined:Baseline= 'sorted(x, reverse=True)'
             mined:+Body= 'sorted(x, reverse=True)'
        mined:+Body, -NL= "sorted(Counter({'a': 5, 'b': 3, 'c': 7})"
      mined:+Body, -Code= 'sorted(x, key=itemgetter(1))'

================================================================================

QUESTION: idx=379    id=9775297
-------------------------------------INPUTS-------------------------------------

tags: numpy
score: 217
slot_map: {'key': ['str_0', 'str_1'], 'quote': ["'", "'"], 'type': ['str', 'str'], 'value': ['b', 'a']}
intent: append a numpy array 'b' to a numpy array 'a'
body(Some added characters for better readability):
	
	<p>I have a numpy_array. Something like 
	`[ a b c ]`.
	And then I want to concatenate it with another NumPy array (just like we create a list of lists). How do we create a NumPy array containing NumPy arrays?
	I tried to do the following without any luck
	
	
	start_block
	>>>M = np.array([])
	>>>M
	...array([], dtype=float64)
	>>>M.append(a,axis=0)
	...Traceback (most recent call last):
	 File " <stdin>", line 1, in <module>
	AttributeError: 'numpy.ndarray' object has no attribute 'append'
	>>>a
	...array([1, 2, 3])


-------------------------------------OUTPUT-------------------------------------

                Expected= 'np.vstack((a, b))'
           base:Baseline= 'a.append(b, a)'
           base:+Canonic= 'np.array([b, a])'
           body:Baseline= 'M.append(a, axis=0)'
              body:-Code= 'np.array([a, b])'
          mined:Baseline= 'a = np.append(b, a)'
             mined:+Body= 'M = np.array([1, 2, 3])'
        mined:+Body, -NL= 'M = np.append(a, dtype=float64)'
      mined:+Body, -Code= 'a = numpy.array([[1, 2, 3], [4, 5, 6]])'

================================================================================

QUESTION: idx=380    id=21887754
-------------------------------------INPUTS-------------------------------------

tags: arrays, numpy, concatenation
score: 75
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['a', 'b']}
intent: numpy concatenate two arrays `a` and `b` along the first axis
body(Some added characters for better readability):
	I tried the following:
	
	
	start_block
	>>>a = np.array([1,2,3])
	>>>b = np.array([4,5,6])
	>>>np.concatenate((a,b), axis=0)
	...array([1, 2, 3, 4, 5, 6])
	>>>np.concatenate((a,b), axis=1)
	...array([1, 2, 3, 4, 5, 6])
	However, I'd expect at least that one result looks like this
	
	start_block
	array([[1, 2, 3],
	       [4, 5, 6]])
	Why is it not concatenated vertically?


-------------------------------------OUTPUT-------------------------------------

                Expected= 'print(concatenate((a, b), axis=0))'
           base:Baseline= 'np.concatenate(a, b, axis=0)'
           base:+Canonic= 'numpy.concat([a, b])'
           body:Baseline= 'np.concatenate((a, b), axis=1)'
              body:-Code= 'numpy.concat([a, b])'
          mined:Baseline= 'np.concatenate([a, b], axis=1)'
             mined:+Body= 'np.concatenate((a, b), axis=1)'
        mined:+Body, -NL= 'np.concatenate((a, b), axis=1)'
      mined:+Body, -Code= 'np.concatenate(a, b, axis=1)'

================================================================================

QUESTION: idx=381    id=21887754
-------------------------------------INPUTS-------------------------------------

tags: arrays, numpy, concatenation
score: 75
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['a', 'b']}
intent: numpy concatenate two arrays `a` and `b` along the second axis
body(Some added characters for better readability):
	I tried the following:
	
	
	start_block
	>>>a = np.array([1,2,3])
	>>>b = np.array([4,5,6])
	>>>np.concatenate((a,b), axis=0)
	...array([1, 2, 3, 4, 5, 6])
	>>>np.concatenate((a,b), axis=1)
	...array([1, 2, 3, 4, 5, 6])
	However, I'd expect at least that one result looks like this
	
	start_block
	array([[1, 2, 3],
	       [4, 5, 6]])
	Why is it not concatenated vertically?


-------------------------------------OUTPUT-------------------------------------

                Expected= 'print(concatenate((a, b), axis=1))'
           base:Baseline= 'np.concatenate(a, b, axis=1)'
           base:+Canonic= 'numpy.concat([a, b])'
           body:Baseline= 'np.concatenate((a, b), axis=1)'
              body:-Code= 'numpy.concat([a, b])'
          mined:Baseline= 'np.concatenate([a, b], axis=1)'
             mined:+Body= 'np.concatenate((a, b), axis=1)'
        mined:+Body, -NL= 'np.concatenate((a, b), axis=1)'
      mined:+Body, -Code= 'np.concatenate(a, b, axis=1)'

================================================================================

QUESTION: idx=382    id=21887754
-------------------------------------INPUTS-------------------------------------

tags: arrays, numpy, concatenation
score: 75
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['a', 'b']}
intent: numpy concatenate two arrays `a` and `b` along the first axis
body(Some added characters for better readability):
	I tried the following:
	
	
	start_block
	>>>a = np.array([1,2,3])
	>>>b = np.array([4,5,6])
	>>>np.concatenate((a,b), axis=0)
	...array([1, 2, 3, 4, 5, 6])
	>>>np.concatenate((a,b), axis=1)
	...array([1, 2, 3, 4, 5, 6])
	However, I'd expect at least that one result looks like this
	
	start_block
	array([[1, 2, 3],
	       [4, 5, 6]])
	Why is it not concatenated vertically?


-------------------------------------OUTPUT-------------------------------------

                Expected= 'c = np.r_[a[(None), :], b[(None), :]]'
           base:Baseline= 'np.concatenate(a, b, axis=0)'
           base:+Canonic= 'numpy.concat([a, b])'
           body:Baseline= 'np.concatenate((a, b), axis=1)'
              body:-Code= 'numpy.concat([a, b])'
          mined:Baseline= 'np.concatenate([a, b], axis=1)'
             mined:+Body= 'np.concatenate((a, b), axis=1)'
        mined:+Body, -NL= 'np.concatenate((a, b), axis=1)'
      mined:+Body, -Code= 'np.concatenate(a, b, axis=1)'

================================================================================

QUESTION: idx=383    id=21887754
-------------------------------------INPUTS-------------------------------------

tags: arrays, numpy, concatenation
score: 75
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['a', 'b']}
intent: numpy concatenate two arrays `a` and `b` along the first axis
body(Some added characters for better readability):
	I tried the following:
	
	
	start_block
	>>>a = np.array([1,2,3])
	>>>b = np.array([4,5,6])
	>>>np.concatenate((a,b), axis=0)
	...array([1, 2, 3, 4, 5, 6])
	>>>np.concatenate((a,b), axis=1)
	...array([1, 2, 3, 4, 5, 6])
	However, I'd expect at least that one result looks like this
	
	start_block
	array([[1, 2, 3],
	       [4, 5, 6]])
	Why is it not concatenated vertically?


-------------------------------------OUTPUT-------------------------------------

                Expected= 'np.array((a, b))'
           base:Baseline= 'np.concatenate(a, b, axis=0)'
           base:+Canonic= 'numpy.concat([a, b])'
           body:Baseline= 'np.concatenate((a, b), axis=1)'
              body:-Code= 'numpy.concat([a, b])'
          mined:Baseline= 'np.concatenate([a, b], axis=1)'
             mined:+Body= 'np.concatenate((a, b), axis=1)'
        mined:+Body, -NL= 'np.concatenate((a, b), axis=1)'
      mined:+Body, -Code= 'np.concatenate(a, b, axis=1)'

================================================================================

QUESTION: idx=384    id=2805231
-------------------------------------INPUTS-------------------------------------

tags: dns
score: 99
slot_map: {'key': ['str_0'], 'quote': ["'"], 'type': ['str'], 'value': ['google.com']}
intent: fetch address information for host 'google.com' ion port 80
body(Some added characters for better readability):
	
	<a>dnspython 
	 will do my DNS lookups very nicely, but it entirely ignores the contents of 
	`/etc/hosts`.
	
	<p>Is there a python library call which will do the right thing? ie check first in 
	`etc/hosts`, and only fall back to DNS lookups otherwise?


-------------------------------------OUTPUT-------------------------------------

                Expected= "print(socket.getaddrinfo('google.com', 80))"
           base:Baseline= "dns.get('google.com', port=80)"
           base:+Canonic= "os.system('str_0 ion port 80')"
           body:Baseline= "print(os.path.get('google.com', 80))"
              body:-Code= "fetch('google.com', port 80)"
          mined:Baseline= 'server.serve_forever()'
             mined:+Body= "dnspython.fetchhostname('google.com', port 80)"
        mined:+Body, -NL= "os.environ['google.com'][0]"
      mined:+Body, -Code= "fetchaddr('google.com', 80)"

================================================================================

QUESTION: idx=385    id=17552997
-------------------------------------INPUTS-------------------------------------

tags: pandas
score: 11
slot_map: {'key': ['str_0', 'str_1', 'var_0'], 'quote': ["'", "'", '`'], 'type': ['str', 'str', 'var'], 'value': ['day', 'sat', 'df']}
intent: add a column 'day' with value 'sat' to dataframe `df`
body(Some added characters for better readability):
	I'm using a MultiIndexed pandas DataFrame and would like to multiply a subset of the DataFrame by a certain number.
	
	<p>It's the same as 
	this  but with a MultiIndex.
	
	
	start_block
	>>>d = pd.DataFrame({'year':[2008,2008,2008,2008,2009,2009,2009,2009], 
	...                     'flavour':['strawberry','strawberry','banana','banana',
	                      'strawberry','strawberry','banana','banana'],
	                      'day':['sat','sun','sat','sun','sat','sun','sat','sun'],
	                      'sales':[10,12,22,23,11,13,23,24]})
	>>>d = d.set_index(['year','flavour','day'])                  
	...
	>>>d
	...                    sales
	year flavour    day       
	2008 strawberry sat     10
	                sun     12
	     banana     sat     22
	                sun     23
	2009 strawberry sat     11
	                sun     13
	     banana     sat     23
	                sun     24
	
	<p>So far, so good. But let's say I spot that all the Saturday figures are only half what they should be! I'd like to multiply all 
	`sat` sales by 2.
	My first attempt at this was:
	
	start_block
	sat = d.xs('sat', level='day')
	sat = sat * 2
	d.update(sat)
	
	<p>but this doesn't work because the variable 
	`sat`
	 has lost the 
	`day` level of the index:
	
	
	start_block
	>>>sat
	...                sales
	year flavour          
	2008 strawberry     20
	     banana         44
	2009 strawberry     22
	     banana         46
	so pandas doesn't know how to join the new sales figures back onto the old dataframe.
	I had a quick stab at:
	
	
	start_block
	>>>sat = d.xs('sat', level='day', copy=False)
	...Traceback (most recent call last):
	  File " <stdin>", line 1, in <module>
	  File "C:\Python27\lib\site-packages\pandas\core\frame.py", line 2248, in xs
	    raise ValueError('Cannot retrieve view (copy=False)')
	ValueError: Cannot retrieve view (copy=False)
	I have no idea what that error means, but I feel like I'm making a mountain out of a molehill. Does anyone know the right way to do this?
	Thanks in advance,
	Rob


-------------------------------------OUTPUT-------------------------------------

                Expected= "df.xs('sat', level='day', drop_level=False)"
           base:Baseline= "df['Day'].strftime('sat')"
           base:+Canonic= "df['day'].str.split('sat')"
           body:Baseline= "df['day'].set_index(['sat'])"
              body:-Code= "df['Day'].strftime('sat')"
          mined:Baseline= "df['day'].str.add('sat')"
             mined:+Body= "df.ix['day'].apply(lambda x: x.strftime('sat'))"
        mined:+Body, -NL= "df['day'] = df['year'].apply(lambda x: x['day'], axis=1)"
      mined:+Body, -Code= "df.groupby('Sales').sum()"

================================================================================

QUESTION: idx=386    id=4356842
-------------------------------------INPUTS-------------------------------------

tags: django
score: 52
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: return a 401 unauthorized in django
body(Some added characters for better readability):
	Instead of doing this:
	
	start_block
	res = HttpResponse("Unauthorized")
	res.status_code = 401
	return res
	Is there a way to do it without typing it every time?


-------------------------------------OUTPUT-------------------------------------

                Expected= "return HttpResponse('Unauthorized', status=401)"
           base:Baseline= 'return 401 unauthorized in django.return False'
           base:+Canonic= 'return (401)(expand=False)'
           body:Baseline= "res = HttpResponse('Unauthorized')"
              body:-Code= 'return 401(None)\nreturn 401((None)'
          mined:Baseline= "self.request.GET.get('401', '')"
             mined:+Body= "return HttpResponse('Unauthorized')"
        mined:+Body, -NL= "return HttpResponse('Unauthorized')"
      mined:+Body, -Code= 'return HttpResponse(status=401, error=False)'

================================================================================

QUESTION: idx=387    id=13598363
-------------------------------------INPUTS-------------------------------------

tags: flask, jinja2
score: 58
slot_map: {'key': ['str_0'], 'quote': ["'"], 'type': ['str'], 'value': ['wherever']}
intent: flask set folder 'wherever' as the default template folder
body(Some added characters for better readability):
	By default flask uses template files stored in "template" directory :
	
	start_block
	/flaskapp
	    /application.py
	    /templates
	        /hello.html
	Is there any way to dynamically choose template directory according to user logged in? This is how I want the directory structure to be :
	
	start_block
	/flaskapp
	    /application.py
	    /templates (default template goes here)
	        /hello.html
	    /userdata
	        /user1
	            /template1
	                 hello.html
	            /template2
	                 hello.html
	        /user2
	            /template1
	                 hello.html
	            /template2
	                 hello.html
	Now if I have the username of logged in user and the name of template activated by user, is it possible to dynamically select the directory to load template files? For example, 
	
	start_block
	/userdata/ <username>/ <activated template name>/
	instead of fixed
	
	start_block
	/templates/
	What I am trying to achieve is a wordpress like theme system for my web application where users can upload/select themes for his website.


-------------------------------------OUTPUT-------------------------------------

                Expected= "Flask(__name__, template_folder='wherever')"
           base:Baseline= "jinja2.set_folder('wherever')"
           base:+Canonic= "flask.set_default_folder('wherever')"
           body:Baseline= "flaskapp.set_folder('wherever')"
              body:-Code= "flask.set_folder('wherever')"
          mined:Baseline= "flask.Set_default_template('wherever')"
             mined:+Body= "app.config['wherever'] = os.path.expanduser('template')"
        mined:+Body, -NL= "os.path.expanduser('wherever')"
      mined:+Body, -Code= "app.run(host='wherever')"

================================================================================

QUESTION: idx=388    id=1849375
-------------------------------------INPUTS-------------------------------------

tags: sqlalchemy
score: 30
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: how do i insert into t1 (select * from t2) in sqlalchemy?
body(Some added characters for better readability):
	
	<p>In SQLAlchemy, how do I populate or update a table from a 
	`SELECT` statement?


-------------------------------------OUTPUT-------------------------------------

                Expected= "session.execute('INSERT INTO t1 (SELECT * FROM t2)')"
           base:Baseline= 'sqlalchemy.insert(select * FROM t2)'
           base:+Canonic= "cursor.execute('select * from t2')"
           body:Baseline= 'print(( SELECT * FROM t2))'
              body:-Code= "input('select * from t2')"
          mined:Baseline= "session.query(T1).select('SELECT * FROM t2')"
             mined:+Body= "cursor.execute('SELECT * FROM t2')"
        mined:+Body, -NL= "cursor.execute('SELECT * FROM t2')"
      mined:+Body, -Code= "session.query('SELECT * FROM t2')"

================================================================================

QUESTION: idx=389    id=3398589
-------------------------------------INPUTS-------------------------------------

tags: list, sorting
score: 9
slot_map: {'key': ['str_0'], 'quote': ["'"], 'type': ['str'], 'value': ['c2']}
intent: sort a list of lists 'c2' such that third row comes first
body(Some added characters for better readability):
	
	start_block
	c2=[]
	row1=[1,22,53]
	row2=[14,25,46]
	row3=[7,8,9]
	c2.append(row2)
	c2.append(row1)
	c2.append(row3)
	
	`c2` is now:
	
	start_block
	[[14, 25, 46], [1, 22, 53], [7, 8, 9]]
	
	<p>how do i sort 
	`c2` in such a way that for example:
	
	start_block
	for row in c2:
	sort on row[2]
	the result would be:
	
	start_block
	[[7,8,9],[14,25,46],[1,22,53]]
	the other question is how do i first sort by row[2] and within that set by row[1]


-------------------------------------OUTPUT-------------------------------------

                Expected= 'c2.sort(key=lambda row: row[2])'
           base:Baseline= 'sorted(c2, key=lambda x: x[1])'
           base:+Canonic= 'sorted(c2, key=lambda x: x[1])'
           body:Baseline= 'sorted(list(c2.items()), key=lambda x: x[2])'
              body:-Code= 'sorted(c2, key=lambda x: x[2])'
          mined:Baseline= 'sorted(c2, key=lambda x: x[1])'
             mined:+Body= 'sorted(c2, key=lambda x: x[2], reverse=True)'
        mined:+Body, -NL= 'c2.sort(key=lambda x: x[1])'
      mined:+Body, -Code= 'sorted(c2, key=lambda row: (row[2], row[3]))'

================================================================================

QUESTION: idx=390    id=3398589
-------------------------------------INPUTS-------------------------------------

tags: list, sorting
score: 9
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: sorting a list of lists in python
body(Some added characters for better readability):
	
	start_block
	c2=[]
	row1=[1,22,53]
	row2=[14,25,46]
	row3=[7,8,9]
	c2.append(row2)
	c2.append(row1)
	c2.append(row3)
	
	`c2` is now:
	
	start_block
	[[14, 25, 46], [1, 22, 53], [7, 8, 9]]
	
	<p>how do i sort 
	`c2` in such a way that for example:
	
	start_block
	for row in c2:
	sort on row[2]
	the result would be:
	
	start_block
	[[7,8,9],[14,25,46],[1,22,53]]
	the other question is how do i first sort by row[2] and within that set by row[1]


-------------------------------------OUTPUT-------------------------------------

                Expected= 'c2.sort(key=lambda row: (row[2], row[1], row[0]))'
           base:Baseline= 'sorted(list, key=lambda x: x[1])'
           base:+Canonic= 'sorted(list, key=lambda x: x[1])'
           body:Baseline= 'c2.sort(key=lambda x: x[1])'
              body:-Code= 'sorted(list, key=lambda x: sorted(x[1])'
          mined:Baseline= 'sorted(list_of_lists, key=lambda x: x[1])'
             mined:+Body= 'c2.sort(key=lambda x: x[2])'
        mined:+Body, -NL= 'c2.sort(key=lambda x: x[1])'
      mined:+Body, -Code= 'sorted(lst, key=lambda x: x[1])'

================================================================================

QUESTION: idx=391    id=3398589
-------------------------------------INPUTS-------------------------------------

tags: list, sorting
score: 9
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: sorting a list of lists in python
body(Some added characters for better readability):
	
	start_block
	c2=[]
	row1=[1,22,53]
	row2=[14,25,46]
	row3=[7,8,9]
	c2.append(row2)
	c2.append(row1)
	c2.append(row3)
	
	`c2` is now:
	
	start_block
	[[14, 25, 46], [1, 22, 53], [7, 8, 9]]
	
	<p>how do i sort 
	`c2` in such a way that for example:
	
	start_block
	for row in c2:
	sort on row[2]
	the result would be:
	
	start_block
	[[7,8,9],[14,25,46],[1,22,53]]
	the other question is how do i first sort by row[2] and within that set by row[1]


-------------------------------------OUTPUT-------------------------------------

                Expected= 'c2.sort(key=lambda row: (row[2], row[1]))'
           base:Baseline= 'sorted(list, key=lambda x: x[1])'
           base:+Canonic= 'sorted(list, key=lambda x: x[1])'
           body:Baseline= 'c2.sort(key=lambda x: x[1])'
              body:-Code= 'sorted(list, key=lambda x: sorted(x[1])'
          mined:Baseline= 'sorted(list_of_lists, key=lambda x: x[1])'
             mined:+Body= 'c2.sort(key=lambda x: x[2])'
        mined:+Body, -NL= 'c2.sort(key=lambda x: x[1])'
      mined:+Body, -Code= 'sorted(lst, key=lambda x: x[1])'

================================================================================

QUESTION: idx=392    id=10960463
-------------------------------------INPUTS-------------------------------------

tags: unicode, matplotlib, ascii
score: 47
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['Arial']}
intent: set font `arial` to display non-ascii characters in matplotlib
body(Some added characters for better readability):
	
	<p>I have a problem displaying non- 
	ASCII  characters in Matplotlib, these characters are rendered as small boxes instead of a proper font, it looks like (I filled these boxes with red paint to hightlight them): 
	How do I fix it? 
	
	<p>A related question is 
	Accented characters in Matplotlib .


-------------------------------------OUTPUT-------------------------------------

                Expected= "matplotlib.rc('font', **{'sans-serif': 'Arial', 'family': 'sans-serif'})"
           base:Baseline= "ax.set_font('arial')"
           base:+Canonic= "plt.set_font('Arial')"
           body:Baseline= "matplotlib.set_font('arial')"
              body:-Code= "matplotlib.set_font('arial')"
          mined:Baseline= "ax.set_font('arial')"
             mined:+Body= "matplotlib.use('font', 'arial')"
        mined:+Body, -NL= "ax.set_font('arial')"
      mined:+Body, -Code= "matplotlib.use('ASCII')"

================================================================================

QUESTION: idx=393    id=20576618
-------------------------------------INPUTS-------------------------------------

tags: datetime, pandas
score: 15
slot_map: {'key': ['str_0', 'str_1'], 'quote': ["'", "'"], 'type': ['str', 'str'], 'value': ['date', 'df']}
intent: convert  datetime column 'date' of pandas dataframe 'df' to ordinal
body(Some added characters for better readability):
	I'm trying to create a new Pandas dataframe column with ordinal day from a datetime column:
	
	start_block
	import pandas as pd
	from datetime import datetime
	print df.ix[0:5]
	                              date
	file                              
	gom3_197801.nc 2011-02-16 00:00:00
	gom3_197802.nc 2011-02-16 00:00:00
	gom3_197803.nc 2011-02-15 00:00:00
	gom3_197804.nc 2011-02-17 00:00:00
	gom3_197805.nc 2011-11-14 00:00:00
	df['date'][0].toordinal()
	<console_out>
	734184
	df['date'].toordinal()
	---------------------------------------------------------------------------
	AttributeError                            Traceback (most recent call last)
	<ipython-input-7-dbfd5e8b60f0> in <module>()
	----> 1 df['date'].toordinal()
	AttributeError: 'Series' object has no attribute 'toordinal'
	I guess this is a basic question, but I've struggled reading docs for last 30 minutes. 
	How can I create an ordinal time column for my dataframe?


-------------------------------------OUTPUT-------------------------------------

                Expected= "df['date'].apply(lambda x: x.toordinal())"
           base:Baseline= "df['Date'].strftime('%Y')"
           base:+Canonic= "df.to_datetime('date').strftime('%Y-%m-%d')"
           body:Baseline= "df['date'].toordinal()"
              body:-Code= "df['Date'].to_ordinal()"
          mined:Baseline= "df['date'] = df['date'].astype(int)"
             mined:+Body= "df['date'].toordinal()"
        mined:+Body, -NL= "df['date'].toordinal()"
      mined:+Body, -Code= "df.to_datetime(df['date'])"

================================================================================

QUESTION: idx=394    id=7263824
-------------------------------------INPUTS-------------------------------------

tags: selenium, selenium-webdriver, webdriver, automated-tests
score: 527
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['element']}
intent: get html source of selenium webelement `element`
body(Some added characters for better readability):
	I'm using the Python bindings to run Selenium WebDriver:
	
	start_block
	from selenium import webdriver
	wd = webdriver.Firefox()
	I know I can grab a webelement like so:
	
	start_block
	elem = wd.find_element_by_css_selector('#my-id')
	And I know I can get the full page source with...
	
	start_block
	wd.page_source
	But is there a way to get the "element source"?
	
	start_block
	elem.source   # <-- returns the HTML as a string
	The Selenium WebDriver documentation for Python are basically non-existent and I don't see anything in the code that seems to enable that functionality.
	What is the best way to access the HTML of an element (and its children)?


-------------------------------------OUTPUT-------------------------------------

                Expected= "element.get_attribute('innerHTML')"
           base:Baseline= 'driver.find_element_by_css_selector(element)'
           base:+Canonic= "webbrowser.find_element_by_css_selector('element').get('html')"
           body:Baseline= "wd.find_element_by_css_selector('#myid')"
              body:-Code= 'driver.find_element_by_css_selector(element)'
          mined:Baseline= "driver.find_element_by_css_selector('.//div[@class='title']/text/plain')"
             mined:+Body= "element = webdriver.get('http://www.google.com')"
        mined:+Body, -NL= "webbrowser.find_element_by_css_selector('#my-id')"
      mined:+Body, -Code= 'element = webdriver.find_element_by_xpath("//element[source\']")'

================================================================================

QUESTION: idx=395    id=31793195
-------------------------------------INPUTS-------------------------------------

tags: pandas
score: 6
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['bob']}
intent: get the integer location of a key `bob` in a pandas data frame
body(Some added characters for better readability):
	How can I get the integer location of a key to a pandas index as quickly as possible?
	
	<p>eg, given `pd.DataFrame(data=np.asarray([[1,2,3],[4,5,6],[7,8,9]]), index=['alice', 'bob', 'charlie'])`
	what is the fastest way to go from 'bob' to 1


-------------------------------------OUTPUT-------------------------------------

                Expected= "df.index.get_loc('bob')"
           base:Baseline= "df['bob'].loc[0]"
           base:+Canonic= 'df.loc[bob]'
           body:Baseline= "df['bob'].loc[1]"
              body:-Code= "df['bob'].loc[0]"
          mined:Baseline= "df['bob'].map(int)"
             mined:+Body= "df['a'] = df['bob'].loc[0]"
        mined:+Body, -NL= "pd.concat([df['bob']], axis=1)"
      mined:+Body, -Code= 'df.loc[len(df.index) == 1]'

================================================================================

QUESTION: idx=396    id=7574841
-------------------------------------INPUTS-------------------------------------

tags: terminal
score: 15
slot_map: {'key': ['str_0', 'str_1'], 'quote': ["'", "'"], 'type': ['str', 'str'], 'value': ['gnome', 'sudo apt-get update']}
intent: open a 'gnome' terminal from python script and run  'sudo apt-get update' command.
body(Some added characters for better readability):
	I'm developing a program that has a button. When pressed, I want to open a terminal that runs:  
	
	start_block
	sudo apt-get update
	I'm using:
	
	start_block
	os.system("gnome-terminal -e 'sudo apt-get update'")
	This works fine. The only problem is that when the update is finished, the terminal closes.
	What can I do to leave the terminal open?


-------------------------------------OUTPUT-------------------------------------

                Expected= 'os.system(\'gnome-terminal -e \\\'bash -c "sudo apt-get update; exec bash"\\\'\')'
           base:Baseline= "os.system('sudo apt-get update')"
           base:+Canonic= "os.system('gnome', shell=True)"
           body:Baseline= "os.system('gnome-terminal -e'sudo apt-get update')"
              body:-Code= "os.system('gnome', shell=True)"
          mined:Baseline= "os.system('sudo apt-get update')"
             mined:+Body= "os.system('gnome-terminal -e'sudo apt-get update')"
        mined:+Body, -NL= 'os.system(\'gnome-terminal -e\'sudo apt-get update\'")'
      mined:+Body, -Code= "os.system('sudo apt-get update')"

================================================================================

QUESTION: idx=397    id=10487278
-------------------------------------INPUTS-------------------------------------

tags: arrays
score: 410
slot_map: {'key': ['str_0', 'var_0'], 'quote': ["'", '`'], 'type': ['str', 'var'], 'value': ['third_key', 'my_dict']}
intent: add an item with key 'third_key' and value 1 to an dictionary `my_dict`
body(Some added characters for better readability):
	I'm trying to add items to an array in python.
	I run 
	
	start_block
	array = {}
	Then, I try to add something to this array by doing:
	
	start_block
	array.append(valueToBeInserted)
	
	<p>There doesn't seem to be a 
	`.append` method for this.  How do I add items to an array?


-------------------------------------OUTPUT-------------------------------------

                Expected= "my_dict.update({'third_key': 1})"
           base:Baseline= 'dict((k, v) for k, v in my_dict.items())'
           base:+Canonic= "my_dict.update({'third_key': 1})"
           body:Baseline= "my_dict.update({'third_key': 1})"
              body:-Code= "my_dict.update({'third_key': 1})"
          mined:Baseline= "my_dict.update({'third_key': 1})"
             mined:+Body= "array = {'third_key': 1, 'value1': 1}"
        mined:+Body, -NL= "my_dict.append({'third_key': '1'})"
      mined:+Body, -Code= "my_dict = {'third_key': 1, '1': 1}"

================================================================================

QUESTION: idx=398    id=10487278
-------------------------------------INPUTS-------------------------------------

tags: arrays
score: 410
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: declare an array
body(Some added characters for better readability):
	I'm trying to add items to an array in python.
	I run 
	
	start_block
	array = {}
	Then, I try to add something to this array by doing:
	
	start_block
	array.append(valueToBeInserted)
	
	<p>There doesn't seem to be a 
	`.append` method for this.  How do I add items to an array?


-------------------------------------OUTPUT-------------------------------------

                Expected= 'my_list = []'
           base:Baseline= 'array([int(x)) for x in array]'
           base:+Canonic= 'np.array([0, 1], axis=1)'
           body:Baseline= 'array.append(valueToBeInserted)'
              body:-Code= 'np.array([x[0] for x in range(10)]'
          mined:Baseline= 'array([[1, 2, 3], [4, 5, 6]])'
             mined:+Body= 'array = [[1, 2, 3], [4, 5, 6]]'
        mined:+Body, -NL= 'array.append(valueToBeInserted)'
      mined:+Body, -Code= 'a = [[1, 2, 3], [4, 5, 6]]'

================================================================================

QUESTION: idx=399    id=10487278
-------------------------------------INPUTS-------------------------------------

tags: arrays
score: 410
slot_map: {'key': ['str_0', 'var_0'], 'quote': ['`', '`'], 'type': ['str', 'var'], 'value': ['12', 'my_list']}
intent: insert item `12` to a list `my_list`
body(Some added characters for better readability):
	I'm trying to add items to an array in python.
	I run 
	
	start_block
	array = {}
	Then, I try to add something to this array by doing:
	
	start_block
	array.append(valueToBeInserted)
	
	<p>There doesn't seem to be a 
	`.append` method for this.  How do I add items to an array?


-------------------------------------OUTPUT-------------------------------------

                Expected= 'my_list.append(12)'
           base:Baseline= 'my_list = [x for x in range(12)]'
           base:+Canonic= 'my_list = my_list.insert(12)'
           body:Baseline= 'my_list = [item for item in my_list]'
              body:-Code= 'my_list.insert(12)'
          mined:Baseline= 'my_list = [i for i in range(12)]'
             mined:+Body= 'my_list.append(12)'
        mined:+Body, -NL= 'my_list.append(12)'
      mined:+Body, -Code= 'my_list.append(12)'

================================================================================

QUESTION: idx=400    id=10155684
-------------------------------------INPUTS-------------------------------------

tags: list, append
score: 13
slot_map: {'key': ['str_0', 'var_0'], 'quote': ["'", '`'], 'type': ['str', 'var'], 'value': ['wuggah', 'myList']}
intent: add an entry 'wuggah' at the beginning of list `mylist`
body(Some added characters for better readability):
	
	<p>I have a 
	`list`
	 of about 40 entries. And I frequently want to append an item to the start of the list (with id 0) and want to delete the 
	`last` entry (with id 40) of the list.
	How do I do this the best?
	Example with 5 entries:
	
	start_block
	[0] = "herp"
	[1] = "derp"
	[2] = "blah"
	[3] = "what"
	[4] = "da..."
	
	<p>after adding 
	`"wuggah"` and deleting last it should be like:
	
	start_block
	[0] = "wuggah"
	[1] = "herp"
	[2] = "derp"
	[3] = "blah"
	[4] = "what"
	And I don't want to end up manually moving them one after another all of the entries to the next id.


-------------------------------------OUTPUT-------------------------------------

                Expected= "myList.insert(0, 'wuggah')"
           base:Baseline= "myList.append('wuggah')"
           base:+Canonic= 'myList = myList[0]'
           body:Baseline= "mylist.pop('wuggah')"
              body:-Code= "mylist.pop('wuggah')"
          mined:Baseline= "mylist = [item['wuggah'] for item in mylist]"
             mined:+Body= "mylist.pop('wuggah')"
        mined:+Body, -NL= "mylist.append('wuggah')"
      mined:+Body, -Code= "mylist.pop('wuggah')"

================================================================================

QUESTION: idx=401    id=3519125
-------------------------------------INPUTS-------------------------------------

tags: hex, representation
score: 6
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: convert a hex-string representation to actual bytes
body(Some added characters for better readability):
	i need to load the third column of this text file as a hex string
	http://www.netmite.com/android/mydroid/1.6/external/skia/emoji/gmojiraw.txt
	
	
	start_block
	>>>open('gmojiraw.txt').read().split('\n')[0].split('\t')[2]
	...'\\xF3\\xBE\\x80\\x80'
	how do i open the file so that i can get the third column as hex string:
	
	start_block
	'\xF3\xBE\x80\x80'
	i also tried binary mode and hex mode, with no success.


-------------------------------------OUTPUT-------------------------------------

                Expected= '"""\\\\xF3\\\\xBE\\\\x80\\\\x80""".replace(\'\\\\x\', \'\').decode(\'hex\')'
           base:Baseline= "struct.unpack('hex', 16)"
           base:+Canonic= "struct.unpack('hex-string', 16)"
           body:Baseline= "[int(x) for x in open('gmojiraw.txt').decode('hex')"
              body:-Code= "struct.unpack('hex', 3)"
          mined:Baseline= "struct.unpack('<I', s)[0]"
             mined:+Body= "hex_string = ''.join(open('gmojiraw.txt').read().split('\\n')[0])"
        mined:+Body, -NL= '"""""".join(struct.unpack(\'Q\', s))'
      mined:+Body, -Code= '"""""".join(chr(ord(c)) for c in open(\'demo.txt\', \'rb\')'

================================================================================

QUESTION: idx=402    id=40144769
-------------------------------------INPUTS-------------------------------------

tags: pandas
score: 85
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['df']}
intent: select the last column of dataframe `df`
body(Some added characters for better readability):
	I have done some searching for the answer to this question, but all I can figure out is this: 
	
	start_block
	df[df.columns[len(df.columns)-1]]
	which to me seems unweildy, and un-pythonic (and slow?). 
	What is the easiest way to select the data for the last column in a pandas dataframe without specifying the name of the column?


-------------------------------------OUTPUT-------------------------------------

                Expected= 'df[df.columns[-1]]'
           base:Baseline= 'df.loc[df.columns]'
           base:+Canonic= 'df.loc[:, (0, 1)]'
           body:Baseline= 'df[df].columns[len(df.columns)-1]]'
              body:-Code= 'df.loc[:, (df.columns)]'
          mined:Baseline= 'df.iloc[:-1]'
             mined:+Body= 'df[df.columns[len(df)] - 1]'
        mined:+Body, -NL= 'df[df.columns[len(df.values), -1]]'
      mined:+Body, -Code= 'df.drop(df.index)'

================================================================================

QUESTION: idx=403    id=30787901
-------------------------------------INPUTS-------------------------------------

tags: pandas, dataframe
score: 126
slot_map: {'key': ['var_0', 'str_0', 'str_1'], 'quote': ['`', "'", "'"], 'type': ['var', 'str', 'str'], 'value': ['df', 'Letters', 'C']}
intent: get the first value from dataframe `df` where column 'letters' is equal to 'c'
body(Some added characters for better readability):
	Say I have the following DataFrame
	
	Letter    Number
	A          1
	B          2
	C          3
	D          4
	Which can be obtained through the following code
	
	start_block
	import pandas as pd
	letters=pd.Series(('A', 'B', 'C', 'D'))
	numbers=pd.Series((1, 2, 3, 4))
	keys=('Letters', 'Numbers')
	df=pd.concat((letters, numbers), axis=1, keys=keys)
	Now I want to get the value C from the column Letters.
	The command line
	
	start_block
	df[df.Letters=='C'].Letters
	will return
	
	2    C
	Name: Letters, dtype: object
	How can I get only the value C and not the whole two line output?


-------------------------------------OUTPUT-------------------------------------

                Expected= "df.loc[df['Letters'] == 'C', 'Letters'].values[0]"
           base:Baseline= "df['letters'] == 'C']"
           base:+Canonic= "df['Letters'] == 'C'"
           body:Baseline= "df[df.Letters == 'C')"
              body:-Code= "df.loc[df['letters'] == 'C']"
          mined:Baseline= "df.loc[df['letters'].isin(['c'])]"
             mined:+Body= "df[df.Letters == 'C']"
        mined:+Body, -NL= "df[df.C.isin(['A', 'B', 'C'])]"
      mined:+Body, -Code= "df['Letter'].str.contains('C')"

================================================================================

QUESTION: idx=404    id=18730044
-------------------------------------INPUTS-------------------------------------

tags: arrays, numpy, matrix
score: 37
slot_map: {'key': ['str_0', 'str_1', '[str_0]', '[str_1]'], 'quote': ['`', '`', '`', '`'], 'type': ['str', 'str', 'str', 'str'], 'value': ['[1, 2, 3]', '[4, 5, 6]', '[1, 2, 3]', '[4, 5, 6]']}
intent: converting two lists `[1, 2, 3]` and `[4, 5, 6]` into a matrix
body(Some added characters for better readability):
	I'll try to be as clear as possible, and I'll start by explaining why I want to transform two arrays into a matrix.
	To plot the performance of a portfolio vs an market index I need a data structure like in this format:
	
	start_block
	[[portfolio_value1, index_value1]
	 [portfolio_value2, index_value2]]
	But I have the the data as two separate 1-D arrays:
	
	start_block
	portfolio = [portfolio_value1, portfolio_value2, <console_out>]
	index = [index_value1, index_value2, <console_out>]
	
	<p>So how do I transform the second scenario into the first. I've tried 
	`np.insert` to add the second array to a test matrix I had in a python shell, my problem was to transpose the first array into a single column matrix.
	Any help on how to achieve this without an imperative loop would be great.


-------------------------------------OUTPUT-------------------------------------

                Expected= 'np.column_stack(([1, 2, 3], [4, 5, 6]))'
           base:Baseline= 'np.concat([1, 2, 3], [4, 5, 6])'
           base:+Canonic= 'numpy.matrix([[1, 2, 3], [4, 5, 6]])'
           body:Baseline= 'np.concat([1, 2, 3], [4, 5, 6])'
              body:-Code= 'np.concat([1, 2, 3], [4, 5, 6])'
          mined:Baseline= 'matrix([1, 2, 3], [4, 5, 6])'
             mined:+Body= 'np.concatenate(([[1, 2, 3]], [4, 5, 6]))'
        mined:+Body, -NL= 'numpy.concat([1, 2, 3], axis=1)'
      mined:+Body, -Code= 'np.array([1, 2, 3], [4, 5, 6])'

================================================================================

QUESTION: idx=405    id=402504
-------------------------------------INPUTS-------------------------------------

tags: types, unsigned, signed, 16-bit
score: 1764
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['i']}
intent: get the type of `i`
body(Some added characters for better readability):
	How do I see the type of a variable whether it is unsigned 32 bit, signed 16 bit, etc.?
	How do I view it?


-------------------------------------OUTPUT-------------------------------------

                Expected= 'type(i)'
           base:Baseline= 'print(i.__type__))'
           base:+Canonic= 'print(i.type())'
           body:Baseline= 'print(i.__str__)'
              body:-Code= 'print(i.__str__)'
          mined:Baseline= 'print(i.__dict__)'
             mined:+Body= 'print(type(i.__str__))'
        mined:+Body, -NL= 'print(i.__type__)'
      mined:+Body, -Code= 'isinstance(i, 16)[0]'

================================================================================

QUESTION: idx=406    id=402504
-------------------------------------INPUTS-------------------------------------

tags: types, unsigned, signed, 16-bit
score: 1764
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['v']}
intent: determine the type of variable `v`
body(Some added characters for better readability):
	How do I see the type of a variable whether it is unsigned 32 bit, signed 16 bit, etc.?
	How do I view it?


-------------------------------------OUTPUT-------------------------------------

                Expected= 'type(v)'
           base:Baseline= 'print(v.__dict__))'
           base:+Canonic= 'print(v.type())'
           body:Baseline= 'print(v.type(float)'
              body:-Code= 'print(v.__str__)'
          mined:Baseline= 'isinstance(v, str(v))'
             mined:+Body= 'globals().unstack(v)'
        mined:+Body, -NL= "globals().set_type('v')"
      mined:+Body, -Code= 'isinstance(v, 16)[0]'

================================================================================

QUESTION: idx=407    id=402504
-------------------------------------INPUTS-------------------------------------

tags: types, unsigned, signed, 16-bit
score: 1764
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['v']}
intent: determine the type of variable `v`
body(Some added characters for better readability):
	How do I see the type of a variable whether it is unsigned 32 bit, signed 16 bit, etc.?
	How do I view it?


-------------------------------------OUTPUT-------------------------------------

                Expected= 'type(v)'
           base:Baseline= 'print(v.__dict__))'
           base:+Canonic= 'print(v.type())'
           body:Baseline= 'print(v.type(float)'
              body:-Code= 'print(v.__str__)'
          mined:Baseline= 'isinstance(v, str(v))'
             mined:+Body= 'globals().unstack(v)'
        mined:+Body, -NL= "globals().set_type('v')"
      mined:+Body, -Code= 'isinstance(v, 16)[0]'

================================================================================

QUESTION: idx=408    id=402504
-------------------------------------INPUTS-------------------------------------

tags: types, unsigned, signed, 16-bit
score: 1764
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['v']}
intent: determine the type of variable `v`
body(Some added characters for better readability):
	How do I see the type of a variable whether it is unsigned 32 bit, signed 16 bit, etc.?
	How do I view it?


-------------------------------------OUTPUT-------------------------------------

                Expected= 'type(v)'
           base:Baseline= 'print(v.__dict__))'
           base:+Canonic= 'print(v.type())'
           body:Baseline= 'print(v.type(float)'
              body:-Code= 'print(v.__str__)'
          mined:Baseline= 'isinstance(v, str(v))'
             mined:+Body= 'globals().unstack(v)'
        mined:+Body, -NL= "globals().set_type('v')"
      mined:+Body, -Code= 'isinstance(v, 16)[0]'

================================================================================

QUESTION: idx=409    id=402504
-------------------------------------INPUTS-------------------------------------

tags: types, unsigned, signed, 16-bit
score: 1764
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['v']}
intent: determine the type of variable `v`
body(Some added characters for better readability):
	How do I see the type of a variable whether it is unsigned 32 bit, signed 16 bit, etc.?
	How do I view it?


-------------------------------------OUTPUT-------------------------------------

                Expected= 'type(v)'
           base:Baseline= 'print(v.__dict__))'
           base:+Canonic= 'print(v.type())'
           body:Baseline= 'print(v.type(float)'
              body:-Code= 'print(v.__str__)'
          mined:Baseline= 'isinstance(v, str(v))'
             mined:+Body= 'globals().unstack(v)'
        mined:+Body, -NL= "globals().set_type('v')"
      mined:+Body, -Code= 'isinstance(v, 16)[0]'

================================================================================

QUESTION: idx=410    id=402504
-------------------------------------INPUTS-------------------------------------

tags: types, unsigned, signed, 16-bit
score: 1764
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['variable_name']}
intent: get the type of variable `variable_name`
body(Some added characters for better readability):
	How do I see the type of a variable whether it is unsigned 32 bit, signed 16 bit, etc.?
	How do I view it?


-------------------------------------OUTPUT-------------------------------------

                Expected= 'print(type(variable_name))'
           base:Baseline= 'variable_name[0].__init__]'
           base:+Canonic= 'print(variable_name.type())'
           body:Baseline= 'print(variable_name.type())'
              body:-Code= 'variable_name.__str__()'
          mined:Baseline= "variable_name.getType('Type')"
             mined:+Body= "variable_name.strftime('NFKD')"
        mined:+Body, -NL= 'variable_name.__get__(__builtins__)'
      mined:+Body, -Code= 'variable_name.isdigit()'

================================================================================

QUESTION: idx=411    id=2300756
-------------------------------------INPUTS-------------------------------------

tags: generator
score: 71
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: get the 5th item of a generator
body(Some added characters for better readability):
	Is there a more syntactically concise way of writing the following?
	
	start_block
	gen = (i for i in xrange(10))
	index = 5
	for i, v in enumerate(gen):
	    if i is index:
	        return v
	
	<p>It seems almost natural that a generator should have a 
	`gen[index]` expression, that acts as a list, but is functionally identical to the above code.


-------------------------------------OUTPUT-------------------------------------

                Expected= 'next(itertools.islice(range(10), 5, 5 + 1))'
           base:Baseline= 'generator.find_element_by_xpath(5)'
           base:+Canonic= 'print(item[5:] for item in generator.items() if item[5] == 5)'
           body:Baseline= 'for i in enumerate(gen):\n    pass'
              body:-Code= '[item[5] for item in generator.items()]'
          mined:Baseline= 'list(g for _, g in itertools.groupby(iterable))'
             mined:+Body= '[i for i, j in enumerate(gen) if i == j]'
        mined:+Body, -NL= 'next(i for i, v in enumerate(gen) if i == 5)'
      mined:+Body, -Code= 'list(itertools.chain(*args, **kwargs))'

================================================================================

QUESTION: idx=412    id=20056548
-------------------------------------INPUTS-------------------------------------

tags: 
score: 22
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['word']}
intent: print a string `word` with string format
body(Some added characters for better readability):
	For instance, we have:
	
	start_block
	word = 'Some Random Word'
	print '"' + word + '"'
	is there a better way to print double quotes around a variable?


-------------------------------------OUTPUT-------------------------------------

                Expected= 'print(\'"{}"\'.format(word))'
           base:Baseline= "print(' '.join(word) for word in range(1))"
           base:+Canonic= "print(' '.join(word))"
           body:Baseline= "print('\\\\d+', 'Some Random Word')"
              body:-Code= "print(' '.join(str(word))"
          mined:Baseline= 'print(\'Word is "{}"\'.format(word))'
             mined:+Body= 'print(\'"\' + word + \'"\'\')'
        mined:+Body, -NL= 'print(\'"\' + \'\'.join(word))'
      mined:+Body, -Code= 'print(\'Value is "{}"\'.format(word))'

================================================================================

QUESTION: idx=413    id=8546245
-------------------------------------INPUTS-------------------------------------

tags: list
score: 45
slot_map: {'key': ['var_0', 'str_0'], 'quote': ['`', "'"], 'type': ['var', 'str'], 'value': ['list', '']}
intent: join a list of strings `list` using a space ' '
body(Some added characters for better readability):
	I wanted to build a string from a list.
	I used the string.join() command, but if I have :
	
	start_block
	['hello', 'good', 'morning']
	
	<p>I get : `hellogoodmorning`
	Is there a method that allows me to put a space between every word ? (without the need to write a for loop)
	kind regards.


-------------------------------------OUTPUT-------------------------------------

                Expected= '""" """.join(list)'
           base:Baseline= 'list = [x for x in zip(list)]'
           base:+Canonic= 'list = []'
           body:Baseline= "list = [str(x) for x in re.findall(' '])"
              body:-Code= "list = [x for x in list if '' in x]"
          mined:Baseline= 'list = [str(x) for x in list]'
             mined:+Body= "list.join(map(str, ''.join(list)))"
        mined:+Body, -NL= "list.join(['hello', 'good', 'morning'])"
      mined:+Body, -Code= "list = [' '.join(word) for word in list]"

================================================================================

QUESTION: idx=414    id=2276416
-------------------------------------INPUTS-------------------------------------

tags: list, extend
score: 10
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['y']}
intent: create list `y` containing two empty lists
body(Some added characters for better readability):
	I might be missing something about the intended behavior of list extend, but why does the following happen?
	
	start_block
	x = [[],[]]
	y = [[]] * 2
	print x       # [[],[]]
	print y       # [[],[]]
	print x == y  # True
	x[0].extend([1])
	y[0].extend([1])
	print x    # [[1],[]], which is what I'd expect
	print y    # [[1],[1]], wtf?
	
	<p>I would guess that the 
	`*`
	 operator is doing something unexpected here, though I'm not exactly sure what.  It seems like something is going on under the hood that's making the original x and y (prior to calling extend) not actually be equal even though the 
	`==`
	 operator and 
	`repr` both would make it seem as though they were identical.
	I only came across this because I wanted to pre-populate a list of empty lists of a size determined at runtime, and then realized that it wasn't working the way I imagined.  I can find a better way to do the same thing, but now I'm curious as to why this didn't work.  This is Python 2.5.2 BTW - I don't have a newer version installed so if this is a bug I'm not sure if it's already fixed.


-------------------------------------OUTPUT-------------------------------------

                Expected= 'y = [[] for n in range(2)]'
           base:Baseline= 'y = [[:] for i in range(2)]'
           base:+Canonic= 'y = [i for i in range(2)]'
           body:Baseline= 'y = [[] for i in range(2)]'
              body:-Code= 'y = [i for i in range(2)]'
          mined:Baseline= 'y = [[] for i in range(0)]'
             mined:+Body= 'y = [[] for i in range(2)]'
        mined:+Body, -NL= 'y = [[] for i in range(2)]'
      mined:+Body, -Code= 'y = [list(x) for x in y]'

================================================================================

QUESTION: idx=415    id=3925614
-------------------------------------INPUTS-------------------------------------

tags: file
score: 158
slot_map: {'key': ['str_0', 'var_0'], 'quote': ["'", '`'], 'type': ['str', 'var'], 'value': ['C:/name/MyDocuments/numbers', 'data']}
intent: read a file 'c:/name/mydocuments/numbers' into a list `data`
body(Some added characters for better readability):
	I want to prompt a user for a number of random numbers to be generated and saved to a file. He gave us that part. The part we have to do is to open that file, convert the numbers into a list, then find the mean, standard deviation, etc. without using the easy built-in Python tools.
	
	<p>I've tried using 
	`open`
	 but it gives me invalid syntax (the file name I chose was "numbers" and it saved into 
	`"My Documents"`
	 automatically, so I tried 
	`open(numbers, 'r')`
	 and 
	`open(C:\name\MyDocuments\numbers, 'r')` and neither one worked).


-------------------------------------OUTPUT-------------------------------------

                Expected= "data = [line.strip() for line in open('C:/name/MyDocuments/numbers', 'r')]"
           base:Baseline= "data = open('C:/name/mydocuments/numbers').read()"
           base:+Canonic= "data = open('C:/name/MyDocuments/numbers', 'rb').read()"
           body:Baseline= 'data = open("""C:/name\\\\MyDocuments\numbers""", \'r\')'
              body:-Code= "data = open('c:/name/mydocuments/numbers')"
          mined:Baseline= "data = open('c:/name/mydocuments/numbers')"
             mined:+Body= "data = open('C:/name/mydocuments/numbers')"
        mined:+Body, -NL= "data = open('C:/name/mydocuments/numbers', 'r')"
      mined:+Body, -Code= "data = open('c:/name/mydocuments/numbers', 'r')"

================================================================================

QUESTION: idx=416    id=22187233
-------------------------------------INPUTS-------------------------------------

tags: string, replace
score: 74
slot_map: {'key': ['str_0', 'str_1'], 'quote': ["'", "'"], 'type': ['str', 'str'], 'value': ['i', 'it is icy']}
intent: delete all occurrences of character 'i' in string 'it is icy'
body(Some added characters for better readability):
	How do I delete all the instances of a character in this string? Here is my code:
	
	start_block
	def findreplace(char, string):
	    place = string.index(char)
	    string[place] = ''
	    return string
	However, if I run this, this is what happens:
	
	
	start_block
	>>>findreplace('i', 'it is icy')
	...Traceback (most recent call last):
	  File " <stdin>", line 1, in <module>
	  File " <stdin>", line 3, in findreplace
	TypeError: 'str' object does not support item assignment
	Why is this?


-------------------------------------OUTPUT-------------------------------------

                Expected= '"""""".join([char for char in \'it is icy\' if char != \'i\'])'
           base:Baseline= "re.sub('it is icy')"
           base:+Canonic= "re.sub('it is icy', 'i')"
           body:Baseline= "re.sub('I', 'it is icy')"
              body:-Code= '"""it is icy""".replace(\'i\', \'\')'
          mined:Baseline= "re.sub('(?<=\\\\w)([^\\\\w])', 'It is icy')"
             mined:+Body= "findreplace('i', 'it is icy')"
        mined:+Body, -NL= "re.sub('\\\\b', 'I', 'It is icy')"
      mined:+Body, -Code= '"""It is icy""".replace(\'I\', \'\')'

================================================================================

QUESTION: idx=417    id=22187233
-------------------------------------INPUTS-------------------------------------

tags: string, replace
score: 74
slot_map: {'key': ['str_0', 'str_1'], 'quote': ["'", "'"], 'type': ['str', 'str'], 'value': ['i', 'it is icy']}
intent: delete all instances of a character 'i' in a string 'it is icy'
body(Some added characters for better readability):
	How do I delete all the instances of a character in this string? Here is my code:
	
	start_block
	def findreplace(char, string):
	    place = string.index(char)
	    string[place] = ''
	    return string
	However, if I run this, this is what happens:
	
	
	start_block
	>>>findreplace('i', 'it is icy')
	...Traceback (most recent call last):
	  File " <stdin>", line 1, in <module>
	  File " <stdin>", line 3, in findreplace
	TypeError: 'str' object does not support item assignment
	Why is this?


-------------------------------------OUTPUT-------------------------------------

                Expected= "re.sub('i', '', 'it is icy')"
           base:Baseline= "re.sub('it is icy')"
           base:+Canonic= "re.sub('it is icy', 'i')"
           body:Baseline= "re.sub('I', 'it is icy')"
              body:-Code= "'it is icy'.join(itertools.chain.from_iterable('I', 'It is icy')))"
          mined:Baseline= "re.sub('[^i]', 'It is icy')"
             mined:+Body= "findreplace('i', 'it is icy')"
        mined:+Body, -NL= "re.sub('\\\\b', 'it is icy', 'I', 'It is icy')"
      mined:+Body, -Code= '"""It is icy""".join([x for x in i if x != \'I\'])'

================================================================================

QUESTION: idx=418    id=22187233
-------------------------------------INPUTS-------------------------------------

tags: string, replace
score: 74
slot_map: {'key': ['str_0', 'str_1'], 'quote': ['"', '"'], 'type': ['str', 'str'], 'value': ['i', 'it is icy']}
intent: delete all characters "i" in string "it is icy"
body(Some added characters for better readability):
	How do I delete all the instances of a character in this string? Here is my code:
	
	start_block
	def findreplace(char, string):
	    place = string.index(char)
	    string[place] = ''
	    return string
	However, if I run this, this is what happens:
	
	
	start_block
	>>>findreplace('i', 'it is icy')
	...Traceback (most recent call last):
	  File " <stdin>", line 1, in <module>
	  File " <stdin>", line 3, in findreplace
	TypeError: 'str' object does not support item assignment
	Why is this?


-------------------------------------OUTPUT-------------------------------------

                Expected= '"""it is icy""".replace(\'i\', \'\')'
           base:Baseline= '"""it is icy""".replace(\'i\', \'\')'
           base:+Canonic= '"""it is icy""".replace(\'i\', \'\')'
           body:Baseline= "re.sub('I', 'it is icy')"
              body:-Code= '"""it is icy""".replace(\'i\', \'\')'
          mined:Baseline= "re.sub('(?<=\\\\w)', 'It is icy')"
             mined:+Body= "findreplace('i', 'it is icy')"
        mined:+Body, -NL= "re.sub('\\\\b', 'it is icy', '', place)"
      mined:+Body, -Code= '"""it is icy""".replace(\'i\', \'\')'

================================================================================

QUESTION: idx=419    id=22187233
-------------------------------------INPUTS-------------------------------------

tags: string, replace
score: 74
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: how to delete all instances of a character in a string in python?
body(Some added characters for better readability):
	How do I delete all the instances of a character in this string? Here is my code:
	
	start_block
	def findreplace(char, string):
	    place = string.index(char)
	    string[place] = ''
	    return string
	However, if I run this, this is what happens:
	
	
	start_block
	>>>findreplace('i', 'it is icy')
	...Traceback (most recent call last):
	  File " <stdin>", line 1, in <module>
	  File " <stdin>", line 3, in findreplace
	TypeError: 'str' object does not support item assignment
	Why is this?


-------------------------------------OUTPUT-------------------------------------

                Expected= '"""""".join([char for char in \'it is icy\' if char != \'i\'])'
           base:Baseline= '"""""".join(str(x) for x in a if x.isdigit()))'
           base:+Canonic= "re.sub('[^a-zA-Z]', '', var_name)"
           body:Baseline= '"""""".join(str for line in \'it is icy\')'
              body:-Code= "re.sub('\\\\d+', '', ''.join(lambda x: x.split())"
          mined:Baseline= "re.sub('[^a-zA-Z]', '', s)"
             mined:+Body= "s = s.replace('i', 'it is icy')"
        mined:+Body, -NL= "re.sub('\\\\b', '\\\\1', '', place)"
      mined:+Body, -Code= '"""""".join(c for c in my_string if c.startswith(\'?\'))'

================================================================================

QUESTION: idx=420    id=13413590
-------------------------------------INPUTS-------------------------------------

tags: pandas, dataframe, nan
score: 938
slot_map: {'key': ['var_0', 'str_0'], 'quote': ['`', '"'], 'type': ['var', 'str'], 'value': ['df', '1']}
intent: drop rows of pandas dataframe `df` having nan in column at index "1"
body(Some added characters for better readability):
	
	<p>I have this 
	`DataFrame`
	 and want only the records whose 
	`EPS`
	 column is not 
	`NaN`:
	
	
	start_block
	>>>df
	...                STK_ID  EPS  cash
	STK_ID RPT_Date                   
	601166 20111231  601166  NaN   NaN
	600036 20111231  600036  NaN    12
	600016 20111231  600016  4.3   NaN
	601009 20111231  601009  NaN   NaN
	601939 20111231  601939  2.5   NaN
	000001 20111231  000001  NaN   NaN
	
	<p><console_out>i.e. something like 
	`df.drop(....)` to get this resulting dataframe:
	
	start_block
	                  STK_ID  EPS  cash
	STK_ID RPT_Date                   
	600016 20111231  600016  4.3   NaN
	601939 20111231  601939  2.5   NaN
	How do I do that?


-------------------------------------OUTPUT-------------------------------------

                Expected= 'df.dropna(subset=[1])'
           base:Baseline= "df.loc[df['1']].isin(axis=1)]"
           base:+Canonic= "df.dropna(['1'], axis=1)"
           body:Baseline= "df.drop(['1'], axis=1)"
              body:-Code= 'df.loc[df.columns == 1]'
          mined:Baseline= "df.loc[df.isnull().isin(['1', '2'])]"
             mined:+Body= "df.drop(df.isnull().drop([' EPS'], axis=1)"
        mined:+Body, -NL= 'df.drop(df.columns, axis=1)'
      mined:+Body, -Code= 'df.loc[df.isnull().any(axis=1)]'

================================================================================

QUESTION: idx=421    id=598398
-------------------------------------INPUTS-------------------------------------

tags: 
score: 96
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['myList', 'n']}
intent: get elements from list `mylist`, that have a field `n` value 30
body(Some added characters for better readability):
	Let's assume I'm creating a simple class to work similar to a C-style struct, to just hold data elements.  I'm trying to figure out how to search a list of objects for objects with an attribute equaling a certain value.  Below is a trivial example to illustrate what I'm trying to do.
	For instance:
	
	start_block
	class Data:
	    pass
	myList = []
	for i in range(20):
	    data = Data()
	    data.n = i
	    data.n_squared = i * i
	    myList.append(data)
	How would I go about searching the myList list to determine if it contains an element with n == 5?
	I've been Googling and searching the Python docs, and I think I might be able to do this with a list comprehension, but I'm not sure.  I might add that I'm having to use Python 2.4.3 by the way, so any new gee-whiz 2.6 or 3.x features aren't available to me.


-------------------------------------OUTPUT-------------------------------------

                Expected= '[x for x in myList if x.n == 30]'
           base:Baseline= '[x for x in mylist if x[i] == 30]'
           base:+Canonic= '[x for x in myList if x != 30]'
           body:Baseline= 'myList = [i for i in range(20)]'
              body:-Code= '[x for x in myList if x == 30]'
          mined:Baseline= '[i for i, j in enumerate(myList) if j != 30]'
             mined:+Body= '[x for x in myList if x.n == 5]'
        mined:+Body, -NL= '[x for x in myList if x.n_squared]'
      mined:+Body, -Code= '[i for i in myList if i != 30]'

================================================================================

QUESTION: idx=422    id=10351772
-------------------------------------INPUTS-------------------------------------

tags: list, input, integer
score: 14
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['intstringlist', 'nums']}
intent: converting list of strings `intstringlist` to list of integer `nums`
body(Some added characters for better readability):
	How do I convert a space separated integer input into a list of integers?
	Example input:
	
	start_block
	list1 = list(input("Enter the unfriendly numbers: "))
	Example conversion:
	
	start_block
	['1', '2', '3', '4', '5']  to  [1, 2, 3, 4, 5]


-------------------------------------OUTPUT-------------------------------------

                Expected= 'nums = [int(x) for x in intstringlist]'
           base:Baseline= 'nums = [int(x) for x in int(nums)]'
           base:+Canonic= '[int(x) for x in nums]'
           body:Baseline= 'nums = [int(x) for x in enumerate(intstringlist)]'
              body:-Code= 'nums = [int(x) for x in intStringlist]'
          mined:Baseline= 'nums = [int(x) for x in enumerate(intstringList)]'
             mined:+Body= 'nums = [int(x) for x in intstringlist]'
        mined:+Body, -NL= 'nums = [int(x) for x in intstringlist]'
      mined:+Body, -Code= 'nums = [int(i) for i in strList]'

================================================================================

QUESTION: idx=423    id=10351772
-------------------------------------INPUTS-------------------------------------

tags: list, input, integer
score: 14
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: convert list of string numbers into list of integers
body(Some added characters for better readability):
	How do I convert a space separated integer input into a list of integers?
	Example input:
	
	start_block
	list1 = list(input("Enter the unfriendly numbers: "))
	Example conversion:
	
	start_block
	['1', '2', '3', '4', '5']  to  [1, 2, 3, 4, 5]


-------------------------------------OUTPUT-------------------------------------

                Expected= "map(int, eval(input('Enter the unfriendly numbers: ')))"
           base:Baseline= '[int(x) for x in zip(map(int, x)))'
           base:+Canonic= "[int(x) for x in re.findall('\\n')]"
           body:Baseline= '[int(x) for x in list(range(0, len(x)))'
              body:-Code= "map(int, re.split('\\n') for i in range(0, len(x))"
          mined:Baseline= '[int(i) for i in l]'
             mined:+Body= "list(map(int, input('Enter the unfriendly numbers: ')))"
        mined:+Body, -NL= "map(int, input('Enter the unfriendly numbers: '))"
      mined:+Body, -Code= '[int(x) for x in list_of_lists]'

================================================================================

QUESTION: idx=424    id=493386
-------------------------------------INPUTS-------------------------------------

tags: newline
score: 2044
slot_map: {'key': ['str_0'], 'quote': ['"'], 'type': ['str'], 'value': ['.']}
intent: print "." without newline
body(Some added characters for better readability):
	
	<p>I'd like to do it in  
	python 
	. What I'd like to do in this example in 
	c :
	In C:
	
	start_block
	#include <stdio.h>
	int main() {
	    int i;
	    for (i=0; i <10; i++) printf(".");
	    return 0;
	}
	Output:
	
	start_block
	<console_out>.......
	In Python:
	
	
	start_block
	>>>for i in range(10): print('.')
	....
	.
	.
	.
	.
	.
	.
	.
	.
	.
	>>>print('.', '.', '.', '.', '.', '.', '.', '.', '.', '.')
	.... . . . . . . . . .
	
	<p>In Python 
	`print`
	 will add a 
	`\n`
	 or space, how can I avoid that? Now, it's just an example, don't tell me I can first build a string then print it. I'd like to know how to "append" strings to 
	`stdout`.


-------------------------------------OUTPUT-------------------------------------

                Expected= "sys.stdout.write('.')"
           base:Baseline= "newline = print('.' + '.' + newline"
           base:+Canonic= "print('.', 'r')"
           body:Baseline= "print('.' without any newline)"
              body:-Code= "print('.' + '.join('.'))"
          mined:Baseline= "sys.stdout.write('.')"
             mined:+Body= "print('.' + str(i) + '.')"
        mined:+Body, -NL= "print('.'.join(str(i) for i in range(10))"
      mined:+Body, -Code= "print(' '.join(str(i) for i in c.split())"

================================================================================

QUESTION: idx=425    id=6569528
-------------------------------------INPUTS-------------------------------------

tags: floating-point, int
score: 73
slot_map: {'key': ['str_0'], 'quote': ['`'], 'type': ['str'], 'value': ['2.52 * 100']}
intent: round off the float that is the product of `2.52 * 100` and convert it to an int
body(Some added characters for better readability):
	Basically, I'm converting a float to an int, but I don't always have the expected value.
	Here's the code I'm executing:
	x = 2.51
	
	start_block
	print("--------- 251.0")
	y = 251.0
	print(y)
	print(int(y))
	print("--------- 2.51 * 100")
	y = x * 100
	print(y)
	print(int(y))
	print("--------- 2.51 * 1000 / 10")
	y = x * 1000 / 10
	print(y)
	print(int(y))
	print("--------- 2.51 * 100 * 10 / 10")
	y = x * 100 * 10 / 10
	print(y)
	print(int(y))
	x = 4.02
	print("--------- 402.0")
	y = 402.0
	print(y)
	print(int(y))
	print("--------- 4.02 * 100")
	y = x * 100
	print(y)
	print(int(y))
	print("--------- 4.02 * 1000 / 10")
	y = x * 1000 / 10
	print(y)
	print(int(y))
	print("--------- 4.02 * 100 * 10 / 10")
	y = x * 100 * 10 / 10
	print(y)
	print(int(y))
	And here's the result (first value is the result of the operation, second value is int() of the same operation):
	
	start_block
	--------- 251.0
	251.0
	251
	--------- 2.51 * 100
	251.0
	250
	--------- 2.51 * 1000 / 10
	251.0
	251
	--------- 2.51 * 100 * 10 / 10
	251.0
	250
	--------- 402.0
	402.0
	402
	--------- 4.02 * 100
	402.0
	401
	--------- 4.02 * 1000 / 10
	402.0
	401
	--------- 4.02 * 100 * 10 / 10
	402.0
	401
	2.51 and 4.02 are the only values that lead to that strange behaviour on the 2.50 -> 5.00 range. Every other two digits value in that range converts to int without any problem when given the same operations.
	So, what am I missing that leads to those results? I'm using Python 2.7.2 by the way.


-------------------------------------OUTPUT-------------------------------------

                Expected= 'int(round(2.51 * 100))'
           base:Baseline= 'int(float(2.52 * 100))'
           base:+Canonic= "float('2.52 * 100', float(1))"
           body:Baseline= 'int(2.52 * 100)'
              body:-Code= 'int(2.52 * 100)'
          mined:Baseline= 'int(float(math.cos(2.52 * 100))'
             mined:+Body= 'int(float(2.52 * 100))'
        mined:+Body, -NL= 'int(2.52 * 100)'
      mined:+Body, -Code= 'int(round(2.52 * 100))'

================================================================================

QUESTION: idx=426    id=3964681
-------------------------------------INPUTS-------------------------------------

tags: file-io
score: 1041
slot_map: {'key': ['str_0', 'str_1'], 'quote': ['"', '"'], 'type': ['str', 'str'], 'value': ['/mydir', '.txt']}
intent: find all files in directory "/mydir" with extension ".txt"
body(Some added characters for better readability):
	
	<p>How can I find all the files in a directory having the extension 
	`.txt` in python?


-------------------------------------OUTPUT-------------------------------------

                Expected= "os.chdir('/mydir')\nfor file in glob.glob('*.txt'):\n    pass"
           base:Baseline= "print(os.path.dirname('/mydir'))"
           base:+Canonic= "os.path.join(/mydir, '.txt')"
           body:Baseline= "print(os.path.dirname('/mydir'))"
              body:-Code= 'print(os.path.exists(\'/mydir\', ".txt\')'
          mined:Baseline= "print(os.path.join(dir, '/mydir'))"
             mined:+Body= "[x for x in os.listdir('/mydir' if x.endswith('.txt'))]"
        mined:+Body, -NL= "[x for x in os.walk('mydir') if x.endswith(' '.txt')]"
      mined:+Body, -Code= "[x for x in os.listdir('/mydir') if x.endswith('.')]"

================================================================================

QUESTION: idx=427    id=3964681
-------------------------------------INPUTS-------------------------------------

tags: file-io
score: 1041
slot_map: {'key': ['str_0', 'str_1'], 'quote': ['"', '"'], 'type': ['str', 'str'], 'value': ['/mydir', '.txt']}
intent: find all files in directory "/mydir" with extension ".txt"
body(Some added characters for better readability):
	
	<p>How can I find all the files in a directory having the extension 
	`.txt` in python?


-------------------------------------OUTPUT-------------------------------------

                Expected= "for file in os.listdir('/mydir'):\n    if file.endswith('.txt'):\n        pass"
           base:Baseline= "print(os.path.dirname('/mydir'))"
           base:+Canonic= "os.path.join(/mydir, '.txt')"
           body:Baseline= "print(os.path.dirname('/mydir'))"
              body:-Code= 'print(os.path.exists(\'/mydir\', ".txt\')'
          mined:Baseline= "print(os.path.join(dir, '/mydir'))"
             mined:+Body= "[x for x in os.listdir('/mydir' if x.endswith('.txt'))]"
        mined:+Body, -NL= "[x for x in os.walk('mydir') if x.endswith(' '.txt')]"
      mined:+Body, -Code= "[x for x in os.listdir('/mydir') if x.endswith('.')]"

================================================================================

QUESTION: idx=428    id=3964681
-------------------------------------INPUTS-------------------------------------

tags: file-io
score: 1041
slot_map: {'key': ['str_0', 'str_1'], 'quote': ['"', '"'], 'type': ['str', 'str'], 'value': ['/mydir', '.txt']}
intent: find all files in directory "/mydir" with extension ".txt"
body(Some added characters for better readability):
	
	<p>How can I find all the files in a directory having the extension 
	`.txt` in python?


-------------------------------------OUTPUT-------------------------------------

                Expected= "for root, dirs, files in os.walk('/mydir'):\n    for file in files:\n        if file.endswith('.txt'):\n            pass"
           base:Baseline= "print(os.path.dirname('/mydir'))"
           base:+Canonic= "os.path.join(/mydir, '.txt')"
           body:Baseline= "print(os.path.dirname('/mydir'))"
              body:-Code= 'print(os.path.exists(\'/mydir\', ".txt\')'
          mined:Baseline= "print(os.path.join(dir, '/mydir'))"
             mined:+Body= "[x for x in os.listdir('/mydir' if x.endswith('.txt'))]"
        mined:+Body, -NL= "[x for x in os.walk('mydir') if x.endswith(' '.txt')]"
      mined:+Body, -Code= "[x for x in os.listdir('/mydir') if x.endswith('.')]"

================================================================================

QUESTION: idx=429    id=20865487
-------------------------------------INPUTS-------------------------------------

tags: pandas, plot
score: 64
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['df']}
intent: plot dataframe `df` without a legend
body(Some added characters for better readability):
	Using the pandas library in python and using 
	
	start_block
	.plot()
	on a dataframe,  how do I display the plot without a legend?


-------------------------------------OUTPUT-------------------------------------

                Expected= 'df.plot(legend=False)'
           base:Baseline= 'df.plot(key=lambda x: x[1])'
           base:+Canonic= 'df.plot(legend=True)'
           body:Baseline= 'df.plot(key=lambda x: x.legend()'
              body:-Code= 'df.plot(key=lambda x: x.legend()'
          mined:Baseline= "df.plot(kind='bar')"
             mined:+Body= 'df.plot(not a legend)'
        mined:+Body, -NL= "df.plot(x, y, 'bo')"
      mined:+Body, -Code= 'df.plot(x, y, legend=False)'

================================================================================

QUESTION: idx=430    id=13368659
-------------------------------------INPUTS-------------------------------------

tags: 
score: 12
slot_map: {'key': ['str_0'], 'quote': ['"'], 'type': ['str'], 'value': ['192.168.x.x']}
intent: loop through the ip address range "192.168.x.x"
body(Some added characters for better readability):
	How can I loop through an IP address range in python? Lets say I want to loop through every IP from 192.168.1.1 to 192.168. How can this be done?


-------------------------------------OUTPUT-------------------------------------

                Expected= "for i in range(256):\n    for j in range(256):\n        ip = '192.168.%d.%d' % (i, j)\n        print(ip)"
           base:Baseline= "os.system('192.168.x.x')"
           base:+Canonic= "os.system('192.168.x.x')"
           body:Baseline= 'print(os.path.realpath((192.168).x.x))'
              body:-Code= "os.system('192.168.x.x')"
          mined:Baseline= "ip.send('192.168.x.x')"
             mined:+Body= 'loop((192.168).x.x)'
        mined:+Body, -NL= "print(os.environ['192.168.x.x'])"
      mined:+Body, -Code= "print(ip.ip.get('192.168.x.x'))"

================================================================================

QUESTION: idx=431    id=13368659
-------------------------------------INPUTS-------------------------------------

tags: 
score: 12
slot_map: {'key': ['str_0'], 'quote': ['"'], 'type': ['str'], 'value': ['192.168.x.x']}
intent: loop through the ip address range "192.168.x.x"
body(Some added characters for better readability):
	How can I loop through an IP address range in python? Lets say I want to loop through every IP from 192.168.1.1 to 192.168. How can this be done?


-------------------------------------OUTPUT-------------------------------------

                Expected= 'for i, j in product(list(range(256)), list(range(256))):\n    pass'
           base:Baseline= "os.system('192.168.x.x')"
           base:+Canonic= "os.system('192.168.x.x')"
           body:Baseline= 'print(os.path.realpath((192.168).x.x))'
              body:-Code= "os.system('192.168.x.x')"
          mined:Baseline= "ip.send('192.168.x.x')"
             mined:+Body= 'loop((192.168).x.x)'
        mined:+Body, -NL= "print(os.environ['192.168.x.x'])"
      mined:+Body, -Code= "print(ip.ip.get('192.168.x.x'))"

================================================================================

QUESTION: idx=432    id=13368659
-------------------------------------INPUTS-------------------------------------

tags: 
score: 12
slot_map: {'key': ['str_0'], 'quote': ['"'], 'type': ['str'], 'value': ['192.168.x.x']}
intent: loop through the ip address range "192.168.x.x"
body(Some added characters for better readability):
	How can I loop through an IP address range in python? Lets say I want to loop through every IP from 192.168.1.1 to 192.168. How can this be done?


-------------------------------------OUTPUT-------------------------------------

                Expected= "generator = iter_iprange('192.168.1.1', '192.168.255.255', step=1)"
           base:Baseline= "os.system('192.168.x.x')"
           base:+Canonic= "os.system('192.168.x.x')"
           body:Baseline= 'print(os.path.realpath((192.168).x.x))'
              body:-Code= "os.system('192.168.x.x')"
          mined:Baseline= "ip.send('192.168.x.x')"
             mined:+Body= 'loop((192.168).x.x)'
        mined:+Body, -NL= "print(os.environ['192.168.x.x'])"
      mined:+Body, -Code= "print(ip.ip.get('192.168.x.x'))"

================================================================================

QUESTION: idx=433    id=4065737
-------------------------------------INPUTS-------------------------------------

tags: list, numpy, scipy
score: 12
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['x']}
intent: sum the corresponding decimal values for binary values of each boolean element in list `x`
body(Some added characters for better readability):
	What is the fastest (or most "Pythonic") way to convert
	
	start_block
	x = [False, False, True, True]
	
	<p>into 
	`12`? (If there is such a way.)
	
	<p>What if 
	`x`
	 were instead a 
	`numpy.array` of bools? Is there a special command for that?
	I have a large m-by-n array of booleans, where each n-element row represents a single low-dimensional hash of a high-dimensional feature vector. (In the example above, n = 4.) I would like to know the answer in order to compress my data as much as possible. Thank you.
	
	<em>Edit : Thank you for the responses! Using the following test code, 
	
	start_block
	t = 0
	for iter in range(500):
	    B = scipy.signbit(scipy.randn(1000,20))
	    for b in B:
	        t0 = time.clock()
	        # test code here
	        t1 = time.clock()
	        t += (t1-t0)
	print t
	<console_out>here were the runtimes on my Thinkpad laptop:
	
	<a>My answer : 4.26 sec
	
	<a>Sven Marnach 1 : 7.88
	
	<a>Emil H : 8.51
	
	<a>Sven Marnach 2 : 8.72
	
	<a>delnan : 10.14
	
	<a>liori : 53.49
	Of course, I welcome any independent tests that may confirm or refute my data!
	
	<em>Edit 
	: In my answer below, changing 
	`int(j)`
	 to simply 
	`j`
	 still works, but runs six times as slow! Then perhaps the other answers would become faster if the bool was casted using 
	`int`. But I'm too lazy to test everything again.
	
	<em>Edit 
	: liori posted results of independent tests 
	here .


-------------------------------------OUTPUT-------------------------------------

                Expected= 'sum(1 << i for i, b in enumerate(x) if b)'
           base:Baseline= 'sum(x[0] for x in zip(*x))'
           base:+Canonic= 'sum(int(x) for x in x)'
           body:Baseline= '[int(x) for x in range(1000, 20)]'
              body:-Code= 'sum(x[0] for x in range(0, len(x))'
          mined:Baseline= '[(x[0], x[0]) for x in range(0, len(x), 2)]'
             mined:+Body= 'x = [(int(i) for i in range(0, len(x))])'
        mined:+Body, -NL= 'numpy.array(list(range(1000)), dtype=bool)'
      mined:+Body, -Code= '[float(i) for i in x]'

================================================================================

QUESTION: idx=434    id=8691311
-------------------------------------INPUTS-------------------------------------

tags: string
score: 16
slot_map: {'key': ['var_0', 'var_1', 'var_2', 'var_3'], 'quote': ['`', '`', '`', '`'], 'type': ['var', 'var', 'var', 'var'], 'value': ['line1', 'line2', 'line3', 'target']}
intent: write multiple strings `line1`, `line2` and `line3` in one line in a file `target`
body(Some added characters for better readability):
	I've started to learn Python with LPTHW and I've gotten to exercise 16:
	http://learnpythonthehardway.org/book/ex16.html
	And feel like an idiot because I can't figure out one of the seemingly simple "extra credit" assignments that wants the following:
	
	start_block
	target.write(line1)
	target.write('\n')
	target.write(line2)
	target.write('\n') 
	target.write(line3)
	target.write('\n') 
	To be condensed to one line of code. I've tried some of the following:
	
	start_block
	target.write(line1 \n, line2 \n, line3 \n)
	Or:
	
	start_block
	target.write('line1 \n, line2 \n, line3 \n')
	Or:
	
	start_block
	target.write(%r \n, %r \n, %r \n) % (line1, line2, line3)
	I just can't get it to rewrite the line1, line2, and line3 strings all in the same line.  And I've tried various other combinations with and without commas, quotes, etc. I keep getting varying errors, like Invalid Syntax or that I have too many arguments.


-------------------------------------OUTPUT-------------------------------------

                Expected= "target.write('%r\\n%r\\n%r\\n' % (line1, line2, line3))"
           base:Baseline= 'target.write(line1, line2, line3)'
           base:+Canonic= "var_3 = open('var_0', 'var_1', var_2').write('\\n')"
           body:Baseline= 'target.write(line1, line2, line3)'
              body:-Code= 'print(target.write(line1, line2, line3))'
          mined:Baseline= "f.write('\\n'.join(line1, line2))"
             mined:+Body= 'target.write(line1, line2, line3)'
        mined:+Body, -NL= 'target.write(line1, line2, line3)'
      mined:+Body, -Code= "fp.write('\\n'.join(line1, line2))"

================================================================================

QUESTION: idx=435    id=10632111
-------------------------------------INPUTS-------------------------------------

tags: list, flatten
score: 4
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['data']}
intent: convert list of lists `data` into a flat list
body(Some added characters for better readability):
	I have a list of objects where objects can be lists or scalars. I want an flattened list with only scalars.
	Eg:
	
	start_block
	L = [35,53,[525,6743],64,63,[743,754,757]]
	outputList = [35,53,525,6743,64,63,743,754,757]
	
	<p>P.S. The answers in this question does not work for heterogeneous lists. Flattening a shallow list in Python


-------------------------------------OUTPUT-------------------------------------

                Expected= '[y for x in data for y in (x if isinstance(x, list) else [x])]'
           base:Baseline= '[x for x in zip(data)]'
           base:+Canonic= 'map(list, zip(*data))'
           body:Baseline= '[list(data) for item in data]'
              body:-Code= 'map(list, zip(*data))'
          mined:Baseline= 'list(itertools.chain(*data))'
             mined:+Body= '[[35, 53, 525, 6743, 64, 63, 743, 754, 757]]'
        mined:+Body, -NL= 'list(itertools.chain(*data))'
      mined:+Body, -Code= '[[1, 2, 3], [4, 5, 6], [7, 8, 9]]'

================================================================================

QUESTION: idx=436    id=15392730
-------------------------------------INPUTS-------------------------------------

tags: escaping, newline
score: 64
slot_map: {'key': ['str_0', 'str_1'], 'quote': ['`', '`'], 'type': ['str', 'str'], 'value': ['\n', 'foo\nbar']}
intent: print new line character as `\n` in a string `foo\nbar`
body(Some added characters for better readability):
	
	<p>I want the newline 
	`\n` to show up explicitly when printing a string retrieved from elsewhere. So if the string is 'abc\ndef' I don't want this to happen:
	
	
	start_block
	>>>print(line)
	...abc
	def
	but instead this:
	
	
	start_block
	>>>print(line)
	...abc\ndef
	Is there a way to modify print, or modify the argument, or maybe another function entirely, to accomplish this?


-------------------------------------OUTPUT-------------------------------------

                Expected= "print('foo\\nbar'.encode('string_escape'))"
           base:Baseline= '"""foo\nbar""".rstrip(\'\\n\')'
           base:+Canonic= "print('foo\\nbar', '\\n')"
           body:Baseline= "print('\\n', 'foo\\nbar')"
              body:-Code= "print('\\n', 'foo\\nbar')"
          mined:Baseline= '"""foo\nbar""".rstrip(\'\\n\')'
             mined:+Body= "print('\\n'.join(foo\\nbar))"
        mined:+Body, -NL= "print('\\n'.join(foo))"
      mined:+Body, -Code= '"""foo\nbar""".rstrip(\'\\n\')'

================================================================================

QUESTION: idx=437    id=1010961
-------------------------------------INPUTS-------------------------------------

tags: 
score: 12
slot_map: {'key': ['str_0', 'var_0'], 'quote': ["'", '`'], 'type': ['str', 'var'], 'value': [',', 's']}
intent: remove last comma character ',' in string `s`
body(Some added characters for better readability):
	I have a string, example:
	
	start_block
	s = "this is a string, a"
	
	<p>Where a 
	`','`
	 (comma) will always be the 3rd to the last character, aka 
	`s[-3]`.
	I am thinking of ways to remove the ',' but can only think of converting the string into a list, deleting it, and converting it back to a string. This however seems a bit too much for simple task. 
	How can I accomplish this in a simpler way?


-------------------------------------OUTPUT-------------------------------------

                Expected= '"""""".join(s.rsplit(\',\', 1))'
           base:Baseline= "re.sub('(?=,)', s)"
           base:+Canonic= "s.replace(',', '')"
           body:Baseline= "s = s.replace(',', ',')"
              body:-Code= "s = s.replace(',', '')"
          mined:Baseline= "s.replace(',', '')"
             mined:+Body= "s = s.replace(',', '')"
        mined:+Body, -NL= "s = s.replace(',', '')"
      mined:+Body, -Code= "s = s.replace(',', 3)"

================================================================================

QUESTION: idx=438    id=23855976
-------------------------------------INPUTS-------------------------------------

tags: numpy, mean
score: 24
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['x']}
intent: calculate the mean of each element in array `x` with the element previous to it
body(Some added characters for better readability):
	I have an array of the form:
	`x = np.array([ 1230.,  1230.,  1227.,  1235.,  1217.,  1153.,  1170.])`
	and I would like to produce another array where the values are the mean of each pair of values within my original array:
	`xm = np.array([ 1230.,  1228.5,  1231.,  1226.,  1185.,  1161.5])`
	Someone knows the easiest and fast way to do it without using loops? 


-------------------------------------OUTPUT-------------------------------------

                Expected= '(x[1:] + x[:-1]) / 2'
           base:Baseline= 'np.mean(x, y)'
           base:+Canonic= 'np.mean(x, x)'
           body:Baseline= 'np.where(np.mean(x[0], x[0] == 0)'
              body:-Code= 'np.mean(x, y)'
          mined:Baseline= 'np.mean(x, y)'
             mined:+Body= 'x.mean(axis=1)'
        mined:+Body, -NL= 'x = np.mean(np.arange(x.shape[0]), xm)'
      mined:+Body, -Code= 'np.mean(x, y)'

================================================================================

QUESTION: idx=439    id=23855976
-------------------------------------INPUTS-------------------------------------

tags: numpy, mean
score: 24
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['x']}
intent: get an array of the mean of each two consecutive values in numpy array `x`
body(Some added characters for better readability):
	I have an array of the form:
	`x = np.array([ 1230.,  1230.,  1227.,  1235.,  1217.,  1153.,  1170.])`
	and I would like to produce another array where the values are the mean of each pair of values within my original array:
	`xm = np.array([ 1230.,  1228.5,  1231.,  1226.,  1185.,  1161.5])`
	Someone knows the easiest and fast way to do it without using loops? 


-------------------------------------OUTPUT-------------------------------------

                Expected= 'x[:-1] + (x[1:] - x[:-1]) / 2'
           base:Baseline= 'np.arange(x, y)'
           base:+Canonic= 'np.arange(np.mean(x, axis=1))'
           body:Baseline= 'np.mean(x, y)'
              body:-Code= 'np.mean(x, y)'
          mined:Baseline= 'np.mean(x, y)'
             mined:+Body= 'x = np.mean(x[:, (np.arange(1), x[2]))'
        mined:+Body, -NL= 'np.mean(x[:, (np.arange(len(x)) - len(x), -1)]'
      mined:+Body, -Code= 'np.mean(x, y)'

================================================================================

QUESTION: idx=440    id=6375343
-------------------------------------INPUTS-------------------------------------

tags: unicode, numpy
score: 10
slot_map: {'key': ['str_0', 'str_1', 'var_0'], 'quote': ['`', '`', '`'], 'type': ['str', 'str', 'var'], 'value': ['utf-8', 'new.txt', 'arr']}
intent: load data containing `utf-8` from file `new.txt` into numpy array `arr`
body(Some added characters for better readability):
	Consider a text file called "new.txt" containing the following elements:
	
	start_block
	mm
	r
	l
	In Python 2.7, I can read the file by typing:
	
	
	start_block
	>>>import codecs
	>>>f = codecs.open('new.txt', encoding='utf-8')
	>>>lines = [line.strip() for line in f2.readlines()]
	>>>lines
	...[u'\u03bcm', u'\u2202r', u'\u2206\u03bb']
	>>>print lines[0]
	...mm
	So far so good. I can easily convert this list to a numpy array via:
	
	
	start_block
	>>>import numpy as np
	>>>arr = np.array(lines)
	>>>arr
	...array([u'\u03bcm', u'\u2202r', u'\u2206\u03bb'], 
	      dtype=' <U2')
	The issue is, I can't read this file directly via numpy's loadtxt function:
	
	
	start_block
	>>>np.loadtxt('new.txt', dtype=np.unicode_)
	...Traceback (most recent call last):
	  File " <stdin>", line 1, in <module>
	  File "/usr/lib64/python2.7/site-packages/numpy/lib/npyio.py", line 805, in loadtxt
	    X = np.array(X, dtype)
	UnicodeDecodeError: 'ascii' codec can't decode byte 0xce in position 0: ordinal not in range(128)
	What is the correct way to read this file into numpy directly?
	Thanks.


-------------------------------------OUTPUT-------------------------------------

                Expected= "arr = numpy.fromiter(codecs.open('new.txt', encoding='utf-8'), dtype='<U2')"
           base:Baseline= "arr = numpy.load(open('new.txt', 'r')"
           base:+Canonic= "arr = numpy.loadtxt('new.txt', 'utf-8')"
           body:Baseline= "arr = np.loadtxt('new.txt', encoding='utf-8')"
              body:-Code= "arr = numpy.loadtxt(open('new.txt', 'utf-8')"
          mined:Baseline= 'arr = numpy.loadtxt(new.txt)'
             mined:+Body= "arr = np.loadtxt('new.txt', encoding='utf-8')"
        mined:+Body, -NL= "np.loadtxt('new.txt', dtype='')"
      mined:+Body, -Code= "arr = numpy.loadtxt(open('new.txt', 'r').read())"

================================================================================

QUESTION: idx=441    id=1547733
-------------------------------------INPUTS-------------------------------------

tags: list
score: 5
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['l', 'time']}
intent: reverse sort list of dicts `l` by value for key `time`
body(Some added characters for better readability):
	[ {'time':33}, {'time':11}, {'time':66} ]
	How to sort by the "time" element, DESC.


-------------------------------------OUTPUT-------------------------------------

                Expected= "l = sorted(l, key=itemgetter('time'), reverse=True)"
           base:Baseline= 'sorted(l, key=lambda x: (x[1])'
           base:+Canonic= 'sorted(l, key=lambda x: x[1])'
           body:Baseline= 'sorted(L, key=lambda t: t[1])'
              body:-Code= 'sorted(l, key=lambda x: (x[1], x[1])'
          mined:Baseline= "sorted(l, key=lambda x: (x['time'], x['time']))"
             mined:+Body= 'sorted(l, key=itemgetter(1), reverse=True)'
        mined:+Body, -NL= 'sorted(L, key=time.itemgetter(1))'
      mined:+Body, -Code= 'sorted(l, key=itemgetter(1), reverse=True)'

================================================================================

QUESTION: idx=442    id=1547733
-------------------------------------INPUTS-------------------------------------

tags: list
score: 5
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['l', 'time']}
intent: sort a list of dictionary `l` based on key `time` in descending order
body(Some added characters for better readability):
	[ {'time':33}, {'time':11}, {'time':66} ]
	How to sort by the "time" element, DESC.


-------------------------------------OUTPUT-------------------------------------

                Expected= "l = sorted(l, key=lambda a: a['time'], reverse=True)"
           base:Baseline= 'sorted(l, key=lambda x: (x[1], reverse=True)'
           base:+Canonic= 'sorted(l, key=time, reverse=True)'
           body:Baseline= 'sorted(L, key=lambda t: t[1])'
              body:-Code= "sorted(l, key=lambda x: (x['time'], x['time':33}, {'time':11}, 'time':66}))"
          mined:Baseline= "sorted(l, key=lambda x: (x['time'], x['time']))"
             mined:+Body= 'sorted(l, key=itemgetter(1), reverse=True)'
        mined:+Body, -NL= 'sorted(L, key=lambda x: x[1])'
      mined:+Body, -Code= 'sorted(l, key=lambda x: (x[time], x[time]), reverse=True)'

================================================================================

QUESTION: idx=443    id=37080612
-------------------------------------INPUTS-------------------------------------

tags: regex, pandas, filter
score: 9
slot_map: {'key': ['var_0', 'str_0', '(str_0)'], 'quote': ['`', "'", "'"], 'type': ['var', 'str', 'str'], 'value': ['df', '(Hel|Just)', '(Hel|Just)']}
intent: get rows of dataframe `df` that match regex '(hel|just)'
body(Some added characters for better readability):
	
	<p>I don't understand `pandas`
	`DataFrame`
	
	`filter`.
	Setup
	
	start_block
	import pandas as pd
	df = pd.DataFrame(
	    [
	        ['Hello', 'World'],
	        ['Just', 'Wanted'],
	        ['To', 'Say'],
	        ['I\'m', 'Tired']
	    ]
	)
	Problem
	
	start_block
	df.filter([0], regex=r'(Hel|Just)', axis=0)
	
	<p>I'd expect the 
	`[0]`
	 to specify the 1st column as the one to look at and 
	`axis=0` to specify filtering rows.  What I get is this:
	
	start_block
	       0      1
	0  Hello  World
	I was expecting
	
	start_block
	       0       1
	0  Hello   World
	1   Just  Wanted
	Question
	What would have gotten me what I expected?


-------------------------------------OUTPUT-------------------------------------

                Expected= "df.loc[df[0].str.contains('(Hel|Just)')]"
           base:Baseline= "df.groupby(['hel|just'])"
           base:+Canonic= "df.groupby('(Hel|Just)')"
           body:Baseline= "df.filter(['(Hel|Just)', axis=0)"
              body:-Code= "df.filter(re.search('(hel|just)', 1)"
          mined:Baseline= "df.groupby(['hel|just'])['count'].apply(lambda x: x.group(1))"
             mined:+Body= "df.filter([0], regex='(Hel|Just)', axis=0)"
        mined:+Body, -NL= "df[df.groupby('Just')['Wanted'].apply(lambda x: x.Tired)"
      mined:+Body, -Code= "df.query(' '(hel|just)')"

================================================================================

QUESTION: idx=444    id=14716342
-------------------------------------INPUTS-------------------------------------

tags: string, special-characters
score: 11
slot_map: {'key': ['var_0', 'str_0', 'str_1'], 'quote': ['`', '"', '"'], 'type': ['var', 'str', 'str'], 'value': ['your_string', '[', ']']}
intent: find the string in `your_string` between two special characters "[" and "]"
body(Some added characters for better readability):
	For example, I need everything in between the two square brackets.
	File1
	
	start_block
	[Home sapiens]
	[Mus musculus 1]
	[virus 1 [isolated from china]]
	So considering the above example, I need everything in between the first and last square brackets.


-------------------------------------OUTPUT-------------------------------------

                Expected= "re.search('\\\\[(.*)\\\\]', your_string).group(1)"
           base:Baseline= '"""""".join(your_string[::(-1)]'
           base:+Canonic= "re.findall('[', ']')"
           body:Baseline= "your_string.split(',')"
              body:-Code= "print(your_string.split(',', ''))"
          mined:Baseline= "re.findall('[^\\\\w]', your_string)"
             mined:+Body= "re.findall('\\\\[\\\\]', your_string)"
        mined:+Body, -NL= "re.findall('\\\\s+', your_string)"
      mined:+Body, -Code= "your_string.split(':', 1)[:2]"

================================================================================

QUESTION: idx=445    id=18684076
-------------------------------------INPUTS-------------------------------------

tags: pandas, datetime-format
score: 10
slot_map: {'key': ['str_0'], 'quote': ["'"], 'type': ['str'], 'value': ['yyyymmdd']}
intent: how to create a list of date string in 'yyyymmdd' format with python pandas?
body(Some added characters for better readability):
	
	<p>I want a list of date range in which each element is 
	`'yyyymmdd'`
	 format string, such as : 
	`['20130226','20130227','20130228','20130301','20130302']` .
	I can use pandas to do so:
	
	
	start_block
	>>>pandas.date_range('20130226','20130302')
	<class 'pandas.tseries.index.DatetimeIndex'>
	[2013-02-26 00:00:00, <console_out>, 2013-03-02 00:00:00]
	Length: 5, Freq: D, Timezone: None
	But it is DatetimeIndex and I need to do some extra format transform, so how to do that in a neat way ? 


-------------------------------------OUTPUT-------------------------------------

                Expected= "[d.strftime('%Y%m%d') for d in pandas.date_range('20130226', '20130302')]"
           base:Baseline= "df = pd.datetime.strptime('yyyymmdd')"
           base:+Canonic= "datetime.strptime('yyyymmdd', '%m/%d/%Y').date()"
           body:Baseline= "pandas.date_range('yyyymmdd').strftime('%Y-%m-%d')"
              body:-Code= "datetime.strptime('yyyymmdd').strftime('%Y-%m-%d')"
          mined:Baseline= "df['Date'].strftime('%Y-%m-%d')"
             mined:+Body= "pandas.date_range('20130226', '20130302')"
        mined:+Body, -NL= "df.date_range('20130226', '20130302')"
      mined:+Body, -Code= "['%Y-%m-%d %H:%M:%S', 'yyyymmdd')"

================================================================================

QUESTION: idx=446    id=1666700
-------------------------------------INPUTS-------------------------------------

tags: 
score: 7
slot_map: {'key': ['str_0', 'str_1'], 'quote': ["'", "'"], 'type': ['str', 'str'], 'value': ['brown', 'The big brown fox is brown']}
intent: count number of times string 'brown' occurred in string 'the big brown fox is brown'
body(Some added characters for better readability):
	In python, I remember there is a function to do this.
	.count? 
	"The big brown fox is brown"
	brown = 2.


-------------------------------------OUTPUT-------------------------------------

                Expected= '"""The big brown fox is brown""".count(\'brown\')'
           base:Baseline= '"""The big brown fox is brown""".count(\'brown\')'
           base:+Canonic= "count('brown', 'The big brown fox is brown')"
           body:Baseline= '"""The big brown fox is brown""".count()'
              body:-Code= '"""The big brown fox is brown""".count()'
          mined:Baseline= "len('the big brown fox is brown')"
             mined:+Body= '"""The big brown fox is brown""".count()'
        mined:+Body, -NL= "len('the big brown fox is brown') - len('brown')"
      mined:+Body, -Code= '"""brown""".count(\'the big brown fox is brown\')'

================================================================================

QUESTION: idx=447    id=18979111
-------------------------------------INPUTS-------------------------------------

tags: django, angularjs, http-post
score: 21
slot_map: {'key': ['str_0'], 'quote': ['`'], 'type': ['str'], 'value': ['request.body']}
intent: decode json string `request.body` to python dict
body(Some added characters for better readability):
	I have a request like this:
	
	start_block
	$http({ 
	    method: 'POST', 
	    url: '/url/', 
	    data: 'test=data'
	})
	In my django views:
	
	start_block
	class SomeClass(View):
	    def get(self, request):
	        return HttpResponse("Hello")
	    def post(self, request):
	        print request.post
	        print request.body
	        return HttpResponse("Done")
	
	<p>So when I do 
	`request.POST`
	  I get an empty query dict : `<QueryDict: {}>`
	
	<p>But my 
	`request.body`
	 has: `test=data`
	So I believe django receives the data as url-encoded parameters and not as a dictionary.
	How do I send or receive this data as JSON/Dict ?


-------------------------------------OUTPUT-------------------------------------

                Expected= 'json.loads(request.body)'
           base:Baseline= "request.body.decode('utf-8')"
           base:+Canonic= "json.dumps('request.body', 'rb')"
           body:Baseline= "request.body.decode('json')"
              body:-Code= "request.body.decode('json')"
          mined:Baseline= "dict(request.body.decode('utf-8'))"
             mined:+Body= "dict(request.body.decode('utf-8'))"
        mined:+Body, -NL= "print(request.body.decode('json'))"
      mined:+Body, -Code= 'json.dumps(request.body, ensure_ascii=False)'

================================================================================

QUESTION: idx=448    id=7243750
-------------------------------------INPUTS-------------------------------------

tags: 
score: 363
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['url', 'file_name']}
intent: download the file from url `url` and save it under file `file_name`
body(Some added characters for better readability):
	I am creating a program that will download a .jar (java) file from a web server, by reading the URL that is specified in the .jad file of the same game/application. I'm using Python 3.2.1
	I've managed to extract the URL of the JAR file from the JAD file (every JAD file contains the URL to the JAR file), but as you may imagine, the extracted value is type() string. 
	Here's the relevant function:
	
	start_block
	def downloadFile(URL=None):
	    import httplib2
	    h = httplib2.Http(".cache")
	    resp, content = h.request(URL, "GET")
	    return content
	downloadFile(URL_from_file)
	However I always get an error saying that the type in the function above has to be bytes, and not string. I've tried using the URL.encode('utf-8'), and also bytes(URL,encoding='utf-8'), but I'd always get the same or similar error.
	So basically my question is how to download a file from a server when the URL is stored in a string type?


-------------------------------------OUTPUT-------------------------------------

                Expected= 'urllib.request.urlretrieve(url, file_name)'
           base:Baseline= "f = open('file_name').read()"
           base:+Canonic= 'urllib.request.urlretrieve(url, file_name)'
           body:Baseline= 'downloadFile(URL_from_file)'
              body:-Code= 'file_name = file_name.save(url)'
          mined:Baseline= 'file_name = os.path.join(url, file_name)'
             mined:+Body= "urllib.request.urlretrieve('http://example.com', file_name)"
        mined:+Body, -NL= "urllib.request.urlretrieve('http://stackoverflow.com', filename)"
      mined:+Body, -Code= 'file_name = os.path.join(url, file_name)'

================================================================================

QUESTION: idx=449    id=743806
-------------------------------------INPUTS-------------------------------------

tags: list, split, text-segmentation
score: 592
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['text']}
intent: split string `text` by space
body(Some added characters for better readability):
	I want my Python function to split a sentence (input) and store each word in a list. My current code splits the sentence, but does not store the words as a list. How do I do that?
	
	start_block
	def split_line(text):
	    # split the text
	    words = text.split()
	    # for each word in the line:
	    for word in words:
	        # print the word
	        print(words)


-------------------------------------OUTPUT-------------------------------------

                Expected= 'text.split()'
           base:Baseline= 'sorted(text, key=lambda x: x[1])'
           base:+Canonic= "text.split('\\n')"
           body:Baseline= 'print(words.split(text))'
              body:-Code= "print(re.split('', text))"
          mined:Baseline= "re.split('\\\\s+', text)"
             mined:+Body= "words = text.split(',')"
        mined:+Body, -NL= "re.split('\\\\s+', text)"
      mined:+Body, -Code= '[s.split() for s in text]'

================================================================================

QUESTION: idx=450    id=743806
-------------------------------------INPUTS-------------------------------------

tags: list, split, text-segmentation
score: 592
slot_map: {'key': ['var_0', 'str_0'], 'quote': ['`', '"'], 'type': ['var', 'str'], 'value': ['text', ',']}
intent: split string `text` by ","
body(Some added characters for better readability):
	I want my Python function to split a sentence (input) and store each word in a list. My current code splits the sentence, but does not store the words as a list. How do I do that?
	
	start_block
	def split_line(text):
	    # split the text
	    words = text.split()
	    # for each word in the line:
	    for word in words:
	        # print the word
	        print(words)


-------------------------------------OUTPUT-------------------------------------

                Expected= "text.split(',')"
           base:Baseline= '[s.split(\',"] for s in text]'
           base:+Canonic= "text.split(',')"
           body:Baseline= "re.split('', '', text)"
              body:-Code= 'print(text.split(\',"))'
          mined:Baseline= "re.split('(.)', text)"
             mined:+Body= "words = text.split(',')"
        mined:+Body, -NL= "re.split('\\\\s+', text)"
      mined:+Body, -Code= '"""""".join(split(\' \') for split in text)'

================================================================================

QUESTION: idx=451    id=743806
-------------------------------------INPUTS-------------------------------------

tags: list, split, text-segmentation
score: 592
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['line']}
intent: split string `line` into a list by whitespace
body(Some added characters for better readability):
	I want my Python function to split a sentence (input) and store each word in a list. My current code splits the sentence, but does not store the words as a list. How do I do that?
	
	start_block
	def split_line(text):
	    # split the text
	    words = text.split()
	    # for each word in the line:
	    for word in words:
	        # print the word
	        print(words)


-------------------------------------OUTPUT-------------------------------------

                Expected= 'line.split()'
           base:Baseline= '[(x.strip() for x in line]'
           base:+Canonic= '[int(x) for x in line.split()]'
           body:Baseline= 'list(itertools.split(line))'
              body:-Code= '[item for item in line if item.split()]'
          mined:Baseline= '[item.strip() for item in line.split()]'
             mined:+Body= 'words = [split(line) for line in words]'
        mined:+Body, -NL= 'words = [line.split() for line in words]'
      mined:+Body, -Code= '[item.split() for item in input]'

================================================================================

QUESTION: idx=452    id=35044115
-------------------------------------INPUTS-------------------------------------

tags: regex, replace, substitution
score: 4
slot_map: {'key': ['str_0', 'var_0', 'str_1'], 'quote': ["'", '`', "'"], 'type': ['str', 'var', 'str'], 'value': ['.', 's', '']}
intent: replace dot characters  '.' associated with ascii letters in list `s` with space ' '
body(Some added characters for better readability):
	Using Python, I have the following strings:
	
	start_block
	['taxes.............................       .7        21.4    (6.2)','regulatory and other matters..................$   39.9        61.5        41.1','Producer contract reformation cost recoveries............................   DASH        26.3        28.3']
	I need to replace each of the dots with a space, but not the periods in the numbers.  So the result should look like this:
	
	start_block
	['taxes                                    .7        21.4    (6.2)','regulatory and other matters                  $   39.9        61.5        41.1','Producer contract reformation cost recoveries                               DASH        26.3        28.3']
	I've tried the following:
	
	start_block
	dots=re.compile('(\.{2,})(\s*?[\d\(\$]|\s*?DASH|\s*.)')
	newlist=[]
	for each in list:
	    newline=dots.sub(r'\2'.replace('.',' '),each)
	    newdoc.append(newline)
	But, this code doesn't retain the white space.  Thanks!


-------------------------------------OUTPUT-------------------------------------

                Expected= "[re.sub('(?<!\\\\d)\\\\.(?!\\\\d)', '', i) for i in s]"
           base:Baseline= "re.sub('(?=.)', s)"
           base:+Canonic= "re.sub('[^a-z]', '.', s)"
           body:Baseline= "re.sub('(\\\\.{2,})(\\\\s*?[\\\\d\\\\(\\\\$]|\\\\s*?)', '.')"
              body:-Code= "s = s.replace('.', '')"
          mined:Baseline= "s = s.replace('.', '')"
             mined:+Body= "s.replace('.', '\\\\2', '')"
        mined:+Body, -NL= "newline = [dots.sub('\\\\2', '.') for dots in s.split(',')]"
      mined:+Body, -Code= "s = s.replace('.', '.')"

================================================================================

QUESTION: idx=453    id=38388799
-------------------------------------INPUTS-------------------------------------

tags: list, sorting
score: 5
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['list_of_strings', 's']}
intent: sort list `list_of_strings` based on second index of each string `s`
body(Some added characters for better readability):
	Overview: I have data something like this (each row is a string):
	
	<p>81:0A:D7:19:25:7B, 
	2016-07-14 14:29:13 , 2016-07-14 14:29:15, -69, 22:22:22:22:22:23,null,^M
	
	<strong>2016-07-14 01:28:59 , 2016-07-14 01:29:01, -36, 33:33:33:33:33:31,null,^M
	
	<strong>2016-07-14 08:26:45 , 2016-07-14 08:26:47, -65, 33:33:33:33:33:32,null,^M
	
	<strong>2016-07-14 06:25:32 , 2016-07-14 06:25:34, -56, 33:33:33:33:33:33,null,^M
	And I want to sort each row based on the first timestamp that is present in the each String, which for these four records is:
	2016-07-14 01:28:59
	2016-07-14 06:25:32
	2016-07-14 08:26:45
	2016-07-14 14:29:13
	
	<p>Now I know the 
	`sort()` method but I don't understand how can I use here to sort all the rows based on this (timestamp) quantity, and I do need to keep the final sorted data in the same format as some other service is going to use it.
	
	<p>I also understand I can make the 
	`key()` but I am not clear how that can be made to sort on the timestamp field.


-------------------------------------OUTPUT-------------------------------------

                Expected= "sorted(list_of_strings, key=lambda s: s.split(',')[1])"
           base:Baseline= 'sorted(list_of_strings, key=lambda x: x[1])'
           base:+Canonic= 'list_of_strings.sort(key=lambda x: x[1])'
           body:Baseline= 'sorted(list_of_strings, key=lambda x: x[1])'
              body:-Code= 'list_of_strings.sort(key=lambda x: x[1])'
          mined:Baseline= 'sorted(list_of_strings, key=lambda x: x[1])'
             mined:+Body= 'sorted(list_of_strings, key=lambda x: int(x[1]))'
        mined:+Body, -NL= 'list_of_strings.sort(key=lambda x: x[1])'
      mined:+Body, -Code= 'sorted(list_of_strings, key=lambda x: int(x[1]))'

================================================================================

QUESTION: idx=454    id=9609375
-------------------------------------INPUTS-------------------------------------

tags: bash, call, subprocess
score: 4
slot_map: {'key': ['str_0', 'str_1', 'str_2'], 'quote': ["'", "'", "'"], 'type': ['str', 'str', 'str'], 'value': ['vasp', 'tee tee_output', '|']}
intent: call multiple bash function 'vasp' and 'tee tee_output' using '|'
body(Some added characters for better readability):
	I am using a scientific software (called vasp) that works only in bash, and using Python to create a script that will make multiple runs for me. When I use subprocess.check_call to call the function normally, it works fine, but when i add the '| tee tee_output' it doesn't work. 
	
	start_block
	subprocess.check_call('vasp') #this works
	subprocess.check_call('vasp | tee tee_output') #this doesn't
	I am a noobie to python and programming altogether. 


-------------------------------------OUTPUT-------------------------------------

                Expected= "subprocess.check_call('vasp | tee tee_output', shell=True)"
           base:Baseline= "subprocess.call('vasp', 'tee tee_output', '|')"
           base:+Canonic= "subprocess.call('str_0','str_1'))"
           body:Baseline= "subprocess.check_call('vasp', 'tee tee_output')"
              body:-Code= "subprocess.call('vasp', 'tee tee_output', '|')"
          mined:Baseline= "subprocess.call('gasp', shell=True)"
             mined:+Body= "subprocess.check_call('vasp | tee tee_output')"
        mined:+Body, -NL= "subprocess.check_call('vasp | tee tee_output', shell=True)"
      mined:+Body, -Code= "subprocess.check_call('vasp', shell=True)"

================================================================================

QUESTION: idx=455    id=37004138
-------------------------------------INPUTS-------------------------------------

tags: 
score: 5
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['lst']}
intent: eliminate all strings from list `lst`
body(Some added characters for better readability):
	
	<p>my question is how to eliminate all strings from a list, for example if I have  
	`list=['hello',1,2,3,4,'goodbye','help']`
	 and the outcome to be `list=[1,2,3,4]`


-------------------------------------OUTPUT-------------------------------------

                Expected= '[element for element in lst if isinstance(element, int)]'
           base:Baseline= 'del lst[::-1]'
           base:+Canonic= "re.compile('[^a-zA-Z]', lst)"
           body:Baseline= '[x for x in lst if x not in x]'
              body:-Code= 'del lst[::-1]'
          mined:Baseline= '[lst for lst in lst]'
             mined:+Body= '[x for x in lst if x not in list]'
        mined:+Body, -NL= 'list(itertools.chain.from_iterable(lst))'
      mined:+Body, -Code= 'list(itertools.chain.from_iterable(lst))'

================================================================================

QUESTION: idx=456    id=37004138
-------------------------------------INPUTS-------------------------------------

tags: 
score: 5
slot_map: {'key': ['str_0'], 'quote': ["'"], 'type': ['str'], 'value': ['lst']}
intent: get all the elements except strings from the list 'lst'.
body(Some added characters for better readability):
	
	<p>my question is how to eliminate all strings from a list, for example if I have  
	`list=['hello',1,2,3,4,'goodbye','help']`
	 and the outcome to be `list=[1,2,3,4]`


-------------------------------------OUTPUT-------------------------------------

                Expected= '[element for element in lst if not isinstance(element, str)]'
           base:Baseline= '[i for i, j in zip(lst, lst)]'
           base:+Canonic= '[x for x in lst]'
           body:Baseline= '[x for x in lst if x not in x]'
              body:-Code= '[x for x in lst if not x in x]'
          mined:Baseline= "[x for x in lst if x.endswith('lst')]"
             mined:+Body= "[x for x in lst if x != 'lst']"
        mined:+Body, -NL= 'list(itertools.chain.from_iterable(lst))'
      mined:+Body, -Code= "[x for x in lst if x != 'lst']"

================================================================================

QUESTION: idx=457    id=72899
-------------------------------------INPUTS-------------------------------------

tags: list, sorting, dictionary, data-structures
score: 2137
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['list_to_be_sorted', 'name']}
intent: sort a list of dictionaries `list_to_be_sorted` by the value of the dictionary key `name`
body(Some added characters for better readability):
	I have a list of dictionaries and want each item to be sorted by a specific value.
	Take into consideration the list:
	
	start_block
	[{'name':'Homer', 'age':39}, {'name':'Bart', 'age':10}]
	
	<p>When sorted by 
	`name`, it should become:
	
	start_block
	[{'name':'Bart', 'age':10}, {'name':'Homer', 'age':39}]


-------------------------------------OUTPUT-------------------------------------

                Expected= "newlist = sorted(list_to_be_sorted, key=lambda k: k['name'])"
           base:Baseline= 'sorted(list_to_be_sorted, key=lambda x: x[1])'
           base:+Canonic= "sorted(list_to_be_sorted, key=lambda d: d['name'])"
           body:Baseline= 'sorted(list_to_be_sorted, key=lambda d: d[name])'
              body:-Code= 'sorted(list_to_be_sorted, key=lambda d: d[name]'
          mined:Baseline= "sorted(list_to_be_sorted, key=lambda d: d['name'])"
             mined:+Body= "sorted(list_to_be_sorted, key=lambda x: x['name'], reverse=True)"
        mined:+Body, -NL= "sorted(list_to_be_sorted, key=lambda d: d['name'], reverse=True)"
      mined:+Body, -Code= "sorted(list_to_be_sorted, key=lambda d: d['name'])"

================================================================================

QUESTION: idx=458    id=72899
-------------------------------------INPUTS-------------------------------------

tags: list, sorting, dictionary, data-structures
score: 2137
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['l', 'name']}
intent: sort a list of dictionaries `l` by values in key `name` in descending order
body(Some added characters for better readability):
	I have a list of dictionaries and want each item to be sorted by a specific value.
	Take into consideration the list:
	
	start_block
	[{'name':'Homer', 'age':39}, {'name':'Bart', 'age':10}]
	
	<p>When sorted by 
	`name`, it should become:
	
	start_block
	[{'name':'Bart', 'age':10}, {'name':'Homer', 'age':39}]


-------------------------------------OUTPUT-------------------------------------

                Expected= "newlist = sorted(l, key=itemgetter('name'), reverse=True)"
           base:Baseline= 'sorted(L, key=lambda x: x[1])'
           base:+Canonic= 'sorted(l, key=lambda x: x[1])'
           body:Baseline= "sorted(l, key=lambda x: x['name']))"
              body:-Code= "sorted(l, key=lambda x: (x['name'], reverse=True)"
          mined:Baseline= "sorted(l, key=lambda d: d['name'], reverse=True)"
             mined:+Body= "sorted(l, key=lambda x: x['name'], reverse=True)"
        mined:+Body, -NL= "sorted(L, key=lambda d: d['name'], reverse=True)"
      mined:+Body, -Code= "sorted(l, key=lambda d: d['name'])"

================================================================================

QUESTION: idx=459    id=72899
-------------------------------------INPUTS-------------------------------------

tags: list, sorting, dictionary, data-structures
score: 2137
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: how do i sort a list of dictionaries by values of the dictionary in python?
body(Some added characters for better readability):
	I have a list of dictionaries and want each item to be sorted by a specific value.
	Take into consideration the list:
	
	start_block
	[{'name':'Homer', 'age':39}, {'name':'Bart', 'age':10}]
	
	<p>When sorted by 
	`name`, it should become:
	
	start_block
	[{'name':'Bart', 'age':10}, {'name':'Homer', 'age':39}]


-------------------------------------OUTPUT-------------------------------------

                Expected= "list_of_dicts.sort(key=operator.itemgetter('name'))"
           base:Baseline= 'sorted(list(d.items()), key=lambda x: x[1])'
           base:+Canonic= 'sorted(list(d.keys()), key=lambda d: d.keys())'
           body:Baseline= 'sorted(list(d.items()), key=lambda x: x[1])'
              body:-Code= 'sorted(list(d.items()), key=lambda x: x[1])'
          mined:Baseline= 'sorted(list(d.items()), key=lambda x: x[1])'
             mined:+Body= "sorted(list(d.items()), key=lambda x: x['name'], reverse=True)"
        mined:+Body, -NL= "sorted(list(d.items()), key=lambda d: d['age'], reverse=True)"
      mined:+Body, -Code= "sorted(lst, key=lambda d: d['value'])"

================================================================================

QUESTION: idx=460    id=72899
-------------------------------------INPUTS-------------------------------------

tags: list, sorting, dictionary, data-structures
score: 2137
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: how do i sort a list of dictionaries by values of the dictionary in python?
body(Some added characters for better readability):
	I have a list of dictionaries and want each item to be sorted by a specific value.
	Take into consideration the list:
	
	start_block
	[{'name':'Homer', 'age':39}, {'name':'Bart', 'age':10}]
	
	<p>When sorted by 
	`name`, it should become:
	
	start_block
	[{'name':'Bart', 'age':10}, {'name':'Homer', 'age':39}]


-------------------------------------OUTPUT-------------------------------------

                Expected= "list_of_dicts.sort(key=operator.itemgetter('age'))"
           base:Baseline= 'sorted(list(d.items()), key=lambda x: x[1])'
           base:+Canonic= 'sorted(list(d.keys()), key=lambda d: d.keys())'
           body:Baseline= 'sorted(list(d.items()), key=lambda x: x[1])'
              body:-Code= 'sorted(list(d.items()), key=lambda x: x[1])'
          mined:Baseline= 'sorted(list(d.items()), key=lambda x: x[1])'
             mined:+Body= "sorted(list(d.items()), key=lambda x: x['name'], reverse=True)"
        mined:+Body, -NL= "sorted(list(d.items()), key=lambda d: d['age'], reverse=True)"
      mined:+Body, -Code= "sorted(lst, key=lambda d: d['value'])"

================================================================================

QUESTION: idx=461    id=36402748
-------------------------------------INPUTS-------------------------------------

tags: sorting, pandas, dataframe
score: 4
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: how to sort a dataframe by the ocurrences in a column in python (pandas)
body(Some added characters for better readability):
	I'm trying to create a dataframe  from my data (scores between chemicals and proteins) with pandas in python. 
	I want my dataframe to first display the proteins that have the most occurences, so I previously sorted my data. But when I make the dataframe it does not get the expected result.
	Here's a sample of my data :
	
	start_block
	chemicals   prots   scores
	CID000000006    10116.ENSRNOP00000003921    196
	CID000000051    10116.ENSRNOP00000003921    246
	CID000000085    10116.ENSRNOP00000003921    196
	CID000000119    10116.ENSRNOP00000003921    247
	CID000000134    10116.ENSRNOP00000008952    159
	CID000000135    10116.ENSRNOP00000008952    157
	CID000000174    10116.ENSRNOP00000008952    439
	CID000000175    10116.ENSRNOP00000001021    858
	CID000000177    10116.ENSRNOP00000004027    760
	As you can see "10116.ENSRNOP00000003921" is the protein with the most occurences in my data.
	So i'd like to get something like :
	
	start_block
	             10116.ENSRNOP00000003921     10116.ENSRNOP00000008952  
	CID000000006   196                 
	CID000000051   246 
	CID000000085   196 
	CID000000119   247 
	CID000000134                                  159   
	CID000000135                                  157   
	CID000000174                                  439
	And Here's my code : 
	
	start_block
	import pandas as pd
	df_rat= pd.read_csv("dt_matrix_rat.csv",sep="\t", header=True)
	df_rat.columns = ['chemicals','proteins','scores']
	df_rat1 = df_rat.pivot(index='chemicals', columns='proteins', values='scores')
	df_rat1.to_csv("rat_matrix.csv", sep='\t', index=True  )


-------------------------------------OUTPUT-------------------------------------

                Expected= "df.groupby('prots').sum().sort('scores', ascending=False)"
           base:Baseline= "df.sort_values(['Ocurrences']).sort(key=lambda x: x[1])"
           base:+Canonic= 'df.sort(df.columns, axis=1)'
           body:Baseline= "df.sort_values(['CID'], axis=1)"
              body:-Code= 'df.sort(key=lambda x: x.Ocurrences)'
          mined:Baseline= "df.sort(['a', 'b'], ascending=[True, False], inplace=True)"
             mined:+Body= "df.sort_values(by=['prots', 'chemicals'])"
        mined:+Body, -NL= "df.sort_values(by=['chemicals', 'proteins', 'scores'])"
      mined:+Body, -Code= "df.sort_values(by=['chemistry', 'chemistry'])"

================================================================================

QUESTION: idx=462    id=29881993
-------------------------------------INPUTS-------------------------------------

tags: json, list, dictionary
score: 4
slot_map: {'key': ['str_0', 'str_1', 'var_0'], 'quote': ['"', "'", '`'], 'type': ['str', 'str', 'var'], 'value': [',', 'category', 'trans']}
intent: join together with "," elements inside a list indexed with 'category' within a dictionary `trans`
body(Some added characters for better readability):
	I have a function that's returning a json formatted dataset. Here's a sample: 
	
	start_block
	[{u'category': [u'Transfer', u'Withdrawal', u'ATM'], u'category_id': u'21012002', u'_account': u'XARE85EJqKsjxLp6XR8ocg8VakrkXpTXmRdOo', u'name': u'ATM Withdrawal', u'amount': 200, u'meta': {u'location': {u'city': u'San Francisco', u'state': u'CA'}}, u'date': u'2014-07-21', u'score': {u'location': {u'city': 1, u'state': 1}, u'name': 1}, u'_id': u'0AZ0De04KqsreDgVwM1RSRYjyd8yXxSDQ8Zxn', u'type': {u'primary': u'special'}, u'pending': False}] 
	for trans in foodie_data:
	            print 'Name={},Amount={},Date={}, Categories ={}\n'.format(trans['name'],trans['amount'],trans['date'],trans['category'])
	This script prints: 
	
	start_block
	Name=ATM Withdrawal,Amount=200,Date=2014-07-21,Categories=[u'Transfer', u'Withdrawal', u'ATM']
	I want it to return Categories as a string and not a list:
	
	start_block
	Name=ATM Withdrawal,Amount=200,Date=2014-07-21,Categories='Transfer, Withdrawal,ATM']
	What's the most efficient way of doing so?


-------------------------------------OUTPUT-------------------------------------

                Expected= '""",""".join(trans[\'category\'])'
           base:Baseline= "[(x, y) for x, y in zip(trans, 'category'])"
           base:+Canonic= "[item['category'] for item in trans.items()]"
           body:Baseline= "[item['category'] for item in Trans.items() if item['category' in item]"
              body:-Code= "[item['category'] for item in Trans]"
          mined:Baseline= "{k: v for k, v in list(trans.items()) if 'category' in k}"
             mined:+Body= "{'category': [item['name'] for item in trans.items()]"
        mined:+Body, -NL= "[x['category'] for x in trans.items() if 'category' in x]"
      mined:+Body, -Code= "Category = [item['category'] for item in trans]"

================================================================================

QUESTION: idx=463    id=34158494
-------------------------------------INPUTS-------------------------------------

tags: string, string-concatenation
score: 8
slot_map: {'key': ['str_0', '[str_0]'], 'quote': ['`', '`'], 'type': ['str', 'str'], 'value': ["['A', 'B', 'C', 'D']", "['A', 'B', 'C', 'D']"]}
intent: concatenate array of strings `['a', 'b', 'c', 'd']` into a string
body(Some added characters for better readability):
	Out of the following two variants (with or without plus-sign between) of string literal concatenation:
	What's the preferred way?
	What's the difference?
	When should one or the other be used?
	Should non of them ever be used, if so why?
	
	<li>Is 
	`join` preferred?
	Code:
	
	
	start_block
	>>># variant 1. Plus
	>>>'A'+'B'
	...'AB'
	>>># variant 2. Just a blank space
	>>>'A' 'B'
	...'AB'
	>>># They seems to be both equal
	>>>'A'+'B' == 'A' 'B'
	...True


-------------------------------------OUTPUT-------------------------------------

                Expected= '"""""".join([\'A\', \'B\', \'C\', \'D\'])'
           base:Baseline= '"""""".join([\'a\', \'b\', \'c\', \'d\'])'
           base:+Canonic= '"""""".join([\'A\', \'B\', \'C\', \'D\'])'
           body:Baseline= '"""""".join([\'A\', \'B\', \'C\', \'D\'])'
              body:-Code= '"""""".join([\'a\', \'b\', \'c\', \'d\'])'
          mined:Baseline= '"""""".join([\'a\', \'b\', \'c\', \'d\'])'
             mined:+Body= '"""""".join([\'A\', \'b\', \'c\', \'d\'])'
        mined:+Body, -NL= '"""""".join([\'a\', \'b\', \'c\', \'d\'])'
      mined:+Body, -Code= '"""""".join([\'a\', \'b\', \'c\', \'d\'])'

================================================================================

QUESTION: idx=464    id=7750557
-------------------------------------INPUTS-------------------------------------

tags: json, rest, kerberos
score: 83
slot_map: {'key': ['str_0'], 'quote': ["'"], 'type': ['str'], 'value': ['url']}
intent: get json data from restful service 'url'
body(Some added characters for better readability):
	Is there any standard way of getting JSON data from RESTful service using Python? 
	I need to use kerberos for authentication.
	some snippet would help.


-------------------------------------OUTPUT-------------------------------------

                Expected= "json.load(urllib.request.urlopen('url'))"
           base:Baseline= 'json.loads(url, key=lambda x: x[1])'
           base:+Canonic= "json.loads('url')"
           body:Baseline= "json = RESTful.get_json('url')"
              body:-Code= 'json.loads(url, verify=True)'
          mined:Baseline= 'print(json.dumps(url))'
             mined:+Body= 'print(json.dumps(url))'
        mined:+Body, -NL= 'json.dumps(url, ensure_ascii=False)'
      mined:+Body, -Code= 'print(json.dumps(url))'

================================================================================

QUESTION: idx=465    id=12666897
-------------------------------------INPUTS-------------------------------------

tags: list, substring, string-matching
score: 25
slot_map: {'key': ['var_0', 'str_0', 'str_1'], 'quote': ['`', '`', '`'], 'type': ['var', 'str', 'str'], 'value': ['sents', '@$\t', '#']}
intent: remove all strings from a list a strings `sents` where the values starts with `@$\t` or `#`
body(Some added characters for better readability):
	How do I remove an element from a list if it matches a substring?
	
	<p>I have tried removing an element from a list using the 
	`pop()`
	 and 
	`enumerate` method but seems like I'm missing a few contiguous items that needs to be removed:
	
	start_block
	sents = ['@$\tthis sentences needs to be removed', 'this doesnt',
	     '@$\tthis sentences also needs to be removed',
	     '@$\tthis sentences must be removed', 'this shouldnt',
	     '# this needs to be removed', 'this isnt',
	     '# this must', 'this musnt']
	for i, j in enumerate(sents):
	  if j[0:3] == "@$\t":
	    sents.pop(i)
	    continue
	  if j[0] == "#":
	    sents.pop(i)
	for i in sents:
	  print i
	Output:
	
	start_block
	this doesnt
	@$  this sentences must be removed
	this shouldnt
	this isnt
	#this should
	this musnt
	Desired output:
	
	start_block
	this doesnt
	this shouldnt
	this isnt
	this musnt


-------------------------------------OUTPUT-------------------------------------

                Expected= "[x for x in sents if not x.startswith('@$\\t') and not x.startswith('#')]"
           base:Baseline= "sents = [x for x in sents if x starts with '@$\\t' or '#')"
           base:+Canonic= "sents = [x for x in sents if '@$\\t' in x]"
           body:Baseline= 'sents = [i for i, j in enumerate(sents) if i!= "@$\\t\')]'
              body:-Code= "sents = [x for x in sents if '@$\\t' in x]"
          mined:Baseline= "sents = [x for x in sents if x.startswith('@$\\t')]"
             mined:+Body= "[x for x in sents if x.startswith('@$\\\\tthis sentences also needs to be removed', '']"
        mined:+Body, -NL= "sents.pop(re.sub('\\\\t\\\\t', '@$\\\\tthis must', sents))"
      mined:+Body, -Code= "sents = [x for x in sents if x.startswith('@$\\t')]"

================================================================================

QUESTION: idx=466    id=2984751
-------------------------------------INPUTS-------------------------------------

tags: django
score: 5
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: django filter by hour
body(Some added characters for better readability):
	
	<p>I've found that link: 
	http://code.djangoproject.com/attachment/ticket/8424/time_filters.diff 
	 and changed my django 1.2 files by adding taht what you can see there. 
	But now, when I'm trying to  write Entry.objects.filter(pub_date__hour = x) - the result is following error:
	Field has invalid lookup: hour
	What should I do else, to make it work?  
	(sorry for my english)


-------------------------------------OUTPUT-------------------------------------

                Expected= "Entry.objects.filter(pub_date__contains='08:00')"
           base:Baseline= 'filter(hour=(1, 2, 3, 4))'
           base:+Canonic= 'dj.filter(hours=1)'
           body:Baseline= 'Entry.objects.filter(pub_date__hour=x)'
              body:-Code= 'pd.objects.filter(pub_date__hour=1)'
          mined:Baseline= 'Article.objects.filter(hour=12)'
             mined:+Body= 'Entry.objects.filter(pub_date__hour__in=hour)'
        mined:+Body, -NL= 'super(MyModel, self).save(*args, **kwargs)'
      mined:+Body, -Code= 'Entry.objects.filter(pub_date__hour=hour)'

================================================================================

QUESTION: idx=467    id=5944630
-------------------------------------INPUTS-------------------------------------

tags: list, sorting
score: 13
slot_map: {'key': ['var_0', 'var_1', 'var_2'], 'quote': ['`', '`', '`'], 'type': ['var', 'var', 'var'], 'value': ['list', 'points', 'time']}
intent: sort a list of dictionary `list` first by key `points` and then by `time`
body(Some added characters for better readability):
	I want to sort this info(name, points, and time):
	
	start_block
	list = [
	    {'name':'JOHN', 'points' : 30, 'time' : '0:02:2'},
	    {'name':'KARL','points':50,'time': '0:03:00'}
	]
	so, what I want is the list sorted first by points made, then by time played (in my example, matt go first because of his less time. any help?
	I'm trying with this:
	
	start_block
	import operator
	list.sort(key=operator.itemgetter('points', 'time'))
	
	<p>but got a 
	`TypeError: list indices must be integers, not str`. 


-------------------------------------OUTPUT-------------------------------------

                Expected= "list.sort(key=lambda item: (item['points'], item['time']))"
           base:Baseline= 'sorted(list, key=lambda x: x[1])'
           base:+Canonic= 'sorted(var_0.items()), key=lambda x: x[1])'
           body:Baseline= "list.sort(key=operator.itemgetter('points', 'time'))"
              body:-Code= 'sorted(list, key=lambda x: x[1])'
          mined:Baseline= 'sorted(list, key=itemgetter(1), reverse=True)'
             mined:+Body= "list.sort(key=operator.itemgetter('points', 'time'))"
        mined:+Body, -NL= "list.sort(key=operator.itemgetter('points', 'time'))"
      mined:+Body, -Code= 'sorted(list, key=itemgetter(1), reverse=True)'

================================================================================

QUESTION: idx=468    id=7852855
-------------------------------------INPUTS-------------------------------------

tags: 
score: 248
slot_map: {'key': ['str_0', '(str_0)'], 'quote': ['`', '`'], 'type': ['str', 'str'], 'value': ['(1970, 1, 1)', '(1970, 1, 1)']}
intent: convert datetime object `(1970, 1, 1)` to seconds
body(Some added characters for better readability):
	Apologies for the simple question... I'm new to Python... I have searched around and nothing seems to be working.
	I have a bunch of datetime objects and I want to calculate the number of seconds since a fixed time in the past for each one (for example since January 1, 1970).  
	
	start_block
	import datetime
	t = datetime.datetime(2009, 10, 21, 0, 0)
	This seems to be only differentiating between dates that have different days:
	
	start_block
	t.toordinal()
	Any help is much appreciated.


-------------------------------------OUTPUT-------------------------------------

                Expected= '(t - datetime.datetime(1970, 1, 1)).total_seconds()'
           base:Baseline= 'datetime.combine(1970, 1, 1)'
           base:+Canonic= "datetime.strptime('(1970, 1, 1)', 'seconds')"
           body:Baseline= 'datetime.datetime(1970, 1, 1)'
              body:-Code= 'seconds = datetime.datetime.combine(1970, 1, 1))'
          mined:Baseline= "datetime.strptime('1970, 1, 1)', '%Y, %d %H:%M')"
             mined:+Body= 'datetime.datetime(1970, 1, 1) - datetime.timedelta(seconds=1)'
        mined:+Body, -NL= 't = datetime.datetime(1970, 1, 1)'
      mined:+Body, -Code= '(1970, 1, 1)).sum()'

================================================================================

QUESTION: idx=469    id=2763750
-------------------------------------INPUTS-------------------------------------

tags: regex
score: 75
slot_map: {'key': ['var_0', 'str_0', 'var_1', 'var_2'], 'quote': ['`', '`', '`', '`'], 'type': ['var', 'str', 'var', 'var'], 'value': ['_suff', 'long.file.name.jpg', '_a', 'suff']}
intent: insert `_suff` before the file extension in `long.file.name.jpg` or replace `_a` with `suff` if it precedes the extension.
body(Some added characters for better readability):
	I need to match two cases by one reg expression and do replacement
	
	<p>'long.file.name.jpg' -> 'long.file.name_ 
	suff .jpg'
	
	<p>'long.file.name_ 
	a 
	.jpg' -> 'long.file.name_ 
	suff .jpg'
	I'm trying to do the following
	
	start_block
	re.sub('(\_a)?\.[^\.]*$' , '_suff.',"long.file.name.jpg")
	But this is cut the extension '.jpg' and I'm getting
	long.file.name_suff. instead of long.file.name_suff.jpg
	I understand that this is because of [^.]*$ part, but I can't exclude it, because
	I have to find last occurance of '_a' to replace or last '.' 
	Is there a way to replace only part of the match? 


-------------------------------------OUTPUT-------------------------------------

                Expected= "re.sub('(\\\\_a)?\\\\.([^\\\\.]*)$', '_suff.\\\\2', 'long.file.name.jpg')"
           base:Baseline= "re.sub('long.file.name.jpg','suff'))"
           base:+Canonic= "with open('str_0', 'var_2' as f:\n    pass"
           body:Baseline= "re.sub('(\\\\_a)?\\\\.[^\\\\.]*$', '_suff.')"
              body:-Code= "re.compile('long.file.name.jpg', '_a', 'suff')"
          mined:Baseline= "os.path.insert(0, 'long.file.name.jpg')"
             mined:+Body= "re.sub('\\\\_a)?\\\\.[^\\\\.]*$', '(long.file.name.jpg')"
        mined:+Body, -NL= "re.sub('\\\\[^\\\\.]*$', '', 'long.file.name.jpg')"
      mined:+Body, -Code= "long.file.name_suff.replace('_a', '')"

================================================================================

QUESTION: idx=470    id=6420361
-------------------------------------INPUTS-------------------------------------

tags: 
score: 24
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['module']}
intent: reload a module `module`
body(Some added characters for better readability):
	After import functions into ipython, how do I reload them when I have modified them outside of ipython ?


-------------------------------------OUTPUT-------------------------------------

                Expected= 'import imp\nimp.reload(module)'
           base:Baseline= 'module.load(key=lambda x: x[1])'
           base:+Canonic= 'module.load(module)'
           body:Baseline= 'module = module.load(0)'
              body:-Code= 'module = module.load()\nmodule.loads()\nexcept:\n    pass'
          mined:Baseline= 'sys.modules.append(module)'
             mined:+Body= 'sys.modules.update(module)'
        mined:+Body, -NL= 'module = module.load(module)'
      mined:+Body, -Code= 'module = Popen(module)\nmodule.reload()'

================================================================================

QUESTION: idx=471    id=19546911
-------------------------------------INPUTS-------------------------------------

tags: integer, bit, unsigned
score: 6
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['number']}
intent: convert integer `number` into an unassigned integer
body(Some added characters for better readability):
	
	<p>I currently read off pixels from an image using python PIL. These pixels are 16bit greyscale and are unsigned. However, whenever PIL reads them in it thinks they are signed and makes values that should be something like 
	45179 
	 into 
	-20357 .
	
	start_block
	org_Image = Image.open(image)
	org_Data = org_Image.load()
	width, height = org_Image.size
	    for y in range(0, height):
	        temprow_data = []
	        for x in range(0, width):
	             temprow_data.append(org_Data[x, y])
	How do I go about getting PIL to output unsigned instead of signed integers? Or is there a really easy way of taking the PIL input and converting it after?


-------------------------------------OUTPUT-------------------------------------

                Expected= "struct.unpack('H', struct.pack('h', number))"
           base:Baseline= "struct.unpack('{0:.2f}'.format(number))"
           base:+Canonic= "int('number', 16)"
           body:Baseline= 'np.arange(int(number))'
              body:-Code= 'print(pil.read_from_iterable(number))'
          mined:Baseline= "struct.unpack('<I', str(number))"
             mined:+Body= "int('45179'.encode('utf-8'))"
        mined:+Body, -NL= "int(''.join(map(str, x)))"
      mined:+Body, -Code= "struct.unpack('>', n)[0]"

================================================================================

QUESTION: idx=472    id=9746522
-------------------------------------INPUTS-------------------------------------

tags: list, function, sum
score: 8
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['numlist']}
intent: convert int values in list `numlist` to float
body(Some added characters for better readability):
	I am doing my homework and it requirers me to use a sum () and len () functions to find the mean of an input number list, when I tried to use sum () to get the sum of the list, I got an error TypeError: unsupported operand type(s) for +: 'int' and 'str'. Following is my code:
	
	start_block
	numlist = input("Enter a list of number separated by commas: ")
	numlist = numlist.split(",")
	s = sum(numlist)
	l = len(numlist)
	m = float(s/l)
	print("mean:",m)


-------------------------------------OUTPUT-------------------------------------

                Expected= 'numlist = [float(x) for x in numlist]'
           base:Baseline= 'float(numList, float(float))'
           base:+Canonic= 'float(numlist).float()'
           body:Baseline= "float(numlist).split(',')"
              body:-Code= 'float(numlist, float(str))'
          mined:Baseline= 'ast.literal_eval(numlist)'
             mined:+Body= 'sum(map(int, numlist))'
        mined:+Body, -NL= 'float(map(int, numlist))'
      mined:+Body, -Code= 'sum(map(int, float(numlist))'

================================================================================

QUESTION: idx=473    id=20107570
-------------------------------------INPUTS-------------------------------------

tags: pandas
score: 151
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['df']}
intent: write dataframe `df`, excluding index, to a csv file
body(Some added characters for better readability):
	I have the following code which imports a CSV file.  There are 3 columns and I want to set the first two of them to variables.  When I set the second column to the variable "efficiency" the index column is also tacked on.  How can I get rid of the index column?
	
	start_block
	df = pd.DataFrame.from_csv('Efficiency_Data.csv', header=0, parse_dates=False)
	energy = df.index
	efficiency = df.Efficiency
	print efficiency
	I tried using 
	
	start_block
	del df['index']
	after I set 
	
	start_block
	energy = df.index
	which I found in another post but that results in "KeyError: 'index' "


-------------------------------------OUTPUT-------------------------------------

                Expected= 'df.to_csv(filename, index=False)'
           base:Baseline= "df.to_csv('csv', excluding index)"
           base:+Canonic= "df.to_csv('\\n', index=False)"
           body:Baseline= "df.to_csv('Efficiency_Data.csv', header=False)"
              body:-Code= "df.to_csv('csv', excluding index)"
          mined:Baseline= "df.to_csv('mycsv.csv', delimiter=',')"
             mined:+Body= "df.to_csv('Efficiency_Data.csv', header=0, parse_dates=False)"
        mined:+Body, -NL= "df = pd.DataFrame.from_csv('Efficiency_Data.csv', header=0, parse_dates=False)"
      mined:+Body, -Code= "df.to_csv('test.csv', index=False)"

================================================================================

QUESTION: idx=474    id=8740353
-------------------------------------INPUTS-------------------------------------

tags: json, web-services, http-post, web.py
score: 6
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['unescaped', 'json_data']}
intent: convert a urllib unquoted string `unescaped` to a json data `json_data`
body(Some added characters for better readability):
	Here is the sample string i am receiving from one of the web services,
	
	start_block
	body=%7B%22type%22%3A%22change%22%2C%22url%22%3A%22http%3A%2F%2Fapi.pachube.com%2Fv2%2Ftriggers%2F4100%22%2C%22environment%22%3A%7B%22feed%22%3A%22http%3A%2F%2Fapi.pachube.com%2Fv2%2Ffeeds%2F36133%22%2C%22title%22%3A%22Current+Cost+Bridge%22%2C%22description%22%3Anull%2C%22id%22%3A36133%7D%2C%22threshold_value%22%3Anull%2C%22timestamp%22%3A%222012-01-05T09%3A27%3A01Z%22%2C%22triggering_datastream%22%3A%7B%22url%22%3A%22http%3A%2F%2Fapi.pachube.com%2Fv2%2Ffeeds%2F36133%2Fdatastreams%2F1%22%2C%22value%22%3A%7B%22value%22%3A%22523%22%2C%22max_value%22%3A1269.0%2C%22min_value%22%3A0.0%7D%2C%22id%22%3A%221%22%2C%22units%22%3A%7B%22symbol%22%3A%22W%22%2C%22type%22%3A%22derivedUnits%22%2C%22label%22%3A%22watts%22%7D%7D%2C%22id%22%3A4100%7D
	Here is the code,
	
	start_block
	class Feeds():
	    def GET(self):
	        print "Get request is accepted."
	        return render.index(None)
	    def POST(self):
	        print "Post request is accepted."
	        print (web.data())
	Now when that web-service posts the above given data, how will i convert it to readable format? Then, i need to convert it to JSON object and use further. So, how will i convert it?
	When i try this code,
	
	start_block
	        json_data = json.loads(web.data())
	        print json_data['body']
	        return render.index(json_data['body'])
	It gives me an error,
	
	start_block
	enter code Traceback (most recent call last):
	File "/usr/local/lib/python2.6/dist-packages/web/application.py", line 237, in process
	return self.handle()
	File "/usr/local/lib/python2.6/dist-packages/web/application.py", line 228, in handle
	return self._delegate(fn, self.fvars, args)
	File "/usr/local/lib/python2.6/dist-packages/web/application.py", line 409, in _delegate
	return handle_class(cls)
	File "/usr/local/lib/python2.6/dist-packages/web/application.py", line 385, in      handle_class
	return tocall(*args)
	File "/home/ubuntu/pachubeConsumer/src/controllers/feeds.py", line 17, in POST
	json_data = json.loads(web.data())
	File "/usr/lib/python2.6/json/__init__.py", line 307, in loads
	return _default_decoder.decode(s)
	File "/usr/lib/python2.6/json/decoder.py", line 319, in decode
	obj, end = self.raw_decode(s, idx=_w(s, 0).end())
	File "/usr/lib/python2.6/json/decoder.py", line 338, in raw_decode
	raise ValueError("No JSON object could be decoded")
	ValueError: No JSON object could be decoded here
	Where am i going wrong ??
	Thanks in advance.


-------------------------------------OUTPUT-------------------------------------

                Expected= 'json_data = json.loads(unescaped)'
           base:Baseline= "json_data = urllib.request.urlretrieve('unescaped')"
           base:+Canonic= 'json.dumps(json_data, unescaped)'
           body:Baseline= 'json_data = urllib.parse.unquote(unquote)'
              body:-Code= 'json_data = urllib.parse.unquote(unescaped)'
          mined:Baseline= 'json_data = json.loads(urllib.parse.unquote(url).split())'
             mined:+Body= 'json_data = urllib.parse.unquote(string)'
        mined:+Body, -NL= 'json_data = urllib.parse.unquote(url, data)'
      mined:+Body, -Code= 'json_data = json.loads(urllib.parse.unquote(unescaped))'

================================================================================

QUESTION: idx=475    id=5891453
-------------------------------------INPUTS-------------------------------------

tags: ascii
score: 104
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: create a list containing all ascii characters as its elements
body(Some added characters for better readability):
	Something like below:
	
	start_block
	import ascii
	print ascii.charlist()
	Which would return something like [A, B, C, D...]


-------------------------------------OUTPUT-------------------------------------

                Expected= '[chr(i) for i in range(127)]'
           base:Baseline= 'list(ascii.enumerate(list(itertools.chain.from_iterable(0)))'
           base:+Canonic= "list(itertools.chain.from_iterable('\\n')))"
           body:Baseline= 'print(ascii.charlist()'
              body:-Code= 'list(itertools.product([A, B, C, D])'
          mined:Baseline= 'list(itertools.chain.from_iterable(ord(c))'
             mined:+Body= 'print([i for i in range(0, len(ascii)))'
        mined:+Body, -NL= '"""""".join(chr(i) for i in L)'
      mined:+Body, -Code= 'list(itertools.product([A, B, C, D])'

================================================================================

QUESTION: idx=476    id=18367007
-------------------------------------INPUTS-------------------------------------

tags: 
score: 139
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['newFileBytes', 'newFile']}
intent: write `newfilebytes` to a binary file `newfile`
body(Some added characters for better readability):
	I have a list of bytes as integers, which is something like
	
	start_block
	[120, 3, 255, 0, 100]
	How can I write this list to a file as binary?
	Would this work?
	
	start_block
	newFileBytes = [123, 3, 255, 0, 100]
	# make file
	newFile = open("filename.txt", "wb")
	# write to file
	newFile.write(newFileBytes)


-------------------------------------OUTPUT-------------------------------------

                Expected= "newFile.write(struct.pack('5B', *newFileBytes))"
           base:Baseline= 'newfilebytes = open(newfile)'
           base:+Canonic= 'bin(newFileBytes, newFile)'
           body:Baseline= "newFile = open('filename.txt', 'wb')"
              body:-Code= 'newfilebytes = [int(x) for x in oldfile]'
          mined:Baseline= "newfile = open('newfile', 'rb')"
             mined:+Body= "newFile = open('filename.txt', 'wb')"
        mined:+Body, -NL= "newFile = open('filename.txt', 'wb')"
      mined:+Body, -Code= "newfile = open('newfilebytes', 'rb')"

================================================================================

QUESTION: idx=477    id=21805490
-------------------------------------INPUTS-------------------------------------

tags: regex, string
score: 6
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['string']}
intent: python regex - check for a capital letter with a following lowercase in string `string`
body(Some added characters for better readability):
	I am trying to check for a capital letter that has a lowercase letter coming directly after it. The trick is that there is going to be a bunch of garbage capital letters and number coming directly before it. For example:
	
	start_block
	AASKH317298DIUANFProgramming is fun
	
	<p>as you can see, there is a bunch of stuff we don't need coming directly before the phrase we do need, 
	`Programming is fun`.
	
	<p>I am trying to use regex to do this by taking each string and then substituting it out with 
	`''` as the original string does not have to be kept. 
	
	start_block
	re.sub(r'^[A-Z0-9]*', '', string)
	
	<p>The problem with this code is that it leaves us with 
	`rogramming is fun`
	, as the 
	`P` is a capital letter. 
	
	<p>How would I go about checking to make sure that if the next letter is a lowercase, then I should leave that capital untouched. (The 
	`P`
	 in 
	`Programming`)


-------------------------------------OUTPUT-------------------------------------

                Expected= "re.sub('^[A-Z0-9]*(?![a-z])', '', string)"
           base:Baseline= "re.findall('\\\\b+\\\\b', string)"
           base:+Canonic= "re.findall('\\\\w+', string)"
           body:Baseline= "re.sub('^[A-Z0-9]*', string)"
              body:-Code= "print(re.sub('\\\\d+', string))"
          mined:Baseline= "re.findall('[a-zA-Z]', string)"
             mined:+Body= "re.sub('^[A-Z0-9]*', '', string)"
        mined:+Body, -NL= "re.sub('^[A-Z0-9]*', '', string)"
      mined:+Body, -Code= "print(re.sub('[^a-zA-Z]*', '', string))"

================================================================================

QUESTION: idx=478    id=16125229
-------------------------------------INPUTS-------------------------------------

tags: 
score: 63
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['dict']}
intent: get the last key of dictionary `dict`
body(Some added characters for better readability):
	I am having difficulty figuring out what the syntax would be for the last key in a Python dictionary. I know that for a Python list, one may say this to denote the last:
	
	start_block
	list[-1]
	I also know that one can get a list of the keys of a dictionary as follows:
	
	start_block
	dict.keys()
	However, when I attempt to use the logical following code, it doesnt work:
	
	start_block
	dict.keys(-1)
	It says that keys cant take any arguments and 1 is given. If keys cant take args, then how can I denote that I want the last key in the list?
	XXXXX
	I am operating under the assumption that Python dictionaries are ordered in the order in which items are added to the dictionary with most recent item last. For this reason, I would like to access the last key in the dictionary.XXXXX
	I am now told that the dictionary keys are not in order based on when they were added. How then would I be able to choose the most recently added key?


-------------------------------------OUTPUT-------------------------------------

                Expected= 'list(dict.keys())[-1]'
           base:Baseline= 'last(dict.last()):\n    pass'
           base:+Canonic= 'last(dict.keys())'
           body:Baseline= 'dict.keys()[-1]'
              body:-Code= '[x for x in list(dict.items() if x is not last]'
          mined:Baseline= 'dict((k, v) for k, v in list(dict.items()))'
             mined:+Body= 'list(dict.keys())[-1]'
        mined:+Body, -NL= 'next(iter(dict.items()))'
      mined:+Body, -Code= 'list(dict.items()[-1])'

================================================================================

QUESTION: idx=479    id=6159900
-------------------------------------INPUTS-------------------------------------

tags: file-io
score: 1156
slot_map: {'key': ['str_0', 'var_0'], 'quote': ['"', '`'], 'type': ['str', 'var'], 'value': ['hi there', 'f']}
intent: write line "hi there" to file `f`
body(Some added characters for better readability):
	
	<p>I'm used to doing `print >>f, "hi there"`
	
	<p>However, it seems that 
	`print >>` is getting deprecated. What is the recommended way to do the line above?
	
	<b>Update :
	
	`"\n"`
	<console_out>is this universal or Unix-specific? IE, should I be doing 
	`"\r\n"` on Windows?


-------------------------------------OUTPUT-------------------------------------

                Expected= "print('hi there', file=f)"
           base:Baseline= "f = f.write('hi there')"
           base:+Canonic= "f.write('hi there')"
           body:Baseline= "f = f.write('hi there')"
              body:-Code= "f = f.write('hi there')"
          mined:Baseline= "f = f.write('hi there')"
             mined:+Body= "print(f, 'hi there')"
        mined:+Body, -NL= "f.write('\\r\\n')"
      mined:+Body, -Code= "f = f.write('hi there')"

================================================================================

QUESTION: idx=480    id=6159900
-------------------------------------INPUTS-------------------------------------

tags: file-io
score: 1156
slot_map: {'key': ['str_0', 'var_0'], 'quote': ['"', '`'], 'type': ['str', 'var'], 'value': ['hi there', 'myfile']}
intent: write line "hi there" to file `myfile`
body(Some added characters for better readability):
	
	<p>I'm used to doing `print >>f, "hi there"`
	
	<p>However, it seems that 
	`print >>` is getting deprecated. What is the recommended way to do the line above?
	
	<b>Update :
	
	`"\n"`
	<console_out>is this universal or Unix-specific? IE, should I be doing 
	`"\r\n"` on Windows?


-------------------------------------OUTPUT-------------------------------------

                Expected= "f = open('myfile', 'w')\nf.write('hi there\\n')\nf.close()"
           base:Baseline= "myfile.write('hi there')"
           base:+Canonic= "myfile.write('hi there')"
           body:Baseline= "print(myfile.write('hi there')"
              body:-Code= "myfile.write('hi there')"
          mined:Baseline= "myfile.write('hi there')"
             mined:+Body= "print(myfile.write('hi there'))"
        mined:+Body, -NL= "myfile.write('hi there')"
      mined:+Body, -Code= "myfile.write('hi there')"

================================================================================

QUESTION: idx=481    id=6159900
-------------------------------------INPUTS-------------------------------------

tags: file-io
score: 1156
slot_map: {'key': ['str_0', 'str_1'], 'quote': ['"', '`'], 'type': ['str', 'str'], 'value': ['Hello', 'somefile.txt']}
intent: write line "hello" to file `somefile.txt`
body(Some added characters for better readability):
	
	<p>I'm used to doing `print >>f, "hi there"`
	
	<p>However, it seems that 
	`print >>` is getting deprecated. What is the recommended way to do the line above?
	
	<b>Update :
	
	`"\n"`
	<console_out>is this universal or Unix-specific? IE, should I be doing 
	`"\r\n"` on Windows?


-------------------------------------OUTPUT-------------------------------------

                Expected= "with open('somefile.txt', 'a') as the_file:\n    the_file.write('Hello\\n')"
           base:Baseline= "somefile.txt.write('hello')"
           base:+Canonic= "open('somefile.txt', 'Hello')"
           body:Baseline= 'print(os.path.commonfile(somefile.txt))'
              body:-Code= "somefile.txt.write('hello')"
          mined:Baseline= "with open('somefile.txt', 'Hello') as f:\n    f.write('\\n')"
             mined:+Body= 'print(os.path.basename(somefile.txt))'
        mined:+Body, -NL= "print(somefile.txt, 'Hello')"
      mined:+Body, -Code= "os.system('somefile.txt')"

================================================================================

QUESTION: idx=482    id=19527279
-------------------------------------INPUTS-------------------------------------

tags: unicode, encoding, ascii
score: 14
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['s']}
intent: convert unicode string `s` to ascii
body(Some added characters for better readability):
	I am unable to convert the following Unicode to ASCII without losing data:
	
	start_block
	u'ABRA\xc3O JOS\xc9'
	
	<p>I tried 
	`encode`
	 and 
	`decode` and they won't do it.
	Does anyone have a suggestion?


-------------------------------------OUTPUT-------------------------------------

                Expected= "s.encode('iso-8859-15')"
           base:Baseline= "s.decode('unicode_escape')"
           base:+Canonic= "s.encode('unicode_escape')"
           body:Baseline= 'urllib.parse.unquote(s)'
              body:-Code= "s.decode('unicode_escape')"
          mined:Baseline= "s.decode('unicode_escape')"
             mined:+Body= "unicodedata.normalize('NFKD', s)"
        mined:+Body, -NL= "s.encode('ascii', 'ignore')"
      mined:+Body, -Code= "s.decode('unicode_escape')"

================================================================================

QUESTION: idx=483    id=10668585
-------------------------------------INPUTS-------------------------------------

tags: django, django-models
score: 11
slot_map: {'key': ['str_0', 'var_0'], 'quote': ["'", '`'], 'type': ['str', 'var'], 'value': ['added', 'AuthorizedEmail']}
intent: django get maximum value associated with field 'added' in model `authorizedemail`
body(Some added characters for better readability):
	
	
	start_block
	>>>AuthorizedEmail.objects.filter(group=group).values('added')
	...[{'added': datetime.datetime(2012, 5, 19, 13, 8, 7)}, 
	{'added': datetime.datetime(2012, 5, 19, 13, 8, 7)}, 
	{'added': datetime.datetime(2012, 5, 19, 13, 7, 23)}, 
	{'added': datetime.datetime(2012, 5, 19, 13, 8, 7)}]
	What would be the best way to get the max value here? In python or in the ORM?


-------------------------------------OUTPUT-------------------------------------

                Expected= "AuthorizedEmail.objects.filter(group=group).order_by('-added')[0]"
           base:Baseline= "authorizedemail.objects.get('added')"
           base:+Canonic= "AuthorizedEmail.max_values('added')"
           body:Baseline= 'AuthorizedEmail.objects.max()'
              body:-Code= "print(authorizedemail.get('added')"
          mined:Baseline= 'super(Model, self).save(*args, **kwargs)'
             mined:+Body= "AuthorizedEmail.objects.filter(group=group).values('added')"
        mined:+Body, -NL= "AuthorizedEmail.objects.values_list('added')"
      mined:+Body, -Code= "max(authorizedemail, auth=['Value'])"

================================================================================

QUESTION: idx=484    id=356483
-------------------------------------INPUTS-------------------------------------

tags: regex, findall
score: 10
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['text']}
intent: find all numbers and dots from a string `text` using regex
body(Some added characters for better readability):
	I'm using re.findall() to extract some version numbers from an HTML file:
	
	
	start_block
	>>>import re
	
	>>>text = " 
	<a href=\"url\">Test0.2.1.zip </a> </td> <td>Test0.2.1 </td> </table> Test0.2.1"
	>>>re.findall("Test([\.0-9]*)", text)
	...['0.2.1.', '0.2.1', '0.2.1']
	but I would like to only get the ones that do not end in a dot.
	The filename might not always be .zip so I can't just stick .zip in the regex.
	I wanna end up with:
	
	start_block
	['0.2.1', '0.2.1']
	Can anyone suggest a better regex to use? :)


-------------------------------------OUTPUT-------------------------------------

                Expected= "re.findall('Test([0-9.]*[0-9]+)', text)"
           base:Baseline= "re.findall('(\\\\w+)', text)"
           base:+Canonic= "re.findall('\\\\w+', text)"
           body:Baseline= "re.findall('Test([\\\\.0-9]*)', text)"
              body:-Code= "re.findall('\\\\w+', text)"
          mined:Baseline= "re.findall('\\\\d+', text)"
             mined:+Body= "re.findall('Test([\\\\.0-9]*)', text)"
        mined:+Body, -NL= "re.findall('Test([\\\\.0-9]*)', text)"
      mined:+Body, -Code= "re.findall('\\\\.zip', text)"

================================================================================

QUESTION: idx=485    id=356483
-------------------------------------INPUTS-------------------------------------

tags: regex, findall
score: 10
slot_map: {'key': ['str_0'], 'quote': ["'"], 'type': ['str'], 'value': ['text']}
intent: python regex  to find all numbers and dots from 'text'
body(Some added characters for better readability):
	I'm using re.findall() to extract some version numbers from an HTML file:
	
	
	start_block
	>>>import re
	
	>>>text = " 
	<a href=\"url\">Test0.2.1.zip </a> </td> <td>Test0.2.1 </td> </table> Test0.2.1"
	>>>re.findall("Test([\.0-9]*)", text)
	...['0.2.1.', '0.2.1', '0.2.1']
	but I would like to only get the ones that do not end in a dot.
	The filename might not always be .zip so I can't just stick .zip in the regex.
	I wanna end up with:
	
	start_block
	['0.2.1', '0.2.1']
	Can anyone suggest a better regex to use? :)


-------------------------------------OUTPUT-------------------------------------

                Expected= "re.findall('Test([\\\\d.]*\\\\d+)', text)"
           base:Baseline= "re.findall('\\\\b+\\\\b', text)"
           base:+Canonic= "re.findall('text', re.UNICODE)"
           body:Baseline= "re.findall('Test([\\\\.0-9]*)', text)"
              body:-Code= "re.findall('\\\\w+', text)"
          mined:Baseline= "re.findall('\\\\d+', text)"
             mined:+Body= "re.findall('Test([\\\\.0-9]*)', text)"
        mined:+Body, -NL= "re.findall('Test([\\\\.0-9]*)', text)"
      mined:+Body, -Code= "re.findall('\\\\w+', text)"

================================================================================

QUESTION: idx=486    id=38081866
-------------------------------------INPUTS-------------------------------------

tags: powershell
score: 4
slot_map: {'key': ['str_0', 'str_1'], 'quote': ["'", "'"], 'type': ['str', 'str'], 'value': ['script.ps1', 'powershell.exe']}
intent: execute script 'script.ps1' using 'powershell.exe' shell
body(Some added characters for better readability):
	Is there a way to run powershell code in python? I've been searching around and all I'm finding is how to run a separate PS script file in python, but nothing about running PS code.
	Example: Let's say I want to run this command from inside a Python script\program...
	
	start_block
	Start-Process -filepath "Path\Filename.exe" -wait
	I understand in that example I could just run the file using Python. I'm looking into writing a Python app, but it would use some powershell code behind the scenes to actually do what it needs to do. In the case for my app idea, it would connect to Office 365 and manipulate users\account info (add, remove, etc) and things you can't do on the 365 admin site. I already have a PS script to do most of this, but I'm looking into a GUI interface and python seems to be the better choice for GUI (so far as what I've seen and played with).
	If this isn't possible, or if it's more pain than it's worth I'd appreciate some suggestions. Should I look into C# or something like that? Python seemed easier to understand.
	Thanks.


-------------------------------------OUTPUT-------------------------------------

                Expected= "os.system('powershell.exe', 'script.ps1')"
           base:Baseline= "os.system('script.ps1', shell=True)"
           base:+Canonic= "subprocess.call('script.ps1', shell=True)"
           body:Baseline= "os.system('script.ps1', shell=True)"
              body:-Code= "os.system('script.ps1', shell=True)"
          mined:Baseline= "exec(compile(open('script.ps1').read(), 'exec'))"
             mined:+Body= "os.system('script.ps1', shell=True)"
        mined:+Body, -NL= "os.system('script.ps1')"
      mined:+Body, -Code= "subprocess.call('script.ps1', shell=True)"

================================================================================

QUESTION: idx=487    id=7349646
-------------------------------------INPUTS-------------------------------------

tags: sorting, dictionary, tuples
score: 10
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['b']}
intent: sort a list of tuples `b` by third item in the tuple
body(Some added characters for better readability):
	I know there's tonnes of questions on python sorting lists/dictionaries already, but I can't seem to find one which helps in my case, and i'm looking for the most efficient solution as I'm going to be sorting a rather large dataset.
	My data basically looks like this at the moment:
	
	start_block
	a = {'a': (1, 2, 3), 'b': (3, 2, 1)}
	I'm basically creating a word list in which I store each word along with some stats about it (n, Sigma(x), Sigma(x^2) )
	I want to sort it based on a particular stat. So far I've been trying something along the lines of:
	
	start_block
	b = a.items()
	b.sort(key = itemgetter(1), reverse=True)
	I'm not sure how to control which index it is sorted based on when its effectively a list of tuples of tuples? I guess I effectively need to nest two itemgetter operations but not really sure how to do this.
	If there's a better data structure I should be using instead please let me know. Should I perhaps create a small class/struct and then use a lambda function to access a member of the class?
	Many Thanks


-------------------------------------OUTPUT-------------------------------------

                Expected= 'b.sort(key=lambda x: x[1][2])'
           base:Baseline= 'sorted(b, key=lambda x: x[1])'
           base:+Canonic= 'sorted(b, key=lambda x: x[1])'
           body:Baseline= 'b.sort(key=itemgetter(1), reverse=True)'
              body:-Code= 'sorted(b, key=lambda x: x[1])'
          mined:Baseline= 'sorted(b, key=operator.itemgetter(1), reverse=True)'
             mined:+Body= 'b.sort(key=lambda x: x[1])'
        mined:+Body, -NL= 'b.sort(key=lambda x: x[1])'
      mined:+Body, -Code= 'sorted(b, key=lambda x: x[1])'

================================================================================

QUESTION: idx=488    id=2430539
-------------------------------------INPUTS-------------------------------------

tags: cassandra, pycassa
score: 6
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['cf']}
intent: get a list of all keys in cassandra database `cf` with pycassa
body(Some added characters for better readability):
	
	<p>Is anyone having experience working with 
	pycassa  I have a doubt with it. How do I get all the keys that are stored in the database?
	well in this small snippet we need to give the keys in order to get the associated columns (here the keys are 'foo' and 'bar'),that is fine but my requirement is to get all the keys (only keys) at once as Python list or similar data structure. 
	
	start_block
	cf.multiget(['foo', 'bar'])
	{'foo': {'column1': 'val2'}, 'bar': {'column1': 'val3', 'column2': 'val4'}}
	Thanks.


-------------------------------------OUTPUT-------------------------------------

                Expected= 'list(cf.get_range().get_keys())'
           base:Baseline= 'list(cf.keys()).all()'
           base:+Canonic= 'list(cf.keys())'
           body:Baseline= '[k for k, v in cf.keys() if v in k]'
              body:-Code= '[k for k, v incf.keys()]'
          mined:Baseline= "cursor.execute('SELECT * FROM records WHERE email LIKE '%s'')"
             mined:+Body= "[k for k, v in cf.multiget(['foo', 'bar']) if k in v]"
        mined:+Body, -NL= "cf.multiget(['foo', 'bar'])"
      mined:+Body, -Code= 'list(cursor.chain.from_iterable(cf.keys())'

================================================================================

QUESTION: idx=489    id=10607688
-------------------------------------INPUTS-------------------------------------

tags: 
score: 203
slot_map: {'key': [], 'quote': [], 'type': [], 'value': []}
intent: create a datetime with the current date & time
body(Some added characters for better readability):
	Here is a functional code (create file with success)
	
	start_block
	sys.stdout = open('filename1.xml', 'w')
	Now I'm trying to name the file with the current date/time (I'm not an expert in Python)
	
	start_block
	filename1 = datetime.now().strftime("%Y%m%d-%H%M%S")
	sys.stdout = open(filename1 + '.xml', 'w')
	I want to write out a file name with the exact date and time, it is a xml file, that the program has already create, I just need to name the file. The above code is not working.
	The error returned:
	
	start_block
	  File "./fix.py", line 226, in <module>
	    filenames = datetime.now().strftime("%Y%m%d-%H%M%S")
	AttributeError: 'module' object has no attribute 'now'


-------------------------------------OUTPUT-------------------------------------

                Expected= 'datetime.datetime.now()'
           base:Baseline= "datetime.now().strftime('%Y-%m-%d %H:%M')"
           base:+Canonic= "datetime.now().strftime('%Y-%m-%d %H:%M:%S')"
           body:Baseline= "datetime.now().strftime('%Y%m%d-%H%M%S')"
              body:-Code= 'today = datetime.datetime.now().date()'
          mined:Baseline= "dt = datetime.datetime.now().strftime('%Y-%m-%d')"
             mined:+Body= "datetime.now().strftime('%Y%m%d-%H%M%S')"
        mined:+Body, -NL= "datetime.now().strftime('%Y%m%d-%H%M%S')"
      mined:+Body, -Code= "print(datetime.now().strftime('%Y-%m-%d')"

================================================================================

QUESTION: idx=490    id=30843103
-------------------------------------INPUTS-------------------------------------

tags: list, indexing
score: 15
slot_map: {'key': ['str_0', 'var_0'], 'quote': ['`', '`'], 'type': ['str', 'var'], 'value': ['1', 'lst']}
intent: get the index of an integer `1` from a list `lst` if the list also contains boolean items
body(Some added characters for better readability):
	I am just starting with Python.
	
	<p>How to get index of integer 
	`1`
	 from a list if the list contains a boolean 
	`True`
	 object before the 
	`1`?
	
	
	start_block
	>>>lst = [True, False, 1, 3]
	>>>lst.index(1)
	...0
	>>>lst.index(True)
	...0
	>>>lst.index(0)
	...1
	
	<p>I think Python considers 
	`0`
	 as 
	`False`
	 and 
	`1`
	 as 
	`True`
	 in the argument of the 
	`index`
	 method. How can I get the index of integer 
	`1`
	 (i.e. 
	`2`)?
	Also what is the reasoning or logic behind treating boolean object this way in list?
	As from the solutions, I can see it is not so straightforward.


-------------------------------------OUTPUT-------------------------------------

                Expected= 'next(i for i, x in enumerate(lst) if not isinstance(x, bool) and x == 1)'
           base:Baseline= '[i for i, j in lst if j[i] == 1]'
           base:+Canonic= '[i for i, j in enumerate(lst, lst.items()) if j]'
           body:Baseline= '[i for i, j in lst if j in i]'
              body:-Code= '[i for i in lst if i == 1]'
          mined:Baseline= '[i for i, j in enumerate(lst) if j == 1]'
             mined:+Body= '[i for i, j in enumerate(lst) if j == 1]'
        mined:+Body, -NL= '[i for i, elem in enumerate(lst) if elem is not a]'
      mined:+Body, -Code= '[i for i, x in enumerate(lst) if x == 9]'

================================================================================

QUESTION: idx=491    id=4918425
-------------------------------------INPUTS-------------------------------------

tags: 
score: 87
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['a']}
intent: subtract 13 from every number in a list `a`
body(Some added characters for better readability):
	I have a list
	
	start_block
	 a = [49, 51, 53, 56]
	How do I subtract 13 from each integer value in the list?


-------------------------------------OUTPUT-------------------------------------

                Expected= 'a[:] = [(x - 13) for x in a]'
           base:Baseline= '[(x[1] for x in a]'
           base:+Canonic= '[(x * 13) for x in a]'
           body:Baseline= '[x[0] for x in a]'
              body:-Code= '[x[0] for x in a]'
          mined:Baseline= '[(i * j) for i, j in zip(a, b)]'
             mined:+Body= '[x for x in a if x != 13]'
        mined:+Body, -NL= '[i for i, j in zip(a, a[i:13]) if j != 13]'
      mined:+Body, -Code= '[(x * 13) for x in a]'

================================================================================

QUESTION: idx=492    id=701402
-------------------------------------INPUTS-------------------------------------

tags: file, random
score: 43
slot_map: {'key': ['str_0'], 'quote': ['`'], 'type': ['str'], 'value': ['C:\\']}
intent: choose a random file from the directory contents of the c drive, `c:\\`
body(Some added characters for better readability):
	What is the best way to choose a random file from a directory in Python?
	
	<em>Edit:  Here is what I am doing:
	
	start_block
	import os
	import random
	import dircache
	dir = 'some/directory'
	filename = random.choice(dircache.listdir(dir))
	path = os.path.join(dir, filename)
	Is this particularly bad, or is there a particularly better way?


-------------------------------------OUTPUT-------------------------------------

                Expected= "random.choice(os.listdir('C:\\\\'))"
           base:Baseline= 'print(random.choice(c:\\\\))'
           base:+Canonic= "random.choice(open('C:\\\\', 'rb').read())"
           body:Baseline= 'print(random.choice(c:\\\\)'
              body:-Code= 'random.choice(c:\\\\)'
          mined:Baseline= 'random.choice(list(c:\\\\))'
             mined:+Body= "random.choice(open('C:\\\\'))"
        mined:+Body, -NL= 'random.choice(listdir, filename)'
      mined:+Body, -Code= "random.choice(open('C:\\\\'))"

================================================================================

QUESTION: idx=493    id=17794266
-------------------------------------INPUTS-------------------------------------

tags: numpy
score: 22
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['x']}
intent: get the highest element in absolute value in a numpy matrix `x`
body(Some added characters for better readability):
	Here is what I am currently doing, it works but it's a little cumbersome:
	
	start_block
	x = np.matrix([[1, 1], [2, -3]])
	xmax = x.flat[abs(x).argmax()]


-------------------------------------OUTPUT-------------------------------------

                Expected= 'max(x.min(), x.max(), key=abs)'
           base:Baseline= 'max(x, key=lambda x: x[1])'
           base:+Canonic= 'print(np.arange(var_0, key=lambda x: x[1])'
           body:Baseline= 'max = np.matrix([1, 1], [2, -3]]'
              body:-Code= 'max(x, key=lambda x: x[1])'
          mined:Baseline= 'np.argwhere(np.isnan(x))[-1]'
             mined:+Body= 'xmax = x.flat[abs(x).argmax(axis=1)]'
        mined:+Body, -NL= 'x.flat[abs(x).argmax(axis=1)]'
      mined:+Body, -Code= 'x.argmax(axis=1)'

================================================================================

QUESTION: idx=494    id=30551576
-------------------------------------INPUTS-------------------------------------

tags: regex
score: 4
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['s']}
intent: get all urls within text `s`
body(Some added characters for better readability):
	I have parsed an html document containing javascript with beautifulsoup, and have managed to isolate the javascript within it and convert it into a string. The javascript looks like this: 
	
	start_block
	<script>
	    [irrelevant javascript code here]
	    sources:[{file:"http://url.com/folder1/v.html",label:"label1"},
	    {file:"http://url.com/folder2/v.html",label:"label2"},
	    {file:"http://url.com/folder3/v.html",label:"label3"}],
	    [irrelevant javascript code here]
	</script>
	I am trying to get an array with only urls contained in this sources array, which would look like so:
	
	start_block
	urls = ['http://url.com/folder1/v.html', 
	        'http://url.com/folder2/v.html', 
	        'http://url.com/folder3/v.html']
	
	<p>The domains are unknown IPs, the folders are of random name-length consisting of lowercase letters and numbers, and there are 1-5 of them in each file(usually 3). All that is constant is that they start with 
	`http`
	 and end with 
	`.html`.
	
	<p>I decided to use regular expressions to deal with this problem(which I am quite new at) and my code looks like this: `urls=re.findall(r'http://[^t][^s"]+', document)`
	
	<p>The 
	`[^t]` is there because there are other urls in the document whose domain names start with t. My problem is, there is another url with a jpg from the same domain as the urls I am extracting, which gets put into the urls array along with the others. 
	Example:
	
	start_block
	urls = ['http://123.45.67.89/asodibfo3ribawoifbadsoifasdf3/v.html'
	        'http://123.45.67.89/alwefaoewifiasdof224a/v.html',
	        'http://123.45.67.89/baoisdbfai235oubodsfb45/v.html',
	        'http://123.45.67.89/i/0123/12345/aoief243oinsdf.jpg']
	How would I go about only fetching the html urls?


-------------------------------------OUTPUT-------------------------------------

                Expected= 're.findall(\'"(http.*?)"\', s, re.MULTILINE | re.DOTALL)'
           base:Baseline= "re.findall('([^a-z])', s)"
           base:+Canonic= 'urls = urls.join(s.split())'
           body:Baseline= "urls = [re.findall('http://[^t][^s]+', document)"
              body:-Code= "print(s.findAll(',')"
          mined:Baseline= "print(re.findall('\\\\s+', s))"
             mined:+Body= "urls = [re.findall('http://[^t][^s]+)', document)"
        mined:+Body, -NL= "urls = re.findall('http://[^t][^s]+', document)"
      mined:+Body, -Code= "[urls for urls in sources.findall('\\\\w+', s)]"

================================================================================

QUESTION: idx=495    id=30551576
-------------------------------------INPUTS-------------------------------------

tags: regex
score: 4
slot_map: {'key': ['var_0', 'var_1'], 'quote': ['`', '`'], 'type': ['var', 'var'], 'value': ['t', 'document']}
intent: match urls whose domain doesn't start with `t` from string `document` using regex
body(Some added characters for better readability):
	I have parsed an html document containing javascript with beautifulsoup, and have managed to isolate the javascript within it and convert it into a string. The javascript looks like this: 
	
	start_block
	<script>
	    [irrelevant javascript code here]
	    sources:[{file:"http://url.com/folder1/v.html",label:"label1"},
	    {file:"http://url.com/folder2/v.html",label:"label2"},
	    {file:"http://url.com/folder3/v.html",label:"label3"}],
	    [irrelevant javascript code here]
	</script>
	I am trying to get an array with only urls contained in this sources array, which would look like so:
	
	start_block
	urls = ['http://url.com/folder1/v.html', 
	        'http://url.com/folder2/v.html', 
	        'http://url.com/folder3/v.html']
	
	<p>The domains are unknown IPs, the folders are of random name-length consisting of lowercase letters and numbers, and there are 1-5 of them in each file(usually 3). All that is constant is that they start with 
	`http`
	 and end with 
	`.html`.
	
	<p>I decided to use regular expressions to deal with this problem(which I am quite new at) and my code looks like this: `urls=re.findall(r'http://[^t][^s"]+', document)`
	
	<p>The 
	`[^t]` is there because there are other urls in the document whose domain names start with t. My problem is, there is another url with a jpg from the same domain as the urls I am extracting, which gets put into the urls array along with the others. 
	Example:
	
	start_block
	urls = ['http://123.45.67.89/asodibfo3ribawoifbadsoifasdf3/v.html'
	        'http://123.45.67.89/alwefaoewifiasdof224a/v.html',
	        'http://123.45.67.89/baoisdbfai235oubodsfb45/v.html',
	        'http://123.45.67.89/i/0123/12345/aoief243oinsdf.jpg']
	How would I go about only fetching the html urls?


-------------------------------------OUTPUT-------------------------------------

                Expected= 're.findall(\'http://[^t][^s"]+\\\\.html\', document)'
           base:Baseline= "re.match('\\\\w+\\\\t+', document)"
           base:+Canonic= "re.match('\\\\w+', document).startswith('t')"
           body:Baseline= "re.findall('http://[^t][^s]+', document)"
              body:-Code= "re.findall('\\\\w+', document)"
          mined:Baseline= "urllib.parse.urlencode({'domain': 'document'})"
             mined:+Body= "urls = re.findall('http://[^t][^s]+', document)"
        mined:+Body, -NL= "urls = re.findall('http://[^t][^s]+', document)"
      mined:+Body, -Code= "re.findall('^[^\\\\w\\\\t\\\\w]', '', source)"

================================================================================

QUESTION: idx=496    id=113534
-------------------------------------INPUTS-------------------------------------

tags: split
score: 12
slot_map: {'key': ['var_0', 'str_0'], 'quote': ['`', "'"], 'type': ['var', 'str'], 'value': ['mystring', '']}
intent: split a string `mystring` considering the spaces ' '
body(Some added characters for better readability):
	Is there a function in Python to split a string without ignoring the spaces in the resulting list? 
	E.g:
	
	start_block
	s="This is the string I want to split".split()
	gives me
	
	
	start_block
	>>>s
	...['This', 'is', 'the', 'string', 'I', 'want', 'to', 'split']
	I want something like
	
	start_block
	['This',' ','is',' ', 'the',' ','string', ' ', <console_out>..]


-------------------------------------OUTPUT-------------------------------------

                Expected= "mystring.replace(' ', '!!').split('!')"
           base:Baseline= "myString.split(' ', '')"
           base:+Canonic= "re.split('', mystring)"
           body:Baseline= '"""This is the string I want to split""".split()'
              body:-Code= "myString.split(' ', 1)"
          mined:Baseline= "re.split(' ', '')"
             mined:+Body= "s = s.replace(' ', '')"
        mined:+Body, -NL= "mystring.split(' ', 1)"
      mined:+Body, -Code= "myString.split(' ', 1)"

================================================================================

QUESTION: idx=497    id=5838735
-------------------------------------INPUTS-------------------------------------

tags: django
score: 4
slot_map: {'key': ['var_0', 'str_0'], 'quote': ['`', "'"], 'type': ['var', 'str'], 'value': ['path', 'r']}
intent: open file `path` with mode 'r'
body(Some added characters for better readability):
	My cwd is ~/Desktop/Development/Python/djcode/mysite, and I want to open a file on my Desktop. What is the syntax to open files in a different directory? (for example, if the file was in the cwd I would use open('file'). Thank you.


-------------------------------------OUTPUT-------------------------------------

                Expected= "open(path, 'r')"
           base:Baseline= "path.open(path, 'r')"
           base:+Canonic= "open(path, 'r')"
           body:Baseline= "os.path.open('path', 'r')"
              body:-Code= "os.path.open('path', 'r')"
          mined:Baseline= "os.path.open('r')"
             mined:+Body= "os.path.join(path, 'r')"
        mined:+Body, -NL= "os.path.expanduser('r')"
      mined:+Body, -Code= "os.path.join(path, 'r')"

================================================================================

QUESTION: idx=498    id=36003967
-------------------------------------INPUTS-------------------------------------

tags: list
score: 8
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['data']}
intent: sum elements at the same index in list `data`
body(Some added characters for better readability):
	Consider I have a list of lists as:
	
	start_block
	[[5, 10, 30, 24, 100], [1, 9, 25, 49, 81]]
	[[15, 10, 10, 16, 70], [10, 1, 25, 11, 19]]
	[[34, 20, 10, 10, 30], [9, 20, 25, 30, 80]]
	
	<p>Now I want the sum of all indexes of first list's index wise and then the 2nd list   
	`5+15+34=54   10+10+20=40`
	and so on as:
	
	start_block
	[54,40,50, 50,200], [20,30,75,90,180]
	I tried:
	
	start_block
	for res in results:     
	    print [sum(j) for j in zip(*res)] 
	
	<p>Here 
	`results` is the list of lists. 
	But it gives sum of each list item as:
	
	start_block
	[6,19,55,73,181]
	[25,11,35,27,89]
	[43,40,35,40,110]


-------------------------------------OUTPUT-------------------------------------

                Expected= '[[sum(item) for item in zip(*items)] for items in zip(*data)]'
           base:Baseline= 'sum(data, key=lambda x: sum(x[1]) for x in data)'
           base:+Canonic= 'sum([i for i, j in zip(var_0, var_0)]'
           body:Baseline= 'sum(j) for i, j in zip(*data)]'
              body:-Code= 'sum(x, y) for x, y in data)'
          mined:Baseline= 'sum([i for i, j in enumerate(data) if j == i])'
             mined:+Body= '[sum(j) for i, j in zip(*data)]'
        mined:+Body, -NL= '[sum(j) for i, j in zip(*data)]'
      mined:+Body, -Code= 'sum(item[0] for item in enumerate(data))'

================================================================================

QUESTION: idx=499    id=7635237
-------------------------------------INPUTS-------------------------------------

tags: arrays, vector, numpy, casting
score: 6
slot_map: {'key': ['var_0'], 'quote': ['`'], 'type': ['var'], 'value': ['a']}
intent: add a new axis to array `a`
body(Some added characters for better readability):
	
	<p>I'd like to cast a numpy 
	`ndarray`
	 object of shape ( 
	n 
	,) into one having shape ( 
	n , 1).  The best I've come up with is to roll my own _to_col function:
	
	start_block
	def _to_col(a):
	    return a.reshape((a.size, 1))
	But it is hard for me to believe that such a ubiquitous operation is not already built into numpy's syntax.  I figure that I just have not been able to hit upon the right Google search to find it.


-------------------------------------OUTPUT-------------------------------------

                Expected= 'a[:, (np.newaxis)]'
           base:Baseline= 'a.reshape(axis=0)'
           base:+Canonic= 'a = a[:]'
           body:Baseline= 'a.reshape((a.size, 1))'
              body:-Code= 'a.reshape(axis=1)'
          mined:Baseline= 'a.set_xticklabels([])'
             mined:+Body= 'a.reshape((1, 1))'
        mined:+Body, -NL= 'a.reshape((a.size, 1), axis=1)'
      mined:+Body, -Code= 'np.roll_to_col(a, axis=1)'

